/**
 * skylark-grapejs - A version of garpejs that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-grapejs/
 * @license MIT
 */
define(["skylark-langx/langx","skylark-underscore","./mixins"],function(t,s,i){"use strict";return class{constructor(t={}){return this.opts={container:null,onStart:null,onDrag:null,onEnd:null,setPosition:null,getPosition:null,guidesStatic:null,guidesTarget:null,snapOffset:5,doc:0,scale:1},s.bindAll(this,"drag","stop","keyHandle","handleScroll"),this.setOptions(t),this.delta={x:0,y:0},this}setOptions(s={}){this.opts=t.mixin({},this.opts,s)}toggleDrag(t){const s=this.getDocumentEl(),e=this.getContainerEl(),o=this.getWindowEl(),n=t?"on":"off";i[n](e,"mousemove dragover",this.drag),i[n](s,"mouseup dragend touchend",this.stop),i[n](s,"keydown",this.keyHandle),i[n](o,"scroll",this.handleScroll)}handleScroll(){const{lastScroll:t,delta:s}=this,i=this.getScrollInfo(),e={x:i.x-t.x,y:i.y-t.y};this.move(s.x+e.x,s.y+e.y),this.lastScrollDiff=e}start(t){const{opts:i}=this,{onStart:e}=i;this.toggleDrag(1),this.startPointer=this.getPointerPos(t),this.guidesStatic=s.result(i,"guidesStatic")||[],this.guidesTarget=s.result(i,"guidesTarget")||[],s.isFunction(e)&&e(t,this),this.startPosition=this.getStartPosition(),this.lastScrollDiff={x:0,y:0},this.globScrollDiff={x:0,y:0},this.drag(t)}drag(i){const{opts:e,lastScrollDiff:o,globScrollDiff:n}=this,{onDrag:l}=e,{startPointer:r}=this,c=this.getPointerPos(i),h={x:n.x+o.x,y:n.y+o.y};this.globScrollDiff=h;const a={x:c.x-r.x+h.x,y:c.y-r.y+h.y};this.lastScrollDiff={x:0,y:0};let{lockedAxis:g}=this;"x"===(g=i.shiftKey?!g&&this.detectAxisLock(a.x,a.y):null)?a.x=r.x:"y"===g&&(a.y=r.y);const u=t=>{["x","y"].forEach(i=>t[i]=t[i]*s.result(e,"scale")),this.delta=t,this.move(t.x,t.y),s.isFunction(l)&&l(i,this)},d=t.clone(a);if(this.currentPointer=c,this.lockedAxis=g,this.lastScroll=this.getScrollInfo(),u(a),this.guidesTarget.length){const{newDelta:t,trgX:s,trgY:i}=this.snapGuides(d);(s||i)&&u(t)}0===i.which&&this.stop(i)}snapGuides(t){const i=t;let{trgX:e,trgY:o}=this;return this.guidesTarget.forEach(i=>{i.x&&this.trgX||i.y&&this.trgY||(i.active=0,this.guidesStatic.forEach(n=>{if(i.y&&n.x||i.x&&n.y)return;const l=i.y&&n.y,r=l?"y":"x",c=i[r],h=n[r],a=t[r],g=l?o:e;if(this.isPointIn(c,h)&&s.isUndefined(g)){const t=a-(c-h);this.setGuideLock(i,t)}}))}),e=this.trgX,o=this.trgY,["x","y"].forEach(e=>{let o=this[`trg${e.toUpperCase()}`];o&&!this.isPointIn(t[e],o.lock)&&(this.setGuideLock(o,null),o=null),o&&!s.isUndefined(o.lock)&&(i[e]=o.lock)}),{newDelta:i,trgX:this.trgX,trgY:this.trgY}}isPointIn(t,s,{offset:i}={}){const e=i||this.opts.snapOffset;return t>=s&&t<=s+e||t<=s&&t>=s-e}setGuideLock(t,i){const e=`trg${s.isUndefined(t.x)?"Y":"X"}`;return null!==i?(t.active=1,t.lock=i,this[e]=t):(delete t.active,delete t.lock,delete this[e]),t}stop(t,i={}){const{delta:e}=this,o=i.cancel,n=o?0:e.x,l=o?0:e.y;this.toggleDrag(),this.lockedAxis=null,this.move(n,l,1);const{onEnd:r}=this.opts;s.isFunction(r)&&r(t,this,{cancelled:o})}keyHandle(t){i.isEscKey(t)&&this.stop(t,{cancel:1})}move(t,i,e){const{el:o,opts:n}=this,l=this.startPosition;if(!l)return;const{setPosition:r}=n,c=l.x+t,h=l.y+i;this.position={x:c,y:h,end:e},s.isFunction(r)&&r(this.position),o&&(o.style.left=`${c}px`,o.style.top=`${h}px`)}getContainerEl(){const{container:t}=this.opts;return t?[t]:this.getDocumentEl()}getWindowEl(){return this.getContainerEl().map(t=>{const s=t.ownerDocument||t;return s.defaultView||s.parentWindow})}getDocumentEl(t){const{doc:s}=this.opts;if(t=t||this.el,!this.docs){const i=[document];t&&i.push(t.ownerDocument),s&&i.push(s),this.docs=i}return this.docs}getPointerPos(t){const s=this.opts.getPointerPosition,e=i.getPointerEvent(t);return s?s(t):{x:e.clientX,y:e.clientY}}getStartPosition(){const{el:t,opts:i}=this,e=i.getPosition;let o={x:0,y:0};return s.isFunction(e)?o=e():t&&(o={x:parseFloat(t.style.left),y:parseFloat(t.style.top)}),o}getScrollInfo(){const{doc:t}=this.opts,s=t&&t.body;return{y:s?s.scrollTop:0,x:s?s.scrollLeft:0}}detectAxisLock(t,s){const i=t,e=s,o=Math.abs(i),n=Math.abs(e);return e>=o||e<=-o?"x":i>n||i<-n?"y":void 0}}});
//# sourceMappingURL=../sourcemaps/utils/Dragger.js.map

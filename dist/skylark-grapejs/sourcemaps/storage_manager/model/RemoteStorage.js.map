{"version":3,"sources":["storage_manager/model/RemoteStorage.js"],"names":["define","langx","Backbone","fetch","a","Model","extend","defaults","urlStore","urlLoad","params","[object Object]","contentTypeJson","credentials","fetchOptions","this","get","before","err","clbErr","em","console","error","trigger","text","clb","complete","res","JSON","parse","data","body","key","request","keys","method","url","opts","typeJson","headers","bodyObj","param","isUndefined","stringify","FormData","bodyKey","append","fetchOpts","addOpts","isFunction","onStart","mixin","then","status","Promise","reject","onResponse","catch","onError"],"mappings":";;;;;;;AAAAA,QACI,sBACA,mBACA,oBACA,sBACD,SAAUC,EAAMC,EAAUC,EAAOC,GAChC,aACA,OAAOF,EAASG,MAAMC,QAClBH,MAAAA,EACAI,UACIC,SAAU,GACVC,QAAS,GACTC,UACAC,eAEAA,eAEAC,iBAAiB,EACjBC,YAAa,UACbC,aAAc,IAElBH,UACeI,KAAKC,IAAI,MAApB,MACMC,EAASF,KAAKC,IAAI,cACxBC,GAAUA,KAEdN,QAAQO,EAAKC,GACT,GAAIA,EACAA,EAAOD,OACJ,CACH,MAAME,EAAKL,KAAKC,IAAI,MACpBK,QAAQC,MAAMJ,GACdE,GAAMA,EAAGG,QAAQ,gBAAiBL,KAG1CP,WAAWa,EAAMC,GACb,MAAML,EAAKL,KAAKC,IAAI,MACdU,EAAWX,KAAKC,IAAI,cAGpBW,EAFWZ,KAAKC,IAAI,qBACTQ,GAAwB,iBAATA,GACGI,KAAKC,MAAML,GAAQA,EACtDE,GAAYA,EAASC,GACrBF,GAAOA,EAAIE,GACXP,GAAMA,EAAGG,QAAQ,mBAAoBI,IAEzChB,MAAMmB,EAAML,EAAKN,GACb,MAAMY,KACN,IAAK,IAAIC,KAAOF,EACZC,EAAKC,GAAOF,EAAKE,GAErBjB,KAAKkB,QAAQlB,KAAKC,IAAI,aAAee,KAAAA,GAAQN,EAAKN,IAEtDR,KAAKuB,EAAMT,EAAKN,GACZJ,KAAKkB,QAAQlB,KAAKC,IAAI,YAAcmB,OAAQ,OAASV,EAAKN,IAE9DR,QAAQyB,EAAKC,KAAWZ,EAAM,KAAMN,EAAS,MACzC,MAAMmB,EAAWvB,KAAKC,IAAI,mBACpBuB,EAAUxB,KAAKC,IAAI,eACnBN,EAASK,KAAKC,IAAI,UAGlBwB,EAAUH,EAAKN,SACrB,IAAIjB,EACAiB,EACJ,IAAK,IAAIU,KAAS/B,EACd8B,EAAQC,GAAS/B,EAAO+B,GAQ5B,GANIrC,EAAEsC,YAAYH,EARF,uBASZA,EATY,oBASO,kBAEnBnC,EAAEsC,YAAYH,EAVD,kBAUuBD,IACpCC,EAXa,gBAWO,mCAEpBD,EACAP,EAAOH,KAAKe,UAAUH,OACnB,CACHT,EAAO,IAAIa,SACX,IAAK,IAAIC,KAAWL,EAChBT,EAAKe,OAAOD,EAASL,EAAQK,IAQT,UAL5B/B,GACIqB,OAAQE,EAAKF,QAAU,OACvBtB,YAAaE,KAAKC,IAAI,eACtBuB,QAAAA,IAEaJ,SACbrB,EAAaiB,KAAOA,GAExB,MAAMgB,EAAYhC,KAAKC,IAAI,oBACrBgC,EAAU5C,EAAE6C,WAAWF,GAAaA,EAAUjC,GAAgBA,EACpEC,KAAKmC,UACLnC,KAAKZ,MAAMiC,EAAKnC,EAAMkD,SAASrC,EAAakC,IAAUI,KAClDzB,GAAiC,IAAzBA,EAAI0B,OAAS,IAAM,GAAU1B,EAAIH,OAASG,EAAIH,OAAO4B,KAAK5B,GAAQ8B,QAAQC,OAAO/B,KAAQ4B,KAAK5B,GAAQT,KAAKyC,WAAWhC,EAAMC,IAAMgC,MAAMvC,GAAOH,KAAK2C,QAAQxC,EAAKC","file":"../../../storage_manager/model/RemoteStorage.js","sourcesContent":["define([\n    \"skylark-langx/langx\",\n    'skylark-backbone',\n    '../../utils/fetch',\n    'skylark-underscore'\n], function (langx,Backbone, fetch, a) {\n    'use strict';\n    return Backbone.Model.extend({\n        fetch,\n        defaults: {\n            urlStore: '',\n            urlLoad: '',\n            params: {},\n            beforeSend() {\n            },\n            onComplete() {\n            },\n            contentTypeJson: false,\n            credentials: 'include',\n            fetchOptions: ''\n        },\n        onStart() {\n            const em = this.get('em');\n            const before = this.get('beforeSend');\n            before && before();\n        },\n        onError(err, clbErr) {\n            if (clbErr) {\n                clbErr(err);\n            } else {\n                const em = this.get('em');\n                console.error(err);\n                em && em.trigger('storage:error', err);\n            }\n        },\n        onResponse(text, clb) {\n            const em = this.get('em');\n            const complete = this.get('onComplete');\n            const typeJson = this.get('contentTypeJson');\n            const parsable = text && typeof text === 'string';\n            const res = typeJson && parsable ? JSON.parse(text) : text;\n            complete && complete(res);\n            clb && clb(res);\n            em && em.trigger('storage:response', res);\n        },\n        store(data, clb, clbErr) {\n            const body = {};\n            for (let key in data) {\n                body[key] = data[key];\n            }\n            this.request(this.get('urlStore'), { body }, clb, clbErr);\n        },\n        load(keys, clb, clbErr) {\n            this.request(this.get('urlLoad'), { method: 'get' }, clb, clbErr);\n        },\n        request(url, opts = {}, clb = null, clbErr = null) {\n            const typeJson = this.get('contentTypeJson');\n            const headers = this.get('headers') || {};\n            const params = this.get('params');\n            const reqHead = 'X-Requested-With';\n            const typeHead = 'Content-Type';\n            const bodyObj = opts.body || {};\n            let fetchOptions;\n            let body;\n            for (let param in params) {\n                bodyObj[param] = params[param];\n            }\n            if (a.isUndefined(headers[reqHead])) {\n                headers[reqHead] = 'XMLHttpRequest';\n            }\n            if (a.isUndefined(headers[typeHead]) && typeJson) {\n                headers[typeHead] = 'application/json; charset=utf-8';\n            }\n            if (typeJson) {\n                body = JSON.stringify(bodyObj);\n            } else {\n                body = new FormData();\n                for (let bodyKey in bodyObj) {\n                    body.append(bodyKey, bodyObj[bodyKey]);\n                }\n            }\n            fetchOptions = {\n                method: opts.method || 'post',\n                credentials: this.get('credentials'),\n                headers\n            };\n            if (fetchOptions.method === 'post') {\n                fetchOptions.body = body;\n            }\n            const fetchOpts = this.get('fetchOptions') || {};\n            const addOpts = a.isFunction(fetchOpts) ? fetchOpts(fetchOptions) : fetchOptions;\n            this.onStart();\n            this.fetch(url, langx.mixin({},fetchOptions,addOpts)).then(\n                res => (res.status / 200 | 0) == 1 ? res.text() : res.text().then(text => Promise.reject(text))).then(text => this.onResponse(text, clb)).catch(err => this.onError(err, clbErr));\n        }\n    });\n});"]}
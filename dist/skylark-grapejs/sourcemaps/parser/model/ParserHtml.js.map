{"version":3,"sources":["parser/model/ParserHtml.js"],"names":["define","a","config","c","compTypes","modelAttrStart","[object Object]","attr","props","attrs","each","value","key","indexOf","this","modelAttr","replace","valueLen","length","valStr","isString","firstChar","substr","lastChar","JSON","parse","e","str","result","decls","split","i","len","decl","trim","prop","slice","join","cls","cl","push","el","nodes","childNodes","node","attributes","attrsLen","nodePrev","nodeChild","ct","model","obj","type","getAttribute","it","compType","isComponent","id","tagName","toLowerCase","j","nodeName","nodeValue","style","parseStyle","classes","parseClass","components","firstChild","nodeType","content","parseNode","keepEmptyTextNodes","comps","allTxt","foundTextNode","ci","comp","cType","textTags","parserCss","em","get","res","html","css","document","createElement","innerHTML","scripts","querySelectorAll","allowScripts","parentNode","removeChild","styleStr","styles"],"mappings":"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","file":"../../../parser/model/ParserHtml.js","sourcesContent":["define(['skylark-underscore'], function (a) {\n    'use strict';\n    return config => {\n        var TEXT_NODE = 'span';\n        var c = config;\n        var modelAttrStart = 'data-gjs-';\n        return {\n            compTypes: '',\n            modelAttrStart,\n            splitPropsFromAttr(attr = {}) {\n                const props = {};\n                const attrs = {};\n                a.each(attr, (value, key) => {\n                    if (key.indexOf(this.modelAttrStart) === 0) {\n                        const modelAttr = key.replace(modelAttrStart, '');\n                        const valueLen = value.length;\n                        const valStr = value && a.isString(value);\n                        const firstChar = valStr && value.substr(0, 1);\n                        const lastChar = valStr && value.substr(valueLen - 1);\n                        value = value === 'true' ? true : value;\n                        value = value === 'false' ? false : value;\n                        try {\n                            value = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(value) : value;\n                        } catch (e) {\n                        }\n                        props[modelAttr] = value;\n                    } else {\n                        attrs[key] = value;\n                    }\n                });\n                return {\n                    props,\n                    attrs\n                };\n            },\n            parseStyle(str) {\n                var result = {};\n                var decls = str.split(';');\n                for (var i = 0, len = decls.length; i < len; i++) {\n                    var decl = decls[i].trim();\n                    if (!decl)\n                        continue;\n                    var prop = decl.split(':');\n                    result[prop[0].trim()] = prop.slice(1).join(':').trim();\n                }\n                return result;\n            },\n            parseClass(str) {\n                const result = [];\n                const cls = str.split(' ');\n                for (let i = 0, len = cls.length; i < len; i++) {\n                    const cl = cls[i].trim();\n                    if (!cl)\n                        continue;\n                    result.push(cl);\n                }\n                return result;\n            },\n            parseNode(el) {\n                const result = [];\n                const nodes = el.childNodes;\n                for (var i = 0, len = nodes.length; i < len; i++) {\n                    const node = nodes[i];\n                    const attrs = node.attributes || [];\n                    const attrsLen = attrs.length;\n                    const nodePrev = result[result.length - 1];\n                    const nodeChild = node.childNodes.length;\n                    const ct = this.compTypes;\n                    let model = {};\n                    if (ct) {\n                        let obj = '';\n                        let type = node.getAttribute && node.getAttribute(`${ modelAttrStart }type`);\n                        if (type) {\n                            model = { type };\n                        } else {\n                            for (let it = 0; it < ct.length; it++) {\n                                const compType = ct[it];\n                                obj = compType.model.isComponent(node);\n                                if (obj) {\n                                    if (typeof obj !== 'object') {\n                                        obj = { type: compType.id };\n                                    }\n                                    break;\n                                }\n                            }\n                            model = obj;\n                        }\n                    }\n                    if (!model.tagName) {\n                        model.tagName = node.tagName ? node.tagName.toLowerCase() : '';\n                    }\n                    if (attrsLen) {\n                        model.attributes = {};\n                    }\n                    for (let j = 0; j < attrsLen; j++) {\n                        const nodeName = attrs[j].nodeName;\n                        let nodeValue = attrs[j].nodeValue;\n                        if (nodeName == 'style') {\n                            model.style = this.parseStyle(nodeValue);\n                        } else if (nodeName == 'class') {\n                            model.classes = this.parseClass(nodeValue);\n                        } else if (nodeName == 'contenteditable') {\n                            continue;\n                        } else if (nodeName.indexOf(modelAttrStart) === 0) {\n                            const modelAttr = nodeName.replace(modelAttrStart, '');\n                            const valueLen = nodeValue.length;\n                            const firstChar = nodeValue && nodeValue.substr(0, 1);\n                            const lastChar = nodeValue && nodeValue.substr(valueLen - 1);\n                            nodeValue = nodeValue === 'true' ? true : nodeValue;\n                            nodeValue = nodeValue === 'false' ? false : nodeValue;\n                            try {\n                                nodeValue = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(nodeValue) : nodeValue;\n                            } catch (e) {\n                            }\n                            model[modelAttr] = nodeValue;\n                        } else {\n                            model.attributes[nodeName] = nodeValue;\n                        }\n                    }\n                    if (nodeChild && !model.components) {\n                        const firstChild = node.childNodes[0];\n                        if (nodeChild === 1 && firstChild.nodeType === 3) {\n                            !model.type && (model.type = 'text');\n                            model.content = firstChild.nodeValue;\n                        } else {\n                            model.components = this.parseNode(node);\n                        }\n                    }\n                    if (model.type == 'textnode') {\n                        if (nodePrev && nodePrev.type == 'textnode') {\n                            nodePrev.content += model.content;\n                            continue;\n                        }\n                        if (!config.keepEmptyTextNodes) {\n                            const content = node.nodeValue;\n                            if (content != ' ' && !content.trim()) {\n                                continue;\n                            }\n                        }\n                    }\n                    const comps = model.components;\n                    if (!model.type && comps) {\n                        let allTxt = 1;\n                        let foundTextNode = 0;\n                        for (let ci = 0; ci < comps.length; ci++) {\n                            const comp = comps[ci];\n                            const cType = comp.type;\n                            if ([\n                                    'text',\n                                    'textnode'\n                                ].indexOf(cType) < 0 && c.textTags.indexOf(comp.tagName) < 0) {\n                                allTxt = 0;\n                                break;\n                            }\n                            if (cType == 'textnode') {\n                                foundTextNode = 1;\n                            }\n                        }\n                        if (allTxt && foundTextNode) {\n                            model.type = 'text';\n                        }\n                    }\n                    if (!model.tagName && model.type != 'textnode') {\n                        continue;\n                    }\n                    result.push(model);\n                }\n                return result;\n            },\n            parse(str, parserCss) {\n                var config = c.em && c.em.get('Config') || {};\n                var res = {\n                    html: '',\n                    css: ''\n                };\n                var el = document.createElement('div');\n                el.innerHTML = str;\n                var scripts = el.querySelectorAll('script');\n                var i = scripts.length;\n                if (!config.allowScripts) {\n                    while (i--)\n                        scripts[i].parentNode.removeChild(scripts[i]);\n                }\n                if (parserCss) {\n                    var styleStr = '';\n                    var styles = el.querySelectorAll('style');\n                    var j = styles.length;\n                    while (j--) {\n                        styleStr = styles[j].innerHTML + styleStr;\n                        styles[j].parentNode.removeChild(styles[j]);\n                    }\n                    if (styleStr)\n                        res.css = parserCss.parse(styleStr);\n                }\n                var result = this.parseNode(el);\n                if (result.length == 1)\n                    result = result[0];\n                res.html = result;\n                return res;\n            }\n        };\n    };\n});"]}
{"version":3,"sources":["utils/Dragger.js"],"names":["define","langx","_","mixins","[object Object]","opts","this","container","onStart","onDrag","onEnd","setPosition","getPosition","guidesStatic","guidesTarget","snapOffset","doc","scale","bindAll","setOptions","delta","x","y","mixin","enable","docs","getDocumentEl","getContainerEl","win","getWindowEl","method","drag","stop","keyHandle","handleScroll","lastScroll","actualScroll","getScrollInfo","scrollDiff","move","lastScrollDiff","ev","toggleDrag","startPointer","getPointerPos","result","isFunction","startPosition","getStartPosition","globScrollDiff","currentPos","glDiff","lockedAxis","shiftKey","detectAxisLock","moveDelta","forEach","co","deltaPre","clone","currentPointer","length","newDelta","trgX","trgY","snapGuides","which","trg","active","stat","isY","axs","trgPoint","statPoint","deltaPoint","trgGuide","isPointIn","isUndefined","trgValue","setGuideLock","toUpperCase","lock","src","offset","ofst","guide","value","trgName","cancelled","cancel","isEscKey","end","el","pos","xPos","yPos","position","style","left","top","map","item","ownerDocument","defaultView","parentWindow","document","push","getPos","getPointerPosition","pEv","getPointerEvent","clientX","clientY","parseFloat","body","scrollTop","scrollLeft","relX","relY","absX","Math","abs","absY"],"mappings":"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","file":"../../utils/Dragger.js","sourcesContent":["define([\n    \"skylark-langx/langx\",\n    'skylark-underscore',\n    './mixins'\n], function (langx,_, mixins) {\n    'use strict';\n    const resetPos = () => ({\n        x: 0,\n        y: 0\n    });\n    return class Dragger {\n        constructor(opts = {}) {\n            this.opts = {\n                container: null,\n                onStart: null,\n                onDrag: null,\n                onEnd: null,\n                setPosition: null,\n                getPosition: null,\n                guidesStatic: null,\n                guidesTarget: null,\n                snapOffset: 5,\n                doc: 0,\n                scale: 1\n            };\n            _.bindAll(this, 'drag', 'stop', 'keyHandle', 'handleScroll');\n            this.setOptions(opts);\n            this.delta = resetPos();\n            return this;\n        }\n        setOptions(opts = {}) {\n            this.opts = langx.mixin({},this.opts,opts);\n        }\n        toggleDrag(enable) {\n            const docs = this.getDocumentEl();\n            const container = this.getContainerEl();\n            const win = this.getWindowEl();\n            const method = enable ? 'on' : 'off';\n\n            mixins[method](container, 'mousemove dragover', this.drag);\n            mixins[method](docs, 'mouseup dragend touchend', this.stop);\n            mixins[method](docs, 'keydown', this.keyHandle);\n            mixins[method](win, 'scroll', this.handleScroll);\n        }\n        handleScroll() {\n            const {lastScroll, delta} = this;\n            const actualScroll = this.getScrollInfo();\n            const scrollDiff = {\n                x: actualScroll.x - lastScroll.x,\n                y: actualScroll.y - lastScroll.y\n            };\n            this.move(delta.x + scrollDiff.x, delta.y + scrollDiff.y);\n            this.lastScrollDiff = scrollDiff;\n        }\n        start(ev) {\n            const {opts} = this;\n            const {onStart} = opts;\n            this.toggleDrag(1);\n            this.startPointer = this.getPointerPos(ev);\n            this.guidesStatic = _.result(opts, 'guidesStatic') || [];\n            this.guidesTarget = _.result(opts, 'guidesTarget') || [];\n            _.isFunction(onStart) && onStart(ev, this);\n            this.startPosition = this.getStartPosition();\n            this.lastScrollDiff = resetPos();\n            this.globScrollDiff = resetPos();\n            this.drag(ev);\n        }\n        drag(ev) {\n            const {opts, lastScrollDiff, globScrollDiff} = this;\n            const {onDrag} = opts;\n            const {startPointer} = this;\n            const currentPos = this.getPointerPos(ev);\n            const glDiff = {\n                x: globScrollDiff.x + lastScrollDiff.x,\n                y: globScrollDiff.y + lastScrollDiff.y\n            };\n            this.globScrollDiff = glDiff;\n            const delta = {\n                x: currentPos.x - startPointer.x + glDiff.x,\n                y: currentPos.y - startPointer.y + glDiff.y\n            };\n            this.lastScrollDiff = resetPos();\n            let {lockedAxis} = this;\n            if (ev.shiftKey) {\n                lockedAxis = !lockedAxis && this.detectAxisLock(delta.x, delta.y);\n            } else {\n                lockedAxis = null;\n            }\n            if (lockedAxis === 'x') {\n                delta.x = startPointer.x;\n            } else if (lockedAxis === 'y') {\n                delta.y = startPointer.y;\n            }\n            const moveDelta = delta => {\n                [\n                    'x',\n                    'y'\n                ].forEach(co => delta[co] = delta[co] * _.result(opts, 'scale'));\n                this.delta = delta;\n                this.move(delta.x, delta.y);\n                _.isFunction(onDrag) && onDrag(ev, this);\n            };\n            const deltaPre = langx.clone(delta);\n            this.currentPointer = currentPos;\n            this.lockedAxis = lockedAxis;\n            this.lastScroll = this.getScrollInfo();\n            moveDelta(delta);\n            if (this.guidesTarget.length) {\n                const {newDelta, trgX, trgY} = this.snapGuides(deltaPre);\n                (trgX || trgY) && moveDelta(newDelta);\n            }\n            ev.which === 0 && this.stop(ev);\n        }\n        snapGuides(delta) {\n            const newDelta = delta;\n            let {trgX, trgY} = this;\n            this.guidesTarget.forEach(trg => {\n                if (trg.x && this.trgX || trg.y && this.trgY)\n                    return;\n                trg.active = 0;\n                this.guidesStatic.forEach(stat => {\n                    if (trg.y && stat.x || trg.x && stat.y)\n                        return;\n                    const isY = trg.y && stat.y;\n                    const axs = isY ? 'y' : 'x';\n                    const trgPoint = trg[axs];\n                    const statPoint = stat[axs];\n                    const deltaPoint = delta[axs];\n                    const trgGuide = isY ? trgY : trgX;\n                    if (this.isPointIn(trgPoint, statPoint)) {\n                        if (_.isUndefined(trgGuide)) {\n                            const trgValue = deltaPoint - (trgPoint - statPoint);\n                            this.setGuideLock(trg, trgValue);\n                        }\n                    }\n                });\n            });\n            trgX = this.trgX;\n            trgY = this.trgY;\n            [\n                'x',\n                'y'\n            ].forEach(co => {\n                const axis = co.toUpperCase();\n                let trg = this[`trg${ axis }`];\n                if (trg && !this.isPointIn(delta[co], trg.lock)) {\n                    this.setGuideLock(trg, null);\n                    trg = null;\n                }\n                if (trg && !_.isUndefined(trg.lock)) {\n                    newDelta[co] = trg.lock;\n                }\n            });\n            return {\n                newDelta,\n                trgX: this.trgX,\n                trgY: this.trgY\n            };\n        }\n        isPointIn(src, trg, {offset} = {}) {\n            const ofst = offset || this.opts.snapOffset;\n            return src >= trg && src <= trg + ofst || src <= trg && src >= trg - ofst;\n        }\n        setGuideLock(guide, value) {\n            const axis = !_.isUndefined(guide.x) ? 'X' : 'Y';\n            const trgName = `trg${ axis }`;\n            if (value !== null) {\n                guide.active = 1;\n                guide.lock = value;\n                this[trgName] = guide;\n            } else {\n                delete guide.active;\n                delete guide.lock;\n                delete this[trgName];\n            }\n            return guide;\n        }\n        stop(ev, opts = {}) {\n            const {delta} = this;\n            const cancelled = opts.cancel;\n            const x = cancelled ? 0 : delta.x;\n            const y = cancelled ? 0 : delta.y;\n            this.toggleDrag();\n            this.lockedAxis = null;\n            this.move(x, y, 1);\n            const {onEnd} = this.opts;\n            _.isFunction(onEnd) && onEnd(ev, this, { cancelled });\n        }\n        keyHandle(ev) {\n            if (mixins.isEscKey(ev)) {\n                this.stop(ev, { cancel: 1 });\n            }\n        }\n        move(x, y, end) {\n            const {el, opts} = this;\n            const pos = this.startPosition;\n            if (!pos)\n                return;\n            const {setPosition} = opts;\n            const xPos = pos.x + x;\n            const yPos = pos.y + y;\n            this.position = {\n                x: xPos,\n                y: yPos,\n                end\n            };\n            _.isFunction(setPosition) && setPosition(this.position);\n            if (el) {\n                el.style.left = `${ xPos }px`;\n                el.style.top = `${ yPos }px`;\n            }\n        }\n        getContainerEl() {\n            const {container} = this.opts;\n            return container ? [container] : this.getDocumentEl();\n        }\n        getWindowEl() {\n            const cont = this.getContainerEl();\n            return cont.map(item => {\n                const doc = item.ownerDocument || item;\n                return doc.defaultView || doc.parentWindow;\n            });\n        }\n        getDocumentEl(el) {\n            const {doc} = this.opts;\n            el = el || this.el;\n            if (!this.docs) {\n                const docs = [document];\n                el && docs.push(el.ownerDocument);\n                doc && docs.push(doc);\n                this.docs = docs;\n            }\n            return this.docs;\n        }\n        getPointerPos(ev) {\n            const getPos = this.opts.getPointerPosition;\n            const pEv = mixins.getPointerEvent(ev);\n            return getPos ? getPos(ev) : {\n                x: pEv.clientX,\n                y: pEv.clientY\n            };\n        }\n        getStartPosition() {\n            const {el, opts} = this;\n            const getPos = opts.getPosition;\n            let result = resetPos();\n            if (_.isFunction(getPos)) {\n                result = getPos();\n            } else if (el) {\n                result = {\n                    x: parseFloat(el.style.left),\n                    y: parseFloat(el.style.top)\n                };\n            }\n            return result;\n        }\n        getScrollInfo() {\n            const {doc} = this.opts;\n            const body = doc && doc.body;\n            return {\n                y: body ? body.scrollTop : 0,\n                x: body ? body.scrollLeft : 0\n            };\n        }\n        detectAxisLock(x, y) {\n            const relX = x;\n            const relY = y;\n            const absX = Math.abs(relX);\n            const absY = Math.abs(relY);\n            if (relY >= absX || relY <= -absX) {\n                return 'x';\n            } else if (relX > absY || relX < -absY) {\n                return 'y';\n            }\n        }\n    };\n});"]}
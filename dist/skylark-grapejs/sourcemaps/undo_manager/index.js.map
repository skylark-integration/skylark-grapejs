{"version":3,"sources":["undo_manager/index.js"],"names":["define","langx","UndoManager","em","um","config","beforeCache","configDef","name","[object Object]","opts","mixin","this","track","register","changeUndoType","condition","model","collection","options","avoidStore","object","before","undefined","after","clone","customUndoType","value","opt","previousAttributes","result","toJSON","bf","af","set","forEach","ev","addUndoType","on","trigger","getConfig","entity","unregister","unregisterAll","startTracking","stopTracking","isEditing","undo","undoAll","redo","redoAll","hasUndo","isAvailable","hasRedo","getStack","stack","clear","getInstance"],"mappings":";;;;;;;AAAAA,QACI,sBACA,gCACD,SAAUC,EAAMC,GACf,aACA,MAAO,KACH,IAAIC,EACAC,EACAC,EACAC,EACJ,MAAMC,KACN,OACIC,KAAM,cACNC,KAAKC,MACDL,EAASJ,EAAMU,SAASD,EAAKH,GAC7BJ,EAAKE,EAAOF,GACZS,KAAKT,GAAKA,GACVC,EAAK,IAAIF,EAAYD,EAAMU,OACfE,OAAO,EACPC,aACFT,KAEPU,eAAe,UAAYC,WAAW,IACzCZ,EAAGW,eAAe,OACdN,GAAGQ,EAAOC,EAAYC,MAClB,IAAIA,EAAQC,WAEZ,OACIC,OAAQH,EACRI,YAAQC,EACRC,MAAOP,EACPE,QAASlB,EAAMwB,MAAMN,OAIjCf,EAAGW,eAAe,UACdN,GAAGQ,EAAOC,EAAYC,MAClB,IAAIA,EAAQC,WAEZ,OACIC,OAAQH,EACRI,OAAQL,EACRO,WAAOD,EACPJ,QAASlB,EAAMwB,MAAMN,OAIjC,MAAMO,GACFjB,GAAGY,EAAQM,EAAOC,MAEd,IADCtB,IAAgBA,EAAce,EAAOQ,uBAClCD,EAAIR,WAED,CACH,MAAMU,GACFT,OAAAA,EACAC,OAAQhB,EACRkB,MAAOH,EAAOU,UAGlB,OADAzB,EAAc,KACPwB,IAGfrB,KAAKQ,EAAOe,EAAIC,EAAIL,GAChBX,EAAMiB,IAAIF,IAEdvB,KAAKQ,EAAOe,EAAIC,EAAIL,GAChBX,EAAMiB,IAAID,KAelB,OAXI,QACA,aACA,UACA,OAEGE,QAAQC,GAAMhC,EAAGiC,sBAAuBD,IAAOV,IACtDtB,EAAGkC,GAAG,YAAa,IAAMnC,EAAGoC,QAAQ,2CAEhC,OACA,QACFJ,QAAQC,GAAMhC,EAAGkC,GAAGF,EAAI,IAAMjC,EAAGoC,QAAQH,KACpCxB,MAEX4B,UAAS,IACEnC,EAEXI,IAAIgC,GAEA,OADArC,EAAGU,SAAS2B,GACL7B,MAEXH,OAAOgC,GAEH,OADArC,EAAGsC,WAAWD,GACP7B,MAEXH,YAEI,OADAL,EAAGuC,gBACI/B,MAEXH,QAEI,OADAL,EAAGwC,gBACIhC,MAEXH,OAEI,OADAL,EAAGyC,eACIjC,MAEXH,OAEI,OADCN,EAAG2C,aAAe1C,EAAG2C,KAAK,GACpBnC,MAEXH,UAEI,OADAL,EAAG4C,UACIpC,MAEXH,OAEI,OADCN,EAAG2C,aAAe1C,EAAG6C,KAAK,GACpBrC,MAEXH,UAEI,OADAL,EAAG8C,UACItC,MAEXuC,QAAO,IACI/C,EAAGgD,YAAY,QAE1BC,QAAO,IACIjD,EAAGgD,YAAY,QAE1BE,SAAQ,IACGlD,EAAGmD,MAEd9C,QAEI,OADAL,EAAGoD,QACI5C,MAEX6C,YAAW,IACArD","file":"../../undo_manager/index.js","sourcesContent":["define([\n    \"skylark-langx/langx\",\n    'skylark-backbone/UndoManager'\n], function (langx,UndoManager) {\n    'use strict';\n    return () => {\n        let em;\n        let um;\n        let config;\n        let beforeCache;\n        const configDef = {};\n        return {\n            name: 'UndoManager',\n            init(opts = {}) {\n                config = langx.mixin({},opts,configDef);\n                em = config.em;\n                this.em = em;\n                um = new UndoManager(langx.mixin({\n                            track: true,\n                            register: [],\n                        },config\n                ));\n                um.changeUndoType('change', { condition: false });\n                um.changeUndoType('add', {\n                    on(model, collection, options = {}) {\n                        if (options.avoidStore)\n                            return;\n                        return {\n                            object: collection,\n                            before: undefined,\n                            after: model,\n                            options: langx.clone(options)\n                        };\n                    }\n                });\n                um.changeUndoType('remove', {\n                    on(model, collection, options = {}) {\n                        if (options.avoidStore)\n                            return;\n                        return {\n                            object: collection,\n                            before: model,\n                            after: undefined,\n                            options: langx.clone(options)\n                        };\n                    }\n                });\n                const customUndoType = {\n                    on(object, value, opt = {}) {\n                        !beforeCache && (beforeCache = object.previousAttributes());\n                        if (opt.avoidStore) {\n                            return;\n                        } else {\n                            const result = {\n                                object,\n                                before: beforeCache,\n                                after: object.toJSON()\n                            };\n                            beforeCache = null;\n                            return result;\n                        }\n                    },\n                    undo(model, bf, af, opt) {\n                        model.set(bf);\n                    },\n                    redo(model, bf, af, opt) {\n                        model.set(af);\n                    }\n                };\n                const events = [\n                    'style',\n                    'attributes',\n                    'content',\n                    'src'\n                ];\n                events.forEach(ev => um.addUndoType(`change:${ ev }`, customUndoType));\n                um.on('undo redo', () => em.trigger('component:toggled change:canvasOffset'));\n                [\n                    'undo',\n                    'redo'\n                ].forEach(ev => um.on(ev, () => em.trigger(ev)));\n                return this;\n            },\n            getConfig() {\n                return config;\n            },\n            add(entity) {\n                um.register(entity);\n                return this;\n            },\n            remove(entity) {\n                um.unregister(entity);\n                return this;\n            },\n            removeAll() {\n                um.unregisterAll();\n                return this;\n            },\n            start() {\n                um.startTracking();\n                return this;\n            },\n            stop() {\n                um.stopTracking();\n                return this;\n            },\n            undo() {\n                !em.isEditing() && um.undo(1);\n                return this;\n            },\n            undoAll() {\n                um.undoAll();\n                return this;\n            },\n            redo() {\n                !em.isEditing() && um.redo(1);\n                return this;\n            },\n            redoAll() {\n                um.redoAll();\n                return this;\n            },\n            hasUndo() {\n                return um.isAvailable('undo');\n            },\n            hasRedo() {\n                return um.isAvailable('redo');\n            },\n            getStack() {\n                return um.stack;\n            },\n            clear() {\n                um.clear();\n                return this;\n            },\n            getInstance() {\n                return um;\n            }\n        };\n    };\n});"]}
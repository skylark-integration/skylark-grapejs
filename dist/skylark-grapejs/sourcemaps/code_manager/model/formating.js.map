{"version":3,"sources":["code_manager/model/formating.js"],"names":["define","CodeMirror","extendMode","commentStart","commentEnd","newlineAfterToken","_type","content","test","textAfter","state","this","jsonMode","lexical","type","inlineElements","inline","configuration","context","tagName","defineExtension","isComment","from","to","cm","curMode","innerMode","getMode","getTokenAt","mode","operation","replaceRange","line","ch","setCursor","length","selText","getRange","startIndex","indexOf","endIndex","lastIndexOf","substr","substring","cmInstance","i","indentLine","outer","text","split","copyState","tabSize","getOption","out","lines","atSol","newline","stream","StringStream","eol","inner","style","token","cur","current","start","pos","string","slice","blankLine","end","setSelection","getCursor"],"mappings":"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","file":"../../../code_manager/model/formating.js","sourcesContent":["define([\r\n    'skylark-codemirror'\r\n], function (CodeMirror) {\r\n\r\n  CodeMirror.extendMode(\"css\", {\r\n    commentStart: \"/*\",\r\n    commentEnd: \"*/\",\r\n    newlineAfterToken: function(_type, content) {\r\n      return /^[;{}]$/.test(content);\r\n    }\r\n  });\r\n\r\n  CodeMirror.extendMode(\"javascript\", {\r\n    commentStart: \"/*\",\r\n    commentEnd: \"*/\",\r\n    // FIXME semicolons inside of for\r\n    newlineAfterToken: function(_type, content, textAfter, state) {\r\n      if (this.jsonMode) {\r\n        return /^[\\[,{]$/.test(content) || /^}/.test(textAfter);\r\n      } else {\r\n        if (content == \";\" && state.lexical && state.lexical.type == \")\") return false;\r\n        return /^[;{}]$/.test(content) && !/^;/.test(textAfter);\r\n      }\r\n    }\r\n  });\r\n\r\n  var inlineElements = /^(a|abbr|acronym|area|base|bdo|big|br|button|caption|cite|code|col|colgroup|dd|del|dfn|em|frame|hr|iframe|img|input|ins|kbd|label|legend|link|map|object|optgroup|option|param|q|samp|script|select|small|span|strong|sub|sup|textarea|tt|var)$/;\r\n\r\n  CodeMirror.extendMode(\"xml\", {\r\n    commentStart: \"<!--\",\r\n    commentEnd: \"-->\",\r\n    newlineAfterToken: function(type, content, textAfter, state) {\r\n      var inline = false;\r\n      if (this.configuration == \"html\")\r\n        inline = state.context ? inlineElements.test(state.context.tagName) : false;\r\n      return !inline && ((type == \"tag\" && />$/.test(content) && state.context) ||\r\n                         /^</.test(textAfter));\r\n    }\r\n  });\r\n\r\n  // Comment/uncomment the specified range\r\n  CodeMirror.defineExtension(\"commentRange\", function (isComment, from, to) {\r\n    var cm = this, curMode = CodeMirror.innerMode(cm.getMode(), cm.getTokenAt(from).state).mode;\r\n    cm.operation(function() {\r\n      if (isComment) { // Comment range\r\n        cm.replaceRange(curMode.commentEnd, to);\r\n        cm.replaceRange(curMode.commentStart, from);\r\n        if (from.line == to.line && from.ch == to.ch) // An empty comment inserted - put cursor inside\r\n          cm.setCursor(from.line, from.ch + curMode.commentStart.length);\r\n      } else { // Uncomment range\r\n        var selText = cm.getRange(from, to);\r\n        var startIndex = selText.indexOf(curMode.commentStart);\r\n        var endIndex = selText.lastIndexOf(curMode.commentEnd);\r\n        if (startIndex > -1 && endIndex > -1 && endIndex > startIndex) {\r\n          // Take string till comment start\r\n          selText = selText.substr(0, startIndex) +\r\n          // From comment start till comment end\r\n             selText.substring(startIndex + curMode.commentStart.length, endIndex) +\r\n          // From comment end till string end\r\n             selText.substr(endIndex + curMode.commentEnd.length);\r\n        }\r\n        cm.replaceRange(selText, from, to);\r\n      }\r\n    });\r\n  });\r\n\r\n  // Applies automatic mode-aware indentation to the specified range\r\n  CodeMirror.defineExtension(\"autoIndentRange\", function (from, to) {\r\n    var cmInstance = this;\r\n    this.operation(function () {\r\n      for (var i = from.line; i <= to.line; i++) {\r\n        cmInstance.indentLine(i, \"smart\");\r\n      }\r\n    });\r\n  });\r\n\r\n  // Applies automatic formatting to the specified range\r\n  CodeMirror.defineExtension(\"autoFormatRange\", function (from, to) {\r\n    var cm = this;\r\n    var outer = cm.getMode(), text = cm.getRange(from, to).split(\"\\n\");\r\n    var state = CodeMirror.copyState(outer, cm.getTokenAt(from).state);\r\n    var tabSize = cm.getOption(\"tabSize\");\r\n\r\n    var out = \"\", lines = 0, atSol = from.ch === 0;\r\n    function newline() {\r\n      out += \"\\n\";\r\n      atSol = true;\r\n      ++lines;\r\n    }\r\n\r\n    for (var i = 0; i < text.length; ++i) {\r\n      var stream = new CodeMirror.StringStream(text[i], tabSize);\r\n      while (!stream.eol()) {\r\n        var inner = CodeMirror.innerMode(outer, state);\r\n        var style = outer.token(stream, state), cur = stream.current();\r\n        stream.start = stream.pos;\r\n        if (!atSol || /\\S/.test(cur)) {\r\n          out += cur;\r\n          atSol = false;\r\n        }\r\n        if (!atSol && inner.mode.newlineAfterToken &&\r\n            inner.mode.newlineAfterToken(style, cur, stream.string.slice(stream.pos) || text[i+1] || \"\", inner.state))\r\n          newline();\r\n      }\r\n      if (!stream.pos && outer.blankLine) outer.blankLine(state);\r\n      if (!atSol && i < text.length - 1) newline();\r\n    }\r\n\r\n    cm.operation(function () {\r\n      cm.replaceRange(out, from, to);\r\n      for (var cur = from.line + 1, end = from.line + lines; cur <= end; ++cur)\r\n        cm.indentLine(cur, \"smart\");\r\n      cm.setSelection(from, cm.getCursor(false));\r\n    });\r\n  });\r\n});\r\n"]}
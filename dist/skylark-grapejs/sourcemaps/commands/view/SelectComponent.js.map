{"version":3,"sources":["commands/view/SelectComponent.js"],"names":["define","Backbone","a","mixins","ToolbarView","Toolbar","$","showOffsets","[object Object]","o","bindAll","this","frameOff","canvasOff","adjScroll","startSelectComponent","toggleSelectComponent","em","getSelected","onSelect","enable","method","trigger","win","body","onHover","onOut","onClick","onFrameScroll","window","onFrameUpdated","onHovered","updateGlobalPos","updateAttached","get","getFrames","forEach","frame","view","getWindow","getBody","e","stopPropagation","trg","target","getViewEl","frameView","_getFrame","$el","model","data","parent","length","currentDoc","ownerDocument","setHovered","set","updateLocalPos","component","result","views","el","pos","getElementPos","updateToolsLocal","elHovered","debounce","currentFrame","getView","elSelected","updateToolsGlobal","sel","getElSelected","getElHovered","canvas","getToolsEl","toggleToolsEl","on","opts","style","opacity","editor","runCommand","elPos","force","top","left","stopCommand","state","getHighlighter","ev","preventDefault","select","event","ctrlKey","metaKey","shiftKey","multiple","getConfig","selectToggle","clearSelection","Canvas","coll","collection","index","indexOf","getSelectedAll","min","max","selColl","selIndex","isUndefined","Math","selectAdd","at","scroll","initResize","badge","getBadge","posOnly","config","icon","getIcon","clsBadge","pStylePrefix","customeLabel","customBadgeLabel","badgeLabel","getName","innerHTML","bStyle","display","badgeH","offsetHeight","posTop","topOff","leftOff","elem","resizeClass","stylePrefix","isElement","isTaggableNode","resizable","getEl","modelToStyle","options","toggleBodyClass","docs","doc","cls","className","replace","trim","resizer","keyHeight","keyWidth","currentUnit","keepAutoHeight","keepAutoWidth","getModelToStyle","toggleFramesEvents","computedStyle","getComputedStyle","modelStyle","getStyle","currentWidth","autoWidth","isNaN","parseFloat","currentHeight","autoHeight","startDim","w","h","unitHeight","getUnitFromValue","unitWidth","rect","store","selectedHandler","onlyHeight","onlyWidth","en","bodyw","offsetWidth","width","addStyle","avoidStore","eventToListen","noEmit","mod","toolbarEl","getToolbarEl","toolbarStyle","toolbar","showToolbar","toolbarView","appendChild","render","reset","getCanvasView","getPosition","getBadgeEl","updateTools","isCompSelected","comp","lastHovered","isHoverEn","isNewEl","badgeOpts","showHighlighter","showElementOffset","hideHighlighter","hideElementOffset","canvasRectOffset","updateBadge","height","lastSelected","updateToolbar","targetToElem","getTargetToElementFixed","canvasOffsetTop","canvasOffsetLeft","updateToolbarPos","status","ed","sender","stopSelectComponent","preserveSelected","setSelected"],"mappings":";;;;;;;AAAAA,QACI,mBACA,qBACA,qBACA,wCACA,sCACD,SAAUC,EAAUC,EAAGC,EAAQC,EAAaC,GAC3C,aACA,MAAMC,EAAIL,EAASK,EACnB,IAAIC,EACJ,OACIC,KAAKC,GACDP,EAAEQ,QAAQC,KAAM,UAAW,QAAS,UAAW,gBAAiB,mBAEpEH,SACIG,KAAKC,SAAWD,KAAKE,UAAYF,KAAKG,UAAY,KAClDH,KAAKI,uBACLR,EAAc,GAElBC,uBACIG,KAAKK,sBAAsB,GAC3BL,KAAKM,GAAGC,eAAiBP,KAAKQ,YAElCX,sBACIG,KAAKK,yBAETR,sBAAsBY,GAClB,MAAMH,GAACA,GAAMN,KACPU,EAASD,EAAS,KAAO,MAEzBE,EAAU,CAACC,EAAKC,KAClBrB,EAAOkB,GAAQG,EAAM,YAAab,KAAKc,SACvCtB,EAAOkB,GAAQG,EAAM,aAAcb,KAAKe,OACxCvB,EAAOkB,GAAQG,EAAM,iBAAkBb,KAAKgB,SAC5CxB,EAAOkB,GAAQE,EAAK,SAAUZ,KAAKiB,gBAEvCzB,EAAOkB,GAAQQ,OAAQ,SAAUlB,KAAKmB,gBACtCb,EAAGI,GAAQ,oBAAqBV,KAAKQ,SAAUR,MAC/CM,EAAGI,GAAQ,0BAA2BV,KAAKoB,UAAWpB,MACtDM,EAAGI,GAAQ,yCAA0CV,KAAKqB,gBAAiBrB,MAC3EM,EAAGI,GAAQ,sBAAuBV,KAAKsB,eAAgBtB,MACvDM,EAAGI,GAAQ,gBAAiBV,KAAKmB,eAAgBnB,MACjDM,EAAGiB,IAAI,UAAUC,YAAYC,QAAQC,IACjC,MAAMC,KAACA,GAAQD,EACff,EAAQgB,EAAKC,YAAaD,EAAKE,cAGvChC,QAAQiC,GACJA,EAAEC,kBACF,MAAMC,EAAMF,EAAEG,OACRN,EAAOnC,EAAO0C,UAAUF,GACxBG,EAAYR,GAAQA,EAAKS,YACzBC,EAAM1C,EAAEqC,GACd,IAAIM,EAAQD,EAAIE,KAAK,SACrB,IAAKD,EAAO,CACR,IAAIE,EAASH,EAAIG,SACjB,MAAQF,GAASE,EAAOC,OAAS,GAC7BH,EAAQE,EAAOD,KAAK,SACpBC,EAASA,EAAOA,SAGxB,GAAIF,IAAUA,EAAMf,IAAI,aAAc,CAClC,IAAIiB,EAASF,GAASA,EAAME,SAC5B,KAAOA,IAAWA,EAAOjB,IAAI,cACzBiB,EAASA,EAAOA,SACpBF,EAAQE,EAEZxC,KAAK0C,WAAaV,EAAIW,cACtB3C,KAAKM,GAAGsC,WAAWN,GACnBH,GAAanC,KAAKM,GAAGuC,IAAI,eAAgBV,IAE7CtC,iBACIG,KAAK8C,iBACL9C,KAAKqB,mBAETxB,UAAUS,EAAIyC,GACV,IAAIC,KACAD,GACAA,EAAUE,MAAMxB,QAAQE,IACpB,MAAMuB,EAAKvB,EAAKuB,GACVC,EAAMnD,KAAKoD,cAAcF,GAC/BF,GACIE,GAAAA,EACAC,IAAAA,EACAJ,UAAAA,EACApB,KAAMnC,EAAO0C,UAAUgB,IAE3BlD,KAAKqD,iBAAiBL,GAClBE,EAAGP,gBAAkB3C,KAAK0C,aAC1B1C,KAAKsD,UAAYN,MAIjCxC,SAAUjB,EAAEgE,SAAS,WACjB,MAAMjD,GAACA,GAAMN,KACP+C,EAAYzC,EAAGC,cACfiD,EAAelD,EAAGiB,IAAI,oBACtBI,EAAOoB,GAAaA,EAAUU,QAAQD,EAAalB,OACzD,IAAIY,EAAKvB,GAAQA,EAAKuB,GAClBF,KACJ,GAAIE,EAAI,CAEJF,GACIE,GAAAA,EACAC,IAHQnD,KAAKoD,cAAcF,GAI3BH,UAAAA,EACApB,KAAMnC,EAAO0C,UAAUgB,IAG/BlD,KAAK0D,WAAaV,EAClBhD,KAAK2D,oBACL3D,KAAKqD,iBAAiBL,KAE1BnD,kBACI,MAAM+D,EAAM5D,KAAK6D,gBACZD,EAAIV,KAETU,EAAIT,IAAMnD,KAAKoD,cAAcQ,EAAIV,IACjClD,KAAK2D,sBAET9D,iBACI,MAAM+D,EAAM5D,KAAK8D,eACZF,EAAIV,KAETU,EAAIT,IAAMnD,KAAKoD,cAAcQ,EAAIV,IACjClD,KAAKqD,qBAETxD,eACI,OAAOG,KAAKsD,eAEhBzD,gBACI,OAAOG,KAAK0D,gBAEhB7D,QACIG,KAAK0C,WAAa,KAClB1C,KAAKM,GAAGsC,WAAW,GACnB5C,KAAK+D,OAAOvC,YAAYC,QAAQC,IAC5B,MAAMwB,EAAKxB,EAAMC,KAAKqC,aACtBhE,KAAKiE,cAAc,EAAG,GAAKf,GAAAA,OAGnCrD,cAAcqE,EAAIvC,EAAMwC,MACpB,MAAMjB,EAAKiB,EAAKjB,IAAMlD,KAAK+D,OAAOC,WAAWrC,GAE7C,OADAuB,EAAGkB,MAAMC,QAAUH,EAAK,EAAI,EACrBhB,GAEXrD,kBAAkBqD,EAAIC,EAAKgB,MAClBvE,GAELI,KAAKsE,OAAOC,WAAW,eACnBrB,GAAAA,EACAsB,MAAOrB,EACPxB,KAAMwC,EAAKxC,KACX8C,MAAO,EACPC,IAAK,EACLC,KAAM,KAGd9E,kBAAkB8B,GACd3B,KAAKsE,OAAOM,YAAY,eAAiBjD,KAAAA,KAE7C9B,uBAAuBqD,EAAIC,GACvBnD,KAAKsE,OAAOC,WAAW,eACnBrB,GAAAA,EACAsB,MAAOrB,EACP0B,MAAO,WAGfhF,uBAAuBqD,EAAIC,GACnBnD,KAAKsE,QACLtE,KAAKsE,OAAOM,YAAY,eAAiBC,MAAO,WAExDhF,gBAAgB8B,GACZ3B,KAAK+D,OAAOe,eAAenD,GAAMyC,MAAMC,QAAU,GAErDxE,QAAQkF,GACJA,EAAGhD,kBACHgD,EAAGC,iBACH,MAAM1E,GAACA,GAAMN,KACb,GAAIM,EAAGiB,IAAI,YACP,OAAOjB,EAAGuC,IAAI,YAClB,MAAMR,EAAM1C,EAAEoF,EAAG9C,QACjB,IAAIK,EAAQD,EAAIE,KAAK,SACrB,IAAKD,EAAO,CACR,IAAIE,EAASH,EAAIG,SACjB,MAAQF,GAASE,EAAOC,OAAS,GAC7BH,EAAQE,EAAOD,KAAK,SACpBC,EAASA,EAAOA,SAGxB,GAAIF,EACA,GAAIA,EAAMf,IAAI,cACVvB,KAAKiF,OAAO3C,EAAOyC,OAChB,CACH,IAAIvC,EAASF,EAAME,SACnB,KAAOA,IAAWA,EAAOjB,IAAI,eACzBiB,EAASA,EAAOA,SACpBxC,KAAKiF,OAAOzC,EAAQuC,KAIhClF,OAAOyC,EAAO4C,MACV,IAAK5C,EACD,OACJ,MAAM6C,EAAUD,EAAMC,SAAWD,EAAME,SACjCC,SAACA,GAAYH,GACbZ,OAACA,EAAMhE,GAAEA,GAAMN,KACfsF,EAAWhB,EAAOiB,UAAU,qBAClC,GAAIJ,GAAWG,EACXhB,EAAOkB,aAAalD,QACjB,GAAI+C,GAAYC,EAAU,CAC7BhF,EAAGmF,eAAenB,EAAOoB,OAAO9D,aAChC,MAAM+D,EAAOrD,EAAMsD,WACbC,EAAQF,EAAKG,QAAQxD,GACZgC,EAAOyB,iBACtB,IAAIC,EAAKC,EAYT,GAXA3B,EAAOyB,iBAAiBtE,QAAQmC,IAC5B,MAAMsC,EAAUtC,EAAIgC,WACdO,EAAWD,EAAQJ,QAAQlC,GAC7BsC,IAAYP,IACRQ,EAAWN,EACXG,EAAMzG,EAAE6G,YAAYJ,GAAOG,EAAWE,KAAKJ,IAAID,EAAKG,GAC7CA,EAAWN,IAClBI,EAAM1G,EAAE6G,YAAYH,GAAOE,EAAWE,KAAKL,IAAIC,EAAKE,QAI3D5G,EAAE6G,YAAYJ,GACf,KAAOA,IAAQH,GACXvB,EAAOgC,UAAUX,EAAKY,GAAGP,IACzBA,IAGR,IAAKzG,EAAE6G,YAAYH,GACf,KAAOA,IAAQJ,GACXvB,EAAOgC,UAAUX,EAAKY,GAAGN,IACzBA,IAGR3B,EAAOgC,UAAUhE,QAEjBgC,EAAOW,OAAO3C,GAASkE,YAE3BxG,KAAKyG,WAAWnE,IAEpBzC,YAAYqD,EAAIC,EAAKgB,MACjB,MAAM7B,EAAQ3C,EAAEuD,GAAIX,KAAK,SACzB,IAAKD,IAAUA,EAAMf,IAAI,YACrB,OACJ,MAAMmF,EAAQ1G,KAAK2G,SAASxC,GAC5B,IAAKA,EAAKyC,QAAS,CACf,MAAMC,EAAS7G,KAAK+D,OAAOwB,YACrBuB,EAAOxE,EAAMyE,UAEbC,KADOH,EAAOI,cAAgB,UAE9BC,EAAeL,EAAOM,iBACtBC,KAAiBN,iBAAuBE,YAAqBF,UAAgB,2BAC5EE,YAAqB1E,EAAM+E,kBAClCX,EAAMY,UAAYJ,EAAeA,EAAa5E,GAAS8E,EAE3D,MACMG,EAASb,EAAMtC,MACrBmD,EAAOC,QAAU,QACjB,MAAMC,EAASf,EAAQA,EAAMgB,aAAe,EACtCC,EAAS,EAAIF,EACb/C,EAAMP,EAAKyD,OAASH,EAAS,GAAKtD,EAAKyD,OAASD,EAChDhD,EAAOR,EAAK0D,QAAU,GAAK1D,EAAK0D,QAAU,EAChDN,EAAO7C,IAAMA,EAPF,KAQX6C,EAAO5C,KAAOA,EARH,MAUf9E,gBAAgB8B,GACZ3B,KAAK+D,OAAOe,eAAenD,GAAMyC,MAAMC,QAAU,IAErDxE,WAAWiI,GACP,MAAMxH,GAACA,EAAEyD,OAAEA,GAAU/D,KACfsE,EAAShE,EAAKA,EAAGiB,IAAI,UAAY,GAGjCwG,MAFSzH,EAAKA,EAAGiB,IAAI,UAAY,IACpByG,aAAe,aAE5B1F,GAAS/C,EAAE0I,UAAUH,IAAStI,EAAO0I,eAAeJ,GAAQA,EAAOxH,EAAGC,cACtE4H,EAAY7F,EAAMf,IAAI,aACtB2B,EAAK3D,EAAE0I,UAAUH,GAAQA,EAAOxF,EAAM8F,QAC5C,IACIC,EADAC,KAEJ,IAAIC,EAAkB,CAAC7H,EAAQoB,EAAGqC,KAC9B,MAAMqE,EAAOrE,EAAKqE,KAClBA,GAAQA,EAAK/G,QAAQgH,IACjB,MAAM5H,EAAO4H,EAAI5H,KACX6H,EAAM7H,EAAK8H,WAAa,GAC9B9H,EAAK8H,WAAuB,OAAVjI,KAAsBgI,KAASX,IAAiBW,EAAIE,QAAQb,EAAa,KAAKc,UAGpGvE,GAAU6D,GACVG,GACIzI,QAAQiC,EAAGqC,MACP,MAAMjB,GAACA,EAAE2D,OAAEA,EAAMiC,QAAEA,GAAW3E,GACxB4E,UAACA,EAASC,SAAEA,EAAQC,YAAEA,EAAWC,eAAEA,EAAcC,cAAEA,GAAiBtC,EAC1E0B,EAAgB,MAAOzG,EAAGqC,GAC1BkE,EAAe/H,EAAGiB,IAAI,gBAAgB6H,gBAAgB9G,GACtDyB,EAAOsF,qBACP,MAAMC,EAAgBC,iBAAiBrG,GACjCsG,EAAanB,EAAaoB,WAChC,IAAIC,EAAeF,EAAWR,GAC9BnC,EAAO8C,UAAYR,GAAkC,SAAjBO,EAChCE,MAAMC,WAAWH,MACjBA,EAAeJ,EAAcN,IAEjC,IAAIc,EAAgBN,EAAWT,GAC/BlC,EAAOkD,WAAab,GAAoC,SAAlBY,EAClCF,MAAMC,WAAWC,MACjBA,EAAgBR,EAAcP,IAElCD,EAAQkB,SAASC,EAAIJ,WAAWH,GAChCZ,EAAQkB,SAASE,EAAIL,WAAWC,GAChClK,EAAc,EACVqJ,IACApC,EAAOsD,WAAa3K,EAAO4K,iBAAiBN,GAC5CjD,EAAOwD,UAAY7K,EAAO4K,iBAAiBV,KAGnD7J,SACIyE,EAAO3D,QAAQ,qBAEnBd,MAAMiC,EAAGqC,GACLoE,EAAgB,SAAUzG,EAAGqC,GAC7BG,EAAO3D,QAAQ,oBACfoD,EAAOsF,mBAAmB,GAC1BzJ,EAAc,GAElBC,aAAaqD,EAAIoH,EAAMhC,MACnB,IAAKD,EACD,OAEJ,MAAMkC,MAACA,EAAKC,gBAAEA,EAAe3D,OAAEA,GAAUyB,GACnCS,UAACA,EAASC,SAAEA,EAAQe,WAAEA,EAAUJ,UAAEA,EAASU,UAAEA,EAASF,WAAEA,GAActD,EACtE4D,GACF,KACA,MACF3E,QAAQ0E,IAAoB,EACxBE,GACF,KACA,MACF5E,QAAQ0E,IAAoB,EACxBpG,KACAuG,EAAMJ,EAAY,GAAJ,EACpB,IAAKE,EAAY,CACb,MAAMG,EAAQ7G,EAAOlC,UAAUgJ,YACzBC,EAAQR,EAAKL,EAAIW,EAAQN,EAAKL,EAAIW,EACxCxG,EAAM4E,GAAYW,EAAY,UAAamB,IAAUT,IAEpDK,IACDtG,EAAM2E,GAAagB,EAAa,UAAaO,EAAKJ,IAAMC,KAE5D9B,EAAa0C,aACN3G,EACHuG,GAAAA,IACCK,YAAaT,IAClB,MACMU,4BAAqClC,4BAAgCC,IAC3E1I,GAAMA,EAAGK,QAAQsK,EAAe,KAAM,MAAQC,OAAQ,MAGtC,iBAAb/C,IACPG,MACOA,KACAH,IAGXnI,KAAK8I,QAAUxE,EAAOC,WAAW,UAC7BrB,GAAAA,EACAoF,QAAAA,EACA7D,MAAO,MAGXH,EAAOM,YAAY,UACnB5E,KAAK8I,QAAU,OAGvBjJ,cAAcsL,GACV,IAAI7K,EAAKN,KAAK6G,OAAOvG,GACjBgC,EAAQ6I,GAAO7K,EAAKA,EAAGC,cAAgB4K,EACvCC,EAAYpL,KAAK+D,OAAOsH,eACxBC,EAAeF,EAAUhH,MAC7B,GAAK9B,EAAL,CAIA,IAAIiJ,EAAUjJ,EAAMf,IAAI,WAExB,GADkBjB,EAAGiB,IAAI,UAAUiK,aAChBD,GAAWA,EAAQ9I,OAAQ,CAG1C,GAFA6I,EAAajH,QAAU,GACvBiH,EAAa9D,QAAU,IAClBxH,KAAKuL,QAAS,CACfH,EAAU9D,UAAY,GACtBtH,KAAKuL,QAAU,IAAI7L,EAAQ6L,GAC3B,IAAIE,EAAc,IAAIhM,GAClBmG,WAAY5F,KAAKuL,QACjBjH,OAAQtE,KAAKsE,OACbhE,GAAAA,IAEJ8K,EAAUM,YAAYD,EAAYE,SAASzI,IAE/ClD,KAAKuL,QAAQK,MAAML,GACnBD,EAAa5G,IAAM,SACnB4G,EAAa3G,KAAO,OAEpB2G,EAAa9D,QAAU,YAtBvB8D,EAAajH,QAAU,GAyB/BxE,iBAAiBsD,GACb,MACMiB,MAACA,GAASpE,KAAK+D,OAAOsH,eAC5BjH,EAAMM,OAAUvB,EAAIuB,QACpBN,EAAMO,QAAWxB,EAAIwB,SACrBP,EAAMC,QAAU,IAEpBxE,oBACI,OAAOG,KAAK+D,OAAO8H,gBAAgBC,eAEvCjM,SAASsE,MACL,OAAOnE,KAAK+D,OAAOgI,WAAW5H,EAAKxC,OAEvC9B,gBACIG,KAAKgM,eAETnM,cACIG,KAAKqD,mBACLrD,KAAKqB,mBAET4K,eAAeC,GACJA,GAA+B,aAAvBA,EAAK3K,IAAI,UAE5B1B,iBAAiB0C,GACb,MAAMW,GAACA,EAAEC,IAAEA,EAAGxB,KAAEA,EAAIoB,UAAEA,GAAaR,GAAQvC,KAAK8D,eAChD,IAAKZ,EAED,YADAlD,KAAKmM,YAAc,GAGvB,MAAMC,EAAYrJ,EAAUxB,IAAI,aAC1B8K,EAAUrM,KAAKmM,cAAgBjJ,EAC/BoJ,EAAYD,MAAiBzF,QAAS,GACxCyF,GAAWD,IACXpM,KAAKmM,YAAcjJ,EACnBlD,KAAKuM,gBAAgB5K,GACrB3B,KAAKwM,kBAAkBtJ,EAAIC,GAAOxB,KAAAA,KAElC3B,KAAKiM,eAAelJ,KACpB/C,KAAKyM,gBAAgB9K,GACrB3B,KAAK0M,kBAAkB/K,IAE3B,MACMyC,MAACA,GAASpE,KAAKiE,cAAc,EAAGtC,GAChC1B,EAAWD,KAAK+D,OAAO4I,iBAAiBzJ,EAAIC,GAC5CyE,EAAS3H,EAASyE,IAClBmD,EAAU5H,EAAS0E,KACzB3E,KAAK4M,YAAY1J,EAAIC,MACdmJ,EACH3K,KAAAA,EACAiG,OAAAA,EACAC,QAAAA,IAEJzD,EAAMM,IAAMkD,EAXC,KAYbxD,EAAMO,KAAOkD,EAZA,KAabzD,EAAM0G,MAAQ3H,EAAI2H,MAbL,KAcb1G,EAAMyI,OAAS1J,EAAI0J,OAdN,MAgBjBhN,oBACI,MAAMqD,GAACA,EAAEC,IAAEA,EAAGJ,UAAEA,GAAa/C,KAAK6D,gBAClC,IAAKX,EAGD,OAFAlD,KAAKiE,qBACLjE,KAAK8M,aAAe,GAGxB,MAAM/I,OAACA,GAAU/D,KACDA,KAAK8M,eAAiB5J,IAElClD,KAAK8M,aAAe5J,EACpBlD,KAAK+M,cAAchK,IAEvB,MACMqB,MAACA,GAASpE,KAAKiE,cAAc,GAC7B+I,EAAejJ,EAAOkJ,wBAAwB/J,EAAIa,EAAOsH,gBAAkBlI,IAAAA,IAC3EyE,EAASoF,EAAaE,gBACtBrF,EAAUmF,EAAaG,iBAC7B/I,EAAMM,IAAMkD,EALC,KAMbxD,EAAMO,KAAOkD,EANA,KAObzD,EAAM0G,MAAQ3H,EAAI2H,MAPL,KAQb1G,EAAMyI,OAAS1J,EAAI0J,OARN,KASb7M,KAAKoN,kBACD1I,IAAKsI,EAAatI,IAClBC,KAAMqI,EAAarI,QAG3BrD,eAAgB/B,EAAEgE,SAAS,WACvBvD,KAAK2D,sBAET9D,cAAcqD,GACV,OAAOlD,KAAK+D,OAAO8H,gBAAgBzI,cAAcF,IAErDrD,YACIG,KAAK2G,WAAWvC,MAAMoD,QAAU,QAEpC3H,cAAcyC,GACVA,GAASA,EAAMO,KACXwK,OAAQ,GACRxI,MAAO,MAGfhF,mBACI,OAAOG,KAAK+D,OAAOnC,aAEvB/B,IAAIyE,GACAtE,KAAKsE,OAASA,GAAUA,EAAO/C,IAAI,UACnCvB,KAAKS,UAETZ,KAAKyN,EAAIC,EAAQpJ,MACb,MAAM7D,GAACA,EAAEgE,OAAEA,GAAUtE,KACrBA,KAAKwN,uBACJrJ,EAAKsJ,kBAAoBnN,EAAGoN,YAAY,MACzC1N,KAAKe,QACLf,KAAKiE,gBACLK,GAAUA,EAAOM,YAAY","file":"../../../commands/view/SelectComponent.js","sourcesContent":["define([\n    'skylark-backbone',\n    'skylark-underscore',\n    '../../utils/mixins',\n    '../../dom_components/view/ToolbarView',\n    '../../dom_components/model/Toolbar'\n], function (Backbone, a, mixins, ToolbarView, Toolbar) {\n    'use strict';\n    const $ = Backbone.$;\n    let showOffsets;\n    return {\n        init(o) {\n            a.bindAll(this, 'onHover', 'onOut', 'onClick', 'onFrameScroll', 'onFrameUpdated');\n        },\n        enable() {\n            this.frameOff = this.canvasOff = this.adjScroll = null;\n            this.startSelectComponent();\n            showOffsets = 1;\n        },\n        startSelectComponent() {\n            this.toggleSelectComponent(1);\n            this.em.getSelected() && this.onSelect();\n        },\n        stopSelectComponent() {\n            this.toggleSelectComponent();\n        },\n        toggleSelectComponent(enable) {\n            const {em} = this;\n            const method = enable ? 'on' : 'off';\n\n            const trigger = (win, body) => {\n                mixins[method](body, 'mouseover', this.onHover);\n                mixins[method](body, 'mouseleave', this.onOut);\n                mixins[method](body, 'click touchend', this.onClick);\n                mixins[method](win, 'scroll', this.onFrameScroll);\n            };\n            mixins[method](window, 'resize', this.onFrameUpdated);\n            em[method]('component:toggled', this.onSelect, this);\n            em[method]('change:componentHovered', this.onHovered, this);\n            em[method]('component:resize component:styleUpdate', this.updateGlobalPos, this);\n            em[method]('change:canvasOffset', this.updateAttached, this);\n            em[method]('frame:updated', this.onFrameUpdated, this);\n            em.get('Canvas').getFrames().forEach(frame => {\n                const {view} = frame;\n                trigger(view.getWindow(), view.getBody());\n            });\n        },\n        onHover(e) {\n            e.stopPropagation();\n            const trg = e.target;\n            const view = mixins.getViewEl(trg);\n            const frameView = view && view._getFrame();\n            const $el = $(trg);\n            let model = $el.data('model');\n            if (!model) {\n                let parent = $el.parent();\n                while (!model && parent.length > 0) {\n                    model = parent.data('model');\n                    parent = parent.parent();\n                }\n            }\n            if (model && !model.get('hoverable')) {\n                let parent = model && model.parent();\n                while (parent && !parent.get('hoverable'))\n                    parent = parent.parent();\n                model = parent;\n            }\n            this.currentDoc = trg.ownerDocument;\n            this.em.setHovered(model);\n            frameView && this.em.set('currentFrame', frameView);\n        },\n        onFrameUpdated() {\n            this.updateLocalPos();\n            this.updateGlobalPos();\n        },\n        onHovered(em, component) {\n            let result = {};\n            if (component) {\n                component.views.forEach(view => {\n                    const el = view.el;\n                    const pos = this.getElementPos(el);\n                    result = {\n                        el,\n                        pos,\n                        component,\n                        view: mixins.getViewEl(el)\n                    };\n                    this.updateToolsLocal(result);\n                    if (el.ownerDocument === this.currentDoc)\n                        this.elHovered = result;\n                });\n            }\n        },\n        onSelect: a.debounce(function () {\n            const {em} = this;\n            const component = em.getSelected();\n            const currentFrame = em.get('currentFrame') || {};\n            const view = component && component.getView(currentFrame.model);\n            let el = view && view.el;\n            let result = {};\n            if (el) {\n                const pos = this.getElementPos(el);\n                result = {\n                    el,\n                    pos,\n                    component,\n                    view: mixins.getViewEl(el)\n                };\n            }\n            this.elSelected = result;\n            this.updateToolsGlobal();\n            this.updateToolsLocal(result);\n        }),\n        updateGlobalPos() {\n            const sel = this.getElSelected();\n            if (!sel.el)\n                return;\n            sel.pos = this.getElementPos(sel.el);\n            this.updateToolsGlobal();\n        },\n        updateLocalPos() {\n            const sel = this.getElHovered();\n            if (!sel.el)\n                return;\n            sel.pos = this.getElementPos(sel.el);\n            this.updateToolsLocal();\n        },\n        getElHovered() {\n            return this.elHovered || {};\n        },\n        getElSelected() {\n            return this.elSelected || {};\n        },\n        onOut() {\n            this.currentDoc = null;\n            this.em.setHovered(0);\n            this.canvas.getFrames().forEach(frame => {\n                const el = frame.view.getToolsEl();\n                this.toggleToolsEl(0, 0, { el });\n            });\n        },\n        toggleToolsEl(on, view, opts = {}) {\n            const el = opts.el || this.canvas.getToolsEl(view);\n            el.style.opacity = on ? 1 : 0;\n            return el;\n        },\n        showElementOffset(el, pos, opts = {}) {\n            if (!showOffsets)\n                return;\n            this.editor.runCommand('show-offset', {\n                el,\n                elPos: pos,\n                view: opts.view,\n                force: 1,\n                top: 0,\n                left: 0\n            });\n        },\n        hideElementOffset(view) {\n            this.editor.stopCommand('show-offset', { view });\n        },\n        showFixedElementOffset(el, pos) {\n            this.editor.runCommand('show-offset', {\n                el,\n                elPos: pos,\n                state: 'Fixed'\n            });\n        },\n        hideFixedElementOffset(el, pos) {\n            if (this.editor)\n                this.editor.stopCommand('show-offset', { state: 'Fixed' });\n        },\n        hideHighlighter(view) {\n            this.canvas.getHighlighter(view).style.opacity = 0;\n        },\n        onClick(ev) {\n            ev.stopPropagation();\n            ev.preventDefault();\n            const {em} = this;\n            if (em.get('_cmpDrag'))\n                return em.set('_cmpDrag');\n            const $el = $(ev.target);\n            let model = $el.data('model');\n            if (!model) {\n                let parent = $el.parent();\n                while (!model && parent.length > 0) {\n                    model = parent.data('model');\n                    parent = parent.parent();\n                }\n            }\n            if (model) {\n                if (model.get('selectable')) {\n                    this.select(model, ev);\n                } else {\n                    let parent = model.parent();\n                    while (parent && !parent.get('selectable'))\n                        parent = parent.parent();\n                    this.select(parent, ev);\n                }\n            }\n        },\n        select(model, event = {}) {\n            if (!model)\n                return;\n            const ctrlKey = event.ctrlKey || event.metaKey;\n            const {shiftKey} = event;\n            const {editor, em} = this;\n            const multiple = editor.getConfig('multipleSelection');\n            if (ctrlKey && multiple) {\n                editor.selectToggle(model);\n            } else if (shiftKey && multiple) {\n                em.clearSelection(editor.Canvas.getWindow());\n                const coll = model.collection;\n                const index = coll.indexOf(model);\n                const selAll = editor.getSelectedAll();\n                let min, max;\n                editor.getSelectedAll().forEach(sel => {\n                    const selColl = sel.collection;\n                    const selIndex = selColl.indexOf(sel);\n                    if (selColl === coll) {\n                        if (selIndex < index) {\n                            min = a.isUndefined(min) ? selIndex : Math.max(min, selIndex);\n                        } else if (selIndex > index) {\n                            max = a.isUndefined(max) ? selIndex : Math.min(max, selIndex);\n                        }\n                    }\n                });\n                if (!a.isUndefined(min)) {\n                    while (min !== index) {\n                        editor.selectAdd(coll.at(min));\n                        min++;\n                    }\n                }\n                if (!a.isUndefined(max)) {\n                    while (max !== index) {\n                        editor.selectAdd(coll.at(max));\n                        max--;\n                    }\n                }\n                editor.selectAdd(model);\n            } else {\n                editor.select(model, { scroll: {} });\n            }\n            this.initResize(model);\n        },\n        updateBadge(el, pos, opts = {}) {\n            const model = $(el).data('model');\n            if (!model || !model.get('badgable'))\n                return;\n            const badge = this.getBadge(opts);\n            if (!opts.posOnly) {\n                const config = this.canvas.getConfig();\n                const icon = model.getIcon();\n                const ppfx = config.pStylePrefix || '';\n                const clsBadge = `${ ppfx }badge`;\n                const customeLabel = config.customBadgeLabel;\n                const badgeLabel = `${ icon ? `<div class=\"${ clsBadge }__icon\">${ icon }</div>` : '' }\n        <div class=\"${ clsBadge }__name\">${ model.getName() }</div>`;\n                badge.innerHTML = customeLabel ? customeLabel(model) : badgeLabel;\n            }\n            const un = 'px';\n            const bStyle = badge.style;\n            bStyle.display = 'block';\n            const badgeH = badge ? badge.offsetHeight : 0;\n            const posTop = 0 - badgeH;\n            const top = opts.topOff - badgeH < 0 ? -opts.topOff : posTop;\n            const left = opts.leftOff < 0 ? -opts.leftOff : 0;\n            bStyle.top = top + un;\n            bStyle.left = left + un;\n        },\n        showHighlighter(view) {\n            this.canvas.getHighlighter(view).style.opacity = '';\n        },\n        initResize(elem) {\n            const {em, canvas} = this;\n            const editor = em ? em.get('Editor') : '';\n            const config = em ? em.get('Config') : '';\n            const pfx = config.stylePrefix || '';\n            const resizeClass = `${ pfx }resizing`;\n            const model = !a.isElement(elem) && mixins.isTaggableNode(elem) ? elem : em.getSelected();\n            const resizable = model.get('resizable');\n            const el = a.isElement(elem) ? elem : model.getEl();\n            let options = {};\n            let modelToStyle;\n            var toggleBodyClass = (method, e, opts) => {\n                const docs = opts.docs;\n                docs && docs.forEach(doc => {\n                    const body = doc.body;\n                    const cls = body.className || '';\n                    body.className = (method == 'add' ? `${ cls } ${ resizeClass }` : cls.replace(resizeClass, '')).trim();\n                });\n            };\n            if (editor && resizable) {\n                options = {\n                    onStart(e, opts = {}) {\n                        const {el, config, resizer} = opts;\n                        const {keyHeight, keyWidth, currentUnit, keepAutoHeight, keepAutoWidth} = config;\n                        toggleBodyClass('add', e, opts);\n                        modelToStyle = em.get('StyleManager').getModelToStyle(model);\n                        canvas.toggleFramesEvents();\n                        const computedStyle = getComputedStyle(el);\n                        const modelStyle = modelToStyle.getStyle();\n                        let currentWidth = modelStyle[keyWidth];\n                        config.autoWidth = keepAutoWidth && currentWidth === 'auto';\n                        if (isNaN(parseFloat(currentWidth))) {\n                            currentWidth = computedStyle[keyWidth];\n                        }\n                        let currentHeight = modelStyle[keyHeight];\n                        config.autoHeight = keepAutoHeight && currentHeight === 'auto';\n                        if (isNaN(parseFloat(currentHeight))) {\n                            currentHeight = computedStyle[keyHeight];\n                        }\n                        resizer.startDim.w = parseFloat(currentWidth);\n                        resizer.startDim.h = parseFloat(currentHeight);\n                        showOffsets = 0;\n                        if (currentUnit) {\n                            config.unitHeight = mixins.getUnitFromValue(currentHeight);\n                            config.unitWidth = mixins.getUnitFromValue(currentWidth);\n                        }\n                    },\n                    onMove() {\n                        editor.trigger('component:resize');\n                    },\n                    onEnd(e, opts) {\n                        toggleBodyClass('remove', e, opts);\n                        editor.trigger('component:resize');\n                        canvas.toggleFramesEvents(1);\n                        showOffsets = 1;\n                    },\n                    updateTarget(el, rect, options = {}) {\n                        if (!modelToStyle) {\n                            return;\n                        }\n                        const {store, selectedHandler, config} = options;\n                        const {keyHeight, keyWidth, autoHeight, autoWidth, unitWidth, unitHeight} = config;\n                        const onlyHeight = [\n                            'tc',\n                            'bc'\n                        ].indexOf(selectedHandler) >= 0;\n                        const onlyWidth = [\n                            'cl',\n                            'cr'\n                        ].indexOf(selectedHandler) >= 0;\n                        const style = {};\n                        const en = !store ? 1 : '';\n                        if (!onlyHeight) {\n                            const bodyw = canvas.getBody().offsetWidth;\n                            const width = rect.w < bodyw ? rect.w : bodyw;\n                            style[keyWidth] = autoWidth ? 'auto' : `${ width }${ unitWidth }`;\n                        }\n                        if (!onlyWidth) {\n                            style[keyHeight] = autoHeight ? 'auto' : `${ rect.h }${ unitHeight }`;\n                        }\n                        modelToStyle.addStyle({\n                            ...style,\n                            en\n                        }, { avoidStore: !store });\n                        const updateEvent = `update:component:style`;\n                        const eventToListen = `${ updateEvent }:${ keyHeight } ${ updateEvent }:${ keyWidth }`;\n                        em && em.trigger(eventToListen, null, null, { noEmit: 1 });\n                    }\n                };\n                if (typeof resizable == 'object') {\n                    options = {\n                        ...options,\n                        ...resizable\n                    };\n                }\n                this.resizer = editor.runCommand('resize', {\n                    el,\n                    options,\n                    force: 1\n                });\n            } else {\n                editor.stopCommand('resize');\n                this.resizer = null;\n            }\n        },\n        updateToolbar(mod) {\n            var em = this.config.em;\n            var model = mod == em ? em.getSelected() : mod;\n            var toolbarEl = this.canvas.getToolbarEl();\n            var toolbarStyle = toolbarEl.style;\n            if (!model) {\n                toolbarStyle.opacity = 0;\n                return;\n            }\n            var toolbar = model.get('toolbar');\n            var showToolbar = em.get('Config').showToolbar;\n            if (showToolbar && toolbar && toolbar.length) {\n                toolbarStyle.opacity = '';\n                toolbarStyle.display = '';\n                if (!this.toolbar) {\n                    toolbarEl.innerHTML = '';\n                    this.toolbar = new Toolbar(toolbar);\n                    var toolbarView = new ToolbarView({\n                        collection: this.toolbar,\n                        editor: this.editor,\n                        em\n                    });\n                    toolbarEl.appendChild(toolbarView.render().el);\n                }\n                this.toolbar.reset(toolbar);\n                toolbarStyle.top = '-100px';\n                toolbarStyle.left = 0;\n            } else {\n                toolbarStyle.display = 'none';\n            }\n        },\n        updateToolbarPos(pos) {\n            const unit = 'px';\n            const {style} = this.canvas.getToolbarEl();\n            style.top = `${ pos.top }${ unit }`;\n            style.left = `${ pos.left }${ unit }`;\n            style.opacity = '';\n        },\n        getCanvasPosition() {\n            return this.canvas.getCanvasView().getPosition();\n        },\n        getBadge(opts = {}) {\n            return this.canvas.getBadgeEl(opts.view);\n        },\n        onFrameScroll() {\n            this.updateTools();\n        },\n        updateTools() {\n            this.updateToolsLocal();\n            this.updateGlobalPos();\n        },\n        isCompSelected(comp) {\n            return comp && comp.get('status') === 'selected';\n        },\n        updateToolsLocal(data) {\n            const {el, pos, view, component} = data || this.getElHovered();\n            if (!el) {\n                this.lastHovered = 0;\n                return;\n            }\n            const isHoverEn = component.get('hoverable');\n            const isNewEl = this.lastHovered !== el;\n            const badgeOpts = isNewEl ? {} : { posOnly: 1 };\n            if (isNewEl && isHoverEn) {\n                this.lastHovered = el;\n                this.showHighlighter(view);\n                this.showElementOffset(el, pos, { view });\n            }\n            if (this.isCompSelected(component)) {\n                this.hideHighlighter(view);\n                this.hideElementOffset(view);\n            }\n            const unit = 'px';\n            const {style} = this.toggleToolsEl(1, view);\n            const frameOff = this.canvas.canvasRectOffset(el, pos);\n            const topOff = frameOff.top;\n            const leftOff = frameOff.left;\n            this.updateBadge(el, pos, {\n                ...badgeOpts,\n                view,\n                topOff,\n                leftOff\n            });\n            style.top = topOff + unit;\n            style.left = leftOff + unit;\n            style.width = pos.width + unit;\n            style.height = pos.height + unit;\n        },\n        updateToolsGlobal() {\n            const {el, pos, component} = this.getElSelected();\n            if (!el) {\n                this.toggleToolsEl();\n                this.lastSelected = 0;\n                return;\n            }\n            const {canvas} = this;\n            const isNewEl = this.lastSelected !== el;\n            if (isNewEl) {\n                this.lastSelected = el;\n                this.updateToolbar(component);\n            }\n            const unit = 'px';\n            const {style} = this.toggleToolsEl(1);\n            const targetToElem = canvas.getTargetToElementFixed(el, canvas.getToolbarEl(), { pos });\n            const topOff = targetToElem.canvasOffsetTop;\n            const leftOff = targetToElem.canvasOffsetLeft;\n            style.top = topOff + unit;\n            style.left = leftOff + unit;\n            style.width = pos.width + unit;\n            style.height = pos.height + unit;\n            this.updateToolbarPos({\n                top: targetToElem.top,\n                left: targetToElem.left\n            });\n        },\n        updateAttached: a.debounce(function () {\n            this.updateToolsGlobal();\n        }),\n        getElementPos(el) {\n            return this.canvas.getCanvasView().getElementPos(el);\n        },\n        hideBadge() {\n            this.getBadge().style.display = 'none';\n        },\n        cleanPrevious(model) {\n            model && model.set({\n                status: '',\n                state: ''\n            });\n        },\n        getContentWindow() {\n            return this.canvas.getWindow();\n        },\n        run(editor) {\n            this.editor = editor && editor.get('Editor');\n            this.enable();\n        },\n        stop(ed, sender, opts = {}) {\n            const {em, editor} = this;\n            this.stopSelectComponent();\n            !opts.preserveSelected && em.setSelected(null);\n            this.onOut();\n            this.toggleToolsEl();\n            editor && editor.stopCommand('resize');\n        }\n    };\n});"]}
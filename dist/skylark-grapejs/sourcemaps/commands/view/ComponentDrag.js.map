{"version":3,"sources":["commands/view/ComponentDrag.js"],"names":["define","a","Dragger","[object Object]","editor","sender","opts","bindAll","this","target","event","mode","dragger","config","doc","getEl","ownerDocument","onStart","onEnd","onDrag","getPosition","setPosition","guidesStatic","guidesTarget","setupGuides","em","getModel","isTran","guidesContainer","getGuidesContainer","getGuidesTarget","getGuidesStatic","drg","setOptions","start","toggleDrag","trigger","getEventOpts","guides","forEach","item","guide","parentNode","removeChild","guidesEl","pfx","getConfig","elInfoX","document","createElement","elInfoY","guideContent","className","innerHTML","appendChild","Canvas","getGlobalToolsEl","elGuideInfoX","elGuideInfoY","elGuideInfoContentX","querySelector","elGuideInfoContentY","on","debounce","updateGuides","debug","renderGuide","result","el","each","children","concat","getElementGuides","lastEl","lastPos","origin","pos","getElementPos","getGuidePosUpdate","val","key","originRect","rect","top","height","left","width","type","y","x","guideSize","active","numEl","style","length","noScroll","map","push","transform","axis","split","itemStr","trim","fn","toUpperCase","indexOf","parseFloat","replace","value","join","getStyle","getTranslate","end","position","en","setTranslate","addStyle","avoidStore","adds","keys","add","prop","parent","index","center","_getDragData","offset","getMouseRelativeCanvas","args","guidesInfo","renderGuideInfo","filter","ev","opt","id","stopCommand","hideGuidesInfo","display","rectOrigin","isUndefined","isY","origEdge1","origEdge1Raw","origEdge2","origEdge2Raw","elGuideInfo","elGuideInfoCnt","guideInfoStyle","res","stat","statEdge2","gap","sort","b","isEdge1","statEdge1","statEdge1Raw","statEdge2Raw","posFirst","posSecond","pos2","size","sizeRaw","Math","round","matched","enable","ppfx","methodCls","classes","body","getBody","cls","classList"],"mappings":"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","file":"../../../commands/view/ComponentDrag.js","sourcesContent":["define([\n    'skylark-underscore',\n    '../../utils/Dragger'\n], function (a, Dragger) {\n    'use strict';\n    const evName = 'dmode';\n    return {\n        run(editor, sender, opts = {}) {\n            a.bindAll(this, 'setPosition', 'onStart', 'onDrag', 'onEnd', 'getPosition', 'getGuidesStatic', 'renderGuide', 'getGuidesTarget');\n            const {target, event, mode, dragger = {}} = opts;\n            const el = target.getEl();\n            const config = {\n                doc: el.ownerDocument,\n                onStart: this.onStart,\n                onEnd: this.onEnd,\n                onDrag: this.onDrag,\n                getPosition: this.getPosition,\n                setPosition: this.setPosition,\n                guidesStatic: () => this.guidesStatic,\n                guidesTarget: () => this.guidesTarget,\n                ...dragger\n            };\n            this.setupGuides();\n            this.opts = opts;\n            this.editor = editor;\n            this.em = editor.getModel();\n            this.target = target;\n            this.isTran = mode == 'translate';\n            this.guidesContainer = this.getGuidesContainer();\n            this.guidesTarget = this.getGuidesTarget();\n            this.guidesStatic = this.getGuidesStatic();\n            let drg = this.dragger;\n            if (!drg) {\n                drg = new Dragger(config);\n                this.dragger = drg;\n            } else {\n                drg.setOptions(config);\n            }\n            event && drg.start(event);\n            this.toggleDrag(1);\n            this.em.trigger(`${ evName }:start`, this.getEventOpts());\n            return drg;\n        },\n        getEventOpts() {\n            return {\n                mode: this.opts.mode,\n                target: this.target,\n                guidesTarget: this.guidesTarget,\n                guidesStatic: this.guidesStatic\n            };\n        },\n        stop() {\n            this.toggleDrag();\n        },\n        setupGuides() {\n            (this.guides || []).forEach(item => {\n                const {guide} = item;\n                guide && guide.parentNode.removeChild(guide);\n            });\n            this.guides = [];\n        },\n        getGuidesContainer() {\n            let {guidesEl} = this;\n            if (!guidesEl) {\n                const {editor, em, opts} = this;\n                const pfx = editor.getConfig('stylePrefix');\n                const elInfoX = document.createElement('div');\n                const elInfoY = document.createElement('div');\n                const guideContent = `<div class=\"${ pfx }guide-info__line ${ pfx }danger-bg\">\n        <div class=\"${ pfx }guide-info__content ${ pfx }danger-color\"></div>\n      </div>`;\n                guidesEl = document.createElement('div');\n                guidesEl.className = `${ pfx }guides`;\n                elInfoX.className = `${ pfx }guide-info ${ pfx }guide-info__x`;\n                elInfoY.className = `${ pfx }guide-info ${ pfx }guide-info__y`;\n                elInfoX.innerHTML = guideContent;\n                elInfoY.innerHTML = guideContent;\n                guidesEl.appendChild(elInfoX);\n                guidesEl.appendChild(elInfoY);\n                editor.Canvas.getGlobalToolsEl().appendChild(guidesEl);\n                this.guidesEl = guidesEl;\n                this.elGuideInfoX = elInfoX;\n                this.elGuideInfoY = elInfoY;\n                this.elGuideInfoContentX = elInfoX.querySelector(`.${ pfx }guide-info__content`);\n                this.elGuideInfoContentY = elInfoY.querySelector(`.${ pfx }guide-info__content`);\n                em.on('canvas:update frame:scroll', a.debounce(() => {\n                    this.updateGuides();\n                    opts.debug && this.guides.forEach(item => this.renderGuide(item));\n                }, 200));\n            }\n            return guidesEl;\n        },\n        getGuidesStatic() {\n            let result = [];\n            const el = this.target.getEl();\n            const {\n                parentNode = {}\n            } = el;\n            a.each(parentNode.children, item => result = result.concat(el !== item ? this.getElementGuides(item) : []));\n            return result.concat(this.getElementGuides(parentNode));\n        },\n        getGuidesTarget() {\n            return this.getElementGuides(this.target.getEl());\n        },\n        updateGuides(guides) {\n            let lastEl, lastPos;\n            (guides || this.guides).forEach(item => {\n                const {origin} = item;\n                const pos = lastEl === origin ? lastPos : this.getElementPos(origin);\n                lastEl = origin;\n                lastPos = pos;\n                a.each(this.getGuidePosUpdate(item, pos), (val, key) => item[key] = val);\n                item.originRect = pos;\n            });\n        },\n        getGuidePosUpdate(item, rect) {\n            const result = {};\n            const {top, height, left, width} = rect;\n            switch (item.type) {\n            case 't':\n                result.y = top;\n                break;\n            case 'b':\n                result.y = top + height;\n                break;\n            case 'l':\n                result.x = left;\n                break;\n            case 'r':\n                result.x = left + width;\n                break;\n            case 'x':\n                result.x = left + width / 2;\n                break;\n            case 'y':\n                result.y = top + height / 2;\n                break;\n            }\n            return result;\n        },\n        renderGuide(item = {}) {\n            const el = item.guide || document.createElement('div');\n            const un = 'px';\n            const guideSize = item.active ? 2 : 1;\n            let numEl = el.children[0];\n            el.style = `position: absolute; background-color: ${ item.active ? 'green' : 'red' };`;\n            if (!el.children.length) {\n                numEl = document.createElement('div');\n                numEl.style = 'position: absolute; color: red; padding: 5px; top: 0; left: 0;';\n                el.appendChild(numEl);\n            }\n            if (item.y) {\n                el.style.width = '100%';\n                el.style.height = `${ guideSize }${ un }`;\n                el.style.top = `${ item.y }${ un }`;\n                el.style.left = 0;\n            } else {\n                el.style.width = `${ guideSize }${ un }`;\n                el.style.height = '100%';\n                el.style.left = `${ item.x }${ un }`;\n                el.style.top = `0${ un }`;\n            }\n            !item.guide && this.guidesContainer.appendChild(el);\n            return el;\n        },\n        getElementPos(el) {\n            return this.editor.Canvas.getElementPos(el, { noScroll: 1 });\n        },\n        getElementGuides(el) {\n            const {opts} = this;\n            const originRect = this.getElementPos(el);\n            const {top, height, left, width} = originRect;\n            const guides = [\n                {\n                    type: 't',\n                    y: top\n                },\n                {\n                    type: 'b',\n                    y: top + height\n                },\n                {\n                    type: 'l',\n                    x: left\n                },\n                {\n                    type: 'r',\n                    x: left + width\n                },\n                {\n                    type: 'x',\n                    x: left + width / 2\n                },\n                {\n                    type: 'y',\n                    y: top + height / 2\n                }\n            ].map(item => ({\n                ...item,\n                origin: el,\n                originRect,\n                guide: opts.debug && this.renderGuide(item)\n            }));\n            guides.forEach(item => this.guides.push(item));\n            return guides;\n        },\n        getTranslate(transform, axis = 'x') {\n            let result = 0;\n            (transform || '').split(' ').forEach(item => {\n                const itemStr = item.trim();\n                const fn = `translate${ axis.toUpperCase() }(`;\n                if (itemStr.indexOf(fn) === 0)\n                    result = parseFloat(itemStr.replace(fn, ''));\n            });\n            return result;\n        },\n        setTranslate(transform, axis, value) {\n            const fn = `translate${ axis.toUpperCase() }(`;\n            const val = `${ fn }${ value })`;\n            let result = (transform || '').split(' ').map(item => {\n                const itemStr = item.trim();\n                if (itemStr.indexOf(fn) === 0)\n                    item = val;\n                return item;\n            }).join(' ');\n            if (result.indexOf(fn) < 0)\n                result += ` ${ val }`;\n            return result;\n        },\n        getPosition() {\n            const {target, isTran} = this;\n            const {left, top, transform} = target.getStyle();\n            let x = 0;\n            let y = 0;\n            if (isTran) {\n                x = this.getTranslate(transform);\n                y = this.getTranslate(transform, 'y');\n            } else {\n                x = parseFloat(left);\n                y = parseFloat(top);\n            }\n            return {\n                x,\n                y\n            };\n        },\n        setPosition({x, y, end, position, width, height}) {\n            const {target, isTran} = this;\n            const unit = 'px';\n            const en = !end ? 1 : '';\n            const left = `${ x }${ unit }`;\n            const top = `${ y }${ unit }`;\n            if (isTran) {\n                let transform = target.getStyle()['transform'] || '';\n                transform = this.setTranslate(transform, 'x', left);\n                transform = this.setTranslate(transform, 'y', top);\n                return target.addStyle({\n                    transform,\n                    en\n                }, { avoidStore: !end });\n            }\n            const adds = {\n                position,\n                width,\n                height\n            };\n            const style = {\n                left,\n                top,\n                en\n            };\n            a.keys(adds).forEach(add => {\n                const prop = adds[add];\n                if (prop)\n                    style[add] = prop;\n            });\n            target.addStyle(style, { avoidStore: !end });\n        },\n        _getDragData() {\n            const {target} = this;\n            return {\n                target,\n                parent: target.parent(),\n                index: target.index()\n            };\n        },\n        onStart() {\n            const {target, editor, isTran, opts} = this;\n            const {center, onStart} = opts;\n            const {Canvas} = editor;\n            const style = target.getStyle();\n            const position = 'absolute';\n            onStart && onStart(this._getDragData());\n            if (isTran)\n                return;\n            if (style.position !== position) {\n                let {left, top, width, height} = Canvas.offset(target.getEl());\n                if (center) {\n                    const {x, y} = Canvas.getMouseRelativeCanvas(event);\n                    left = x;\n                    top = y;\n                }\n                this.setPosition({\n                    x: left,\n                    y: top,\n                    width: `${ width }px`,\n                    height: `${ height }px`,\n                    position\n                });\n            }\n        },\n        onDrag(...args) {\n            const {guidesTarget, opts} = this;\n            const {onDrag} = opts;\n            this.updateGuides(guidesTarget);\n            opts.debug && guidesTarget.forEach(item => this.renderGuide(item));\n            opts.guidesInfo && this.renderGuideInfo(guidesTarget.filter(item => item.active));\n            onDrag && onDrag(this._getDragData());\n        },\n        onEnd(ev, dragger, opt = {}) {\n            const {editor, opts, id} = this;\n            const {onEnd} = opts;\n            onEnd && onEnd(ev, opt, {\n                event: ev,\n                ...opt,\n                ...this._getDragData()\n            });\n            editor.stopCommand(id);\n            this.hideGuidesInfo();\n            this.em.trigger(`${ evName }:end`, this.getEventOpts());\n        },\n        hideGuidesInfo() {\n            [\n                'X',\n                'Y'\n            ].forEach(item => {\n                const guide = this[`elGuideInfo${ item }`];\n                if (guide)\n                    guide.style.display = 'none';\n            });\n        },\n        renderGuideInfo(guides = []) {\n            const {guidesStatic} = this;\n            this.hideGuidesInfo();\n            guides.forEach(item => {\n                const {origin, x} = item;\n                const rectOrigin = this.getElementPos(origin);\n                const axis = a.isUndefined(x) ? 'y' : 'x';\n                const isY = axis === 'y';\n                const origEdge1 = rectOrigin[isY ? 'left' : 'top'];\n                const origEdge1Raw = rectOrigin.rect[isY ? 'left' : 'top'];\n                const origEdge2 = isY ? origEdge1 + rectOrigin.width : origEdge1 + rectOrigin.height;\n                const origEdge2Raw = isY ? origEdge1Raw + rectOrigin.rect.width : origEdge1Raw + rectOrigin.rect.height;\n                const elGuideInfo = this[`elGuideInfo${ axis.toUpperCase() }`];\n                const elGuideInfoCnt = this[`elGuideInfoContent${ axis.toUpperCase() }`];\n                const guideInfoStyle = elGuideInfo.style;\n                const res = guidesStatic.filter(stat => stat.type === item.type).map(stat => {\n                    const {left, width, top, height} = stat.originRect;\n                    const statEdge1 = isY ? left : top;\n                    const statEdge2 = isY ? left + width : top + height;\n                    return {\n                        gap: statEdge2 < origEdge1 ? origEdge1 - statEdge2 : statEdge1 - origEdge2,\n                        guide: stat\n                    };\n                }).filter(item => item.gap > 0).sort((a, b) => a.gap - b.gap).map(item => item.guide)[0];\n                if (res) {\n                    const {left, width, top, height, rect} = res.originRect;\n                    const isEdge1 = isY ? left < rectOrigin.left : top < rectOrigin.top;\n                    const statEdge1 = isY ? left : top;\n                    const statEdge1Raw = isY ? rect.left : rect.top;\n                    const statEdge2 = isY ? left + width : top + height;\n                    const statEdge2Raw = isY ? rect.left + rect.width : rect.top + rect.height;\n                    const posFirst = isY ? item.y : item.x;\n                    const posSecond = isEdge1 ? statEdge2 : origEdge2;\n                    const pos2 = `${ posFirst }px`;\n                    const size = isEdge1 ? origEdge1 - statEdge2 : statEdge1 - origEdge2;\n                    const sizeRaw = isEdge1 ? origEdge1Raw - statEdge2Raw : statEdge1Raw - origEdge2Raw;\n                    guideInfoStyle.display = '';\n                    guideInfoStyle[isY ? 'top' : 'left'] = pos2;\n                    guideInfoStyle[isY ? 'left' : 'top'] = `${ posSecond }px`;\n                    guideInfoStyle[isY ? 'width' : 'height'] = `${ size }px`;\n                    elGuideInfoCnt.innerHTML = `${ Math.round(sizeRaw) }px`;\n                    this.em.trigger(`${ evName }:active`, {\n                        ...this.getEventOpts(),\n                        guide: item,\n                        guidesStatic,\n                        matched: res,\n                        posFirst,\n                        posSecond,\n                        size,\n                        sizeRaw,\n                        elGuideInfo,\n                        elGuideInfoCnt\n                    });\n                }\n            });\n        },\n        toggleDrag(enable) {\n            const {ppfx, editor} = this;\n            const methodCls = enable ? 'add' : 'remove';\n            const classes = [`${ ppfx }is__grabbing`];\n            const {Canvas} = editor;\n            const body = Canvas.getBody();\n            classes.forEach(cls => body.classList[methodCls](cls));\n            Canvas[enable ? 'startAutoscroll' : 'stopAutoscroll']();\n        }\n    };\n});"]}
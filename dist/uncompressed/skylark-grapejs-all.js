/**
 * skylark-grapejs - A version of garpejs that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-grapejs/
 * @license MIT
 */
(function(factory,globals) {
  var define = globals.define,
      require = globals.require,
      isAmd = (typeof define === 'function' && define.amd),
      isCmd = (!isAmd && typeof exports !== 'undefined');

  if (!isAmd && !define) {
    var map = {};
    function absolute(relative, base) {
        if (relative[0]!==".") {
          return relative;
        }
        var stack = base.split("/"),
            parts = relative.split("/");
        stack.pop(); 
        for (var i=0; i<parts.length; i++) {
            if (parts[i] == ".")
                continue;
            if (parts[i] == "..")
                stack.pop();
            else
                stack.push(parts[i]);
        }
        return stack.join("/");
    }
    define = globals.define = function(id, deps, factory) {
        if (typeof factory == 'function') {
            map[id] = {
                factory: factory,
                deps: deps.map(function(dep){
                  return absolute(dep,id);
                }),
                resolved: false,
                exports: null
            };
            require(id);
        } else {
            map[id] = {
                factory : null,
                resolved : true,
                exports : factory
            };
        }
    };
    require = globals.require = function(id) {
        if (!map.hasOwnProperty(id)) {
            throw new Error('Module ' + id + ' has not been defined');
        }
        var module = map[id];
        if (!module.resolved) {
            var args = [];

            module.deps.forEach(function(dep){
                args.push(require(dep));
            })

            module.exports = module.factory.apply(globals, args) || null;
            module.resolved = true;
        }
        return module.exports;
    };
  }
  
  if (!define) {
     throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
  }

  factory(define,require);

  if (!isAmd) {
    var skylarkjs = require("skylark-langx/skylark");

    if (isCmd) {
      module.exports = skylarkjs;
    } else {
      globals.skylarkjs  = skylarkjs;
    }
  }

})(function(define,require) {

define('skylark-langx-ns/_attach',[],function(){
    return  function attach(obj1,path,obj2) {
        if (typeof path == "string") {
            path = path.split(".");//[path]
        };
        var length = path.length,
            ns=obj1,
            i=0,
            name = path[i++];

        while (i < length) {
            ns = ns[name] = ns[name] || {};
            name = path[i++];
        }

        return ns[name] = obj2;
    }
});
define('skylark-langx-ns/ns',[
    "./_attach"
], function(_attach) {
    var skylark = {
    	attach : function(path,obj) {
    		return _attach(skylark,path,obj);
    	}
    };
    return skylark;
});

define('skylark-langx-ns/main',[
	"./ns"
],function(skylark){
	return skylark;
});
define('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });

define('skylark-langx/skylark',[
    "skylark-langx-ns"
], function(ns) {
	return ns;
});

define('skylark-langx-types/types',[
    "skylark-langx-ns"
],function(skylark){
    var toString = {}.toString;
    
    var type = (function() {
        var class2type = {};

        // Populate the class2type map
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" ").forEach(function(name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        return function type(obj) {
            return obj == null ? String(obj) :
                class2type[toString.call(obj)] || "object";
        };
    })();

    function isArray(object) {
        return object && object.constructor === Array;
    }


    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function/string/element and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * isArrayLike([1, 2, 3])
     * // => true
     *
     * isArrayLike(document.body.children)
     * // => false
     *
     * isArrayLike('abc')
     * // => true
     *
     * isArrayLike(Function)
     * // => false
     */    
    function isArrayLike(obj) {
        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * isBoolean(false)
     * // => true
     *
     * isBoolean(null)
     * // => false
     */
    function isBoolean(obj) {
        return typeof(obj) === "boolean";
    }

    function isDefined(obj) {
        return typeof obj !== 'undefined';
    }

    function isDocument(obj) {
        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
    }

    function isEmptyObject(obj) {
        var name;
        for (name in obj) {
            if (obj[name] !== null) {
                return false;
            }
        }
        return true;
    }


    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * isFunction(parseInt)
     * // => true
     *
     * isFunction(/abc/)
     * // => false
     */
    function isFunction(value) {
        return type(value) == "function";
    }

    function isHtmlNode(obj) {
        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME
    }

    function isInstanceOf( /*Object*/ value, /*Type*/ type) {
        //Tests whether the value is an instance of a type.
        if (value === undefined) {
            return false;
        } else if (value === null || type == Object) {
            return true;
        } else if (typeof value === "number") {
            return type === Number;
        } else if (typeof value === "string") {
            return type === String;
        } else if (typeof value === "boolean") {
            return type === Boolean;
        } else if (typeof value === "string") {
            return type === String;
        } else {
            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);
        }
    }

    function isNull(value) {
      return type(value) === "null";
    }

    function isNumber(obj) {
        return typeof obj == 'number';
    }

    function isObject(obj) {
        return type(obj) == "object";
    }

    function isPlainObject(obj) {
        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
    }

    function isString(obj) {
        return typeof obj === 'string';
    }

    function isWindow(obj) {
        return obj && obj == obj.window;
    }

    function isSameOrigin(href) {
        if (href) {
            var origin = location.protocol + '//' + location.hostname;
            if (location.port) {
                origin += ':' + location.port;
            }
            return href.startsWith(origin);
        }
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    function isUndefined(value) {
      return value === undefined
    }

    return skylark.attach("langx.types",{

        isArray: isArray,

        isArrayLike: isArrayLike,

        isBoolean: isBoolean,

        isDefined: isDefined,

        isDocument: isDocument,

        isEmpty : isEmptyObject,

        isEmptyObject: isEmptyObject,

        isFunction: isFunction,

        isHtmlNode: isHtmlNode,

        isNull: isNull,

        isNumber: isNumber,

        isNumeric: isNumber,

        isObject: isObject,

        isPlainObject: isPlainObject,

        isString: isString,

        isSameOrigin: isSameOrigin,

        isSymbol : isSymbol,

        isUndefined: isUndefined,

        isWindow: isWindow,

        type: type
    });

});
define('skylark-langx-types/main',[
	"./types"
],function(types){
	return types;
});
define('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });

define('skylark-langx-numbers/numbers',[
    "skylark-langx-ns",
    "skylark-langx-types"
],function(skylark,types){
	var isObject = types.isObject,
		isSymbol = types.isSymbol;

	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}	

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	return  skylark.attach("langx.numbers",{
		toFinite : toFinite,
		toNumber : toNumber,
		toInteger : toInteger
	});
});
define('skylark-langx-numbers/main',[
	"./numbers"
],function(numbers){
	return numbers;
});
define('skylark-langx-numbers', ['skylark-langx-numbers/main'], function (main) { return main; });

define('skylark-langx-objects/objects',[
    "skylark-langx-ns/ns",
    "skylark-langx-ns/_attach",
	"skylark-langx-types",
    "skylark-langx-numbers"
],function(skylark,_attach,types,numbers){
	var hasOwnProperty = Object.prototype.hasOwnProperty,
        slice = Array.prototype.slice,
        isBoolean = types.isBoolean,
        isFunction = types.isFunction,
		isObject = types.isObject,
		isPlainObject = types.isPlainObject,
		isArray = types.isArray,
        isArrayLike = types.isArrayLike,
        isString = types.isString,
        toInteger = numbers.toInteger;

     // An internal function for creating assigner functions.
    function createAssigner(keysFunc, defaults) {
        return function(obj) {
          var length = arguments.length;
          if (defaults) obj = Object(obj);  
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index],
                keys = keysFunc(source),
                l = keys.length;
            for (var i = 0; i < l; i++) {
              var key = keys[i];
              if (!defaults || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
       };
    }

    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // `null` or `undefined` only equal to itself (strict comparison).
        if (a == null || b == null) return false;
        // `NaN`s are equivalent, but non-reflexive.
        if (a !== a) return b !== b;
        // Exhaust primitive checks
        var type = typeof a;
        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
        return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
        // Unwrap any wrapped objects.
        //if (a instanceof _) a = a._wrapped;
        //if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b;
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN.
                if (+a !== +a) return +b !== +b;
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b;
            case '[object Symbol]':
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        }

        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object') return false;
            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
                               isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
        }

        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);

        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length) return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            // Deep compare objects.
            var keys = Object.keys(a), key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (Object.keys(b).length !== length) return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    };

    // Retrieve all the property names of an object.
    function allKeys(obj) {
        if (!isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }

    function each(obj, callback) {
        var length, key, i, undef, value;

        if (obj) {
            length = obj.length;

            if (length === undef) {
                // Loop object items
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        value = obj[key];
                        if (callback.call(value, key, value) === false) {
                            break;
                        }
                    }
                }
            } else {
                // Loop array items
                for (i = 0; i < length; i++) {
                    value = obj[i];
                    if (callback.call(value, i, value) === false) {
                        break;
                    }
                }
            }
        }

        return this;
    }

    function extend(target) {
        var deep, args = slice.call(arguments, 1);
        if (typeof target == 'boolean') {
            deep = target
            target = args.shift()
        }
        if (args.length == 0) {
            args = [target];
            target = this;
        }
        args.forEach(function(arg) {
            mixin(target, arg, deep);
        });
        return target;
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys(obj) {
        if (isObject(obj)) return [];
        var keys = [];
        for (var key in obj) if (has(obj, key)) keys.push(key);
        return keys;
    }

    function has(obj, path) {
        if (!isArray(path)) {
            return obj != null && hasOwnProperty.call(obj, path);
        }
        var length = path.length;
        for (var i = 0; i < length; i++) {
            var key = path[i];
            if (obj == null || !hasOwnProperty.call(obj, key)) {
                return false;
            }
            obj = obj[key];
        }
        return !!length;
    }

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }


   // Perform a deep comparison to check if two objects are equal.
    function isEqual(a, b) {
        return eq(a, b);
    }

    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
        var keys = keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    }    

    function _mixin(target, source, deep, safe) {
        for (var key in source) {
            //if (!source.hasOwnProperty(key)) {
            //    continue;
            //}
            if (safe && target[key] !== undefined) {
                continue;
            }
            if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
                if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                    target[key] = {};
                }
                if (isArray(source[key]) && !isArray(target[key])) {
                    target[key] = [];
                }
                _mixin(target[key], source[key], deep, safe);
            } else if (source[key] !== undefined) {
                target[key] = source[key]
            }
        }
        return target;
    }

    function _parseMixinArgs(args) {
        var params = slice.call(arguments, 0),
            target = params.shift(),
            deep = false;
        if (isBoolean(params[params.length - 1])) {
            deep = params.pop();
        }

        return {
            target: target,
            sources: params,
            deep: deep
        };
    }

    function mixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, false);
        });
        return args.target;
    }

   // Return a copy of the object without the blacklisted properties.
    function omit(obj, prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = mixin({},obj);
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                delete result[pn];
            }
        }
        return result;

    }

   // Return a copy of the object only containing the whitelisted properties.
    function pick(obj,prop1,prop2) {
        if (!obj) {
            return null;
        }
        var result = {};
        for(var i=1;i<arguments.length;i++) {
            var pn = arguments[i];
            if (pn in obj) {
                result[pn] = obj[pn];
            }
        }
        return result;
    }

    function removeItem(items, item) {
        if (isArray(items)) {
            var idx = items.indexOf(item);
            if (idx != -1) {
                items.splice(idx, 1);
            }
        } else if (isPlainObject(items)) {
            for (var key in items) {
                if (items[key] == item) {
                    delete items[key];
                    break;
                }
            }
        }

        return this;
    }

    function result(obj, path, fallback) {
        if (!isArray(path)) {
            path = path.split(".");//[path]
        };
        var length = path.length;
        if (!length) {
          return isFunction(fallback) ? fallback.call(obj) : fallback;
        }
        for (var i = 0; i < length; i++) {
          var prop = obj == null ? void 0 : obj[path[i]];
          if (prop === void 0) {
            prop = fallback;
            i = length; // Ensure we don't continue iterating.
          }
          obj = isFunction(prop) ? prop.call(obj) : prop;
        }

        return obj;
    }

    function safeMixin() {
        var args = _parseMixinArgs.apply(this, arguments);

        args.sources.forEach(function(source) {
            _mixin(args.target, source, args.deep, true);
        });
        return args.target;
    }

    // Retrieve the values of an object's properties.
    function values(obj) {
        var keys = allKeys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }

    function clone( /*anything*/ src,checkCloneMethod) {
        var copy;
        if (src === undefined || src === null) {
            copy = src;
        } else if (checkCloneMethod && src.clone) {
            copy = src.clone();
        } else if (isArray(src)) {
            copy = [];
            for (var i = 0; i < src.length; i++) {
                copy.push(clone(src[i]));
            }
        } else if (isPlainObject(src)) {
            copy = {};
            for (var key in src) {
                copy[key] = clone(src[key]);
            }
        } else {
            copy = src;
        }

        return copy;

    }

    return skylark.attach("langx.objects",{
        allKeys: allKeys,

        attach : _attach,

        clone: clone,

        defaults : createAssigner(allKeys, true),

        each : each,

        extend : extend,

        has: has,

        isEqual: isEqual,   

        includes: includes,

        isMatch: isMatch,

        keys: keys,

        mixin: mixin,

        omit: omit,

        pick: pick,

        removeItem: removeItem,

        result : result,
        
        safeMixin: safeMixin,

        values: values
    });


});
define('skylark-langx-objects/main',[
	"./objects"
],function(objects){
	return objects;
});
define('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });

define('skylark-langx-arrays/arrays',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects"
],function(skylark,types,objects){
  var filter = Array.prototype.filter,
      find = Array.prototype.find,
    isArrayLike = types.isArrayLike;

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }


    function compact(array) {
        return filter.call(array, function(item) {
            return item != null;
        });
    }

    function filter2(array,func) {
      return filter.call(array,func);
    }

    function flatten(array) {
        if (isArrayLike(array)) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                if (isArrayLike(item)) {
                    for (var j = 0; j < item.length; j++) {
                        result.push(item[j]);
                    }
                } else {
                    result.push(item);
                }
            }
            return result;
        } else {
            return array;
        }
        //return array.length > 0 ? concat.apply([], array) : array;
    }

    function grep(array, callback) {
        var out = [];

        objects.each(array, function(i, item) {
            if (callback(item, i)) {
                out.push(item);
            }
        });

        return out;
    }

    function inArray(item, array) {
        if (!array) {
            return -1;
        }
        var i;

        if (array.indexOf) {
            return array.indexOf(item);
        }

        i = array.length;
        while (i--) {
            if (array[i] === item) {
                return i;
            }
        }

        return -1;
    }

    function makeArray(obj, offset, startWith) {
       if (isArrayLike(obj) ) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }

      // array of single index
      return [ obj ];             
    }


    function forEach (arr, fn) {
      if (arr.forEach) return arr.forEach(fn)
      for (var i = 0; i < arr.length; i++) fn(arr[i], i);
    }

    function map(elements, callback) {
        var value, values = [],
            i, key
        if (isArrayLike(elements))
            for (i = 0; i < elements.length; i++) {
                value = callback.call(elements[i], elements[i], i);
                if (value != null) values.push(value)
            }
        else
            for (key in elements) {
                value = callback.call(elements[key], elements[key], key);
                if (value != null) values.push(value)
            }
        return flatten(values)
    }


    function merge( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }

    function reduce(array,callback,initialValue) {
        return Array.prototype.reduce.call(array,callback,initialValue);
    }

    function uniq(array) {
        return filter.call(array, function(item, idx) {
            return array.indexOf(item) == idx;
        })
    }

    function find2(array,func) {
      return find.call(array,func);
    }

    return skylark.attach("langx.arrays",{
        baseFindIndex: baseFindIndex,

        baseIndexOf : baseIndexOf,
        
        compact: compact,

        first : function(items,n) {
            if (n) {
                return items.slice(0,n);
            } else {
                return items[0];
            }
        },

        filter : filter2,

        find : find2,
        
        flatten: flatten,

        grep: grep,

        inArray: inArray,

        makeArray: makeArray,

        merge : merge,

        forEach : forEach,

        map : map,
        
        reduce : reduce,

        uniq : uniq

    });
});
define('skylark-langx-arrays/main',[
	"./arrays"
],function(arrays){
	return arrays;
});
define('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });

define('skylark-langx/arrays',[
	"skylark-langx-arrays"
],function(arrays){
  return arrays;
});
define('skylark-langx-klass/klass',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
],function(skylark,types,objects,arrays){
    var uniq = arrays.uniq,
        has = objects.has,
        mixin = objects.mixin,
        isArray = types.isArray,
        isDefined = types.isDefined;

/* for reference 
 function klass(props,parent) {
    var ctor = function(){
        this._construct();
    };
    ctor.prototype = props;
    if (parent) {
        ctor._proto_ = parent;
        props.__proto__ = parent.prototype;
    }
    return ctor;
}

// Type some JavaScript code here.
let animal = klass({
  _construct(){
      this.name = this.name + ",hi";
  },
    
  name: "Animal",
  eat() {         // [[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
    
    
});


let rabbit = klass({
  name: "Rabbit",
  _construct(){
      super._construct();
  },
  eat() {         // [[HomeObject]] == rabbit
    super.eat();
  }
},animal);

let longEar = klass({
  name: "Long Ear",
  eat() {         // [[HomeObject]] == longEar
    super.eat();
  }
},rabbit);
*/
    
    function inherit(ctor, base) {
        var f = function() {};
        f.prototype = base.prototype;

        ctor.prototype = new f();
    }

    var f1 = function() {
        function extendClass(ctor, props, options) {
            // Copy the properties to the prototype of the class.
            var proto = ctor.prototype,
                _super = ctor.superclass.prototype,
                noOverrided = options && options.noOverrided,
                overrides = options && options.overrides || {};

            for (var name in props) {
                if (name === "constructor") {
                    continue;
                }

                // Check if we're overwriting an existing function
                var prop = props[name];
                if (typeof props[name] == "function") {
                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == "function" ?
                          (function(name, fn, superFn) {
                            return function() {
                                var tmp = this.overrided;

                                // Add a new ._super() method that is the same method
                                // but on the super-class
                                this.overrided = superFn;

                                // The method only need to be bound temporarily, so we
                                // remove it when we're done executing
                                var ret = fn.apply(this, arguments);

                                this.overrided = tmp;

                                return ret;
                            };
                        })(name, prop, _super[name]) :
                        prop;
                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {
                    Object.defineProperty(proto,name,prop);
                } else {
                    proto[name] = prop;
                }
            }
            return ctor;
        }

        function serialMixins(ctor,mixins) {
            var result = [];

            mixins.forEach(function(mixin){
                if (has(mixin,"__mixins__")) {
                     throw new Error("nested mixins");
                }
                var clss = [];
                while (mixin) {
                    clss.unshift(mixin);
                    mixin = mixin.superclass;
                }
                result = result.concat(clss);
            });

            result = uniq(result);

            result = result.filter(function(mixin){
                var cls = ctor;
                while (cls) {
                    if (mixin === cls) {
                        return false;
                    }
                    if (has(cls,"__mixins__")) {
                        var clsMixines = cls["__mixins__"];
                        for (var i=0; i<clsMixines.length;i++) {
                            if (clsMixines[i]===mixin) {
                                return false;
                            }
                        }
                    }
                    cls = cls.superclass;
                }
                return true;
            });

            if (result.length>0) {
                return result;
            } else {
                return false;
            }
        }

        function mergeMixins(ctor,mixins) {
            var newCtor =ctor;
            for (var i=0;i<mixins.length;i++) {
                var xtor = new Function();
                xtor.prototype = Object.create(newCtor.prototype);
                xtor.__proto__ = newCtor;
                xtor.superclass = null;
                mixin(xtor.prototype,mixins[i].prototype);
                xtor.prototype.__mixin__ = mixins[i];
                newCtor = xtor;
            }

            return newCtor;
        }

        function _constructor ()  {
            if (this._construct) {
                return this._construct.apply(this, arguments);
            } else  if (this.init) {
                return this.init.apply(this, arguments);
            }
        }

        return function createClass(props, parent, mixins,options) {
            if (isArray(parent)) {
                options = mixins;
                mixins = parent;
                parent = null;
            }
            parent = parent || Object;

            if (isDefined(mixins) && !isArray(mixins)) {
                options = mixins;
                mixins = false;
            }

            var innerParent = parent;

            if (mixins) {
                mixins = serialMixins(innerParent,mixins);
            }

            if (mixins) {
                innerParent = mergeMixins(innerParent,mixins);
            }

            var klassName = props.klassName || "",
                ctor = new Function(
                    "return function " + klassName + "() {" +
                    "var inst = this," +
                    " ctor = arguments.callee;" +
                    "if (!(inst instanceof ctor)) {" +
                    "inst = Object.create(ctor.prototype);" +
                    "}" +
                    "return ctor._constructor.apply(inst, arguments) || inst;" + 
                    "}"
                )();


            // Populate our constructed prototype object
            ctor.prototype = Object.create(innerParent.prototype);

            // Enforce the constructor to be what we expect
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent;

            // And make this class extendable
            ctor.__proto__ = innerParent;


            if (!ctor._constructor) {
                ctor._constructor = _constructor;
            } 

            if (mixins) {
                ctor.__mixins__ = mixins;
            }

            if (!ctor.partial) {
                ctor.partial = function(props, options) {
                    return extendClass(this, props, options);
                };
            }
            if (!ctor.inherit) {
                ctor.inherit = function(props, mixins,options) {
                    return createClass(props, this, mixins,options);
                };
            }

            ctor.partial(props, options);

            return ctor;
        };
    }

    var createClass = f1();

    return skylark.attach("langx.klass",createClass);
});
define('skylark-langx-klass/main',[
	"./klass"
],function(klass){
	return klass;
});
define('skylark-langx-klass', ['skylark-langx-klass/main'], function (main) { return main; });

define('skylark-langx/klass',[
    "skylark-langx-klass"
],function(klass){
    return klass;
});
define('skylark-langx/ArrayStore',[
    "./klass"
],function(klass){
    var SimpleQueryEngine = function(query, options){
        // summary:
        //      Simple query engine that matches using filter functions, named filter
        //      functions or objects by name-value on a query object hash
        //
        // description:
        //      The SimpleQueryEngine provides a way of getting a QueryResults through
        //      the use of a simple object hash as a filter.  The hash will be used to
        //      match properties on data objects with the corresponding value given. In
        //      other words, only exact matches will be returned.
        //
        //      This function can be used as a template for more complex query engines;
        //      for example, an engine can be created that accepts an object hash that
        //      contains filtering functions, or a string that gets evaluated, etc.
        //
        //      When creating a new dojo.store, simply set the store's queryEngine
        //      field as a reference to this function.
        //
        // query: Object
        //      An object hash with fields that may match fields of items in the store.
        //      Values in the hash will be compared by normal == operator, but regular expressions
        //      or any object that provides a test() method are also supported and can be
        //      used to match strings by more complex expressions
        //      (and then the regex's or object's test() method will be used to match values).
        //
        // options: dojo/store/api/Store.QueryOptions?
        //      An object that contains optional information such as sort, start, and count.
        //
        // returns: Function
        //      A function that caches the passed query under the field "matches".  See any
        //      of the "query" methods on dojo.stores.
        //
        // example:
        //      Define a store with a reference to this engine, and set up a query method.
        //
        //  |   var myStore = function(options){
        //  |       //  ...more properties here
        //  |       this.queryEngine = SimpleQueryEngine;
        //  |       //  define our query method
        //  |       this.query = function(query, options){
        //  |           return QueryResults(this.queryEngine(query, options)(this.data));
        //  |       };
        //  |   };

        // create our matching query function
        switch(typeof query){
            default:
                throw new Error("Can not query with a " + typeof query);
            case "object": case "undefined":
                var queryObject = query;
                query = function(object){
                    for(var key in queryObject){
                        var required = queryObject[key];
                        if(required && required.test){
                            // an object can provide a test method, which makes it work with regex
                            if(!required.test(object[key], object)){
                                return false;
                            }
                        }else if(required != object[key]){
                            return false;
                        }
                    }
                    return true;
                };
                break;
            case "string":
                // named query
                if(!this[query]){
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];
                // fall through
            case "function":
                // fall through
        }
        
        function filter(arr, callback, thisObject){
            // summary:
            //      Returns a new Array with those items from arr that match the
            //      condition implemented by callback.
            // arr: Array
            //      the array to iterate over.
            // callback: Function|String
            //      a function that is invoked with three arguments (item,
            //      index, array). The return of this function is expected to
            //      be a boolean which determines whether the passed-in item
            //      will be included in the returned array.
            // thisObject: Object?
            //      may be used to scope the call to callback
            // returns: Array
            // description:
            //      This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
            //      run over sparse arrays, this implementation passes the "holes" in the sparse array to
            //      the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
            //      For more details, see:
            //      https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
            // example:
            //  | // returns [2, 3, 4]
            //  | array.filter([1, 2, 3, 4], function(item){ return item>1; });

            // TODO: do we need "Ctr" here like in map()?
            var i = 0, l = arr && arr.length || 0, out = [], value;
            if(l && typeof arr == "string") arr = arr.split("");
            if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
            if(thisObject){
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback.call(thisObject, value, i, arr)){
                        out.push(value);
                    }
                }
            }else{
                for(; i < l; ++i){
                    value = arr[i];
                    if(callback(value, i, arr)){
                        out.push(value);
                    }
                }
            }
            return out; // Array
        }

        function execute(array){
            // execute the whole query, first we filter
            var results = filter(array, query);
            // next we sort
            var sortSet = options && options.sort;
            if(sortSet){
                results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
                    for(var sort, i=0; sort = sortSet[i]; i++){
                        var aValue = a[sort.attribute];
                        var bValue = b[sort.attribute];
                        // valueOf enables proper comparison of dates
                        aValue = aValue != null ? aValue.valueOf() : aValue;
                        bValue = bValue != null ? bValue.valueOf() : bValue;
                        if (aValue != bValue){
                            // modified by lwf 2016/07/09
                            //return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                        }
                    }
                    return 0;
                });
            }
            // now we paginate
            if(options && (options.start || options.count)){
                var total = results.length;
                results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                results.total = total;
            }
            return results;
        }
        execute.matches = query;
        return execute;
    };

    var QueryResults = function(results){
        // summary:
        //      A function that wraps the results of a store query with additional
        //      methods.
        // description:
        //      QueryResults is a basic wrapper that allows for array-like iteration
        //      over any kind of returned data from a query.  While the simplest store
        //      will return a plain array of data, other stores may return deferreds or
        //      promises; this wrapper makes sure that *all* results can be treated
        //      the same.
        //
        //      Additional methods include `forEach`, `filter` and `map`.
        // results: Array|dojo/promise/Promise
        //      The result set as an array, or a promise for an array.
        // returns:
        //      An array-like object that can be used for iterating over.
        // example:
        //      Query a store and iterate over the results.
        //
        //  |   store.query({ prime: true }).forEach(function(item){
        //  |       //  do something
        //  |   });

        if(!results){
            return results;
        }

        var isPromise = !!results.then;
        // if it is a promise it may be frozen
        if(isPromise){
            results = Object.delegate(results);
        }
        function addIterativeMethod(method){
            // Always add the iterative methods so a QueryResults is
            // returned whether the environment is ES3 or ES5
            results[method] = function(){
                var args = arguments;
                var result = Deferred.when(results, function(results){
                    //Array.prototype.unshift.call(args, results);
                    return QueryResults(Array.prototype[method].apply(results, args));
                });
                // forEach should only return the result of when()
                // when we're wrapping a promise
                if(method !== "forEach" || isPromise){
                    return result;
                }
            };
        }

        addIterativeMethod("forEach");
        addIterativeMethod("filter");
        addIterativeMethod("map");
        if(results.total == null){
            results.total = Deferred.when(results, function(results){
                return results.length;
            });
        }
        return results; // Object
    };

    var ArrayStore = klass({
        "klassName": "ArrayStore",

        "queryEngine": SimpleQueryEngine,
        
        "idProperty": "id",


        get: function(id){
            // summary:
            //      Retrieves an object by its identity
            // id: Number
            //      The identity to use to lookup the object
            // returns: Object
            //      The object in the store that matches the given id.
            return this.data[this.index[id]];
        },

        getIdentity: function(object){
            return object[this.idProperty];
        },

        put: function(object, options){
            var data = this.data,
                index = this.index,
                idProperty = this.idProperty;
            var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
            if(id in index){
                // object exists
                if(options && options.overwrite === false){
                    throw new Error("Object already exists");
                }
                // replace the entry in data
                data[index[id]] = object;
            }else{
                // add the new object
                index[id] = data.push(object) - 1;
            }
            return id;
        },

        add: function(object, options){
            (options = options || {}).overwrite = false;
            // call put with overwrite being false
            return this.put(object, options);
        },

        remove: function(id){
            // summary:
            //      Deletes an object by its identity
            // id: Number
            //      The identity to use to delete the object
            // returns: Boolean
            //      Returns true if an object was removed, falsy (undefined) if no object matched the id
            var index = this.index;
            var data = this.data;
            if(id in index){
                data.splice(index[id], 1);
                // now we have to reindex
                this.setData(data);
                return true;
            }
        },
        query: function(query, options){
            // summary:
            //      Queries the store for objects.
            // query: Object
            //      The query to use for retrieving objects from the store.
            // options: dojo/store/api/Store.QueryOptions?
            //      The optional arguments to apply to the resultset.
            // returns: dojo/store/api/Store.QueryResults
            //      The results of the query, extended with iterative methods.
            //
            // example:
            //      Given the following store:
            //
            //  |   var store = new Memory({
            //  |       data: [
            //  |           {id: 1, name: "one", prime: false },
            //  |           {id: 2, name: "two", even: true, prime: true},
            //  |           {id: 3, name: "three", prime: true},
            //  |           {id: 4, name: "four", even: true, prime: false},
            //  |           {id: 5, name: "five", prime: true}
            //  |       ]
            //  |   });
            //
            //  ...find all items where "prime" is true:
            //
            //  |   var results = store.query({ prime: true });
            //
            //  ...or find all items where "even" is true:
            //
            //  |   var results = store.query({ even: true });
            return QueryResults(this.queryEngine(query, options)(this.data));
        },

        setData: function(data){
            // summary:
            //      Sets the given data as the source for this store, and indexes it
            // data: Object[]
            //      An array of objects to use as the source of data.
            if(data.items){
                // just for convenience with the data format IFRS expects
                this.idProperty = data.identifier || this.idProperty;
                data = this.data = data.items;
            }else{
                this.data = data;
            }
            this.index = {};
            for(var i = 0, l = data.length; i < l; i++){
                this.index[data[i][this.idProperty]] = i;
            }
        },

        init: function(options) {
            for(var i in options){
                this[i] = options[i];
            }
            this.setData(this.data || []);
        }

    });

	return ArrayStore;
});
define('skylark-langx-aspect/aspect',[
    "skylark-langx-ns"
],function(skylark){

  var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments){
        var previous = dispatcher[type];
        var around = type == "around";
        var signal;
        if(around){
            var advised = advice(function(){
                return previous.advice(this, arguments);
            });
            signal = {
                remove: function(){
                    if(advised){
                        advised = dispatcher = advice = null;
                    }
                },
                advice: function(target, args){
                    return advised ?
                        advised.apply(target, args) :  // called the advised function
                        previous.advice(target, args); // cancelled, skip to next one
                }
            };
        }else{
            // create the remove handler
            signal = {
                remove: function(){
                    if(signal.advice){
                        var previous = signal.previous;
                        var next = signal.next;
                        if(!next && !previous){
                            delete dispatcher[type];
                        }else{
                            if(previous){
                                previous.next = next;
                            }else{
                                dispatcher[type] = next;
                            }
                            if(next){
                                next.previous = previous;
                            }
                        }

                        // remove the advice to signal that this signal has been removed
                        dispatcher = advice = signal.advice = null;
                    }
                },
                id: nextId++,
                advice: advice,
                receiveArguments: receiveArguments
            };
        }
        if(previous && !around){
            if(type == "after"){
                // add the listener to the end of the list
                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
                while(previous.next && (previous = previous.next)){}
                previous.next = signal;
                signal.previous = previous;
            }else if(type == "before"){
                // add to beginning
                dispatcher[type] = signal;
                signal.next = previous;
                previous.previous = signal;
            }
        }else{
            // around or first one just replaces
            dispatcher[type] = signal;
        }
        return signal;
    }
    function aspect(type){
        return function(target, methodName, advice, receiveArguments){
            var existing = target[methodName], dispatcher;
            if(!existing || existing.target != target){
                // no dispatcher in place
                target[methodName] = dispatcher = function(){
                    var executionId = nextId;
                    // before advice
                    var args = arguments;
                    var before = dispatcher.before;
                    while(before){
                        args = before.advice.apply(this, args) || args;
                        before = before.next;
                    }
                    // around advice
                    if(dispatcher.around){
                        var results = dispatcher.around.advice(this, args);
                    }
                    // after advice
                    var after = dispatcher.after;
                    while(after && after.id < executionId){
                        if(after.receiveArguments){
                            var newResults = after.advice.apply(this, args);
                            // change the return value only if a new value was returned
                            results = newResults === undefined ? results : newResults;
                        }else{
                            results = after.advice.call(this, results, args);
                        }
                        after = after.next;
                    }
                    return results;
                };
                if(existing){
                    dispatcher.around = {advice: function(target, args){
                        return existing.apply(target, args);
                    }};
                }
                dispatcher.target = target;
            }
            var results = advise((dispatcher || existing), type, advice, receiveArguments);
            advice = null;
            return results;
        };
    }

    return skylark.attach("langx.aspect",{
        after: aspect("after"),
 
        around: aspect("around"),
        
        before: aspect("before")
    });
});
define('skylark-langx-aspect/main',[
	"./aspect"
],function(aspect){
	return aspect;
});
define('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });

define('skylark-langx/aspect',[
    "skylark-langx-aspect"
],function(aspect){
  return aspect;
});
define('skylark-langx-funcs/funcs',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects"
],function(skylark,types,objects){
	var mixin = objects.mixin,
        slice = Array.prototype.slice,
        isFunction = types.isFunction,
        isString = types.isString;

    function defer(fn) {
        if (requestAnimationFrame) {
            requestAnimationFrame(fn);
        } else {
            setTimeoutout(fn);
        }
        return this;
    }

    function noop() {
    }

    function proxy(fn, context) {
        var args = (2 in arguments) && slice.call(arguments, 2)
        if (isFunction(fn)) {
            var proxyFn = function() {
                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
            }
            return proxyFn;
        } else if (isString(context)) {
            if (args) {
                args.unshift(fn[context], fn)
                return proxy.apply(null, args)
            } else {
                return proxy(fn[context], fn);
            }
        } else {
            throw new TypeError("expected function");
        }
    }

    function debounce(fn, wait) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                fn.apply(context, args);
            };
            if (timeout) clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
   
    var delegate = (function() {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {}
        return function(obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();


    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    var templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;


    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;


    function template(text, data, settings) {
        var render;
        settings = objects.defaults({}, settings,templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset)
              .replace(escaper, function(match) { return '\\' + escapes[match]; });

          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," +
          "print=function(){__p+=__j.call(arguments,'');};\n" +
          source + 'return __p;\n';

        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }

        if (data) {
          return render(data,this)
        }
        var template = proxy(function(data) {
          return render.call(this, data,this);
        },this);

        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';

        return template;
    }


    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0
     * }
     *
     * filter([1, 2, 3, 4, 5, 6], negate(isEven))
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate !== 'function') {
        throw new TypeError('Expected a function')
      }
      return function(...args) {
        return !predicate.apply(this, args)
      }
    }


    return skylark.attach("langx.funcs",{
        bind : proxy,
        
        debounce: debounce,

        delegate: delegate,

        defer: defer,

        negate: negate,

        noop : noop,

        proxy: proxy,

        returnTrue: function() {
            return true;
        },

        returnFalse: function() {
            return false;
        },

        templateSettings : templateSettings,
        template : template
    });
});
define('skylark-langx-funcs/main',[
	"./funcs"
],function(funcs){
	return funcs;
});
define('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });

define('skylark-langx-async/Deferred',[
    "skylark-langx-arrays",
	"skylark-langx-funcs",
    "skylark-langx-objects"
],function(arrays,funcs,objects){
    "use strict";
    
    var  PGLISTENERS = Symbol ? Symbol() : '__pglisteners',
         PGNOTIFIES = Symbol ? Symbol() : '__pgnotifies';

    var slice = Array.prototype.slice,
        proxy = funcs.proxy,
        makeArray = arrays.makeArray,
        result = objects.result,
        mixin = objects.mixin;

    mixin(Promise.prototype,{
        always: function(handler) {
            //this.done(handler);
            //this.fail(handler);
            this.then(handler,handler);
            return this;
        },
        done : function() {
            for (var i = 0;i<arguments.length;i++) {
                this.then(arguments[i]);
            }
            return this;
        },
        fail : function(handler) { 
            //return mixin(Promise.prototype.catch.call(this,handler),added);
            //return this.then(null,handler);
            this.catch(handler);
            return this;
         }
    });


    var Deferred = function() {
        var self = this,
            p = this.promise = new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            });

        wrapPromise(p,self);

        this[PGLISTENERS] = [];
        this[PGNOTIFIES] = [];

        //this.resolve = Deferred.prototype.resolve.bind(this);
        //this.reject = Deferred.prototype.reject.bind(this);
        //this.progress = Deferred.prototype.progress.bind(this);

    };

    function wrapPromise(p,d) {
        var   added = {
                state : function() {
                    if (d.isResolved()) {
                        return 'resolved';
                    }
                    if (d.isRejected()) {
                        return 'rejected';
                    }
                    return 'pending';
                },
                then : function(onResolved,onRejected,onProgress) {
                    if (onProgress) {
                        this.progress(onProgress);
                    }
                    return wrapPromise(Promise.prototype.then.call(this,
                            onResolved && function(args) {
                                if (args && args.__ctx__ !== undefined) {
                                    return onResolved.apply(args.__ctx__,args);
                                } else {
                                    return onResolved(args);
                                }
                            },
                            onRejected && function(args){
                                if (args && args.__ctx__ !== undefined) {
                                    return onRejected.apply(args.__ctx__,args);
                                } else {
                                    return onRejected(args);
                                }
                            }));
                },
                progress : function(handler) {
                    d[PGNOTIFIES].forEach(function (value) {
                        handler(value);
                    });
                    d[PGLISTENERS].push(handler);
                    return this;
                }

            };

        added.pipe = added.then;
        return mixin(p,added);

    }

    Deferred.prototype.resolve = function(value) {
        var args = slice.call(arguments);
        return this.resolveWith(null,args);
    };

    Deferred.prototype.resolveWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._resolve(args);
        this._resolved = true;
        return this;
    };

    Deferred.prototype.notify = function(value) {
        try {
            this[PGNOTIFIES].push(value);

            return this[PGLISTENERS].forEach(function (listener) {
                return listener(value);
            });
        } catch (error) {
          this.reject(error);
        }
        return this;
    };

    Deferred.prototype.reject = function(reason) {
        var args = slice.call(arguments);
        return this.rejectWith(null,args);
    };

    Deferred.prototype.rejectWith = function(context,args) {
        args = args ? makeArray(args) : []; 
        args.__ctx__ = context;
        this._reject(args);
        this._rejected = true;
        return this;
    };

    Deferred.prototype.isResolved = function() {
        return !!this._resolved;
    };

    Deferred.prototype.isRejected = function() {
        return !!this._rejected;
    };

    Deferred.prototype.then = function(callback, errback, progback) {
        var p = result(this,"promise");
        return p.then(callback, errback, progback);
    };

    Deferred.prototype.progress = function(progback){
        var p = result(this,"promise");
        return p.progress(progback);
    };
   
    Deferred.prototype.catch = function(errback) {
        var p = result(this,"promise");
        return p.catch(errback);
    };


    Deferred.prototype.done  = function() {
        var p = result(this,"promise");
        return p.done.apply(p,arguments);
    };

    Deferred.prototype.fail = function(errback) {
        var p = result(this,"promise");
        return p.fail(errback);
    };


    Deferred.all = function(array) {
        //return wrapPromise(Promise.all(array));
        var d = new Deferred();
        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));
        return result(d,"promise");
    };

    Deferred.first = function(array) {
        return wrapPromise(Promise.race(array));
    };


    Deferred.when = function(valueOrPromise, callback, errback, progback) {
        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

        if (!receivedPromise) {
            if (arguments.length > 1) {
                return callback ? callback(valueOrPromise) : valueOrPromise;
            } else {
                return new Deferred().resolve(valueOrPromise);
            }
        } else if (!nativePromise) {
            var deferred = new Deferred(valueOrPromise.cancel);
            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);
            valueOrPromise = deferred.promise;
        }

        if (callback || errback || progback) {
            return valueOrPromise.then(callback, errback, progback);
        }
        return valueOrPromise;
    };

    Deferred.reject = function(err) {
        var d = new Deferred();
        d.reject(err);
        return d.promise;
    };

    Deferred.resolve = function(data) {
        var d = new Deferred();
        d.resolve.apply(d,arguments);
        return d.promise;
    };

    Deferred.immediate = Deferred.resolve;

    return Deferred;
});
define('skylark-langx-async/async',[
    "skylark-langx-ns",
    "skylark-langx-objects",
    "./Deferred"
],function(skylark,objects,Deferred){
    var each = objects.each;
    
    var async = {
        Deferred : Deferred,

        parallel : function(arr,args,ctx) {
            var rets = [];
            ctx = ctx || null;
            args = args || [];

            each(arr,function(i,func){
                rets.push(func.apply(ctx,args));
            });

            return Deferred.all(rets);
        },

        series : function(arr,args,ctx) {
            var rets = [],
                d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolve();
            each(arr,function(i,func){
                p = p.then(function(){
                    return func.apply(ctx,args);
                });
                rets.push(p);
            });

            return Deferred.all(rets);
        },

        waterful : function(arr,args,ctx) {
            var d = new Deferred(),
                p = d.promise;

            ctx = ctx || null;
            args = args || [];

            d.resolveWith(ctx,args);

            each(arr,function(i,func){
                p = p.then(func);
            });
            return p;
        }
    };

	return skylark.attach("langx.async",async);	
});
define('skylark-langx-async/main',[
	"./async"
],function(async){
	return async;
});
define('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });

define('skylark-langx/async',[
    "skylark-langx-async"
],function(async){
    return async;
});
define('skylark-langx-datetimes/datetimes',[
    "skylark-langx-ns"
],function(skylark){
     function parseMilliSeconds(str) {

        var strs = str.split(' ');
        var number = parseInt(strs[0]);

        if (isNaN(number)){
            return 0;
        }

        var min = 60000 * 60;

        switch (strs[1].trim().replace(/\./g, '')) {
            case 'minutes':
            case 'minute':
            case 'min':
            case 'mm':
            case 'm':
                return 60000 * number;
            case 'hours':
            case 'hour':
            case 'HH':
            case 'hh':
            case 'h':
            case 'H':
                return min * number;
            case 'seconds':
            case 'second':
            case 'sec':
            case 'ss':
            case 's':
                return 1000 * number;
            case 'days':
            case 'day':
            case 'DD':
            case 'dd':
            case 'd':
                return (min * 24) * number;
            case 'months':
            case 'month':
            case 'MM':
            case 'M':
                return (min * 24 * 28) * number;
            case 'weeks':
            case 'week':
            case 'W':
            case 'w':
                return (min * 24 * 7) * number;
            case 'years':
            case 'year':
            case 'yyyy':
            case 'yy':
            case 'y':
                return (min * 24 * 365) * number;
            default:
                return 0;
        }
    };
	
	return skylark.attach("langx.datetimes",{
		parseMilliSeconds
	});
});
define('skylark-langx-datetimes/main',[
	"./datetimes"
],function(datetimes){
	return datetimes;
});
define('skylark-langx-datetimes', ['skylark-langx-datetimes/main'], function (main) { return main; });

define('skylark-langx/datetimes',[
    "skylark-langx-datetimes"
],function(datetimes){
    return datetimes;
});
define('skylark-langx/Deferred',[
    "skylark-langx-async/Deferred"
],function(Deferred){
    return Deferred;
});
define('skylark-langx-emitter/Emitter',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-klass"
],function(skylark,types,objects,arrays,klass){
    var slice = Array.prototype.slice,
        compact = arrays.compact,
        isDefined = types.isDefined,
        isPlainObject = types.isPlainObject,
        isFunction = types.isFunction,
        isString = types.isString,
        isEmptyObject = types.isEmptyObject,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin;

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            name: segs[0],
            ns: segs.slice(1).join(" ")
        };
    }

    var Emitter = klass({
        on: function(events, selector, data, callback, ctx, /*used internally*/ one) {
            var self = this,
                _hub = this._hub || (this._hub = {});

            if (isPlainObject(events)) {
                ctx = callback;
                each(events, function(type, fn) {
                    self.on(type, selector, data, fn, ctx, one);
                });
                return this;
            }

            if (!isString(selector) && !isFunction(callback)) {
                ctx = callback;
                callback = data;
                data = selector;
                selector = undefined;
            }

            if (isFunction(data)) {
                ctx = callback;
                callback = data;
                data = null;
            }

            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                (_hub[name] || (_hub[name] = [])).push({
                    fn: callback,
                    selector: selector,
                    data: data,
                    ctx: ctx,
                    ns : ns,
                    one: one
                });
            });

            return this;
        },

        one: function(events, selector, data, callback, ctx) {
            return this.on(events, selector, data, callback, ctx, 1);
        },

        emit: function(e /*,argument list*/ ) {
            if (!this._hub) {
                return this;
            }

            var self = this;

            if (isString(e)) {
                e = new CustomEvent(e);
            }

            Object.defineProperty(e,"target",{
                value : this
            });

            var args = slice.call(arguments, 1);
            if (isDefined(args)) {
                args = [e].concat(args);
            } else {
                args = [e];
            }
            [e.type || e.name, "all"].forEach(function(eventName) {
                var parsed = parse(eventName),
                    name = parsed.name,
                    ns = parsed.ns;

                var listeners = self._hub[name];
                if (!listeners) {
                    return;
                }

                var len = listeners.length,
                    reCompact = false;

                for (var i = 0; i < len; i++) {
                    var listener = listeners[i];
                    if (ns && (!listener.ns ||  !listener.ns.startsWith(ns))) {
                        continue;
                    }
                    if (e.data) {
                        if (listener.data) {
                            e.data = mixin({}, listener.data, e.data);
                        }
                    } else {
                        e.data = listener.data || null;
                    }
                    listener.fn.apply(listener.ctx, args);
                    if (listener.one) {
                        listeners[i] = null;
                        reCompact = true;
                    }
                }

                if (reCompact) {
                    self._hub[eventName] = compact(listeners);
                }

            });
            return this;
        },

        listened: function(event) {
            var evtArr = ((this._hub || (this._events = {}))[event] || []);
            return evtArr.length > 0;
        },

        listenTo: function(obj, event, callback, /*used internally*/ one) {
            if (!obj) {
                return this;
            }

            // Bind callbacks on obj,
            if (isString(callback)) {
                callback = this[callback];
            }

            if (one) {
                obj.one(event, callback, this);
            } else {
                obj.on(event, callback, this);
            }

            //keep track of them on listening.
            var listeningTo = this._listeningTo || (this._listeningTo = []),
                listening;

            for (var i = 0; i < listeningTo.length; i++) {
                if (listeningTo[i].obj == obj) {
                    listening = listeningTo[i];
                    break;
                }
            }
            if (!listening) {
                listeningTo.push(
                    listening = {
                        obj: obj,
                        events: {}
                    }
                );
            }
            var listeningEvents = listening.events,
                listeningEvent = listeningEvents[event] = listeningEvents[event] || [];
            if (listeningEvent.indexOf(callback) == -1) {
                listeningEvent.push(callback);
            }

            return this;
        },

        listenToOnce: function(obj, event, callback) {
            return this.listenTo(obj, event, callback, 1);
        },

        off: function(events, callback) {
            var _hub = this._hub || (this._hub = {});
            if (isString(events)) {
                events = events.split(/\s/)
            }

            events.forEach(function(event) {
                var parsed = parse(event),
                    name = parsed.name,
                    ns = parsed.ns;

                var evts = _hub[name];

                if (evts) {
                    var liveEvents = [];

                    if (callback || ns) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            
                            if (callback && evts[i].fn !== callback && evts[i].fn._ !== callback) {
                                liveEvents.push(evts[i]);
                                continue;
                            } 

                            if (ns && (!evts[i].ns || evts[i].ns.indexOf(ns)!=0)) {
                                liveEvents.push(evts[i]);
                                continue;
                            }
                        }
                    }

                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }

                }
            });

            return this;
        },
        unlistenTo: function(obj, event, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo) {
                return this;
            }
            for (var i = 0; i < listeningTo.length; i++) {
                var listening = listeningTo[i];

                if (obj && obj != listening.obj) {
                    continue;
                }

                var listeningEvents = listening.events;
                for (var eventName in listeningEvents) {
                    if (event && event != eventName) {
                        continue;
                    }

                    var listeningEvent = listeningEvents[eventName];

                    for (var j = 0; j < listeningEvent.length; j++) {
                        if (!callback || callback == listeningEvent[i]) {
                            listening.obj.off(eventName, listeningEvent[i], this);
                            listeningEvent[i] = null;
                        }
                    }

                    listeningEvent = listeningEvents[eventName] = compact(listeningEvent);

                    if (isEmptyObject(listeningEvent)) {
                        listeningEvents[eventName] = null;
                    }

                }

                if (isEmptyObject(listeningEvents)) {
                    listeningTo[i] = null;
                }
            }

            listeningTo = this._listeningTo = compact(listeningTo);
            if (isEmptyObject(listeningTo)) {
                this._listeningTo = null;
            }

            return this;
        },

        trigger  : function() {
            return this.emit.apply(this,arguments);
        }
    });

    Emitter.createEvent = function (type,props) {
        var e = new CustomEvent(type,props);
        return safeMixin(e, props);
    };

    return skylark.attach("langx.Emitter",Emitter);

});
define('skylark-langx-emitter/Evented',[
  "skylark-langx-ns/ns",
	"./Emitter"
],function(skylark,Emitter){
	return skylark.attach("langx.Evented",Emitter);
});
define('skylark-langx-emitter/main',[
	"./Emitter",
	"./Evented"
],function(Emitter){
	return Emitter;
});
define('skylark-langx-emitter', ['skylark-langx-emitter/main'], function (main) { return main; });

define('skylark-langx/Emitter',[
    "skylark-langx-emitter"
],function(Evented){
    return Evented;
});
define('skylark-langx/Evented',[
    "skylark-langx-emitter"
],function(Evented){
    return Evented;
});
define('skylark-langx/funcs',[
    "skylark-langx-funcs"
],function(funcs){
    return funcs;
});
define('skylark-langx-hoster/hoster',[
    "skylark-langx-ns"
],function(skylark){
	// The javascript host environment, brower and nodejs are supported.
	var hoster = {
		"isBrowser" : true, // default
		"isNode" : null,
		"global" : this,
		"browser" : null,
		"node" : null
	};

	if (typeof process == "object" && process.versions && process.versions.node && process.versions.v8) {
		hoster.isNode = true;
		hoster.isBrowser = false;
	}

	hoster.global = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		} else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	var _document = null;

	Object.defineProperty(hoster,"document",function(){
		if (!_document) {
			var w = typeof window === 'undefined' ? require('html-element') : window;
			_document = w.document;
		}

		return _document;
	});

	if (hoster.isBrowser) {
	    function uaMatch( ua ) {
		    ua = ua.toLowerCase();

		    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		      /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		      /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		      /(msie) ([\w.]+)/.exec( ua ) ||
		      ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		      [];

		    return {
		      browser: match[ 1 ] || '',
		      version: match[ 2 ] || '0'
		    };
	  	};

	    var matched = uaMatch( navigator.userAgent );

	    var browser = hoster.browser = {};

	    if ( matched.browser ) {
	      browser[ matched.browser ] = true;
	      browser.version = matched.version;
	    }

	    // Chrome is Webkit, but Webkit is also Safari.
	    if ( browser.chrome ) {
	      browser.webkit = true;
	    } else if ( browser.webkit ) {
	      browser.safari = true;
	    }
	}

	return  skylark.attach("langx.hoster",hoster);
});
define('skylark-langx-hoster/main',[
	"./hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx-hoster', ['skylark-langx-hoster/main'], function (main) { return main; });

define('skylark-langx/hoster',[
	"skylark-langx-hoster"
],function(hoster){
	return hoster;
});
define('skylark-langx/numbers',[
	"skylark-langx-numbers"
],function(numbers){
	return numbers;
});
define('skylark-langx/objects',[
    "skylark-langx-objects"
],function(objects){
    return objects;
});
define('skylark-langx-strings/strings',[
    "skylark-langx-ns"
],function(skylark){
    // add default escape function for escaping HTML entities
    var escapeCharMap = Object.freeze({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;',
    });
    function replaceChar(c) {
        return escapeCharMap[c];
    }
    var escapeChars = /[&<>"'`=]/g;


     /*
     * Converts camel case into dashes.
     * @param {String} str
     * @return {String}
     * @exapmle marginTop -> margin-top
     */
    function dasherize(str) {
        return str.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/_/g, '-')
            .toLowerCase();
    }

    function deserializeValue(value) {
        try {
            return value ?
                value == "true" ||
                (value == "false" ? false :
                    value == "null" ? null :
                    +value + "" == value ? +value :
                    /^[\[\{]/.test(value) ? JSON.parse(value) :
                    value) : value;
        } catch (e) {
            return value;
        }
    }

    function escapeHTML(str) {
        if (str == null) {
            return '';
        }
        if (!str) {
            return String(str);
        }

        return str.toString().replace(escapeChars, replaceChar);
    }

    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : ((r & 0x3) | 0x8);
            return v.toString(16);
        });
    }

    function trim(str) {
        return str == null ? "" : String.prototype.trim.call(str);
    }

    function substitute( /*String*/ template,
        /*Object|Array*/
        map,
        /*Function?*/
        transform,
        /*Object?*/
        thisObject) {
        // summary:
        //    Performs parameterized substitutions on a string. Throws an
        //    exception if any parameter is unmatched.
        // template:
        //    a string with expressions in the form `${key}` to be replaced or
        //    `${key:format}` which specifies a format function. keys are case-sensitive.
        // map:
        //    hash to search for substitutions
        // transform:
        //    a function to process all parameters before substitution takes


        thisObject = thisObject || window;
        transform = transform ?
            proxy(thisObject, transform) : function(v) {
                return v;
            };

        function getObject(key, map) {
            if (key.match(/\./)) {
                var retVal,
                    getValue = function(keys, obj) {
                        var _k = keys.pop();
                        if (_k) {
                            if (!obj[_k]) return null;
                            return getValue(keys, retVal = obj[_k]);
                        } else {
                            return retVal;
                        }
                    };
                return getValue(key.split(".").reverse(), map);
            } else {
                return map[key];
            }
        }

        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
            function(match, key, format) {
                var value = getObject(key, map);
                if (format) {
                    value = getObject(format, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            }); // String
    }

    var idCounter = 0;
    function uniqueId (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    }


    /**
     * https://github.com/cho45/micro-template.js
     * (c) cho45 http://cho45.github.com/mit-license
     */
    function template (id, data) {

        function include(name, args) {
            var stash = {};
            for (var key in template.context.stash) if (template.context.stash.hasOwnProperty(key)) {
                stash[key] = template.context.stash[key];
            }
            if (args) for (var key in args) if (args.hasOwnProperty(key)) {
                stash[key] = args[key];
            }
            var context = template.context;
            context.ret += template(name, stash);
            template.context = context;
        }

        function wrapper(name, fun) {
            var current = template.context.ret;
            template.context.ret = '';
            fun.apply(template.context);
            var content = template.context.ret;
            var orig_content = template.context.stash.content;
            template.context.stash.content = content;
            template.context.ret = current + template(name, template.context.stash);
            template.context.stash.content = orig_content;
        }

        var me = arguments.callee;
        if (!me.cache[id]) me.cache[id] = (function () {
            var name = id, string = /^[\w\-]+$/.test(id) ? me.get(id): (name = 'template(string)', id); // no warnings
            var line = 1, body = (
                "try { " +
                    (me.variable ?  "var " + me.variable + " = this.stash;" : "with (this.stash) { ") +
                        "this.ret += '"  +
                        string.
                            replace(/<%/g, '\x11').replace(/%>/g, '\x13'). // if you want other tag, just edit this line
                            replace(/'(?![^\x11\x13]+?\x13)/g, '\\x27').
                            replace(/^\s*|\s*$/g, '').
                            replace(/\n|\r\n/g, function () { return "';\nthis.line = " + (++line) + "; this.ret += '\\n" }).
                            replace(/\x11=raw(.+?)\x13/g, "' + ($1) + '").
                            replace(/\x11=(.+?)\x13/g, "' + this.escapeHTML($1) + '").
                            replace(/\x11(.+?)\x13/g, "'; $1; this.ret += '") +
                    "'; " + (me.variable ? "" : "}") + "return this.ret;" +
                "} catch (e) { throw 'TemplateError: ' + e + ' (on " + name + "' + ' line ' + this.line + ')'; } " +
                "//@ sourceURL=" + name + "\n" // source map
            ).replace(/this\.ret \+= '';/g, '');
            var func = new Function(body);
            var map  = { '&' : '&amp;', '<' : '&lt;', '>' : '&gt;', '\x22' : '&#x22;', '\x27' : '&#x27;' };
            var escapeHTML = function (string) { return (''+string).replace(/[&<>\'\"]/g, function (_) { return map[_] }) };
            return function (stash) { return func.call(me.context = { escapeHTML: escapeHTML, line: 1, ret : '', stash: stash }) };
        })();
        return data ? me.cache[id](data) : me.cache[id];
    }

    template.cache = {};
    

    template.get = function (id) {
        return document.getElementById(id).innerHTML;
    };

    function rtrim(str) {
        return str.replace(/\s+$/g, '');
    }

    // Slugify a string
    function slugify(str) {
        str = str.replace(/^\s+|\s+$/g, '');

        // Make the string lowercase
        str = str.toLowerCase();

        // Remove accents, swap  for n, etc
        var from = "a/_,:;";
        var to   = "AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------";
        for (var i=0, l=from.length ; i<l ; i++) {
            str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
        }

        // Remove invalid chars
        //str = str.replace(/[^a-z0-9 -]/g, '') 
        // Collapse whitespace and replace by -
        str = str.replace(/\s+/g, '-') 
        // Collapse dashes
        .replace(/-+/g, '-'); 

        return str;
    }    

    // return boolean if string 'true' or string 'false', or if a parsable string which is a number
    // also supports JSON object and/or arrays parsing
    function toType(str) {
        var type = typeof str;
        if (type !== 'string') {
            return str;
        }
        var nb = parseFloat(str);
        if (!isNaN(nb) && isFinite(str)) {
            return nb;
        }
        if (str === 'false') {
            return false;
        }
        if (str === 'true') {
            return true;
        }

        try {
            str = JSON.parse(str);
        } catch (e) {}

        return str;
    }

	return skylark.attach("langx.strings",{
        camelCase: function(str) {
            return str.replace(/-([\da-z])/g, function(a) {
                return a.toUpperCase().replace('-', '');
            });
        },

        dasherize: dasherize,

        deserializeValue: deserializeValue,

        escapeHTML : escapeHTML,

        generateUUID : generateUUID,

        lowerFirst: function(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        },

        rtrim : rtrim,

        serializeValue: function(value) {
            return JSON.stringify(value)
        },


        substitute: substitute,

        slugify : slugify,

        //template : template,

        trim: trim,

        uniqueId: uniqueId,

        upperFirst: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
	}) ; 

});
define('skylark-langx-strings/main',[
	"./strings"
],function(strings){
	return strings;
});
define('skylark-langx-strings', ['skylark-langx-strings/main'], function (main) { return main; });

define('skylark-langx/strings',[
    "skylark-langx-strings"
],function(strings){
    return strings;
});
define('skylark-langx/Stateful',[
	"./Evented",
  "./strings",
  "./objects"
],function(Evented,strings,objects){
    var isEqual = objects.isEqual,
        mixin = objects.mixin,
        result = objects.result,
        isEmptyObject = objects.isEmptyObject,
        clone = objects.clone,
        uniqueId = strings.uniqueId;

    var Stateful = Evented.inherit({
        _construct : function(attributes, options) {
            var attrs = attributes || {};
            options || (options = {});
            this.cid = uniqueId(this.cidPrefix);
            this.attributes = {};
            if (options.collection) this.collection = options.collection;
            if (options.parse) attrs = this.parse(attrs, options) || {};
            var defaults = result(this, 'defaults');
            attrs = mixin({}, defaults, attrs);
            this.set(attrs, options);
            this.changed = {};
        },

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',


        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return clone(this.attributes);
        },


        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null) return this;

          // Handle both `"key", value` and `{key: value}` -style arguments.
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }

          options || (options = {});

          // Run validation.
          if (!this._validate(attrs, options)) return false;

          // Extract attributes and options.
          var unset      = options.unset;
          var silent     = options.silent;
          var changes    = [];
          var changing   = this._changing;
          this._changing = true;

          if (!changing) {
            this._previousAttributes = clone(this.attributes);
            this.changed = {};
          }

          var current = this.attributes;
          var changed = this.changed;
          var prev    = this._previousAttributes;

          // For each `set` attribute, update or delete the current value.
          for (var attr in attrs) {
            val = attrs[attr];
            if (!isEqual(current[attr], val)) changes.push(attr);
            if (!isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }

          // Update the `id`.
          if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

          // Trigger all relevant attribute changes.
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }

          // You might be wondering why there's a `while` loop here. Changes can
          // be recursively nested within `"change"` events.
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, mixin({}, options, {unset: true}));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, mixin({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !isEmptyObject(this.changed);
          return this.changed[attr] !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff) return this.hasChanged() ? clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (isEqual(old[attr], val)) continue;
            changed[attr] = val;
          }
          return !isEmptyObject(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return clone(this._previousAttributes);
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, mixin({}, options, {validate: true}));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = mixin({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger('invalid', this, error, mixin(options, {validationError: error}));
          return false;
        }
    });

	return Stateful;
});
define('skylark-langx-topic/topic',[
	"skylark-langx-ns",
	"skylark-langx-emitter/Evented"
],function(skylark,Evented){
	var hub = new Evented();

	return skylark.attach("langx.topic",{
	    publish: function(name, arg1,argn) {
	        var data = [].slice.call(arguments, 1);

	        return hub.trigger({
	            type : name,
	            data : data
	        });
	    },

        subscribe: function(name, listener,ctx) {
        	var handler = function(e){
                listener.apply(ctx,e.data);
            };
            hub.on(name, handler);
            return {
            	remove : function(){
            		hub.off(name,handler);
            	}
            }

        }

	});
});
define('skylark-langx-topic/main',[
	"./topic"
],function(topic){
	return topic;
});
define('skylark-langx-topic', ['skylark-langx-topic/main'], function (main) { return main; });

define('skylark-langx/topic',[
	"skylark-langx-topic"
],function(topic){
	return topic;
});
define('skylark-langx/types',[
    "skylark-langx-types"
],function(types){
    return types;
});
define('skylark-langx/langx',[
    "./skylark",
    "./arrays",
    "./ArrayStore",
    "./aspect",
    "./async",
    "./datetimes",
    "./Deferred",
    "./Emitter",
    "./Evented",
    "./funcs",
    "./hoster",
    "./klass",
    "./numbers",
    "./objects",
    "./Stateful",
    "./strings",
    "./topic",
    "./types"
], function(skylark,arrays,ArrayStore,aspect,async,datetimes,Deferred,Emitter,Evented,funcs,hoster,klass,numbers,objects,Stateful,strings,topic,types) {
    "use strict";
    var toString = {}.toString,
        concat = Array.prototype.concat,
        indexOf = Array.prototype.indexOf,
        slice = Array.prototype.slice,
        filter = Array.prototype.filter,
        mixin = objects.mixin,
        safeMixin = objects.safeMixin,
        isFunction = types.isFunction;


    function funcArg(context, arg, idx, payload) {
        return isFunction(arg) ? arg.call(context, idx, payload) : arg;
    }

    function getQueryParams(url) {
        var url = url || window.location.href,
            segs = url.split("?"),
            params = {};

        if (segs.length > 1) {
            segs[1].split("&").forEach(function(queryParam) {
                var nv = queryParam.split('=');
                params[nv[0]] = nv[1];
            });
        }
        return params;
    }


    function toPixel(value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
    }


    var _uid = 1;

    function uid(obj) {
        return obj._uid || (obj._uid = _uid++);
    }

    function langx() {
        return langx;
    }

    mixin(langx, {
        createEvent : Emitter.createEvent,

        funcArg: funcArg,

        getQueryParams: getQueryParams,

        toPixel: toPixel,

        uid: uid,

        URL: typeof window !== "undefined" ? window.URL || window.webkitURL : null

    });


    mixin(langx, arrays,aspect,datetimes,funcs,numbers,objects,strings,types,{
        ArrayStore : ArrayStore,

        async : async,
        
        Deferred: Deferred,

        Emitter: Emitter,

        Evented: Evented,

        hoster : hoster,

        klass : klass,
       
        Stateful: Stateful,

        topic : topic
    });

    return skylark.langx = langx;
});
define('skylark-domx-browser/browser',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark,langx) {
    "use strict";

    var browser = langx.hoster.browser;
 
    var checkedCssProperties = {
            "transitionproperty": "TransitionProperty",
        },
        transEndEventNames = {
          WebkitTransition : 'webkitTransitionEnd',
          MozTransition    : 'transitionend',
          OTransition      : 'oTransitionEnd otransitionend',
          transition       : 'transitionend'
        },
        transEndEventName = null;


    var css3PropPrefix = "",
        css3StylePrefix = "",
        css3EventPrefix = "",

        cssStyles = {},
        cssProps = {},

        vendorPrefix,
        vendorPrefixRE,
        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,

        document = window.document,
        testEl = document.createElement("div"),

        matchesSelector = testEl.webkitMatchesSelector ||
                          testEl.mozMatchesSelector ||
                          testEl.oMatchesSelector ||
                          testEl.matchesSelector,

        requestFullScreen = testEl.requestFullscreen || 
                            testEl.webkitRequestFullscreen || 
                            testEl.mozRequestFullScreen || 
                            testEl.msRequestFullscreen,

        exitFullScreen =  document.exitFullscreen ||
                          document.webkitCancelFullScreen ||
                          document.mozCancelFullScreen ||
                          document.msExitFullscreen,

        testStyle = testEl.style;

    for (var name in testStyle) {
        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);
        if (matched) {
            if (!vendorPrefixRE) {
                vendorPrefix = matched[1];
                vendorPrefixRE = new RegExp("^(" + vendorPrefix + ")(.*)$");

                css3StylePrefix = vendorPrefix;
                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';
                css3EventPrefix = vendorPrefix.toLowerCase();
            }

            cssStyles[langx.lowerFirst(matched[2])] = name;
            var cssPropName = langx.dasherize(matched[2]);
            cssProps[cssPropName] = css3PropPrefix + cssPropName;

            if (transEndEventNames[name]) {
              transEndEventName = transEndEventNames[name];
            }
        }
    }

    if (!transEndEventName) {
        if (testStyle["transition"] !== undefined) {
            transEndEventName = transEndEventNames["transition"];
        }
    }

    function normalizeCssEvent(name) {
        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();
    }

    function normalizeCssProperty(name) {
        return cssProps[name] || name;
    }

    function normalizeStyleProperty(name) {
        return cssStyles[name] || name;
    }

    langx.mixin(browser, {
        css3PropPrefix: css3PropPrefix,

        isIE : !!/msie/i.exec( window.navigator.userAgent ),

        normalizeStyleProperty: normalizeStyleProperty,

        normalizeCssProperty: normalizeCssProperty,

        normalizeCssEvent: normalizeCssEvent,

        matchesSelector: matchesSelector,

        requestFullScreen : requestFullScreen,

        exitFullscreen : requestFullScreen,

        location: function() {
            return window.location;
        },

        support : {

        }

    });

    if  (transEndEventName) {
        browser.support.transition = {
            end : transEndEventName
        };
    }

    testEl = null;

    return skylark.attach("domx.browser",browser);
});

define('skylark-domx-browser/main',[
	"./browser"
],function(browser){
	return browser;
});
define('skylark-domx-browser', ['skylark-domx-browser/main'], function (main) { return main; });

define('skylark-domx-noder/noder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser"
], function(skylark, langx, browser) {
    var isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g),
        fragmentRE = /^\s*<(\w+|!)[^>]*>/,
        singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        div = document.createElement("div"),
        table = document.createElement('table'),
        tableBody = document.createElement('tbody'),
        tableRow = document.createElement('tr'),
        containers = {
            'tr': tableBody,
            'tbody': table,
            'thead': table,
            'tfoot': table,
            'td': tableRow,
            'th': tableRow,
            '*': div
        },
        rootNodeRE = /^(?:body|html)$/i,
        map = Array.prototype.map,
        slice = Array.prototype.slice;

    function ensureNodes(nodes, copyByClone) {
        if (!langx.isArrayLike(nodes)) {
            nodes = [nodes];
        }
        if (copyByClone) {
            nodes = map.call(nodes, function(node) {
                return node.cloneNode(true);
            });
        }
        return langx.flatten(nodes);
    }

    function nodeName(elm, chkName) {
        var name = elm.nodeName && elm.nodeName.toLowerCase();
        if (chkName !== undefined) {
            return name === chkName.toLowerCase();
        }
        return name;
    };


    function activeElement(doc) {
        doc = doc || document;
        var el;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            el = doc.activeElement;
        } catch ( error ) {
            el = doc.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if ( !el ) {
            el = doc.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if ( !el.nodeName ) {
            el = doc.body;
        }

        return el;
    };

    function enhancePlaceContent(placing,node) {
        if (langx.isFunction(placing)) {
            return placing.apply(node,[]);
        }
        if (langx.isArrayLike(placing)) {
            var neddsFlattern;
            for (var i=0;i<placing.length;i++) {
                if (langx.isFunction(placing[i])) {
                    placing[i] = placing[i].apply(node,[]);
                    if (langx.isArrayLike(placing[i])) {
                        neddsFlattern = true;
                    }
                }
            }
            if (neddsFlattern) {
                placing = langx.flatten(placing);
            }
        }
        return placing;
    }
    function after(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone),
                refNode = refNode.nextSibling;

            for (var i = 0; i < nodes.length; i++) {
                if (refNode) {
                    parent.insertBefore(nodes[i], refNode);
                } else {
                    parent.appendChild(nodes[i]);
                }
            }
        }
        return this;
    }

    function append(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var parentNode = node,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            parentNode.appendChild(nodes[i]);
        }
        return this;
    }

    function before(node, placing, copyByClone) {
        placing = enhancePlaceContent(placing,node);
        var refNode = node,
            parent = refNode.parentNode;
        if (parent) {
            var nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                parent.insertBefore(nodes[i], refNode);
            }
        }
        return this;
    }
    /*   
     * Get the children of the specified node, including text and comment nodes.
     * @param {HTMLElement} elm
     */
    function contents(elm) {
        if (nodeName(elm, "iframe")) {
            return elm.contentDocument;
        }
        return elm.childNodes;
    }

    /*   
     * Create a element and set attributes on it.
     * @param {HTMLElement} tag
     * @param {props} props
     * @param } parent
     */
    function createElement(tag, props, parent) {
        var node;

        if (/svg/i.test(tag)) {
            node = document.createElementNS("http://www.w3.org/2000/svg", tag)
        } else {
            node = document.createElement(tag);
        }

        if (props) {
            for (var name in props) {
                node.setAttribute(name, props[name]);
            }
        }
        if (parent) {
            append(parent, node);
        }
        return node;
    }

    /*   
     * Create a DocumentFragment from the HTML fragment.
     * @param {String} html
     */
    function createFragment(html) {
        // A special case optimization for a single tag
        html = langx.trim(html);
        if (singleTagRE.test(html)) {
            return [createElement(RegExp.$1)];
        }

        var name = fragmentRE.test(html) && RegExp.$1
        if (!(name in containers)) {
            name = "*"
        }
        var container = containers[name];
        container.innerHTML = "" + html;
        dom = slice.call(container.childNodes);

        dom.forEach(function(node) {
            container.removeChild(node);
        })

        return dom;
    }

    /*   
     * Create a deep copy of the set of matched elements.
     * @param {HTMLElement} node
     * @param {Boolean} deep
     */
    function clone(node, deep) {
        var self = this,
            clone;

        // TODO: Add feature detection here in the future
        if (!isIE || node.nodeType !== 1 || deep) {
            return node.cloneNode(deep);
        }

        // Make a HTML5 safe shallow copy
        if (!deep) {
            clone = document.createElement(node.nodeName);

            // Copy attribs
            each(self.getAttribs(node), function(attr) {
                self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
            });

            return clone;
        }
    }

    /*   
     * Check to see if a dom node is a descendant of another dom node .
     * @param {String} node
     * @param {Node} child
     */
    function contains(node, child) {
        return isChildOf(child, node);
    }

    /*   
     * Create a new Text node.
     * @param {String} text
     * @param {Node} child
     */
    function createTextNode(text) {
        return document.createTextNode(text);
    }

    /*   
     * Get the current document object.
     */
    function doc() {
        return document;
    }

    /*   
     * Remove all child nodes of the set of matched elements from the DOM.
     * @param {Object} node
     */
    function empty(node) {
        while (node.hasChildNodes()) {
            var child = node.firstChild;
            node.removeChild(child);
        }
        return this;
    }

    var fulledEl = null;

    function fullScreen(el) {
        if (el === false) {
            browser.exitFullScreen.apply(document);
        } else if (el) {
            browser.requestFullScreen.apply(el);
            fulledEl = el;
        } else {
            return (
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement
            )
        }
    }


    // Selectors
    function focusable( element, hasTabindex ) {
        var map, mapName, img, focusableIfVisible, fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ( "area" === nodeName ) {
            map = element.parentNode;
            mapName = map.name;
            if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                return false;
            }
            img = $( "img[usemap='#" + mapName + "']" );
            return img.length > 0 && img.is( ":visible" );
        }

        if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
            focusableIfVisible = !element.disabled;

            if ( focusableIfVisible ) {

                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $( element ).closest( "fieldset" )[ 0 ];
                if ( fieldset ) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ( "a" === nodeName ) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
    };


   var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
 
    /*   
     * Get the HTML contents of the first element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} html
     */
    function html(node, html) {
        if (html === undefined) {
            return node.innerHTML;
        } else {
            this.empty(node);
            html = html || "";
            if (langx.isString(html)) {
                html = html.replace( rxhtmlTag, "<$1></$2>" );
            }
            if (langx.isString(html) || langx.isNumber(html)) {               
                node.innerHTML = html;
            } else if (langx.isArrayLike(html)) {
                for (var i = 0; i < html.length; i++) {
                    node.appendChild(html[i]);
                }
            } else {
                node.appendChild(html);
            }

            return this;
        }
    }


    /*   
     * Check to see if a dom node is a descendant of another dom node.
     * @param {Node} node
     * @param {Node} parent
     * @param {Node} directly
     */
    function isChildOf(node, parent, directly) {
        if (directly) {
            return node.parentNode === parent;
        }
        if (document.documentElement.contains) {
            return parent.contains(node);
        }
        while (node) {
            if (parent === node) {
                return true;
            }

            node = node.parentNode;
        }

        return false;
    }

    /*   
     * Check to see if a dom node is a document.
     * @param {Node} node
     */
    function isDocument(node) {
        return node != null && node.nodeType == node.DOCUMENT_NODE
    }

    /*   
     * Check to see if a dom node is in the document
     * @param {Node} node
     */
    function isInDocument(node) {
      return (node === document.body) ? true : document.body.contains(node);
    }        

    var blockNodes = ["div", "p", "ul", "ol", "li", "blockquote", "hr", "pre", "h1", "h2", "h3", "h4", "h5", "table"];

    function isBlockNode(node) {
        if (!node || node.nodeType === 3) {
          return false;
        }
        return new RegExp("^(" + (blockNodes.join('|')) + ")$").test(node.nodeName.toLowerCase());
    }


    /*   
     * Get the owner document object for the specified element.
     * @param {Node} elm
     */
    function ownerDoc(elm) {
        if (!elm) {
            return document;
        }

        if (elm.nodeType == 9) {
            return elm;
        }

        return elm.ownerDocument;
    }

    /*   
     *
     * @param {Node} elm
     */
    function ownerWindow(elm) {
        var doc = ownerDoc(elm);
        return doc.defaultView || doc.parentWindow;
    }

    /*   
     * insert one or more nodes as the first children of the specified node.
     * @param {Node} node
     * @param {Node or ArrayLike} placing
     * @param {Boolean Optional} copyByClone
     */
    function prepend(node, placing, copyByClone) {
        var parentNode = node,
            refNode = parentNode.firstChild,
            nodes = ensureNodes(placing, copyByClone);
        for (var i = 0; i < nodes.length; i++) {
            if (refNode) {
                parentNode.insertBefore(nodes[i], refNode);
            } else {
                parentNode.appendChild(nodes[i]);
            }
        }
        return this;
    }

    /*   
     *
     * @param {Node} elm
     */
    function offsetParent(elm) {
        var parent = elm.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && document.defaultView.getComputedStyle(parent).position == "static") {
            parent = parent.offsetParent;
        }
        return parent;
    }

    /*   
     * Remove the set of matched elements from the DOM.
     * @param {Node} node
     */
    function remove(node) {
        if (node && node.parentNode) {
            try {
                node.parentNode.removeChild(node);
            } catch (e) {
                console.warn("The node is already removed", e);
            }
        }
        return this;
    }

    function removeChild(node,children) {
        if (!langx.isArrayLike(children)) {
            children = [children];
        }
        for (var i=0;i<children.length;i++) {
            node.removeChild(children[i]);
        }

        return this;
    }

    function scrollParent( elm, includeHidden ) {
        var position = document.defaultView.getComputedStyle(elm).position,
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter( function() {
                var parent = $( this );
                if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                    return false;
                }
                return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                    parent.css( "overflow-x" ) );
            } ).eq( 0 );

        return position === "fixed" || !scrollParent.length ?
            $( this[ 0 ].ownerDocument || document ) :
            scrollParent;
    };


    function reflow(elm) {
        if (el == null) {
          elm = document;
        }
        elm.offsetHeight;

        return this;      
    }

    /*   
     * Replace an old node with the specified node.
     * @param {Node} node
     * @param {Node} oldNode
     */
    function replace(node, oldNode) {
        oldNode.parentNode.replaceChild(node, oldNode);
        return this;
    }


    /*   
     * traverse the specified node and its descendants, perform the callback function on each
     * @param {Node} node
     * @param {Function} fn
     */
    function traverse(node, fn) {
        fn(node)
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            traverse(node.childNodes[i], fn);
        }
        return this;
    }

    /*   
     *
     * @param {Node} node
     */
    function reverse(node) {
        var firstChild = node.firstChild;
        for (var i = node.children.length - 1; i > 0; i--) {
            if (i > 0) {
                var child = node.children[i];
                node.insertBefore(child, firstChild);
            }
        }
    }

    /*   
     * Wrap an HTML structure around each element in the set of matched elements.
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapper(node, wrapperNode) {
        if (langx.isString(wrapperNode)) {
            wrapperNode = this.createFragment(wrapperNode).firstChild;
        }
        node.parentNode.insertBefore(wrapperNode, node);
        wrapperNode.appendChild(node);
    }

    /*   
     * Wrap an HTML structure around the content of each element in the set of matched
     * @param {Node} node
     * @param {Node} wrapperNode
     */
    function wrapperInner(node, wrapperNode) {
        var childNodes = slice.call(node.childNodes);
        node.appendChild(wrapperNode);
        for (var i = 0; i < childNodes.length; i++) {
            wrapperNode.appendChild(childNodes[i]);
        }
        return this;
    }

    /*   
     * Remove the parents of the set of matched elements from the DOM, leaving the matched
     * @param {Node} node
     */
    function unwrap(node) {
        var child, parent = node.parentNode;
        if (parent) {
            if (this.isDoc(parent.parentNode)) return;
            parent.parentNode.insertBefore(node, parent);
        }
    }

    function noder() {
        return noder;
    }

    langx.mixin(noder, {
        active  : activeElement,

        blur : function(el) {
            el.blur();
        },

        body: function() {
            return document.body;
        },

        clone: clone,
        contents: contents,

        createElement: createElement,

        createFragment: createFragment,

        contains: contains,

        createTextNode: createTextNode,

        doc: doc,

        empty: empty,

        fullScreen: fullScreen,

        focusable: focusable,

        html: html,

        isChildOf: isChildOf,

        isDocument: isDocument,

        isInDocument: isInDocument,

        isWindow: langx.isWindow,

        nodeName : nodeName,

        offsetParent: offsetParent,

        ownerDoc: ownerDoc,

        ownerWindow: ownerWindow,

        after: after,

        before: before,

        prepend: prepend,

        append: append,

        reflow: reflow,

        remove: remove,

        removeChild : removeChild,

        replace: replace,

        traverse: traverse,

        reverse: reverse,

        wrapper: wrapper,

        wrapperInner: wrapperInner,

        unwrap: unwrap
    });

    return skylark.attach("domx.noder" , noder);
});
define('skylark-domx-noder/main',[
	"./noder"
],function(noder){
	return noder;
});
define('skylark-domx-noder', ['skylark-domx-noder/main'], function (main) { return main; });

define('skylark-domx-finder/finder',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder"
], function(skylark, langx, browser, noder) {
    var local = {},
        filter = Array.prototype.filter,
        slice = Array.prototype.slice,
        nativeMatchesSelector = browser.matchesSelector;

    /*
    ---
    name: Slick.Parser
    description: Standalone CSS3 Selector parser
    provides: Slick.Parser
    ...
    */
    ;
    (function() {

        var parsed,
            separatorIndex,
            combinatorIndex,
            reversed,
            cache = {},
            reverseCache = {},
            reUnescape = /\\/g;

        var parse = function(expression, isReversed) {
            if (expression == null) return null;
            if (expression.Slick === true) return expression;
            expression = ('' + expression).replace(/^\s+|\s+$/g, '');
            reversed = !!isReversed;
            var currentCache = (reversed) ? reverseCache : cache;
            if (currentCache[expression]) return currentCache[expression];
            parsed = {
                Slick: true,
                expressions: [],
                raw: expression,
                reverse: function() {
                    return parse(this.raw, true);
                }
            };
            separatorIndex = -1;
            while (expression != (expression = expression.replace(regexp, parser)));
            parsed.length = parsed.expressions.length;
            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
        };

        var reverseCombinator = function(combinator) {
            if (combinator === '!') return ' ';
            else if (combinator === ' ') return '!';
            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
            else return '!' + combinator;
        };

        var reverse = function(expression) {
            var expressions = expression.expressions;
            for (var i = 0; i < expressions.length; i++) {
                var exp = expressions[i];
                var last = {
                    parts: [],
                    tag: '*',
                    combinator: reverseCombinator(exp[0].combinator)
                };

                for (var j = 0; j < exp.length; j++) {
                    var cexp = exp[j];
                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
                    cexp.combinator = cexp.reverseCombinator;
                    delete cexp.reverseCombinator;
                }

                exp.reverse().push(last);
            }
            return expression;
        };

        var escapeRegExp = (function() {
            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
            var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g,
                to = '\\';
            return function(string) {
                return string.replace(from, to)
            }
        }())

        var regexp = new RegExp(
            "^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
            .replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
            .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
            .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
        );

        function parser(
            rawMatch,

            separator,
            combinator,
            combinatorChildren,

            tagName,
            id,
            className,

            attributeKey,
            attributeOperator,
            attributeQuote,
            attributeValue,

            pseudoMarker,
            pseudoClass,
            pseudoQuote,
            pseudoClassQuotedValue,
            pseudoClassValue
        ) {
            if (separator || separatorIndex === -1) {
                parsed.expressions[++separatorIndex] = [];
                combinatorIndex = -1;
                if (separator) return '';
            }

            if (combinator || combinatorChildren || combinatorIndex === -1) {
                combinator = combinator || ' ';
                var currentSeparator = parsed.expressions[separatorIndex];
                if (reversed && currentSeparator[combinatorIndex])
                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
                currentSeparator[++combinatorIndex] = {
                    combinator: combinator,
                    tag: '*'
                };
            }

            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

            if (tagName) {
                currentParsed.tag = tagName.replace(reUnescape, '');

            } else if (id) {
                currentParsed.id = id.replace(reUnescape, '');

            } else if (className) {
                className = className.replace(reUnescape, '');

                if (!currentParsed.classList) currentParsed.classList = [];
                if (!currentParsed.classes) currentParsed.classes = [];
                currentParsed.classList.push(className);
                currentParsed.classes.push({
                    value: className,
                    regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
                });

            } else if (pseudoClass) {
                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

                if (!currentParsed.pseudos) currentParsed.pseudos = [];
                currentParsed.pseudos.push({
                    key: pseudoClass.replace(reUnescape, ''),
                    value: pseudoClassValue,
                    type: pseudoMarker.length == 1 ? 'class' : 'element'
                });

            } else if (attributeKey) {
                attributeKey = attributeKey.replace(reUnescape, '');
                attributeValue = (attributeValue || '').replace(reUnescape, '');

                var test, regexp;

                switch (attributeOperator) {
                    case '^=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue));
                        break;
                    case '$=':
                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');
                        break;
                    case '~=':
                        regexp = new RegExp('(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)');
                        break;
                    case '|=':
                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');
                        break;
                    case '=':
                        test = function(value) {
                            return attributeValue == value;
                        };
                        break;
                    case '*=':
                        test = function(value) {
                            return value && value.indexOf(attributeValue) > -1;
                        };
                        break;
                    case '!=':
                        test = function(value) {
                            return attributeValue != value;
                        };
                        break;
                    default:
                        test = function(value) {
                            return !!value;
                        };
                }

                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {
                    return false;
                };

                if (!test) test = function(value) {
                    return value && regexp.test(value);
                };

                if (!currentParsed.attributes) currentParsed.attributes = [];
                currentParsed.attributes.push({
                    key: attributeKey,
                    operator: attributeOperator,
                    value: attributeValue,
                    test: test
                });

            }

            return '';
        };

        // Slick NS

        var Slick = (this.Slick || {});

        Slick.parse = function(expression) {
            return parse(expression);
        };

        Slick.escapeRegExp = escapeRegExp;

        if (!this.Slick) this.Slick = Slick;

    }).apply(local);


    var simpleClassSelectorRE = /^\.([\w-]*)$/,
        simpleIdSelectorRE = /^#([\w-]*)$/,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        slice = Array.prototype.slice;


    local.parseSelector = local.Slick.parse;


    var pseudos = local.pseudos = {
        // custom pseudos
        "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        'checked': function(elm) {
            return !!elm.checked;
        },

        'contains': function(elm, idx, nodes, text) {
            if ($(this).text().indexOf(text) > -1) return this
        },

        'disabled': function(elm) {
            return !!elm.disabled;
        },

        'enabled': function(elm) {
            return !elm.disabled;
        },

        'eq': function(elm, idx, nodes, value) {
            return (idx == value);
        },

        'even': function(elm, idx, nodes, value) {
            return (idx % 2) === 0;
        },

        'focus': function(elm) {
            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);
        },

        'focusable': function( elm ) {
            return noder.focusable(elm, elm.tabindex != null );
        },

        'first': function(elm, idx) {
            return (idx === 0);
        },

        'gt': function(elm, idx, nodes, value) {
            return (idx > value);
        },

        'has': function(elm, idx, nodes, sel) {
            return find(elm, sel);
        },

        // Element/input types
        "header": function(elem) {
            return rheader.test(elem.nodeName);
        },

        'hidden': function(elm) {
            return !local.pseudos["visible"](elm);
        },

        "input": function(elem) {
            return rinputs.test(elem.nodeName);
        },

        'last': function(elm, idx, nodes) {
            return (idx === nodes.length - 1);
        },

        'lt': function(elm, idx, nodes, value) {
            return (idx < value);
        },

        'not': function(elm, idx, nodes, sel) {
            return !matches(elm, sel);
        },

        'odd': function(elm, idx, nodes, value) {
            return (idx % 2) === 1;
        },

        /*   
         * Get the parent of each element in the current set of matched elements.
         * @param {Object} elm
         */
        'parent': function(elm) {
            return !!elm.parentNode;
        },

        'selected': function(elm) {
            return !!elm.selected;
        },

        'tabbable': function(elm) {
            var tabIndex = elm.tabindex,
                hasTabindex = tabIndex != null;
            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );
        },

        'text': function(elm) {
            return elm.type === "text";
        },

        'visible': function(elm) {
            return elm.offsetWidth && elm.offsetWidth
        },
        'empty': function(elm) {
            return !elm.hasChildNodes();
        }
    };

    ["first", "eq", "last"].forEach(function(item) {
        pseudos[item].isArrayFilter = true;
    });



    pseudos["nth"] = pseudos["eq"];

    function createInputPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    function createButtonPseudo(type) {
        return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
        };
    }

    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
    }) {
        pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
    }) {
        pseudos[i] = createButtonPseudo(i);
    }


    local.divide = function(cond) {
        var nativeSelector = "",
            customPseudos = [],
            tag,
            id,
            classes,
            attributes,
            pseudos;


        if (id = cond.id) {
            nativeSelector += ("#" + id);
        }
        if (classes = cond.classes) {
            for (var i = classes.length; i--;) {
                nativeSelector += ("." + classes[i].value);
            }
        }
        if (attributes = cond.attributes) {
            for (var i = 0; i < attributes.length; i++) {
                if (attributes[i].operator) {
                    nativeSelector += ("[" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + "]");
                } else {
                    nativeSelector += ("[" + attributes[i].key + "]");
                }
            }
        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (this.pseudos[part.key]) {
                    customPseudos.push(part);
                } else {
                    if (part.value !== undefined) {
                        nativeSelector += (":" + part.key + "(" + JSON.stringify(part))
                    }
                }
            }
        }

        if (tag = cond.tag) {
            if (tag !== "*") {
                nativeSelector = tag.toUpperCase() + nativeSelector;
            }
        }

        if (!nativeSelector) {
            nativeSelector = "*";
        }

        return {
            nativeSelector: nativeSelector,
            customPseudos: customPseudos
        }

    };

    local.check = function(node, cond, idx, nodes, arrayFilte) {
        var tag,
            id,
            classes,
            attributes,
            pseudos,

            i, part, cls, pseudo;

        if (!arrayFilte) {
            if (tag = cond.tag) {
                var nodeName = node.nodeName.toUpperCase();
                if (tag == '*') {
                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
                } else {
                    if (nodeName != (tag || "").toUpperCase()) return false;
                }
            }

            if (id = cond.id) {
                if (node.getAttribute('id') != id) {
                    return false;
                }
            }


            if (classes = cond.classes) {
                for (i = classes.length; i--;) {
                    cls = node.getAttribute('class');
                    if (!(cls && classes[i].regexp.test(cls))) return false;
                }
            }

            if (attributes = cond.attributes) {
                for (i = attributes.length; i--;) {
                    part = attributes[i];
                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;
                }
            }

        }
        if (pseudos = cond.pseudos) {
            for (i = pseudos.length; i--;) {
                part = pseudos[i];
                if (pseudo = this.pseudos[part.key]) {
                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {
                        if (!pseudo(node, idx, nodes, part.value)) {
                            return false;
                        }
                    }
                } else {
                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    local.match = function(node, selector) {

        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            parsed = selector;
        }

        if (!parsed) {
            return true;
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            simpleExpCounter = 0,
            i,
            currentExpression;
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];
                if (this.check(node, exp)) {
                    return true;
                }
                simpleExpCounter++;
            }
        }

        if (simpleExpCounter == parsed.length) {
            return false;
        }

        var nodes = this.query(document, parsed),
            item;
        for (i = 0; item = nodes[i++];) {
            if (item === node) {
                return true;
            }
        }
        return false;
    };


    local.filterSingle = function(nodes, exp) {
        var matchs = filter.call(nodes, function(node, idx) {
            return local.check(node, exp, idx, nodes, false);
        });

        matchs = filter.call(matchs, function(node, idx) {
            return local.check(node, exp, idx, matchs, true);
        });
        return matchs;
    };

    local.filter = function(nodes, selector) {
        var parsed;

        if (langx.isString(selector)) {
            parsed = local.Slick.parse(selector);
        } else {
            return local.filterSingle(nodes, selector);
        }

        // simple (single) selectors
        var expressions = parsed.expressions,
            i,
            currentExpression,
            ret = [];
        for (i = 0;
            (currentExpression = expressions[i]); i++) {
            if (currentExpression.length == 1) {
                var exp = currentExpression[0];

                var matchs = local.filterSingle(nodes, exp);

                ret = langx.uniq(ret.concat(matchs));
            } else {
                throw new Error("not supported selector:" + selector);
            }
        }

        return ret;

    };

    local.combine = function(elm, bit) {
        var op = bit.combinator,
            cond = bit,
            node1,
            nodes = [];

        switch (op) {
            case '>': // direct children
                nodes = children(elm, cond);
                break;
            case '+': // next sibling
                node1 = nextSibling(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '^': // first child
                node1 = firstChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '~': // next siblings
                nodes = nextSiblings(elm, cond);
                break;
            case '++': // next sibling and previous sibling
                var prev = previousSibling(elm, cond, true),
                    next = nextSibling(elm, cond, true);
                if (prev) {
                    nodes.push(prev);
                }
                if (next) {
                    nodes.push(next);
                }
                break;
            case '~~': // next siblings and previous siblings
                nodes = siblings(elm, cond);
                break;
            case '!': // all parent nodes up to document
                nodes = ancestors(elm, cond);
                break;
            case '!>': // direct parent (one level)
                node1 = parent(elm, cond);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!+': // previous sibling
                nodes = previousSibling(elm, cond, true);
                break;
            case '!^': // last child
                node1 = lastChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;
            case '!~': // previous siblings
                nodes = previousSiblings(elm, cond);
                break;
            default:
                var divided = this.divide(bit);
                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));
                if (divided.customPseudos) {
                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, false)
                        });

                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [divided.customPseudos[i]]
                            }, idx, nodes, true)
                        });
                    }
                }
                break;

        }
        return nodes;
    }

    local.query = function(node, selector, single) {


        var parsed = this.Slick.parse(selector);

        var
            founds = [],
            currentExpression, currentBit,
            expressions = parsed.expressions;

        for (var i = 0;
            (currentExpression = expressions[i]); i++) {
            var currentItems = [node],
                found;
            for (var j = 0;
                (currentBit = currentExpression[j]); j++) {
                found = langx.map(currentItems, function(item, i) {
                    return local.combine(item, currentBit)
                });
                if (found) {
                    currentItems = found;
                }
            }
            if (found) {
                founds = founds.concat(found);
            }
        }

        return founds;
    }

    /*
     * Get the nearest ancestor of the specified element,optional matched by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestor(node, selector, root) {
        var rootIsSelector = root && langx.isString(root);
        while (node = node.parentNode) {
            if (matches(node, selector)) {
                return node;
            }
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
        }
        return null;
    }

    /*
     * Get the ancestors of the specitied element , optionally filtered by a selector.
     * @param {HTMLElement} node
     * @param {String Optional } selector
     * @param {Object} root
     */
    function ancestors(node, selector, root) {
        var ret = [],
            rootIsSelector = root && langx.isString(root);
        while ((node = node.parentNode) && (node.nodeType !== 9)) {
            if (root) {
                if (rootIsSelector) {
                    if (matches(node, root)) {
                        break;
                    }
                } else if (langx.isArrayLike(root)) {
                    if (langx.inArray(node,root)>-1) {
                        break;
                    }
                } else if (node == root) {
                    break;
                }
            }
            if (!selector || matches(node, selector)) {
              ret.push(node); 
            }
        }

        //if (selector) {
        //    ret = local.filter(ret, selector);
        //}
        return ret;
    }


    /*
     * Returns a element by its ID.
     * @param {string} id
     */
    function byId(id, doc) {
        doc = doc || noder.doc();
        return doc.getElementById(id);
    }

    /*
     * Get the children of the specified element , optionally filtered by a selector.
     * @param {string} node
     * @param {String optionlly} selector
     */
    function children(node, selector) {
        var childNodes = node.childNodes,
            ret = [];
        for (var i = 0; i < childNodes.length; i++) {
            var node = childNodes[i];
            if (node.nodeType == 1) {
                ret.push(node);
            }
        }
        if (selector) {
            ret = local.filter(ret, selector);
        }
        return ret;
    }

    function closest(node, selector) {
        while (node && !(matches(node, selector))) {
            node = node.parentNode;
        }

        return node;
    }

    /*
     * Get the decendant of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendants(elm, selector) {
        // Selector
        try {
            return slice.call(elm.querySelectorAll(selector));
        } catch (matchError) {
            //console.log(matchError);
        }
        return local.query(elm, selector);
    }

    /*
     * Get the nearest decendent of the specified element,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function descendant(elm, selector) {
        // Selector
        try {
            return elm.querySelector(selector);
        } catch (matchError) {
            //console.log(matchError);
        }
        var nodes = local.query(elm, selector);
        if (nodes.length > 0) {
            return nodes[0];
        } else {
            return null;
        }
    }

    /*
     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function find(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        if (matches(elm, selector)) {
            return elm;
        } else {
            return descendant(elm, selector);
        }
    }

    /*
     * Get the findAll of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function findAll(elm, selector) {
        if (!selector) {
            selector = elm;
            elm = document.body;
        }
        return descendants(elm, selector);
    }

    /*
     * Get the first child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String} first
     */
    function firstChild(elm, selector, first) {
        var childNodes = elm.childNodes,
            node = childNodes[0];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (first) {
                    break;
                }
            }
            node = node.nextSibling;
        }

        return null;
    }

    /*
     * Get the last child of the specified element , optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {String } last
     */
    function lastChild(elm, selector, last) {
        var childNodes = elm.childNodes,
            node = childNodes[childNodes.length - 1];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (last) {
                    break;
                }
            }
            node = node.previousSibling;
        }

        return null;
    }

    /*
     * Check the specified element against a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function matches(elm, selector) {
        if (!selector || !elm || elm.nodeType !== 1) {
            return false
        }

        if (langx.isString(selector)) {
            try {
                return nativeMatchesSelector.call(elm, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
            } catch (matchError) {
                //console.log(matchError);
            }
            return local.match(elm, selector);
        } else if (langx.isArrayLike(selector)) {
            return langx.inArray(elm, selector) > -1;
        } else if (langx.isPlainObject(selector)) {
            return local.check(elm, selector);
        } else {
            return elm === selector;
        }

    }

    /*
     * Get the nearest next sibing of the specitied element , optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional} adjacent
     */
    function nextSibling(elm, selector, adjacent) {
        var node = elm.nextSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.nextSibling;
        }
        return null;
    }

    /*
     * Get the next siblings of the specified element , optional filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function nextSiblings(elm, selector) {
        var node = elm.nextSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    /*
     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function parent(elm, selector) {
        var node = elm.parentNode;
        if (node && (!selector || matches(node, selector))) {
            return node;
        }

        return null;
    }

    /*
     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     * @param {Boolean Optional } adjacent
     */
    function previousSibling(elm, selector, adjacent) {
        var node = elm.previousSibling;
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    return node;
                }
                if (adjacent) {
                    break;
                }
            }
            node = node.previousSibling;
        }
        return null;
    }

    /*
     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function previousSiblings(elm, selector) {
        var node = elm.previousSibling,
            ret = [];
        while (node) {
            if (node.nodeType == 1) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.previousSibling;
        }
        return ret;
    }

    /*
     * Selects all sibling elements that follow after the prev element, have the same parent, and match the filtering siblings selector.
     * @param {HTMLElement} elm
     * @param {String optionlly} selector
     */
    function siblings(elm, selector) {
        var node = elm.parentNode.firstChild,
            ret = [];
        while (node) {
            if (node.nodeType == 1 && node !== elm) {
                if (!selector || matches(node, selector)) {
                    ret.push(node);
                }
            }
            node = node.nextSibling;
        }
        return ret;
    }

    var finder = function() {
        return finder;
    };

    langx.mixin(finder, {

        ancestor: ancestor,

        ancestors: ancestors,

        byId: byId,

        children: children,

        closest: closest,

        descendant: descendant,

        descendants: descendants,

        find: find,

        findAll: findAll,

        firstChild: firstChild,

        lastChild: lastChild,

        matches: matches,

        nextSibling: nextSibling,

        nextSiblings: nextSiblings,

        parent: parent,

        previousSibling,

        previousSiblings,

        pseudos: local.pseudos,

        siblings: siblings
    });

    return skylark.attach("domx.finder", finder);
});
define('skylark-domx-finder/main',[
	"./finder"
],function(finder){

	return finder;
});
define('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });

define('skylark-domx-data/data',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-finder",
    "skylark-domx-noder"
], function(skylark, langx, finder,noder) {
    var map = Array.prototype.map,
        filter = Array.prototype.filter,
        camelCase = langx.camelCase,
        deserializeValue = langx.deserializeValue,

        capitalRE = /([A-Z])/g,
        propMap = {
            'tabindex': 'tabIndex',
            'readonly': 'readOnly',
            'for': 'htmlFor',
            'class': 'className',
            'maxlength': 'maxLength',
            'cellspacing': 'cellSpacing',
            'cellpadding': 'cellPadding',
            'rowspan': 'rowSpan',
            'colspan': 'colSpan',
            'usemap': 'useMap',
            'frameborder': 'frameBorder',
            'contenteditable': 'contentEditable'
        };

    // Strip and collapse whitespace according to HTML spec
    function stripAndCollapse( value ) {
      var tokens = value.match( /[^\x20\t\r\n\f]+/g ) || [];
      return tokens.join( " " );
    }


    var valHooks = {
      option: {
        get: function( elem ) {
          var val = elem.getAttribute( "value" );
          return val != null ?  val :  stripAndCollapse(text( elem ) );
        }
      },
      select: {
        get: function( elem ) {
          var value, option, i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;

          if ( index < 0 ) {
            i = max;

          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for ( ; i < max; i++ ) {
            option = options[ i ];

            if ( option.selected &&

                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                ( !option.parentNode.disabled ||
                  !noder.nodeName( option.parentNode, "optgroup" ) ) ) {

              // Get the specific value for the option
              value = val(option);

              // We don't need an array for one selects
              if ( one ) {
                return value;
              }

              // Multi-Selects return an array
              values.push( value );
            }
          }

          return values;
        },

        set: function( elem, value ) {
          var optionSet, option,
            options = elem.options,
            values = langx.makeArray( value ),
            i = options.length;

          while ( i-- ) {
            option = options[ i ];

            /* eslint-disable no-cond-assign */

            if ( option.selected =
              langx.inArray( valHooks.option.get( option ), values ) > -1
            ) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if ( !optionSet ) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    };


    // Radios and checkboxes getter/setter
    langx.each( [ "radio", "checkbox" ], function() {
      valHooks[ this ] = {
        set: function( elem, value ) {
          if ( langx.isArray( value ) ) {
            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );
          }
        }
      };
    });



    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function setAttribute(elm, name, value) {
        if (value == null) {
            elm.removeAttribute(name);
        } else {
            elm.setAttribute(name, value);
        }
    }

    function aria(elm, name, value) {
        return this.attr(elm, "aria-" + name, value);
    }

    /*
     * Set property values
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */

    function attr(elm, name, value) {
        if (value === undefined) {
            if (typeof name === "object") {
                for (var attrName in name) {
                    attr(elm, attrName, name[attrName]);
                }
                return this;
            } else {
                return elm.getAttribute(name);
            }
        } else {
            elm.setAttribute(name, value);
            return this;
        }
    }


    /*
     *  Read all "data-*" attributes from a node
     * @param {Object} elm  
     */

    function _attributeData(elm) {
        var store = {}
        langx.each(elm.attributes || [], function(i, attr) {
            if (attr.name.indexOf('data-') == 0) {
                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);
            }
        })
        return store;
    }

    function _store(elm, confirm) {
        var store = elm["_$_store"];
        if (!store && confirm) {
            store = elm["_$_store"] = _attributeData(elm);
        }
        return store;
    }

    function _getData(elm, name) {
        if (name === undefined) {
            return _store(elm, true);
        } else {
            var store = _store(elm);
            if (store) {
                if (name in store) {
                    return store[name];
                }
                var camelName = camelCase(name);
                if (camelName in store) {
                    return store[camelName];
                }
            }
            var attrName = 'data-' + name.replace(capitalRE, "-$1").toLowerCase()
            return attr(elm, attrName);
        }

    }

    function _setData(elm, name, value) {
        var store = _store(elm, true);
        store[camelCase(name)] = value;
    }


    /*
     * xxx
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function data(elm, name, value) {

        if (value === undefined) {
            if (typeof name === "object") {
                for (var dataAttrName in name) {
                    _setData(elm, dataAttrName, name[dataAttrName]);
                }
                return this;
            } else {
                return _getData(elm, name);
            }
        } else {
            _setData(elm, name, value);
            return this;
        }
    } 
    /*
     * Remove from the element all items that have not yet been run. 
     * @param {Object} elm  
     */

    function cleanData(elm) {
        if (elm["_$_store"]) {
            delete elm["_$_store"];
        }
    }

    /*
     * Remove a previously-stored piece of data. 
     * @param {Object} elm  
     * @param {Array} names
     */
    function removeData(elm, names) {
        if (names) {
            if (langx.isString(names)) {
                names = names.split(/\s+/);
            }
            var store = _store(elm, true);
            names.forEach(function(name) {
                delete store[name];
            });            
        } else {
            cleanData(elm);
        }
        return this;
    }

    /*
     * xxx 
     * @param {Object} elm  
     * @param {Array} names
     */
    function pluck(nodes, property) {
        return map.call(nodes, function(elm) {
            return elm[property];
        });
    }

    /*
     * Get or set the value of an property for the specified element.
     * @param {Object} elm  
     * @param {String} name
     * @param {String} value
     */
    function prop(elm, name, value) {
        name = propMap[name] || name;
        if (value === undefined) {
            return elm[name];
        } else {
            elm[name] = value;
            return this;
        }
    }

    /*
     * remove Attributes  
     * @param {Object} elm  
     * @param {String} name
     */
    function removeAttr(elm, name) {
        name.split(' ').forEach(function(attr) {
            setAttribute(elm, attr);
        });
        return this;
    }


    /*
     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.
     * @param {Object} elm  
     * @param {String} name
     */
    function removeProp(elm, name) {
        name.split(' ').forEach(function(prop) {
            delete elm[prop];
        });
        return this;
    }

    /*   
     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  
     * @param {Object} elm  
     * @param {String} txt
     */
    function text(elm, txt) {
        if (txt === undefined) {
            return elm.textContent;
        } else {
            elm.textContent = txt == null ? '' : '' + txt;
            return this;
        }
    }

    /*   
     * Get the current value of the first element in the set of matched elements or set the value of every matched element.
     * @param {Object} elm  
     * @param {String} value
     */
    function val(elm, value) {
        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];
        if (value === undefined) {
/*
            if (elm.multiple) {
                // select multiple values
                var selectedOptions = filter.call(finder.find(elm, "option"), (function(option) {
                    return option.selected;
                }));
                return pluck(selectedOptions, "value");
            } else {
                if (/input|textarea/i.test(elm.tagName)) {
                  return elm.value;
                }
                return text(elm);
            }
*/

          if ( hooks &&  "get" in hooks &&  ( ret = hooks.get( elm, "value" ) ) !== undefined ) {
            return ret;
          }

          ret = elm.value;

          // Handle most common string cases
          if ( typeof ret === "string" ) {
            return ret.replace( /\r/g, "" );
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;

        } else {
/*          
            if (/input|textarea/i.test(elm.tagName)) {
              elm.value = value;
            } else {
              text(elm,value);
            }
            return this;
*/
          // Treat null/undefined as ""; convert numbers to string
          if ( value == null ) {
            value = "";

          } else if ( typeof value === "number" ) {
            value += "";

          } else if ( langx.isArray( value ) ) {
            value = langx.map( value, function( value1 ) {
              return value1 == null ? "" : value1 + "";
            } );
          }

          // If set returns undefined, fall back to normal setting
          if ( !hooks || !( "set" in hooks ) || hooks.set( elm, value, "value" ) === undefined ) {
            elm.value = value;
          }
        }      
    }


    finder.pseudos.data = function( elem, i, match,dataName ) {
        return !!data( elem, dataName || match[3]);
    };
   

    function datax() {
        return datax;
    }

    langx.mixin(datax, {
        aria: aria,

        attr: attr,

        cleanData: cleanData,

        data: data,

        pluck: pluck,

        prop: prop,

        removeAttr: removeAttr,

        removeData: removeData,

        removeProp: removeProp,

        text: text,

        val: val,

        valHooks : valHooks
    });

    return skylark.attach("domx.data", datax);
});
define('skylark-domx-query/query',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {
    var some = Array.prototype.some,
        push = Array.prototype.push,
        every = Array.prototype.every,
        concat = Array.prototype.concat,
        slice = Array.prototype.slice,
        map = Array.prototype.map,
        filter = Array.prototype.filter,
        forEach = Array.prototype.forEach,
        indexOf = Array.prototype.indexOf,
        sort = Array.prototype.sort,
        isQ;

    var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;

    var funcArg = langx.funcArg,
        isArrayLike = langx.isArrayLike,
        isString = langx.isString,
        uniq = langx.uniq,
        isFunction = langx.isFunction;

    var type = langx.type,
        isArray = langx.isArray,

        isWindow = langx.isWindow,

        isDocument = langx.isDocument,

        isObject = langx.isObject,

        isPlainObject = langx.isPlainObject,

        compact = langx.compact,

        flatten = langx.flatten,

        camelCase = langx.camelCase,

        dasherize = langx.dasherize,
        children = finder.children;

    function wrapper_node_operation(func, context, oldValueFunc) {
        return function(html) {
            var argType, nodes = langx.map(arguments, function(arg) {
                argType = type(arg)
                return argType == "function" || argType == "object" || argType == "array" || arg == null ?
                    arg : noder.createFragment(arg)
            });
            if (nodes.length < 1) {
                return this
            }
            this.each(function(idx) {
                func.apply(context, [this, nodes, idx > 0]);
            });
            return this;
        }
    }

    function wrapper_map(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            var result = langx.map(self, function(elem, idx) {
                return func.apply(context, [elem].concat(params));
            });
            return query(uniq(result));
        }
    }

    function wrapper_selector(func, context, last) {
        return function(selector) {
            var self = this,
                params = slice.call(arguments);
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) {
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem] : [elem, selector]);
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }

    function wrapper_selector_until(func, context, last) {
        return function(util, selector) {
            var self = this,
                params = slice.call(arguments);
            //if (selector === undefined) { //TODO : needs confirm?
            //    selector = util;
            //    util = undefined;
            //}
            var result = this.map(function(idx, elem) {
                // if (elem.nodeType == 1) { // TODO
                //if (elem.querySelector) {
                    return func.apply(context, last ? [elem, util] : [elem, selector, util]);
                //}
            });
            if (last && selector) {
                return result.filter(selector);
            } else {
                return result;
            }
        }
    }


    function wrapper_every_act(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            this.each(function(idx,node) {
                func.apply(context, [this].concat(params));
            });
            return self;
        }
    }

    function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {
        return function(arg1) {
            var self = this,
                params = slice.call(arguments);
            forEach.call(self, function(elem, idx) {
                var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));
                func.apply(context, [elem, arg1].concat(params.slice(1)));
            });
            return self;
        }
    }

    function wrapper_some_chk(func, context) {
        return function() {
            var self = this,
                params = slice.call(arguments);
            return some.call(self, function(elem) {
                return func.apply(context, [elem].concat(params));
            });
        }
    }

    function wrapper_name_value(func, context, oldValueFunc) {
        return function(name, value) {
            var self = this;

            if (langx.isPlainObject(name) || langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem,name,newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0], name]);
                }
            }

        }
    }

    function wrapper_value(func, context, oldValueFunc) {
        return function(value) {
            var self = this;

            if (langx.isDefined(value)) {
                forEach.call(self, function(elem, idx) {
                    var newValue;
                    if (oldValueFunc) {
                        newValue = funcArg(elem, value, idx, oldValueFunc(elem));
                    } else {
                        newValue = value
                    }
                    func.apply(context, [elem, newValue]);
                });
                return self;
            } else {
                if (self[0]) {
                    return func.apply(context, [self[0]]);
                }
            }

        }
    }

    var NodeList = langx.klass({
        klassName: "SkNodeList",
        init: function(selector, context) {
            var self = this,
                match, nodes, node, props;

            if (selector) {
                self.context = context = context || noder.doc();

                if (isString(selector)) {
                    // a html string or a css selector is expected
                    self.selector = selector;

                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        match = [null, selector, null];
                    } else {
                        match = rquickExpr.exec(selector);
                    }

                    if (match) {
                        if (match[1]) {
                            // if selector is html
                            nodes = noder.createFragment(selector);

                            if (langx.isPlainObject(context)) {
                                props = context;
                            }

                        } else {
                            node = finder.byId(match[2], noder.ownerDoc(context));

                            if (node) {
                                // if selector is id
                                nodes = [node];
                            }

                        }
                    } else {
                        // if selector is css selector
                        if (langx.isString(context)) {
                            context = finder.find(context);
                        }

                        nodes = finder.descendants(context, selector);
                    }
                } else {
                    if (selector !== window && isArrayLike(selector)) {
                        // a dom node array is expected
                        nodes = selector;
                    } else {
                        // a dom node is expected
                        nodes = [selector];
                    }
                    //self.add(selector, false);
                }
            }


            if (nodes) {

                push.apply(self, nodes);

                if (props) {
                    for ( var name  in props ) {
                        // Properties of context are called as methods if possible
                        if ( langx.isFunction( this[ name ] ) ) {
                            this[ name ]( props[ name ] );
                        } else {
                            this.attr( name, props[ name ] );
                        }
                    }
                }
            }

            return self;
        }
    });

    var query = (function() {
        isQ = function(object) {
            return object instanceof NodeList;
        }
        init = function(selector, context) {
            return new NodeList(selector, context);
        }

        var $ = function(selector, context) {
            if (isFunction(selector)) {
                $.ready(function() {
                    selector($);
                });
            } else if (isQ(selector)) {
                return selector;
            } else {
                if (context && isQ(context) && isString(selector)) {
                    return context.find(selector);
                }
                return init(selector, context);
            }
        };

        $.fn = NodeList.prototype;
        langx.mixin($.fn, {
            // `map` and `slice` in the jQuery API work differently
            // from their array counterparts
            length : 0,

            map: function(fn) {
                return $(uniq(langx.map(this, function(el, i) {
                    return fn.call(el, i, el)
                })));
            },

            slice: function() {
                return $(slice.apply(this, arguments))
            },

            forEach: function() {
                return forEach.apply(this,arguments);
            },

            get: function(idx) {
                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
            },

            indexOf: function() {
                return indexOf.apply(this,arguments);
            },

            sort : function() {
                return sort.apply(this,arguments);
            },

            toArray: function() {
                return slice.call(this);
            },

            size: function() {
                return this.length
            },

            //remove: wrapper_every_act(noder.remove, noder),
            remove : function(selector) {
                if (selector) {
                    return this.find(selector).remove();
                }
                this.each(function(i,node){
                    noder.remove(node);
                });
                return this;
            },

            each: function(callback) {
                langx.each(this, callback);
                return this;
            },

            filter: function(selector) {
                if (isFunction(selector)) return this.not(this.not(selector))
                return $(filter.call(this, function(element) {
                    return finder.matches(element, selector)
                }))
            },

            add: function(selector, context) {
                return $(uniq(this.toArray().concat($(selector, context).toArray())));
            },

            is: function(selector) {
                if (this.length > 0) {
                    var self = this;
                    if (langx.isString(selector)) {
                        return some.call(self,function(elem) {
                            return finder.matches(elem, selector);
                        });
                    } else if (langx.isArrayLike(selector)) {
                       return some.call(self,function(elem) {
                            return langx.inArray(elem, selector) > -1;
                        });
                    } else if (langx.isHtmlNode(selector)) {
                       return some.call(self,function(elem) {
                            return elem ==  selector;
                        });
                    }
                }
                return false;
            },
            
            not: function(selector) {
                var nodes = []
                if (isFunction(selector) && selector.call !== undefined)
                    this.each(function(idx,node) {
                        if (!selector.call(this, idx,node)) nodes.push(this)
                    })
                else {
                    var excludes = typeof selector == 'string' ? this.filter(selector) :
                        (isArrayLike(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
                    this.forEach(function(el) {
                        if (excludes.indexOf(el) < 0) nodes.push(el)
                    })
                }
                return $(nodes)
            },

            has: function(selector) {
                return this.filter(function() {
                    return isObject(selector) ?
                        noder.contains(this, selector) :
                        $(this).find(selector).size()
                })
            },

            eq: function(idx) {
                return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
            },

            first: function() {
                return this.eq(0);
            },

            last: function() {
                return this.eq(-1);
            },

            find: wrapper_selector(finder.descendants, finder),

            closest: wrapper_selector(finder.closest, finder),
            /*
                        closest: function(selector, context) {
                            var node = this[0],
                                collection = false
                            if (typeof selector == 'object') collection = $(selector)
                            while (node && !(collection ? collection.indexOf(node) >= 0 : finder.matches(node, selector)))
                                node = node !== context && !isDocument(node) && node.parentNode
                            return $(node)
                        },
            */


            parents: wrapper_selector(finder.ancestors, finder),

            parentsUntil: wrapper_selector_until(finder.ancestors, finder),


            parent: wrapper_selector(finder.parent, finder),

            children: wrapper_selector(finder.children, finder),

            contents: wrapper_map(noder.contents, noder),

            empty: wrapper_every_act(noder.empty, noder),

            html: wrapper_value(noder.html, noder),

            // `pluck` is borrowed from Prototype.js
            pluck: function(property) {
                return langx.map(this, function(el) {
                    return el[property]
                })
            },

            pushStack : function(elms) {
                var ret = $(elms);
                ret.prevObject = this;
                return ret;
            },
            
            replaceWith: function(newContent) {
                return this.before(newContent).remove();
            },

            wrap: function(html) {
                /*
                var func = isFunction(structure)
                if (this[0] && !func)
                    var dom = $(structure).get(0),
                        clone = dom.parentNode || this.length > 1

                return this.each(function(index,node) {
                    $(this).wrapAll(
                        func ? structure.call(this, index,node) :
                        clone ? dom.cloneNode(true) : dom
                    )
                })
                */
                var htmlIsFunction = typeof html === "function";

                return this.each( function( i ) {
                    $( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
                } );                
            },

            wrapAll: function(html) {
                /*
                if (this[0]) {
                    $(this[0]).before(wrappingElement = $(wrappingElement));
                    var children;
                    // drill down to the inmost element
                    while ((children = wrappingElement.children()).length) {
                        wrappingElement = children.first();
                    }
                    $(wrappingElement).append(this);
                }
                return this
                */
                var wrap;

                if ( this[ 0 ] ) {
                    if ( typeof html === "function" ) {
                        html = html.call( this[ 0 ] );
                    }

                    // The elements to wrap the target around
                    wrap = $( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                    if ( this[ 0 ].parentNode ) {
                        wrap.insertBefore( this[ 0 ] );
                    }

                    wrap.map( function() {
                        var elem = this;

                        while ( elem.firstElementChild ) {
                            elem = elem.firstElementChild;
                        }

                        return elem;
                    } ).append( this );
                }

                return this;

            },

            wrapInner: function(html) {
                /*
                var func = isFunction(wrappingElement)
                return this.each(function(index,node) {
                    var self = $(this),
                        contents = self.contents(),
                        dom = func ? wrappingElement.call(this, index,node) : wrappingElement
                    contents.length ? contents.wrapAll(dom) : self.append(dom)
                })
                */
                if ( typeof html === "function" ) {
                    return this.each( function( i ) {
                        $( this ).wrapInner( html.call( this, i ) );
                    } );
                }

                return this.each( function() {
                    var self = $( this ),
                        contents = self.contents();

                    if ( contents.length ) {
                        contents.wrapAll( html );

                    } else {
                        self.append( html );
                    }
                } );

            },

            unwrap: function(selector) {
                /*
                if (this.parent().children().length === 0) {
                    // remove dom without text
                    this.parent(selector).not("body").each(function() {
                        $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));
                    });
                } else {
                    this.parent().each(function() {
                        $(this).replaceWith($(this).children())
                    });
                }
                return this
                */
                this.parent(selector).not("body").each( function() {
                    $(this).replaceWith(this.childNodes);
                });
                return this;

            },

            clone: function() {
                return this.map(function() {
                    return this.cloneNode(true)
                })
            },


            toggle: function(setting) {
                return this.each(function() {
                    var el = $(this);
                    (setting === undefined ? el.css("display") == "none" : setting) ? el.show(): el.hide()
                })
            },

            prev: function(selector) {
                return $(this.pluck('previousElementSibling')).filter(selector || '*')
            },

            prevAll: wrapper_selector(finder.previousSiblings, finder),

            next: function(selector) {
                return $(this.pluck('nextElementSibling')).filter(selector || '*')
            },

            nextAll: wrapper_selector(finder.nextSiblings, finder),

            siblings: wrapper_selector(finder.siblings, finder),

            index: function(elem) {
                if (elem) {
                    return this.indexOf($(elem)[0]);
                } else {
                    return this.parent().children().indexOf(this[0]);
                }
            }
        });

        // for now
        $.fn.detach = $.fn.remove;

        $.fn.hover = function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        };


        var traverseNode = noder.traverse;


        $.fn.after = wrapper_node_operation(noder.after, noder);

        $.fn.prepend = wrapper_node_operation(noder.prepend, noder);

        $.fn.before = wrapper_node_operation(noder.before, noder);

        $.fn.append = wrapper_node_operation(noder.append, noder);


        langx.each( {
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function( name, original ) {
            $.fn[ name ] = function( selector ) {
                var elems,
                    ret = [],
                    insert = $( selector ),
                    last = insert.length - 1,
                    i = 0;

                for ( ; i <= last; i++ ) {
                    elems = i === last ? this : this.clone( true );
                    $( insert[ i ] )[ original ]( elems );

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // .get() because push.apply(_, arraylike) throws on ancient WebKit
                    push.apply( ret, elems.get() );
                }

                return this.pushStack( ret );
            };
        } );

/*
        $.fn.insertAfter = function(html) {
            $(html).after(this);
            return this;
        };

        $.fn.insertBefore = function(html) {
            $(html).before(this);
            return this;
        };

        $.fn.appendTo = function(html) {
            $(html).append(this);
            return this;
        };

        $.fn.prependTo = function(html) {
            $(html).prepend(this);
            return this;
        };

        $.fn.replaceAll = function(selector) {
            $(selector).replaceWith(this);
            return this;
        };
*/
        return $;
    })();

    (function($) {
        $.fn.scrollParent = function( includeHidden ) {
            var position = this.css( "position" ),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter( function() {
                    var parent = $( this );
                    if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
                        return false;
                    }
                    return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
                        parent.css( "overflow-x" ) );
                } ).eq( 0 );

            return position === "fixed" || !scrollParent.length ?
                $( this[ 0 ].ownerDocument || document ) :
                scrollParent;
        };

    })(query);


    (function($) {
        $.fn.end = function() {
            return this.prevObject || $()
        }

        $.fn.andSelf = function() {
            return this.add(this.prevObject || $())
        }

        $.fn.addBack = function(selector) {
            if (this.prevObject) {
                if (selector) {
                    return this.add(this.prevObject.filter(selector));
                } else {
                    return this.add(this.prevObject);
                }
            } else {
                return this;
            }
        }

        'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings,prev,prevAll,next,nextAll'.split(',').forEach(function(property) {
            var fn = $.fn[property]
            $.fn[property] = function() {
                var ret = fn.apply(this, arguments)
                ret.prevObject = this
                return ret
            }
        })
    })(query);


    (function($) {
        $.fn.query = $.fn.find;

        $.fn.place = function(refNode, position) {
            // summary:
            //      places elements of this node list relative to the first element matched
            //      by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
            // queryOrNode:
            //      may be a string representing any valid CSS3 selector or a DOM node.
            //      In the selector case, only the first matching element will be used
            //      for relative positioning.
            // position:
            //      can be one of:
            //
            //      -   "last" (default)
            //      -   "first"
            //      -   "before"
            //      -   "after"
            //      -   "only"
            //      -   "replace"
            //
            //      or an offset in the childNodes
            if (langx.isString(refNode)) {
                refNode = finder.descendant(refNode);
            } else if (isQ(refNode)) {
                refNode = refNode[0];
            }
            return this.each(function(i, node) {
                switch (position) {
                    case "before":
                        noder.before(refNode, node);
                        break;
                    case "after":
                        noder.after(refNode, node);
                        break;
                    case "replace":
                        noder.replace(refNode, node);
                        break;
                    case "only":
                        noder.empty(refNode);
                        noder.append(refNode, node);
                        break;
                    case "first":
                        noder.prepend(refNode, node);
                        break;
                        // else fallthrough...
                    default: // aka: last
                        noder.append(refNode, node);
                }
            });
        };

        $.fn.addContent = function(content, position) {
            if (content.template) {
                content = langx.substitute(content.template, content);
            }
            return this.append(content);
        };



        $.fn.disableSelection = ( function() {
            var eventType = "onselectstart" in document.createElement( "div" ) ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.on( eventType + ".ui-disableSelection", function( event ) {
                    event.preventDefault();
                } );
            };
        } )();

        $.fn.enableSelection = function() {
            return this.off( ".ui-disableSelection" );
        };

        $.fn.reflow = function() {
            return noder.flow(this[0]);
        };

        $.fn.isBlockNode = function() {
            return noder.isBlockNode(this[0]);
        };
       

    })(query);

    query.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = plugins.instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };


    query.wraps = {
        wrapper_node_operation,
        wrapper_map,
        wrapper_value,
        wrapper_selector,
        wrapper_some_chk,
        wrapper_selector_until,
        wrapper_every_act_firstArgFunc,
        wrapper_every_act,
        wrapper_name_value

    };

    return skylark.attach("domx.query", query);

});
define('skylark-domx-query/main',[
	"./query"
],function(query){
	return query;
});
define('skylark-domx-query', ['skylark-domx-query/main'], function (main) { return main; });

define('skylark-domx-velm/velm',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder",
    "skylark-domx-query"
], function(skylark, langx, noder, finder, $) {
    var map = Array.prototype.map,
        slice = Array.prototype.slice;
    /*
     * VisualElement is a skylark class type wrapping a visule dom node,
     * provides a number of prototype methods and supports chain calls.
     */
    var VisualElement = langx.klass({
        klassName: "VisualElement",

        "_construct": function(node) {
            if (langx.isString(node)) {
                if (node.charAt(0) === "<") {
                    //html
                    node = noder.createFragment(node)[0];
                } else {
                    // id
                    node = document.getElementById(node);
                }
            }
            this._elm = node;
        }
    });

    VisualElement.prototype.$ = VisualElement.prototype.query = function(selector) {
        return $(selector,this._elm);
    };

    VisualElement.prototype.elm = function() {
        return this._elm;
    };

    /*
     * the VisualElement object wrapping document.body
     */
    var root = new VisualElement(document.body),
        velm = function(node) {
            if (node) {
                return new VisualElement(node);
            } else {
                return root;
            }
        };
    /*
     * Extend VisualElement prototype with wrapping the specified methods.
     * @param {ArrayLike} fn
     * @param {Object} context
     */
    function _delegator(fn, context) {
        return function() {
            var self = this,
                elem = self._elm,
                ret = fn.apply(context, [elem].concat(slice.call(arguments)));

            if (ret) {
                if (ret === context) {
                    return self;
                } else {
                    if (ret instanceof HTMLElement) {
                        ret = new VisualElement(ret);
                    } else if (langx.isArrayLike(ret)) {
                        ret = map.call(ret, function(el) {
                            if (el instanceof HTMLElement) {
                                return new VisualElement(el);
                            } else {
                                return el;
                            }
                        })
                    }
                }
            }
            return ret;
        };
    }

    langx.mixin(velm, {
        batch: function(nodes, action, args) {
            nodes.forEach(function(node) {
                var elm = (node instanceof VisualElement) ? node : velm(node);
                elm[action].apply(elm, args);
            });

            return this;
        },

        root: new VisualElement(document.body),

        VisualElement: VisualElement,

        partial: function(name, fn) {
            var props = {};

            props[name] = fn;

            VisualElement.partial(props);
        },

        delegate: function(names, context) {
            var props = {};

            names.forEach(function(name) {
                props[name] = _delegator(context[name], context);
            });

            VisualElement.partial(props);
        }
    });

    // from ./finder
    velm.delegate([
        "ancestor",
        "ancestors",
        "children",
        "descendant",
        "find",
        "findAll",
        "firstChild",
        "lastChild",
        "matches",
        "nextSibling",
        "nextSiblings",
        "parent",
        "previousSibling",
        "previousSiblings",
        "siblings"
    ], finder);

    /*
     * find a dom element matched by the specified selector.
     * @param {String} selector
     */
    velm.find = function(selector) {
        if (selector === "body") {
            return this.root;
        } else {
            return this.root.descendant(selector);
        }
    };


    // from ./noder
    velm.delegate([
        "after",
        "append",
        "before",
        "clone",
        "contains",
        "contents",
        "empty",
        "html",
        "isChildOf",
        "isDocument",
        "isInDocument",
        "isWindow",
        "ownerDoc",
        "prepend",
        "remove",
        "removeChild",
        "replace",
        "reverse",
        "throb",
        "traverse",
        "wrapper",
        "wrapperInner",
        "unwrap"
    ], noder);


    return skylark.attach("domx.velm", velm);
});
define('skylark-domx-velm/main',[
	"./velm"
],function(velm){
	return velm;
});
define('skylark-domx-velm', ['skylark-domx-velm/main'], function (main) { return main; });

define('skylark-domx-data/main',[
    "./data",
    "skylark-domx-velm",
    "skylark-domx-query"    
],function(data,velm,$){
    // from ./data
    velm.delegate([
        "attr",
        "data",
        "prop",
        "removeAttr",
        "removeData",
        "text",
        "val"
    ], data);

    $.fn.text = $.wraps.wrapper_value(data.text, data, data.text);

    $.fn.attr = $.wraps.wrapper_name_value(data.attr, data, data.attr);

    $.fn.removeAttr = $.wraps.wrapper_every_act(data.removeAttr, data);

    $.fn.prop = $.wraps.wrapper_name_value(data.prop, data, data.prop);

    $.fn.removeProp = $.wraps.wrapper_every_act(data.removeProp, data);

    $.fn.data = $.wraps.wrapper_name_value(data.data, data, data.data);

    $.fn.removeData = $.wraps.wrapper_every_act(data.removeData, data);

    $.fn.val = $.wraps.wrapper_value(data.val, data, data.val);


    return data;
});
define('skylark-domx-data', ['skylark-domx-data/main'], function (main) { return main; });

define('skylark-domx-eventer/eventer',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-finder",
    "skylark-domx-noder",
    "skylark-domx-data"
], function(skylark, langx, browser, finder, noder, datax) {
    var mixin = langx.mixin,
        each = langx.each,
        slice = Array.prototype.slice,
        uid = langx.uid,
        ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,
        eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        },
        readyRE = /complete|loaded|interactive/;

    function compatible(event, source) {
        if (source || !event.isDefaultPrevented) {
            if (!source) {
                source = event;
            }

            langx.each(eventMethods, function(name, predicate) {
                var sourceMethod = source[name];
                event[name] = function() {
                    this[predicate] = langx.returnTrue;
                    return sourceMethod && sourceMethod.apply(source, arguments);
                }
                event[predicate] = langx.returnFalse;
            });
        }
        return event;
    }

    function parse(event) {
        var segs = ("" + event).split(".");
        return {
            type: segs[0],
            ns: segs.slice(1).sort().join(" ")
        };
    }


    var NativeEventCtors = [
            window["CustomEvent"], // 0 default
            window["CompositionEvent"], // 1
            window["DragEvent"], // 2
            window["Event"], // 3
            window["FocusEvent"], // 4
            window["KeyboardEvent"], // 5
            window["MessageEvent"], // 6
            window["MouseEvent"], // 7
            window["MouseScrollEvent"], // 8
            window["MouseWheelEvent"], // 9
            window["MutationEvent"], // 10
            window["ProgressEvent"], // 11
            window["TextEvent"], // 12
            window["TouchEvent"], // 13
            window["UIEvent"], // 14
            window["WheelEvent"], // 15
            window["ClipboardEvent"] // 16
        ],
        NativeEvents = {
            "compositionstart": 1, // CompositionEvent
            "compositionend": 1, // CompositionEvent
            "compositionupdate": 1, // CompositionEvent

            "beforecopy": 16, // ClipboardEvent
            "beforecut": 16, // ClipboardEvent
            "beforepaste": 16, // ClipboardEvent
            "copy": 16, // ClipboardEvent
            "cut": 16, // ClipboardEvent
            "paste": 16, // ClipboardEvent

            "drag": 2, // DragEvent
            "dragend": 2, // DragEvent
            "dragenter": 2, // DragEvent
            "dragexit": 2, // DragEvent
            "dragleave": 2, // DragEvent
            "dragover": 2, // DragEvent
            "dragstart": 2, // DragEvent
            "drop": 2, // DragEvent

            "abort": 3, // Event
            "change": 3, // Event
            "error": 3, // Event
            "selectionchange": 3, // Event
            "submit": 3, // Event
            "reset": 3, // Event

            "focus": 4, // FocusEvent
            "blur": 4, // FocusEvent
            "focusin": 4, // FocusEvent
            "focusout": 4, // FocusEvent

            "keydown": 5, // KeyboardEvent
            "keypress": 5, // KeyboardEvent
            "keyup": 5, // KeyboardEvent

            "message": 6, // MessageEvent

            "click": 7, // MouseEvent
            "contextmenu": 7, // MouseEvent
            "dblclick": 7, // MouseEvent
            "mousedown": 7, // MouseEvent
            "mouseup": 7, // MouseEvent
            "mousemove": 7, // MouseEvent
            "mouseover": 7, // MouseEvent
            "mouseout": 7, // MouseEvent
            "mouseenter": 7, // MouseEvent
            "mouseleave": 7, // MouseEvent


            "textInput": 12, // TextEvent

            "touchstart": 13, // TouchEvent
            "touchmove": 13, // TouchEvent
            "touchend": 13, // TouchEvent

            "load": 14, // UIEvent
            "resize": 14, // UIEvent
            "select": 14, // UIEvent
            "scroll": 14, // UIEvent
            "unload": 14, // UIEvent,

            "wheel": 15 // WheelEvent
        };

    //create a custom dom event
    var createEvent = (function() {

        function getEventCtor(type) {
            var idx = NativeEvents[type];
            if (!idx) {
                idx = 0;
            }
            return NativeEventCtors[idx];
        }

        return function(type, props) {
            //create a custom dom event

            if (langx.isString(type)) {
                props = props || {};
            } else {
                props = type || {};
                type = props.type || "";
            }
            var parsed = parse(type);
            type = parsed.type;

            props = langx.mixin({
                bubbles: true,
                cancelable: true
            }, props);

            if (parsed.ns) {
                props.namespace = parsed.ns;
            }

            var ctor = getEventCtor(type),
                e = new ctor(type, props);

            langx.safeMixin(e, props);

            return compatible(e);
        };
    })();

    function createProxy(src, props) {
        var key,
            proxy = {
                originalEvent: src
            };
        for (key in src) {
            if (key !== "keyIdentifier" && !ignoreProperties.test(key) && src[key] !== undefined) {
                proxy[key] = src[key];
            }
        }
        if (props) {
            langx.mixin(proxy, props);
        }
        return compatible(proxy, src);
    }

    var
        specialEvents = {},
        focusinSupported = "onfocusin" in window,
        focus = { focus: "focusin", blur: "focusout" },
        hover = { mouseenter: "mouseover", mouseleave: "mouseout" },
        realEvent = function(type) {
            return hover[type] || (focusinSupported && focus[type]) || type;
        },
        handlers = {},
        EventBindings = langx.klass({
            init: function(target, event) {
                this._target = target;
                this._event = event;
                this._bindings = [];
            },

            add: function(fn, options) {
                var bindings = this._bindings,
                    binding = {
                        fn: fn,
                        options: langx.mixin({}, options)
                    };

                bindings.push(binding);

                var self = this;
                if (!self._listener) {
                    self._listener = function(domEvt) {
                        var elm = this,
                            e = createProxy(domEvt),
                            args = domEvt._args,
                            bindings = self._bindings,
                            ns = e.namespace;

                        if (langx.isDefined(args)) {
                            args = [e].concat(args);
                        } else {
                            args = [e];
                        }

                        langx.each(bindings, function(idx, binding) {
                            var match = elm;
                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                                return false;
                            }
                            var fn = binding.fn,
                                options = binding.options || {},
                                selector = options.selector,
                                one = options.one,
                                data = options.data;

                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {
                                return;
                            }
                            if (selector) {
                                match = finder.closest(e.target, selector);
                                if (match && match !== elm) {
                                    langx.mixin(e, {
                                        currentTarget: match,
                                        liveFired: elm
                                    });
                                } else {
                                    return;
                                }
                            }

                            var originalEvent = self._event;
                            if (originalEvent in hover) {
                                var related = e.relatedTarget;
                                if (related && (related === match || noder.contains(match, related))) {
                                    return;
                                }
                            }

                            if (langx.isDefined(data)) {
                                e.data = data;
                            }

                            if (one) {
                                self.remove(fn, options);
                            }

                            var result = fn.apply(match, args);

                            if (result === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });;
                    };

                    var event = self._event;
                    /*
                                        if (event in hover) {
                                            var l = self._listener;
                                            self._listener = function(e) {
                                                var related = e.relatedTarget;
                                                if (!related || (related !== this && !noder.contains(this, related))) {
                                                    return l.apply(this, arguments);
                                                }
                                            }
                                        }
                    */

                    if (self._target.addEventListener) {
                        self._target.addEventListener(realEvent(event), self._listener, false);
                    } else {
                        console.warn("invalid eventer object", self._target);
                    }
                }

            },
            remove: function(fn, options) {
                options = langx.mixin({}, options);

                function matcherFor(ns) {
                    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
                }
                var matcher;
                if (options.ns) {
                    matcher = matcherFor(options.ns);
                }

                this._bindings = this._bindings.filter(function(binding) {
                    var removing = (!fn || fn === binding.fn) &&
                        (!matcher || matcher.test(binding.options.ns)) &&
                        (!options.selector || options.selector == binding.options.selector);

                    return !removing;
                });
                if (this._bindings.length == 0) {
                    if (this._target.removeEventListener) {
                        this._target.removeEventListener(realEvent(this._event), this._listener, false);
                    }
                    this._listener = null;
                }
            }
        }),
        EventsHandler = langx.klass({
            init: function(elm) {
                this._target = elm;
                this._handler = {};
            },

            // add a event listener
            // selector Optional
            register: function(event, callback, options) {
                // Seperate the event from the namespace
                var parsed = parse(event),
                    event = parsed.type,
                    specialEvent = specialEvents[event],
                    bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);

                var events = this._handler;

                // Check if there is already a handler for this event
                if (events[event] === undefined) {
                    events[event] = new EventBindings(this._target, bindingEvent || event);
                }

                // Register the new callback function
                events[event].add(callback, langx.mixin({
                    ns: parsed.ns
                }, options)); // options:{selector:xxx}
            },

            // remove a event listener
            unregister: function(event, fn, options) {
                // Check for parameter validtiy
                var events = this._handler,
                    parsed = parse(event);
                event = parsed.type;

                if (event) {
                    var listener = events[event];

                    if (listener) {
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                } else {
                    //remove all events
                    for (event in events) {
                        var listener = events[event];
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                }
            }
        }),

        findHandler = function(elm) {
            var id = uid(elm),
                handler = handlers[id];
            if (!handler) {
                handler = handlers[id] = new EventsHandler(elm);
            }
            return handler;
        };

    /*   
     * Remove an event handler for one or more events from the specified element.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {StringOptional } selector
     * @param {Function} callback
     */
    function off(elm, events, selector, callback) {
        var $this = this
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                off(elm, type, selector, fn);
            })
            return $this;
        }

        if (!langx.isString(selector) && !langx.isFunction(callback) && callback !== false) {
            callback = selector;
            selector = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        if (events) events.forEach(function(event) {

            handler.unregister(event, callback, {
                selector: selector,
            });
        });
        return this;
    }

    /*   
     * Attach an event handler function for one or more events to the selected elements.
     * @param {HTMLElement} elm  
     * @param {String} events
     * @param {StringOptional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     * @param {BooleanOptional} one
     */
    function on(elm, events, selector, data, callback, one) {

        var autoRemove, delegator;
        if (langx.isPlainObject(events)) {
            langx.each(events, function(type, fn) {
                on(elm, type, selector, data, fn, one);
            });
            return this;
        }

        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = undefined;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = undefined;
        }

        if (callback === false) {
            callback = langx.returnFalse;
        }

        if (typeof events == "string") {
            if (events.indexOf(",") > -1) {
                events = events.split(",");
            } else {
                events = events.split(/\s/);
            }
        }

        var handler = findHandler(elm);

        events.forEach(function(event) {
            if (event == "ready") {
                return ready(callback);
            }
            handler.register(event, callback, {
                data: data,
                selector: selector,
                one: !!one
            });
        });
        return this;
    }

    /*   
     * Attach a handler to an event for the elements. The handler is executed at most once per 
     * @param {HTMLElement} elm  
     * @param {String} event
     * @param {StringOptional} selector
     * @param {Anything Optional} data
     * @param {Function} callback
     */
    function one(elm, events, selector, data, callback) {
        on(elm, events, selector, data, callback, 1);

        return this;
    }

    /*   
     * Prevents propagation and clobbers the default action of the passed event. The same as calling event.preventDefault() and event.stopPropagation(). 
     * @param {String} event
     */
    function stop(event) {
        if (window.document.all) {
            event.keyCode = 0;
        }
        if (event.preventDefault) {
            event.preventDefault();
            event.stopPropagation();
        }
        return this;
    }
    /*   
     * Execute all handlers and behaviors attached to the matched elements for the given event  
     * @param {String} evented
     * @param {String} type
     * @param {Array or PlainObject } args
     */
    function trigger(evented, type, args) {
        var e;
        if (type instanceof Event) {
            e = type;
        } else {
            e = createEvent(type, args);
        }
        e._args = args;

        var fn = (evented.dispatchEvent || evented.trigger);
        if (fn) {
            fn.call(evented, e);
        } else {
            console.warn("The evented parameter is not a eventable object");
        }

        return this;
    }
    /*   
     * Specify a function to execute when the DOM is fully loaded.  
     * @param {Function} callback
     */
    function ready(callback) {
        // need to check if document.body exists for IE as that browser reports
        // document ready when it hasn't yet created the body elm
        if (readyRE.test(document.readyState) && document.body) {
            langx.defer(callback);
        } else {
            document.addEventListener('DOMContentLoaded', callback, false);
        }

        return this;
    }

    var keyCodeLookup = {
        "backspace": 8,
        "comma": 188,
        "delete": 46,
        "down": 40,
        "end": 35,
        "enter": 13,
        "escape": 27,
        "home": 36,
        "left": 37,
        "page_down": 34,
        "page_up": 33,
        "period": 190,
        "right": 39,
        "space": 32,
        "tab": 9,
        "up": 38
    };
    //example:
    //shortcuts(elm).add("CTRL+ALT+SHIFT+X",function(){console.log("test!")});
    function shortcuts(elm) {

        var registry = datax.data(elm, "shortcuts");
        if (!registry) {
            registry = {};
            datax.data(elm, "shortcuts", registry);
            var run = function(shortcut, event) {
                var n = event.metaKey || event.ctrlKey;
                if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {
                    if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {
                        event.preventDefault();
                        if ("keydown" == event.type) {
                            shortcut.fn(event);
                        }
                        return true;
                    }
                }
            };
            on(elm, "keyup keypress keydown", function(event) {
                if (!(/INPUT|TEXTAREA/.test(event.target.nodeName))) {
                    for (var key in registry) {
                        run(registry[key], event);
                    }
                }
            });

        }

        return {
            add: function(pattern, fn) {
                var shortcutKeys;
                if (pattern.indexOf(",") > -1) {
                    shortcutKeys = pattern.toLowerCase().split(",");
                } else {
                    shortcutKeys = pattern.toLowerCase().split(" ");
                }
                shortcutKeys.forEach(function(shortcutKey) {
                    var setting = {
                        fn: fn,
                        alt: false,
                        ctrl: false,
                        shift: false
                    };
                    shortcutKey.split("+").forEach(function(key) {
                        switch (key) {
                            case "alt":
                            case "ctrl":
                            case "shift":
                                setting[key] = true;
                                break;
                            default:
                                setting.charCode = key.charCodeAt(0);
                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);
                        }
                    });
                    var regKey = (setting.ctrl ? "ctrl" : "") + "," + (setting.alt ? "alt" : "") + "," + (setting.shift ? "shift" : "") + "," + setting.keyCode;
                    registry[regKey] = setting;
                })
            }

        };

    }

    if (browser.support.transition) {
        specialEvents.transitionEnd = {
//          handle: function (e) {
//            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
//          },
          bindType: browser.support.transition.end,
          delegateType: browser.support.transition.end
        }        
    }

    function eventer() {
        return eventer;
    }

    langx.mixin(eventer, {
        NativeEvents : NativeEvents,
        
        create: createEvent,

        keys: keyCodeLookup,

        off: off,

        on: on,

        one: one,

        proxy: createProxy,

        ready: ready,

        shortcuts: shortcuts,

        special: specialEvents,

        stop: stop,

        trigger: trigger

    });

    each(NativeEvents,function(name){
        eventer[name] = function(elm,selector,data,callback) {
            if (arguments.length>1) {
                return this.on(elm,name,selector,data,callback);
            } else {
                if (name == "focus") {
                    if (elm.focus) {
                        elm.focus();
                    }
                } else if (name == "blur") {
                    if (elm.blur) {
                        elm.blur();
                    }
                } else if (name == "click") {
                    if (elm.click) {
                        elm.click();
                    }
                } else {
                    this.trigger(elm,name);
                }

                return this;
            }
        };
    });

    return skylark.attach("domx.eventer",eventer);
});
define('skylark-domx-eventer/main',[
    "skylark-langx/langx",
    "./eventer",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,eventer,velm,$){

    var delegateMethodNames = [
        "off",
        "on",
        "one",
        "trigger"
    ];

    langx.each(eventer.NativeEvents,function(name){
        delegateMethodNames.push(name);
    });

    // from ./eventer
    velm.delegate(delegateMethodNames, eventer);

    langx.each(delegateMethodNames,function(i,name){
        $.fn[name] = $.wraps.wrapper_every_act(eventer[name],eventer);
    });


    /*
    $.fn.on = $.wraps.wrapper_every_act(eventer.on, eventer);

    $.fn.off = $.wraps.wrapper_every_act(eventer.off, eventer);

    $.fn.trigger = $.wraps.wrapper_every_act(eventer.trigger, eventer);

    ('focusin focusout focus blur load resize scroll unload click dblclick ' +
        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +
        'change select keydown keypress keyup error transitionEnd').split(' ').forEach(function(event) {
        $.fn[event] = $.wraps.wrapper_every_act(eventer[event],eventer);
    });

    $.fn.one = function(event, selector, data, callback) {
        if (!langx.isString(selector) && !langx.isFunction(callback)) {
            callback = data;
            data = selector;
            selector = null;
        }

        if (langx.isFunction(data)) {
            callback = data;
            data = null;
        }

        return this.on(event, selector, data, callback, 1)
    }; 
    */

    $.ready = eventer.ready;

    return eventer;
});
define('skylark-domx-eventer', ['skylark-domx-eventer/main'], function (main) { return main; });

define('skylark-domx-forms/forms',[
	"skylark-langx/skylark"
],function(skylark){
	return skylark.attach("domx.forms",{});
});
define('skylark-domx-forms/deserialize',[
  "skylark-langx/langx",
  "skylark-domx-query",
  "./forms"
],function(langx,$,forms){
  /**
   * Updates a key/valueArray with the given property and value. Values will always be stored as arrays.
   *
   * @param prop The property to add the value to.
   * @param value The value to add.
   * @param obj The object to update.
   * @returns {object} Updated object.
   */
  function updateKeyValueArray( prop, value, obj ) {
    var current = obj[ prop ];

    if ( current === undefined ) {
      obj[ prop ] = [ value ];
    } else {
      current.push( value );
    }

    return obj;
  }

  /**
   * Get all of the fields contained within the given elements by name.
   *
   * @param formElm The form element.
   * @param filter Custom filter to apply to the list of fields.
   * @returns {object} All of the fields contained within the given elements, keyed by name.
   */
  function getFieldsByName(formElm, filter ) {
    var elementsByName = {};

    // Extract fields from elements
    var fields = $(formElm)
      .map(function convertFormToElements() {
        return this.elements ? langx.makeArray( this.elements ) : this;
      })
      .filter( filter || ":input:not(:disabled)" )
      .get();

    langx.each( fields, function( index, field ) {
      updateKeyValueArray( field.name, field, elementsByName );
    });

    return elementsByName;
  }

  /**
   * Figure out the type of an element. Input type will be used first, falling back to nodeName.
   *
   * @param element DOM element to check type of.
   * @returns {string} The element's type.
   */
  function getElementType( element ) {
    return ( element.type || element.nodeName ).toLowerCase();
  }

  /**
   * Normalize the provided data into a key/valueArray store.
   *
   * @param data The data provided by the user to the plugin.
   * @returns {object} The data normalized into a key/valueArray store.
   */
  function normalizeData( data ) {
    var normalized = {};
    var rPlus = /\+/g;

    // Convert data from .serializeObject() notation
    if ( langx.isPlainObject( data ) ) {
      langx.extend( normalized, data );

      // Convert non-array values into an array
      langx.each( normalized, function( name, value ) {
        if ( !langx.isArray( value ) ) {
          normalized[ name ] = [ value ];
        }
      });

    // Convert data from .serializeArray() notation
    } else if ( langx.isArray( data ) ) {
      langx.each( data, function( index, field ) {
        updateKeyValueArray( field.name, field.value, normalized );
      });

    // Convert data from .serialize() notation
    } else if ( typeof data === "string" ) {
      langx.each( data.split( "&" ), function( index, field ) {
        var current = field.split( "=" );
        var name = decodeURIComponent( current[ 0 ].replace( rPlus, "%20" ) );
        var value = decodeURIComponent( current[ 1 ].replace( rPlus, "%20" ) );
        updateKeyValueArray( name, value, normalized );
      });
    }

    return normalized;
  }

  /**
   * Map of property name -> element types.
   *
   * @type {object}
   */
  var updateTypes = {
    checked: [
      "radio",
      "checkbox"
    ],
    selected: [
      "option",
      "select-one",
      "select-multiple"
    ],
    value: [
      "button",
      "color",
      "date",
      "datetime",
      "datetime-local",
      "email",
      "hidden",
      "month",
      "number",
      "password",
      "range",
      "reset",
      "search",
      "submit",
      "tel",
      "text",
      "textarea",
      "time",
      "url",
      "week"
    ]
  };

  /**
   * Get the property to update on an element being updated.
   *
   * @param element The DOM element to get the property for.
   * @returns The name of the property to update if element is supported, otherwise `undefined`.
   */
  function getPropertyToUpdate( element ) {
    var type = getElementType( element );
    var elementProperty = undefined;

    langx.each( updateTypes, function( property, types ) {
      if ( langx.inArray( type, types ) > -1 ) {
        elementProperty = property;
        return false;
      }
    });

    return elementProperty;
  }

  /**
   * Update the element based on the provided data.
   *
   * @param element The DOM element to update.
   * @param elementIndex The index of this element in the list of elements with the same name.
   * @param value The serialized element value.
   * @param valueIndex The index of the value in the list of values for elements with the same name.
   * @param callback A function to call if the value of an element was updated.
   */
  function update( element, elementIndex, value, valueIndex, callback ) {
    var property = getPropertyToUpdate( element );

    // Handle value inputs
    // If there are multiple value inputs with the same name, they will be populated by matching indexes.
    if ( property == "value" && elementIndex == valueIndex ) {
      element.value = value;
      callback.call( element, value );

    // Handle select menus, checkboxes and radio buttons
    } else if ( property == "checked" || property == "selected" ) {
      var fields = [];

      // Extract option fields from select menus
      if ( element.options ) {
        langx.each( element.options, function( index, option ) {
          fields.push( option );
        });

      } else {
        fields.push( element );
      }

      // #37: Remove selection from multiple select menus before deserialization
      if ( element.multiple && valueIndex == 0 ) {
        element.selectedIndex = -1;
      }

      langx.each( fields, function( index, field ) {
        if ( field.value == value ) {
          field[ property ] = true;
          callback.call( field, value );
        }
      });
    }
  }

  /**
   * Default plugin options.
   *
   * @type {object}
   */
  var defaultOptions = {
    change: langx.noop,
    complete: langx.noop
  };

  /**
   * The $.deserialize function.
   *
   * @param data The data to deserialize.
   * @param options Additional options.
   * @returns {jQuery} The jQuery object that was provided to the plugin.
   */
  function deserialize(formElm,data, options ) {

    // Backwards compatible with old arguments: data, callback
    if ( langx.isFunction( options ) ) {
      options = { complete: options };
    }

    options = langx.extend( defaultOptions, options || {} );
    data = normalizeData( data );

    var elementsByName = getFieldsByName( formElm, options.filter );

    langx.each( data, function( name, values ) {
      langx.each( elementsByName[ name ], function( elementIndex, element ) {
        langx.each( values, function( valueIndex, value ) {
          update( element, elementIndex, value, valueIndex, options.change );
        });
      });
    });

    options.complete.call( formElm );

    return this;
  };

  return forms.deserialize = deserialize;
});
define('skylark-domx-forms/serializeArray',[
  "skylark-langx/langx",
  "skylark-domx-data",
  "./forms"
],function(langx,datax,forms){
    function serializeArray(formElm) {
        var name, type, result = [],
            add = function(value) {
                if (value.forEach) return value.forEach(add)
                result.push({ name: name, value: value })
            }
        langx.each(formElm.elements, function(_, field) {
            type = field.type, name = field.name
            if (name && field.nodeName.toLowerCase() != 'fieldset' &&
                !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&
                ((type != 'radio' && type != 'checkbox') || field.checked))
                add(datax.val(field))
        })
        return result
    };

    return forms.serializeArray = serializeArray;
});

define('skylark-domx-forms/serializeObject',[
  "skylark-langx/langx",
  "./forms",
  "./serializeArray"
],function(langx,forms,serializeArray){

  function serializeObject(formElm){
    var obj = {};
    
    langx.each(serializeArray(formElm), function(i,o){
      var n = o.name,
        v = o.value;
        
        obj[n] = obj[n] === undefined ? v
          : langx.isArray( obj[n] ) ? obj[n].concat( v )
          : [ obj[n], v ];
    });
    
    return obj;
  }

  return forms.serializeObject = serializeObject;
});  
define('skylark-domx-forms/serialize',[
  "skylark-langx/langx",
  "./forms",
  "./serializeArray"
],function(langx,forms,serializeArray){
    function serialize(formElm) {
        var result = []
        serializeArray(formElm).forEach(function(elm) {
            result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))
        })
        return result.join('&')
    }

    return forms.serialize = serialize;
});
define('skylark-domx-forms/main',[
	"./forms",
    "skylark-domx-velm",
    "skylark-domx-query",
    "./deserialize",
    "./serializeArray",
    "./serializeObject",
    "./serialize"
],function(forms,velm,$){

    // from ./data
    velm.delegate([
        "deserialize",
        "serializeArray",
        "serializeObject",
        "serialize"
    ], forms);

    $.fn.deserialize = $.wraps.wrapper_value(forms.deserialize, forms, forms.deserialize);
    $.fn.serializeArray = $.wraps.wrapper_value(forms.serializeArray, forms, forms.serializeArray);
    $.fn.serializeObject = $.wraps.wrapper_value(forms.serializeObject, forms, forms.serializeObject);
    $.fn.serialize = $.wraps.wrapper_value(forms.serialize, forms, forms.serialize);


	return forms;
});
define('skylark-domx-forms', ['skylark-domx-forms/main'], function (main) { return main; });

define('skylark-domx-styler/styler',[
    "skylark-langx/skylark",
    "skylark-langx/langx"
], function(skylark, langx) {
    var every = Array.prototype.every,
        forEach = Array.prototype.forEach,
        camelCase = langx.camelCase,
        dasherize = langx.dasherize;

    function maybeAddPx(name, value) {
        return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
    }

    var cssNumber = {
            'column-count': 1,
            'columns': 1,
            'font-weight': 1,
            'line-height': 1,
            'opacity': 1,
            'z-index': 1,
            'zoom': 1
        },
        classReCache = {

        };

    function classRE(name) {
        return name in classReCache ?
            classReCache[name] : (classReCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'));
    }

    // access className property while respecting SVGAnimatedString
    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} node
     * @param {String} value
     */
    function className(node, value) {
        var klass = node.className || '',
            svg = klass && klass.baseVal !== undefined

        if (value === undefined) return svg ? klass.baseVal : klass
        svg ? (klass.baseVal = value) : (node.className = value)
    }

    function disabled(elm, value ) {
        if (arguments.length < 2) {
            return !!this.dom.disabled;
        }

        elm.disabled = value;

        return this;
    }

    var elementDisplay = {};

    function defaultDisplay(nodeName) {
        var element, display
        if (!elementDisplay[nodeName]) {
            element = document.createElement(nodeName)
            document.body.appendChild(element)
            display = getStyles(element).getPropertyValue("display")
            element.parentNode.removeChild(element)
            display == "none" && (display = "block")
            elementDisplay[nodeName] = display
        }
        return elementDisplay[nodeName]
    }
    /*
     * Display the matched elements.
     * @param {HTMLElement} elm
     */
    function show(elm) {
        styler.css(elm, "display", "");
        if (styler.css(elm, "display") == "none") {
            styler.css(elm, "display", defaultDisplay(elm.nodeName));
        }
        return this;
    }

    function isInvisible(elm) {
        return styler.css(elm, "display") == "none" || styler.css(elm, "opacity") == 0;
    }

    /*
     * Hide the matched elements.
     * @param {HTMLElement} elm
     */
    function hide(elm) {
        styler.css(elm, "display", "none");
        return this;
    }

    /*
     * Adds the specified class(es) to each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function addClass(elm, name) {
        if (!name) return this
        var cls = className(elm),
            names;
        if (langx.isString(name)) {
            names = name.split(/\s+/g);
        } else {
            names = name;
        }
        names.forEach(function(klass) {
            var re = classRE(klass);
            if (!cls.match(re)) {
                cls += (cls ? " " : "") + klass;
            }
        });

        className(elm, cls);

        return this;
    }

    function getStyles( elem ) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem);
    }


    /*
     * Get the value of a computed style property for the first element in the set of matched elements or set one or more CSS properties for every matched element.
     * @param {HTMLElement} elm
     * @param {String} property
     * @param {Any} value
     */
    function css(elm, property, value) {
        if (arguments.length < 3) {
            var computedStyle,
                computedStyle = getStyles(elm)
            if (langx.isString(property)) {
                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(dasherize(property))
            } else if (langx.isArrayLike(property)) {
                var props = {}
                forEach.call(property, function(prop) {
                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(dasherize(prop)))
                })
                return props
            }
        }

        var css = '';
        if (typeof(property) == 'string') {
            if (!value && value !== 0) {
                elm.style.removeProperty(dasherize(property));
            } else {
                css = dasherize(property) + ":" + maybeAddPx(property, value)
            }
        } else {
            for (key in property) {
                if (property[key] === undefined) {
                    continue;
                }
                if (!property[key] && property[key] !== 0) {
                    elm.style.removeProperty(dasherize(key));
                } else {
                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
                }
            }
        }

        elm.style.cssText += ';' + css;
        return this;
    }

    /*
     * Determine whether any of the matched elements are assigned the given class.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function hasClass(elm, name) {
        var re = classRE(name);
        return elm.className && elm.className.match(re);
    }

    /*
     * Remove a single class, multiple classes, or all classes from each element in the set of matched elements.
     * @param {HTMLElement} elm
     * @param {String} name
     */
    function removeClass(elm, name) {
        if (name) {
            var cls = className(elm),
                names;

            if (langx.isString(name)) {
                names = name.split(/\s+/g);
            } else {
                names = name;
            }

            names.forEach(function(klass) {
                var re = classRE(klass);
                if (cls.match(re)) {
                    cls = cls.replace(re, " ");
                }
            });

            className(elm, cls.trim());
        } else {
            className(elm, "");
        }

        return this;
    }

    /*
     * Add or remove one or more classes from the specified element.
     * @param {HTMLElement} elm
     * @param {String} name
     * @param {} when
     */
    function toggleClass(elm, name, when) {
        var self = this;
        name.split(/\s+/g).forEach(function(klass) {
            if (when === undefined) {
                when = !self.hasClass(elm, klass);
            }
            if (when) {
                self.addClass(elm, klass);
            } else {
                self.removeClass(elm, klass)
            }
        });

        return self;
    }

    var styler = function() {
        return styler;
    };

    langx.mixin(styler, {
        autocssfix: false,
        cssHooks: {

        },

        addClass: addClass,
        className: className,
        css: css,
        disabled : disabled,        
        hasClass: hasClass,
        hide: hide,
        isInvisible: isInvisible,
        removeClass: removeClass,
        show: show,
        toggleClass: toggleClass
    });

    return skylark.attach("domx.styler", styler);
});
define('skylark-domx-styler/main',[
	"./styler",
	"skylark-domx-velm",
	"skylark-domx-query"	
],function(styler,velm,$){
	
    // from ./styler
    velm.delegate([
        "addClass",
        "className",
        "css",
        "hasClass",
        "hide",
        "isInvisible",
        "removeClass",
        "show",
        "toggleClass"
    ], styler);

    // properties

    var properties = [ 'position', 'left', 'top', 'right', 'bottom', 'width', 'height', 'border', 'borderLeft',
    'borderTop', 'borderRight', 'borderBottom', 'borderColor', 'display', 'overflow', 'margin', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'padding', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'color',
    'background', 'backgroundColor', 'opacity', 'fontSize', 'fontWeight', 'textAlign', 'textDecoration', 'textTransform', 'cursor', 'zIndex' ];

    properties.forEach( function ( property ) {

        var method = property;

        velm.VisualElement.prototype[method ] = function (value) {

            this.css( property, value );

            return this;

        };

    });


    $.fn.style = $.wraps.wrapper_name_value(styler.css, styler);

    $.fn.css = $.wraps.wrapper_name_value(styler.css, styler);

    //hasClass(name)
    $.fn.hasClass = $.wraps.wrapper_some_chk(styler.hasClass, styler);

    //addClass(name)
    $.fn.addClass = $.wraps.wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className);

    //removeClass(name)
    $.fn.removeClass = $.wraps.wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className);

    //toogleClass(name,when)
    $.fn.toggleClass = $.wraps.wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className);

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };

    $.fn.replaceClass = function(newClass, oldClass) {
        this.removeClass(oldClass);
        this.addClass(newClass);
        return this;
    };
        
	return styler;
});
define('skylark-domx-styler', ['skylark-domx-styler/main'], function (main) { return main; });

define('skylark-domx-geom/geom',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-styler"
], function(skylark, langx, noder, styler) {
    var rootNodeRE = /^(?:body|html)$/i,
        px = langx.toPixel,
        offsetParent = noder.offsetParent,
        cachedScrollbarWidth;

    function scrollbarWidth() {
        if (cachedScrollbarWidth !== undefined) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = noder.createFragment("<div style=" +
                "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                "<div style='height:300px;width:auto;'></div></div>")[0],
            innerDiv = div.childNodes[0];

        noder.append(document.body, div);

        w1 = innerDiv.offsetWidth;

        styler.css(div, "overflow", "scroll");

        w2 = innerDiv.offsetWidth;

        if (w1 === w2) {
            w2 = div[0].clientWidth;
        }

        noder.remove(div);

        return (cachedScrollbarWidth = w1 - w2);
    }
    /*
     * Get the widths of each border of the specified element.
     * @param {HTMLElement} elm
     */
    function borderExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }        var s = getComputedStyle(elm);
        return {
            left: px(s.borderLeftWidth, elm),
            top: px(s.borderTopWidth, elm),
            right: px(s.borderRightWidth, elm),
            bottom: px(s.borderBottomWidth, elm)
        }
    }

    //viewport coordinate
    /*
     * Get or set the viewport position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingPosition(elm, coords) {
        if (coords === undefined) {
            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the viewport rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function boundingRect(elm, coords) {
        if (coords === undefined) {
            return elm.getBoundingClientRect()
        } else {
            boundingPosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the height of the specified element client box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function clientHeight(elm, value) {
        if (value == undefined) {
            return clientSize(elm).height;
        } else {
            return clientSize(elm, {
                height: value
            });
        }
    }

    /*
     * Get or set the size of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientSize(elm, dimension) {
        if (dimension == undefined) {
            return {
                width: elm.clientWidth,
                height: elm.clientHeight
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width - pex.left - pex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height - pex.top - pex.bottom;
                }
            } else {
                var bex = borderExtents(elm);

                if (props.width !== undefined) {
                    props.width = props.width + bex.left + bex.right;
                }

                if (props.height !== undefined) {
                    props.height = props.height + bex.top + bex.bottom;
                }

            }
            styler.css(elm, props);
            return this;
        }
        return {
            width: elm.clientWidth,
            height: elm.clientHeight
        };
    }

    /*
     * Get or set the width of the specified element client box.
     * @param {HTMLElement} elm
     * @param {PlainObject} dimension
     */
    function clientWidth(elm, value) {
        if (value == undefined) {
            return clientSize(elm).width;
        } else {
            clientSize(elm, {
                width: value
            });
            return this;
        }
    }

    /*
     * Get the rect of the specified element content box.
     * @param {HTMLElement} elm
     */
    function contentRect(elm) {
        var cs = clientSize(elm),
            pex = paddingExtents(elm);


        //// On Opera, offsetLeft includes the parent's border
        //if(has("opera")){
        //    pe.l += be.l;
        //    pe.t += be.t;
        //}
        return {
            left: pex.left,
            top: pex.top,
            width: cs.width - pex.left - pex.right,
            height: cs.height - pex.top - pex.bottom
        };
    }

    /*
     * Get the document size.
     * @param {HTMLDocument} doc
     */
    function getDocumentSize(doc) {
        var documentElement = doc.documentElement,
            body = doc.body,
            max = Math.max,
            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),
            clientWidth = max(documentElement.clientWidth, body.clientWidth),
            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),
            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),
            clientHeight = max(documentElement.clientHeight, body.clientHeight),
            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);

        return {
            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
        };
    }

    /*
     * Get the document size.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function height(elm, value) {
        if (value == undefined) {
            return size(elm).height;
        } else {
            size(elm, {
                height: value
            });
            return this;
        }
    }

    /*
     * Get the widths of each margin of the specified element.
     * @param {HTMLElement} elm
     */
    function marginExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.marginLeft),
            top: px(s.marginTop),
            right: px(s.marginRight),
            bottom: px(s.marginBottom),
        }
    }


    function marginRect(elm) {
        var obj = relativeRect(elm),
            me = marginExtents(elm);

        return {
            left: obj.left,
            top: obj.top,
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }


    function marginSize(elm) {
        var obj = size(elm),
            me = marginExtents(elm);

        return {
            width: obj.width + me.left + me.right,
            height: obj.height + me.top + me.bottom
        };
    }

    /*
     * Get the widths of each padding of the specified element.
     * @param {HTMLElement} elm
     */
    function paddingExtents(elm) {
        if (noder.isWindow(elm)) {
            return {
                left : 0,
                top : 0,
                right : 0,
                bottom : 0
            }
        }
        var s = getComputedStyle(elm);
        return {
            left: px(s.paddingLeft),
            top: px(s.paddingTop),
            right: px(s.paddingRight),
            bottom: px(s.paddingBottom),
        }
    }

    /*
     * Get or set the document position of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    //coordinate to the document
    function pagePosition(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect()
            return {
                left: obj.left + window.pageXOffset,
                top: obj.top + window.pageYOffset
            }
        } else {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                parentOffset = pagePosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            relativePosition(elm, {
                top: coords.top - parentOffset.top - mex.top - pbex.top,
                left: coords.left - parentOffset.left - mex.left - pbex.left
            });
            return this;
        }
    }

    /*
     * Get or set the document rect of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function pageRect(elm, coords) {
        if (coords === undefined) {
            var obj = elm.getBoundingClientRect()
            return {
                left: obj.left + window.pageXOffset,
                top: obj.top + window.pageYOffset,
                width: Math.round(obj.width),
                height: Math.round(obj.height)
            }
        } else {
            pagePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }

    /*
     * Get or set the position of the specified element border box , relative to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    // coordinate relative to it's parent
    function relativePosition(elm, coords) {
        if (coords == undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingPosition(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left
            }
        } else {
            var props = {
                top: coords.top,
                left: coords.left
            }

            if (styler.css(elm, "position") == "static") {
                props['position'] = "relative";
            }
            styler.css(elm, props);
            return this;
        }
    }

    /*
     * Get or set the rect of the specified element border box , relatived to parent element.
     * @param {HTMLElement} elm
     * @param {PlainObject} coords
     */
    function relativeRect(elm, coords) {
        if (coords === undefined) {
            var // Get *real* offsetParent
                parent = offsetParent(elm),
                // Get correct offsets
                offset = boundingRect(elm),
                parentOffset = boundingPosition(parent),
                mex = marginExtents(elm),
                pbex = borderExtents(parent);

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - pbex.top, // - mex.top,
                left: offset.left - parentOffset.left - pbex.left, // - mex.left,
                width: offset.width,
                height: offset.height
            }
        } else {
            relativePosition(elm, coords);
            size(elm, coords);
            return this;
        }
    }
    /*
     * Scroll the specified element into view.
     * @param {HTMLElement} elm
     * @param {} align
     */
    function scrollIntoView(elm, align) {
        function getOffset(elm, rootElm) {
            var x, y, parent = elm;

            x = y = 0;
            while (parent && parent != rootElm && parent.nodeType) {
                x += parent.offsetLeft || 0;
                y += parent.offsetTop || 0;
                parent = parent.offsetParent;
            }

            return { x: x, y: y };
        }

        var parentElm = elm.parentNode;
        var x, y, width, height, parentWidth, parentHeight;
        var pos = getOffset(elm, parentElm);

        x = pos.x;
        y = pos.y;
        width = elm.offsetWidth;
        height = elm.offsetHeight;
        parentWidth = parentElm.clientWidth;
        parentHeight = parentElm.clientHeight;

        if (align == "end") {
            x -= parentWidth - width;
            y -= parentHeight - height;
        } else if (align == "center") {
            x -= (parentWidth / 2) - (width / 2);
            y -= (parentHeight / 2) - (height / 2);
        }

        parentElm.scrollLeft = x;
        parentElm.scrollTop = y;

        return this;
    }
    /*
     * Get or set the current horizontal position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollLeft(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        }
        var hasScrollLeft = "scrollLeft" in elm;
        if (value === undefined) {
            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset
        } else {
            if (hasScrollLeft) {
                elm.scrollLeft = value;
            } else {
                elm.scrollTo(value, elm.scrollY);
            }
            return this;
        }
    }
    /*
     * Get or the current vertical position of the scroll bar for the specified element.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function scrollTop(elm, value) {
        if (elm.nodeType === 9) {
            elm = elm.defaultView;
        }
        var hasScrollTop = "scrollTop" in elm;

        if (value === undefined) {
            return hasScrollTop ? elm.scrollTop : elm.pageYOffset
        } else {
            if (hasScrollTop) {
                elm.scrollTop = value;
            } else {
                elm.scrollTo(elm.scrollX, value);
            }
            return this;
        }
    }
    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {PlainObject}dimension
     */
    function size(elm, dimension) {
        if (dimension == undefined) {
            if (langx.isWindow(elm)) {
                return {
                    width: elm.innerWidth,
                    height: elm.innerHeight
                }

            } else if (langx.isDocument(elm)) {
                return getDocumentSize(document);
            } else {
                return {
                    width: elm.offsetWidth,
                    height: elm.offsetHeight
                }
            }
        } else {
            var isBorderBox = (styler.css(elm, "box-sizing") === "border-box"),
                props = {
                    width: dimension.width,
                    height: dimension.height
                };
            if (!isBorderBox) {
                var pex = paddingExtents(elm),
                    bex = borderExtents(elm);

                if (props.width !== undefined && props.width !== "" && props.width !== null) {
                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;
                }

                if (props.height !== undefined && props.height !== "" && props.height !== null) {
                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;
                }
            }
            styler.css(elm, props);
            return this;
        }
    }
    /*
     * Get or set the size of the specified element border box.
     * @param {HTMLElement} elm
     * @param {Number} value
     */
    function width(elm, value) {
        if (value == undefined) {
            return size(elm).width;
        } else {
            size(elm, {
                width: value
            });
            return this;
        }
    }

    function geom() {
        return geom;
    }

    langx.mixin(geom, {
        borderExtents: borderExtents,
        //viewport coordinate
        boundingPosition: boundingPosition,

        boundingRect: boundingRect,

        clientHeight: clientHeight,

        clientSize: clientSize,

        clientWidth: clientWidth,

        contentRect: contentRect,

        getDocumentSize: getDocumentSize,

        height: height,

        marginExtents: marginExtents,

        marginRect: marginRect,

        marginSize: marginSize,

        offsetParent: offsetParent,

        paddingExtents: paddingExtents,

        //coordinate to the document
        pagePosition: pagePosition,

        pageRect: pageRect,

        // coordinate relative to it's parent
        relativePosition: relativePosition,

        relativeRect: relativeRect,

        scrollbarWidth: scrollbarWidth,

        scrollIntoView: scrollIntoView,

        scrollLeft: scrollLeft,

        scrollTop: scrollTop,

        size: size,

        width: width
    });

    ( function() {
        var max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/;

        function getOffsets( offsets, width, height ) {
            return [
                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
            ];
        }

        function parseCss( element, property ) {
            return parseInt( styler.css( element, property ), 10 ) || 0;
        }

        function getDimensions( raw ) {
            if ( raw.nodeType === 9 ) {
                return {
                    size: size(raw),
                    offset: { top: 0, left: 0 }
                };
            }
            if ( noder.isWindow( raw ) ) {
                return {
                    size: size(raw),
                    offset: { 
                        top: scrollTop(raw), 
                        left: scrollLeft(raw) 
                    }
                };
            }
            if ( raw.preventDefault ) {
                return {
                    size : {
                        width: 0,
                        height: 0
                    },
                    offset: { 
                        top: raw.pageY, 
                        left: raw.pageX 
                    }
                };
            }
            return {
                size: size(raw),
                offset: pagePosition(raw)
            };
        }

        function getScrollInfo( within ) {
            var overflowX = within.isWindow || within.isDocument ? "" :
                    styler.css(within.element,"overflow-x" ),
                overflowY = within.isWindow || within.isDocument ? "" :
                    styler.css(within.element,"overflow-y" ),
                hasOverflowX = overflowX === "scroll" ||
                    ( overflowX === "auto" && within.width < scrollWidth(within.element) ),
                hasOverflowY = overflowY === "scroll" ||
                    ( overflowY === "auto" && within.height < scrollHeight(within.element));
            return {
                width: hasOverflowY ? scrollbarWidth() : 0,
                height: hasOverflowX ? scrollbarWidth() : 0
            };
        }

        function getWithinInfo( element ) {
            var withinElement = element || window,
                isWindow = noder.isWindow( withinElement),
                isDocument = !!withinElement && withinElement.nodeType === 9,
                hasOffset = !isWindow && !isDocument,
                msize = marginSize(withinElement);
            return {
                element: withinElement,
                isWindow: isWindow,
                isDocument: isDocument,
                offset: hasOffset ? pagePosition(element) : { left: 0, top: 0 },
                scrollLeft: scrollLeft(withinElement),
                scrollTop: scrollTop(withinElement),
                width: msize.width,
                height: msize.height
            };
        }

        function posit(elm,options ) {
            // Make a copy, we don't want to modify arguments
            options = langx.extend( {}, options );

            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = options.of,
                within = getWithinInfo( options.within ),
                scrollInfo = getScrollInfo( within ),
                collision = ( options.collision || "flip" ).split( " " ),
                offsets = {};

            dimensions = getDimensions( target );
            if ( target.preventDefault ) {

                // Force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.size.width;
            targetHeight = dimensions.size.height;
            targetOffset = dimensions.offset;

            // Clone to reuse original targetOffset later
            basePosition = langx.extend( {}, targetOffset );

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            langx.each( [ "my", "at" ], function() {
                var pos = ( options[ this ] || "" ).split( " " ),
                    horizontalOffset,
                    verticalOffset;

                if ( pos.length === 1 ) {
                    pos = rhorizontal.test( pos[ 0 ] ) ?
                        pos.concat( [ "center" ] ) :
                        rvertical.test( pos[ 0 ] ) ?
                            [ "center" ].concat( pos ) :
                            [ "center", "center" ];
                }
                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

                // Calculate offsets
                horizontalOffset = roffset.exec( pos[ 0 ] );
                verticalOffset = roffset.exec( pos[ 1 ] );
                offsets[ this ] = [
                    horizontalOffset ? horizontalOffset[ 0 ] : 0,
                    verticalOffset ? verticalOffset[ 0 ] : 0
                ];

                // Reduce to just the positions without the offsets
                options[ this ] = [
                    rposition.exec( pos[ 0 ] )[ 0 ],
                    rposition.exec( pos[ 1 ] )[ 0 ]
                ];
            } );

            // Normalize collision option
            if ( collision.length === 1 ) {
                collision[ 1 ] = collision[ 0 ];
            }

            if ( options.at[ 0 ] === "right" ) {
                basePosition.left += targetWidth;
            } else if ( options.at[ 0 ] === "center" ) {
                basePosition.left += targetWidth / 2;
            }

            if ( options.at[ 1 ] === "bottom" ) {
                basePosition.top += targetHeight;
            } else if ( options.at[ 1 ] === "center" ) {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
            basePosition.left += atOffset[ 0 ];
            basePosition.top += atOffset[ 1 ];

            return ( function(elem) {
                var collisionPosition, using,
                    msize = marginSize(elem),
                    elemWidth = msize.width,
                    elemHeight = msize.height,
                    marginLeft = parseCss( elem, "marginLeft" ),
                    marginTop = parseCss( elem, "marginTop" ),
                    collisionWidth = elemWidth + marginLeft + parseCss( elem, "marginRight" ) +
                        scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss( elem, "marginBottom" ) +
                        scrollInfo.height,
                    position = langx.extend( {}, basePosition ),
                    myOffset = getOffsets( offsets.my, msize.width, msize.height);

                if ( options.my[ 0 ] === "right" ) {
                    position.left -= elemWidth;
                } else if ( options.my[ 0 ] === "center" ) {
                    position.left -= elemWidth / 2;
                }

                if ( options.my[ 1 ] === "bottom" ) {
                    position.top -= elemHeight;
                } else if ( options.my[ 1 ] === "center" ) {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[ 0 ];
                position.top += myOffset[ 1 ];

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };

                langx.each( [ "left", "top" ], function( i, dir ) {
                    if ( positions[ collision[ i ] ] ) {
                        positions[ collision[ i ] ][ dir ]( position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        } );
                    }
                } );

                if ( options.using ) {

                    // Adds feedback as second argument to using callback, if present
                    using = function( props ) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                            feedback.horizontal = "center";
                        }
                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                            feedback.vertical = "middle";
                        }
                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call( this, props, feedback );
                    };
                }

                pagePosition(elem, langx.extend( position, { using: using } ));
            })(elm);
        }

        var positions = {
            fit: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;

                    // Element is wider than within
                    if ( data.collisionWidth > outerWidth ) {

                        // Element is initially over the left side of within
                        if ( overLeft > 0 && overRight <= 0 ) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
                                withinOffset;
                            position.left += overLeft - newOverRight;

                        // Element is initially over right side of within
                        } else if ( overRight > 0 && overLeft <= 0 ) {
                            position.left = withinOffset;

                        // Element is initially over both left and right sides of within
                        } else {
                            if ( overLeft > overRight ) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }

                    // Too far left -> align with left edge
                    } else if ( overLeft > 0 ) {
                        position.left += overLeft;

                    // Too far right -> align with right edge
                    } else if ( overRight > 0 ) {
                        position.left -= overRight;

                    // Adjust based on position and margin
                    } else {
                        position.left = max( position.left - collisionPosLeft, position.left );
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;

                    // Element is taller than within
                    if ( data.collisionHeight > outerHeight ) {

                        // Element is initially over the top of within
                        if ( overTop > 0 && overBottom <= 0 ) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
                                withinOffset;
                            position.top += overTop - newOverBottom;

                        // Element is initially over bottom of within
                        } else if ( overBottom > 0 && overTop <= 0 ) {
                            position.top = withinOffset;

                        // Element is initially over both top and bottom of within
                        } else {
                            if ( overTop > overBottom ) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }

                    // Too far up -> align with top
                    } else if ( overTop > 0 ) {
                        position.top += overTop;

                    // Too far down -> align with bottom edge
                    } else if ( overBottom > 0 ) {
                        position.top -= overBottom;

                    // Adjust based on position and margin
                    } else {
                        position.top = max( position.top - collisionPosTop, position.top );
                    }
                }
            },
            flip: {
                left: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[ 0 ] === "left" ?
                            -data.elemWidth :
                            data.my[ 0 ] === "right" ?
                                data.elemWidth :
                                0,
                        atOffset = data.at[ 0 ] === "left" ?
                            data.targetWidth :
                            data.at[ 0 ] === "right" ?
                                -data.targetWidth :
                                0,
                        offset = -2 * data.offset[ 0 ],
                        newOverRight,
                        newOverLeft;

                    if ( overLeft < 0 ) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
                            outerWidth - withinOffset;
                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if ( overRight > 0 ) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
                            atOffset + offset - offsetLeft;
                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function( position, data ) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[ 1 ] === "top",
                        myOffset = top ?
                            -data.elemHeight :
                            data.my[ 1 ] === "bottom" ?
                                data.elemHeight :
                                0,
                        atOffset = data.at[ 1 ] === "top" ?
                            data.targetHeight :
                            data.at[ 1 ] === "bottom" ?
                                -data.targetHeight :
                                0,
                        offset = -2 * data.offset[ 1 ],
                        newOverTop,
                        newOverBottom;
                    if ( overTop < 0 ) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
                            outerHeight - withinOffset;
                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if ( overBottom > 0 ) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
                            offset - offsetTop;
                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    positions.flip.left.apply( this, arguments );
                    positions.fit.left.apply( this, arguments );
                },
                top: function() {
                    positions.flip.top.apply( this, arguments );
                    positions.fit.top.apply( this, arguments );
                }
            }
        };

        geom.posit = posit;
    })();

    return skylark.attach("domx.geom", geom);
});
define('skylark-domx-geom/main',[
    "skylark-langx/langx",
    "./geom",
    "skylark-domx-velm",
    "skylark-domx-query"        
],function(langx,geom,velm,$){
   // from ./geom
    velm.delegate([
        "borderExtents",
        "boundingPosition",
        "boundingRect",
        "clientHeight",
        "clientSize",
        "clientWidth",
        "contentRect",
        "height",
        "marginExtents",
        "offsetParent",
        "paddingExtents",
        "pagePosition",
        "pageRect",
        "relativePosition",
        "relativeRect",
        "scrollIntoView",
        "scrollLeft",
        "scrollTop",
        "size",
        "width"
    ], geom);

    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);

    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);

    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);

    $.fn.position =  function(options) {
        if (!this.length) {
            return this;
        }

        if (options) {
            if (options.of && options.of.length) {
                options = langx.clone(options);
                options.of = options.of[0];
            }
            return this.each( function() {
                geom.posit(this,options);
            });
        } else {
            var elem = this[0];

            return geom.relativePosition(elem);

        }             
    };

    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);


    $.fn.size = $.wraps.wrapper_value(geom.size, geom);

    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);

    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);

    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom.clientSize);
    
    ['width', 'height'].forEach(function(dimension) {
        var offset, Dimension = dimension.replace(/./, function(m) {
            return m[0].toUpperCase()
        });

        $.fn['outer' + Dimension] = function(margin, value) {
            if (arguments.length) {
                if (typeof margin !== 'boolean') {
                    value = margin;
                    margin = false;
                }
            } else {
                margin = false;
                value = undefined;
            }

            if (value === undefined) {
                var el = this[0];
                if (!el) {
                    return undefined;
                }
                var cb = geom.size(el);
                if (margin) {
                    var me = geom.marginExtents(el);
                    cb.width = cb.width + me.left + me.right;
                    cb.height = cb.height + me.top + me.bottom;
                }
                return dimension === "width" ? cb.width : cb.height;
            } else {
                return this.each(function(idx, el) {
                    var mb = {};
                    var me = geom.marginExtents(el);
                    if (dimension === "width") {
                        mb.width = value;
                        if (margin) {
                            mb.width = mb.width - me.left - me.right
                        }
                    } else {
                        mb.height = value;
                        if (margin) {
                            mb.height = mb.height - me.top - me.bottom;
                        }
                    }
                    geom.size(el, mb);
                })

            }
        };
    })

    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);

    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);

    return geom;
});
define('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });

define('skylark-domx-fx/fx',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-browser",
    "skylark-domx-noder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-eventer"
], function(skylark, langx, browser, noder, geom, styler, eventer) {
    var animationName,
        animationDuration,
        animationTiming,
        animationDelay,
        transitionProperty,
        transitionDuration,
        transitionTiming,
        transitionDelay,

        animationEnd = browser.normalizeCssEvent('AnimationEnd'),
        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),

        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
        transform = browser.css3PropPrefix + "transform",
        cssReset = {};


    cssReset[animationName = browser.normalizeCssProperty("animation-name")] =
        cssReset[animationDuration = browser.normalizeCssProperty("animation-duration")] =
        cssReset[animationDelay = browser.normalizeCssProperty("animation-delay")] =
        cssReset[animationTiming = browser.normalizeCssProperty("animation-timing-function")] = "";

    cssReset[transitionProperty = browser.normalizeCssProperty("transition-property")] =
        cssReset[transitionDuration = browser.normalizeCssProperty("transition-duration")] =
        cssReset[transitionDelay = browser.normalizeCssProperty("transition-delay")] =
        cssReset[transitionTiming = browser.normalizeCssProperty("transition-timing-function")] = "";



    /*   
     * Perform a custom animation of a set of CSS properties.
     * @param {Object} elm  
     * @param {Number or String} properties
     * @param {String} ease
     * @param {Number or String} duration
     * @param {Function} callback
     * @param {Number or String} delay
     */
    function animate(elm, properties, duration, ease, callback, delay) {
        var key,
            cssValues = {},
            cssProperties = [],
            transforms = "",
            that = this,
            endEvent,
            wrappedCallback,
            fired = false,
            hasScrollTop = false,
            resetClipAuto = false;

        if (langx.isPlainObject(duration)) {
            ease = duration.easing;
            callback = duration.complete;
            delay = duration.delay;
            duration = duration.duration;
        }

        if (langx.isString(duration)) {
            duration = fx.speeds[duration];
        }
        if (duration === undefined) {
            duration = fx.speeds.normal;
        }
        duration = duration / 1000;
        if (fx.off) {
            duration = 0;
        }

        if (langx.isFunction(ease)) {
            callback = ease;
            eace = "swing";
        } else {
            ease = ease || "swing";
        }

        if (delay) {
            delay = delay / 1000;
        } else {
            delay = 0;
        }

        if (langx.isString(properties)) {
            // keyframe animation
            cssValues[animationName] = properties;
            cssValues[animationDuration] = duration + "s";
            cssValues[animationTiming] = ease;
            endEvent = animationEnd;
        } else {
            // CSS transitions
            for (key in properties) {
                var v = properties[key];
                if (supportedTransforms.test(key)) {
                    transforms += key + "(" + v + ") ";
                } else {
                    if (key === "scrollTop") {
                        hasScrollTop = true;
                    }
                    if (key == "clip" && langx.isPlainObject(v)) {
                        cssValues[key] = "rect(" + v.top+"px,"+ v.right +"px,"+ v.bottom +"px,"+ v.left+"px)";
                        if (styler.css(elm,"clip") == "auto") {
                            var size = geom.size(elm);
                            styler.css(elm,"clip","rect("+"0px,"+ size.width +"px,"+ size.height +"px,"+"0px)");  
                            resetClipAuto = true;
                        }

                    } else {
                        cssValues[key] = v;
                    }
                    cssProperties.push(langx.dasherize(key));
                }
            }
            endEvent = transitionEnd;
        }

        if (transforms) {
            cssValues[transform] = transforms;
            cssProperties.push(transform);
        }

        if (duration > 0 && langx.isPlainObject(properties)) {
            cssValues[transitionProperty] = cssProperties.join(", ");
            cssValues[transitionDuration] = duration + "s";
            cssValues[transitionDelay] = delay + "s";
            cssValues[transitionTiming] = ease;
        }

        wrappedCallback = function(event) {
            fired = true;
            if (event) {
                if (event.target !== event.currentTarget) {
                    return // makes sure the event didn't bubble from "below"
                }
                eventer.off(event.target, endEvent, wrappedCallback)
            } else {
                eventer.off(elm, animationEnd, wrappedCallback) // triggered by setTimeout
            }
            styler.css(elm, cssReset);
            if (resetClipAuto) {
 //               styler.css(elm,"clip","auto");
            }
            callback && callback.call(this);
        };

        if (duration > 0) {
            eventer.on(elm, endEvent, wrappedCallback);
            // transitionEnd is not always firing on older Android phones
            // so make sure it gets fired
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, ((duration + delay) * 1000) + 25)();
        }

        // trigger page reflow so new elements can animate
        elm.clientLeft;

        styler.css(elm, cssValues);

        if (duration <= 0) {
            langx.debounce(function() {
                if (fired) {
                    return;
                }
                wrappedCallback.call(that);
            }, 0)();
        }

        if (hasScrollTop) {
            scrollToTop(elm, properties["scrollTop"], duration, callback);
        }

        return this;
    }

    /*   
     * Display an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function show(elm, speed, callback) {
        styler.show(elm);
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            styler.css(elm, "opacity", 0)
            animate(elm, { opacity: 1, scale: "1,1" }, speed, callback);
        }
        return this;
    }


    /*   
     * Hide an element.
     * @param {Object} elm  
     * @param {String} speed
     * @param {Function} callback
     */
    function hide(elm, speed, callback) {
        if (speed) {
            if (!callback && langx.isFunction(speed)) {
                callback = speed;
                speed = "normal";
            }
            animate(elm, { opacity: 0, scale: "0,0" }, speed, function() {
                styler.hide(elm);
                if (callback) {
                    callback.call(elm);
                }
            });
        } else {
            styler.hide(elm);
        }
        return this;
    }

    /*   
     * Set the vertical position of the scroll bar for an element.
     * @param {Object} elm  
     * @param {Number or String} pos
     * @param {Number or String} speed
     * @param {Function} callback
     */
    function scrollToTop(elm, pos, speed, callback) {
        var scrollFrom = parseInt(elm.scrollTop),
            i = 0,
            runEvery = 5, // run every 5ms
            freq = speed * 1000 / runEvery,
            scrollTo = parseInt(pos);

        var interval = setInterval(function() {
            i++;

            if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;

            if (i >= freq + 1) {
                clearInterval(interval);
                if (callback) langx.debounce(callback, 1000)();
            }
        }, runEvery);
    }

    /*   
     * Display or hide an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Function} callback
     */
    function toggle(elm, speed, callback) {
        if (styler.isInvisible(elm)) {
            show(elm, speed, callback);
        } else {
            hide(elm, speed, callback);
        }
        return this;
    }

    /*   
     * Adjust the opacity of an element.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {Number or String} opacity
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeTo(elm, speed, opacity, easing, callback) {
        animate(elm, { opacity: opacity }, speed, easing, callback);
        return this;
    }


    /*   
     * Display an element by fading them to opaque.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeIn(elm, speed, easing, callback) {
        var target = styler.css(elm, "opacity");
        if (target > 0) {
            styler.css(elm, "opacity", 0);
        } else {
            target = 1;
        }
        styler.show(elm);

        fadeTo(elm, speed, target, easing, callback);

        return this;
    }

    /*   
     * Hide an element by fading them to transparent.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} easing
     * @param {Function} callback
     */
    function fadeOut(elm, speed, easing, callback) {
        var _elm = elm,
            complete,
            opacity = styler.css(elm,"opacity"),
            options = {};

        if (langx.isPlainObject(speed)) {
            options.easing = speed.easing;
            options.duration = speed.duration;
            complete = speed.complete;
        } else {
            options.duration = speed;
            if (callback) {
                complete = callback;
                options.easing = easing;
            } else {
                complete = easing;
            }
        }
        options.complete = function() {
            styler.css(elm,"opacity",opacity);
            styler.hide(elm);
            if (complete) {
                complete.call(elm);
            }
        }

        fadeTo(elm, options, 0);

        return this;
    }

    /*   
     * Display or hide an element by animating its opacity.
     * @param {Object} elm  
     * @param {Number or String} speed
     * @param {String} ceasing
     * @param {Function} callback
     */
    function fadeToggle(elm, speed, ceasing, allback) {
        if (styler.isInvisible(elm)) {
            fadeIn(elm, speed, easing, callback);
        } else {
            fadeOut(elm, speed, easing, callback);
        }
        return this;
    }

    /*   
     * Display an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideDown(elm, duration, callback) {

        // get the element position to restore it then
        var position = styler.css(elm, 'position');

        // show element if it is hidden
        show(elm);

        // place it so it displays as usually but hidden
        styler.css(elm, {
            position: 'absolute',
            visibility: 'hidden'
        });

        // get naturally height, margin, padding
        var marginTop = styler.css(elm, 'margin-top');
        var marginBottom = styler.css(elm, 'margin-bottom');
        var paddingTop = styler.css(elm, 'padding-top');
        var paddingBottom = styler.css(elm, 'padding-bottom');
        var height = styler.css(elm, 'height');

        // set initial css for animation
        styler.css(elm, {
            position: position,
            visibility: 'visible',
            overflow: 'hidden',
            height: 0,
            marginTop: 0,
            marginBottom: 0,
            paddingTop: 0,
            paddingBottom: 0
        });

        // animate to gotten height, margin and padding
        animate(elm, {
            height: height,
            marginTop: marginTop,
            marginBottom: marginBottom,
            paddingTop: paddingTop,
            paddingBottom: paddingBottom
        }, {
            duration: duration,
            complete: function() {
                if (callback) {
                    callback.apply(elm);
                }
            }
        });

        return this;
    }

    /*   
     * Hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideUp(elm, duration, callback) {
        // active the function only if the element is visible
        if (geom.height(elm) > 0) {

            // get the element position to restore it then
            var position = styler.css(elm, 'position');

            // get the element height, margin and padding to restore them then
            var height = styler.css(elm, 'height');
            var marginTop = styler.css(elm, 'margin-top');
            var marginBottom = styler.css(elm, 'margin-bottom');
            var paddingTop = styler.css(elm, 'padding-top');
            var paddingBottom = styler.css(elm, 'padding-bottom');

            // set initial css for animation
            styler.css(elm, {
                visibility: 'visible',
                overflow: 'hidden',
                height: height,
                marginTop: marginTop,
                marginBottom: marginBottom,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom
            });

            // animate element height, margin and padding to zero
            animate(elm, {
                height: 0,
                marginTop: 0,
                marginBottom: 0,
                paddingTop: 0,
                paddingBottom: 0
            }, {
                // callback : restore the element position, height, margin and padding to original values
                duration: duration,
                queue: false,
                complete: function() {
                    hide(elm);
                    styler.css(elm, {
                        visibility: 'visible',
                        overflow: 'hidden',
                        height: height,
                        marginTop: marginTop,
                        marginBottom: marginBottom,
                        paddingTop: paddingTop,
                        paddingBottom: paddingBottom
                    });
                    if (callback) {
                        callback.apply(elm);
                    }
                }
            });
        }
        return this;
    }


    /*   
     * Display or hide an element with a sliding motion.
     * @param {Object} elm  
     * @param {Number or String} duration
     * @param {Function} callback
     */
    function slideToggle(elm, duration, callback) {

        // if the element is hidden, slideDown !
        if (geom.height(elm) == 0) {
            slideDown(elm, duration, callback);
        }
        // if the element is visible, slideUp !
        else {
            slideUp(elm, duration, callback);
        }
        return this;
    }

    function emulateTransitionEnd(elm,duration) {
        var called = false;
        eventer.one(elm,'transitionEnd', function () { 
            called = true;
        })
        var callback = function () { 
            if (!called) {
                eventer.trigger(elm,browser.support.transition.end) 
            }
        };
        setTimeout(callback, duration);
        
        return this;
    } 

    /*   
     *
     * @param {Node} elm
     * @param {Node} params
     */
    function overlay(elm, params) {
        var overlayDiv = noder.createElement("div", params);
        styler.css(overlayDiv, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 0x7FFFFFFF,
            opacity: 0.7
        });
        elm.appendChild(overlayDiv);
        return overlayDiv;

    }
    
    /*   
     * Replace an old node with the specified node.
     * @param {HTMLElement} elm
     * @param {Node} params
     */
    function throb(elm, params) {
        params = params || {};
        var self = this,
            text = params.text,
            style = params.style,
            time = params.time,
            callback = params.callback,
            timer,

            throbber = noder.createElement("div", {
                "class": params.className || "throbber"
            }),
            _overlay = overlay(throbber, {
                "class": 'overlay fade'
            }),
            throb = noder.createElement("div", {
                "class": "throb"
            }),
            textNode = noder.createTextNode(text || ""),
            remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    noder.remove(throbber);
                    throbber = null;
                }
            },
            update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };
        if (params.style) {
            styler.css(throbber,params.style);
        }
        throb.appendChild(textNode);
        throbber.appendChild(throb);
        elm.appendChild(throbber);
        var end = function() {
            remove();
            if (callback) callback();
        };
        if (time) {
            timer = setTimeout(end, time);
        }

        return {
            remove: remove,
            update: update
        };
    }

    function fx() {
        return fx;
    }

    langx.mixin(fx, {
        off: false,

        speeds: {
            normal: 400,
            fast: 200,
            slow: 600
        },

        animate,
        emulateTransitionEnd,
        fadeIn,
        fadeOut,
        fadeTo,
        fadeToggle,
        hide,
        scrollToTop,

        slideDown,
        slideToggle,
        slideUp,
        show,
        throb,
        toggle
    });

    return skylark.attach("domx.fx", fx);
});
define('skylark-domx-fx/main',[
	"./fx",
	"skylark-domx-velm",
	"skylark-domx-query"	
],function(fx,velm,$){
    // from ./fx
    velm.delegate([
        "animate",
        "emulateTransitionEnd",
        "fadeIn",
        "fadeOut",
        "fadeTo",
        "fadeToggle",
        "hide",
        "scrollToTop",
        "slideDown",
        "slideToggle",
        "slideUp",
        "show",
        "toggle"
    ], fx);

    $.fn.hide =  $.wraps.wrapper_every_act(fx.hide, fx);

    $.fn.animate = $.wraps.wrapper_every_act(fx.animate, fx);
    $.fn.emulateTransitionEnd = $.wraps.wrapper_every_act(fx.emulateTransitionEnd, fx);

    $.fn.show = $.wraps.wrapper_every_act(fx.show, fx);
    $.fn.hide = $.wraps.wrapper_every_act(fx.hide, fx);
    $.fn.toogle = $.wraps.wrapper_every_act(fx.toogle, fx);
    $.fn.fadeTo = $.wraps.wrapper_every_act(fx.fadeTo, fx);
    $.fn.fadeIn = $.wraps.wrapper_every_act(fx.fadeIn, fx);
    $.fn.fadeOut = $.wraps.wrapper_every_act(fx.fadeOut, fx);
    $.fn.fadeToggle = $.wraps.wrapper_every_act(fx.fadeToggle, fx);

    $.fn.slideDown = $.wraps.wrapper_every_act(fx.slideDown, fx);
    $.fn.slideToggle = $.wraps.wrapper_every_act(fx.slideToggle, fx);
    $.fn.slideUp = $.wraps.wrapper_every_act(fx.slideUp, fx);

	return fx;
});
define('skylark-domx-fx', ['skylark-domx-fx/main'], function (main) { return main; });

define('skylark-domx-scripter/scripter',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-finder"
], function(skylark, langx, noder, finder) {

    var head = document.getElementsByTagName('head')[0],
        scriptsByUrl = {},
        scriptElementsById = {},
        count = 0;

    var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );

    function scripter() {
        return scripter;
    }


    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function evaluate(code,node, doc ) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if ( node ) {
            for ( i in preservedScriptAttributes ) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[ i ] || node.getAttribute && node.getAttribute( i );
                if ( val ) {
                    script.setAttribute( i, val );
                }
            }
        }
        doc.head.appendChild( script ).parentNode.removeChild( script );

        return this;
    }

    langx.mixin(scripter, {
        /*
         * Load a script from a url into the document.
         * @param {} url
         * @param {} loadedCallback
         * @param {} errorCallback
         */
        loadJavaScript: function(url, loadedCallback, errorCallback) {
            var script = scriptsByUrl[url];
            if (!script) {
                script = scriptsByUrl[url] = {
                    state: 0, //0:unload,1:loaded,-1:loaderror
                    loadedCallbacks: [],
                    errorCallbacks: []
                }
            }

            script.loadedCallbacks.push(loadedCallback);
            script.errorCallbacks.push(errorCallback);

            if (script.state === 1) {
                script.node.onload();
            } else if (script.state === -1) {
                script.node.onerror();
            } else {
                var node = script.node = document.createElement("script"),
                    id = script.id = (count++);

                node.type = "text/javascript";
                node.async = false;
                node.defer = false;
                startTime = new Date().getTime();
                head.appendChild(node);

                node.onload = function() {
                        script.state = 1;

                        var callbacks = script.loadedCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    },
                    node.onerror = function() {
                        script.state = -1;
                        var callbacks = script.errorCallbacks,
                            i = callbacks.length;

                        while (i--) {
                            callbacks[i]();
                        }
                        script.loadedCallbacks = [];
                        script.errorCallbacks = [];
                    };
                node.src = url;

                scriptElementsById[id] = node;
            }
            return script.id;
        },
        /*
         * Remove the specified script from the document.
         * @param {Number} id
         */
        deleteJavaScript: function(id) {
            var node = scriptElementsById[id];
            if (node) {
                var url = node.src;
                noder.remove(node);
                delete scriptElementsById[id];
                delete scriptsByUrl[url];
            }
        },

        evaluate : evaluate,

        html : function(node,value) {

            var result = noder.html(node,value);

            if (value !== undefined) {
                var scripts = node.querySelectorAll('script');

                for (var i =0; i<scripts.length; i++) {
                    var node1 = scripts[i];
                    if (rscriptType.test( node1.type || "" ) ) {
                      evaluate(node1.textContent,node1);
                    }
                }       
                return this;         
            } else {
                return result;
            }



        }
    });

    return skylark.attach("domx.scripter", scripter);
});
define('skylark-domx-scripter/main',[
	"./scripter",
	"skylark-domx-query"
],function(scripter,$){

    $.fn.html = $.wraps.wrapper_value(scripter.html, scripter, scripter.html);

	return scripter;
});
define('skylark-domx-scripter', ['skylark-domx-scripter/main'], function (main) { return main; });

define('skylark-jquery/core',[
	"skylark-langx/skylark",
	"skylark-langx/langx",
	"skylark-domx-browser",
	"skylark-domx-noder",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-finder",
	"skylark-domx-forms",
	"skylark-domx-fx",
	"skylark-domx-styler",
	"skylark-domx-query",
	"skylark-domx-scripter"
],function(skylark,langx,browser,noder,datax,eventer,finder,forms,fx,styler,query,scripter){
	var filter = Array.prototype.filter,
		slice = Array.prototype.slice;

    (function($){
	    $.fn.jquery = '2.2.0';

	    $.browser = browser;
	    
	    $.camelCase = langx.camelCase;

		$.cleanData = function( elems ) {
			var elem,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				datax.cleanData(elem);
			}
		};

		$.removeData = function(elm,name) {
			datax.removeData(elm,name);
		}
	
	    $.each = langx.each;

	    $.extend = langx.extend;

	    $.grep = function(elements, callback) {
	        return filter.call(elements, callback)
	    };

	    $.attr = function(elm,name) {
	    	return datax.attr(elm,name);
	    };

	    $.isArray = langx.isArray;
	    $.isEmptyObject = langx.isEmptyObject;
	    $.isFunction = langx.isFunction;
	    $.isWindow = langx.isWindow;
	    $.isPlainObject = langx.isPlainObject;
        $.isNumeric = langx.isNumber;

	    $.inArray = langx.inArray;

	    $.makeArray = langx.makeArray;
	    $.map = langx.map;  // The behavior is somewhat different from the original jquery.

	    $.noop = function() {
	    };

	    $.parseJSON = window.JSON.parse;

	    $.proxy = langx.proxy;

	    $.trim = langx.trim;
	    $.type = langx.type;

	    $.fn.extend = function(props) {
	        langx.mixin($.fn, props);
	    };


    })(query);

    (function($){
        $.Event = function Event(src, props) {
            if (langx.isString(src)) {
            	var type = src;
            	return eventer.create(type, props);
	        }
            return eventer.proxy(src, props);
        };

        $.event = {};

	    $.event.special = eventer.special;

	    $.fn.submit = function(callback) {
	        if (0 in arguments) this.bind('submit', callback)
	        else if (this.length) {
	            var event = $.Event('submit')
	            this.eq(0).trigger(event)
	            if (!event.isDefaultPrevented()) this.get(0).submit()
	        }
	        return this
	    };

	    // event
	    $.fn.triggerHandler = $.fn.trigger;

	    $.fn.delegate = function(selector, event, callback) {
	        return this.on(event, selector, callback)
	    };

	    $.fn.undelegate = function(selector, event, callback) {
	        return this.off(event, selector, callback)
	    };

	    $.fn.live = function(event, callback) {
	        $(document.body).delegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.die = function(event, callback) {
	        $(document.body).undelegate(this.selector, event, callback)
	        return this
	    };

	    $.fn.bind = function(event, selector, data, callback) {
	        return this.on(event, selector, data, callback)
	    };

	    $.fn.unbind = function(event, callback) {
	        return this.off(event, callback)
	    };

	    $.fn.ready = function(callback) {
	        eventer.ready(callback);
	        return this;
	    };

	    $.fn.stop = function() {
	        // todo
	        return this;
	    };

	    $.fn.moveto = function(x, y) {
	        return this.animate({
	            left: x + "px",
	            top: y + "px"
	        }, 0.4);

	    };

	    $.ready = eventer.ready;

	    $.on = eventer.on;

	    $.off = eventer.off;
    })(query);

    (function($){
	    // plugin compatibility
	    $.uuid = 0;
	    $.support = browser.support;
	    $.expr = {};

	    $.expr[":"] = $.expr.pseudos = $.expr.filters = finder.pseudos;

	    $.expr.createPseudo = function(fn) {
	    	return fn;
	    };

	    $.cssHooks = styler.cssHooks;

	    $.contains = noder.contains;

	    $.css = styler.css;

	    $.data = datax.data;

	    $.fx = fx;
	    $.fx.step = {

        };

        $.speed = function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? $.extend( {}, speed ) : {
                complete: fn || !fn && easing ||
                    $.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !$.isFunction( easing ) && easing
            };

            // Go to the end state if fx are off
            if ( $.fx.off ) {
                opt.duration = 0;

            } else {
                if ( typeof opt.duration !== "number" ) {
                    if ( opt.duration in $.fx.speeds ) {
                        opt.duration = $.fx.speeds[ opt.duration ];

                    } else {
                        opt.duration = $.fx.speeds._default;
                    }
                }
            }

            // Normalize opt.queue - true/undefined/null -> "fx"
            if ( opt.queue == null || opt.queue === true ) {
                opt.queue = "fx";
            }

            // Queueing
            opt.old = opt.complete;

            opt.complete = function() {
                if ( $.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue ) {
                    $.dequeue( this, opt.queue );
                }
            };

            return opt;
        };

        $.easing = {};

	    $.offset = {};
	    $.offset.setOffset = function(elem, options, i) {
	        var position = $.css(elem, "position");

	        // set position first, in-case top/left are set even on static elem
	        if (position === "static") {
	            elem.style.position = "relative";
	        }

	        var curElem = $(elem),
	            curOffset = curElem.offset(),
	            curCSSTop = $.css(elem, "top"),
	            curCSSLeft = $.css(elem, "left"),
	            calculatePosition = (position === "absolute" || position === "fixed") && $.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
	            props = {},
	            curPosition = {},
	            curTop, curLeft;

	        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
	        if (calculatePosition) {
	            curPosition = curElem.position();
	            curTop = curPosition.top;
	            curLeft = curPosition.left;
	        } else {
	            curTop = parseFloat(curCSSTop) || 0;
	            curLeft = parseFloat(curCSSLeft) || 0;
	        }

	        if ($.isFunction(options)) {
	            options = options.call(elem, i, curOffset);
	        }

	        if (options.top != null) {
	            props.top = (options.top - curOffset.top) + curTop;
	        }
	        if (options.left != null) {
	            props.left = (options.left - curOffset.left) + curLeft;
	        }

	        if ("using" in options) {
	            options.using.call(elem, props);
	        } else {
	            curElem.css(props);
	        }
	    };

        $._data = function(elm,propName) {
            if (elm.hasAttribute) {
                return datax.data(elm,propName);
            } else {
                return {};
            }
        };

     	var t = $.fn.text;  
	    $.fn.text = function(v) {
	        var r = t.apply(this,arguments);
	        if (r === undefined) {
	            r = "";
	        }  
	        return r;
	    };       

	    $.fn.pos = $.fn.position;
        	    
    })(query);

    query.parseHTML = function(html) {
        return  noder.createFragment(html);
    };

    query.uniqueSort = query.unique = langx.uniq;

    query.skylark = skylark;

    return window.jQuery = window.$ = query;
});

define('skylark-net-http/http',[
  "skylark-langx-ns/ns",
],function(skylark){
	return skylark.attach("net.http",{});
});
define('skylark-net-http/Xhr',[
  "skylark-langx-ns/ns",
  "skylark-langx-types",
  "skylark-langx-objects",
  "skylark-langx-arrays",
  "skylark-langx-funcs",
  "skylark-langx-async/Deferred",
  "skylark-langx-emitter/Evented",
  "./http"
],function(skylark,types,objects,arrays,funcs,Deferred,Evented,http){

    var each = objects.each,
        mixin = objects.mixin,
        noop = funcs.noop,
        isArray = types.isArray,
        isFunction = types.isFunction,
        isPlainObject = types.isPlainObject,
        type = types.type;
 
     var getAbsoluteUrl = (function() {
        var a;

        return function(url) {
            if (!a) a = document.createElement('a');
            a.href = url;

            return a.href;
        };
    })();
   
    var Xhr = (function(){
        var jsonpID = 0,
            key,
            name,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            scriptTypeRE = /^(?:text|application)\/javascript/i,
            xmlTypeRE = /^(?:text|application)\/xml/i,
            jsonType = 'application/json',
            htmlType = 'text/html',
            blankRE = /^\s*$/;

        var XhrDefaultOptions = {
            async: true,

            // Default type of request
            type: 'GET',
            // Callback that is executed before request
            beforeSend: noop,
            // Callback that is executed if the request succeeds
            success: noop,
            // Callback that is executed the the server drops error
            error: noop,
            // Callback that is executed on request complete (both: error and success)
            complete: noop,
            // The context for the callbacks
            context: null,
            // Whether to trigger "global" Ajax events
            global: true,

            // MIME types mapping
            // IIS returns Javascript as "application/x-javascript"
            accepts: {
                script: 'text/javascript, application/javascript, application/x-javascript',
                json: 'application/json',
                xml: 'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain'
            },
            // Whether the request is to another domain
            crossDomain: false,
            // Default timeout
            timeout: 0,
            // Whether data should be serialized to string
            processData: false,
            // Whether the browser should be allowed to cache GET responses
            cache: true,

            traditional : false,
            
            xhrFields : {
                withCredentials : false
            }
        };

        function mimeToDataType(mime) {
            if (mime) {
                mime = mime.split(';', 2)[0];
            }
            if (mime) {
                if (mime == htmlType) {
                    return "html";
                } else if (mime == jsonType) {
                    return "json";
                } else if (scriptTypeRE.test(mime)) {
                    return "script";
                } else if (xmlTypeRE.test(mime)) {
                    return "xml";
                }
            }
            return "text";
        }

        function appendQuery(url, query) {
            if (query == '') return url
            return (url + '&' + query).replace(/[&?]{1,2}/, '?')
        }

        // serialize payload and append it to the URL for GET requests
        function serializeData(options) {
            options.data = options.data || options.query;
            if (options.processData && options.data && type(options.data) != "string") {
                options.data = param(options.data, options.traditional);
            }
            if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) {
                options.url = appendQuery(options.url, options.data);
                options.data = undefined;
            }
        }

        function serialize(params, obj, traditional, scope) {
            var t, array = isArray(obj),
                hash = isPlainObject(obj)
            each(obj, function(key, value) {
                t =type(value);
                if (scope) key = traditional ? scope :
                    scope + '[' + (hash || t == 'object' || t == 'array' ? key : '') + ']'
                // handle data in serializeArray() format
                if (!scope && array) params.add(value.name, value.value)
                // recurse into nested objects
                else if (t == "array" || (!traditional && t == "object"))
                    serialize(params, value, traditional, key)
                else params.add(key, value)
            })
        }

        var param = function(obj, traditional) {
            var params = []
            params.add = function(key, value) {
                if (isFunction(value)) {
                  value = value();
                }
                if (value == null) {
                  value = "";
                }
                this.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
            serialize(params, obj, traditional)
            return params.join('&').replace(/%20/g, '+')
        };

        var Xhr = Evented.inherit({
            klassName : "Xhr",

            _request  : function(args) {
                var _ = this._,
                    self = this,
                    options = mixin({},XhrDefaultOptions,_.options,args),
                    xhr = _.xhr = new XMLHttpRequest();

                serializeData(options)

                if (options.beforeSend) {
                    options.beforeSend.call(this, xhr, options);
                }                

                var dataType = options.dataType || options.handleAs,
                    mime = options.mimeType || options.accepts[dataType],
                    headers = options.headers,
                    xhrFields = options.xhrFields,
                    isFormData = options.data && options.data instanceof FormData,
                    basicAuthorizationToken = options.basicAuthorizationToken,
                    type = options.type,
                    url = options.url,
                    async = options.async,
                    user = options.user , 
                    password = options.password,
                    deferred = new Deferred(),
                    contentType = options.contentType || (isFormData ? false : 'application/x-www-form-urlencoded');

                if (xhrFields) {
                    for (name in xhrFields) {
                        xhr[name] = xhrFields[name];
                    }
                }

                if (mime && mime.indexOf(',') > -1) {
                    mime = mime.split(',', 2)[0];
                }
                if (mime && xhr.overrideMimeType) {
                    xhr.overrideMimeType(mime);
                }

                //if (dataType) {
                //    xhr.responseType = dataType;
                //}

                var finish = function() {
                    xhr.onloadend = noop;
                    xhr.onabort = noop;
                    xhr.onprogress = noop;
                    xhr.ontimeout = noop;
                    xhr = null;
                }
                var onloadend = function() {
                    var result, error = false
                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && getAbsoluteUrl(url).startsWith('file:'))) {
                        dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader('content-type'));

                        result = xhr.responseText;
                        try {
                            if (dataType == 'script') {
                                eval(result);
                            } else if (dataType == 'xml') {
                                result = xhr.responseXML;
                            } else if (dataType == 'json') {
                                result = blankRE.test(result) ? null : JSON.parse(result);
                            } else if (dataType == "blob") {
                                result = Blob([xhrObj.response]);
                            } else if (dataType == "arraybuffer") {
                                result = xhr.reponse;
                            }
                        } catch (e) { 
                            error = e;
                        }

                        if (error) {
                            deferred.reject(error,xhr.status,xhr);
                        } else {
                            deferred.resolve(result,xhr.status,xhr);
                        }
                    } else {
                        deferred.reject(new Error(xhr.statusText),xhr.status,xhr);
                    }
                    finish();
                };

                var onabort = function() {
                    if (deferred) {
                        deferred.reject(new Error("abort"),xhr.status,xhr);
                    }
                    finish();                 
                }
 
                var ontimeout = function() {
                    if (deferred) {
                        deferred.reject(new Error("timeout"),xhr.status,xhr);
                    }
                    finish();                 
                }

                var onprogress = function(evt) {
                    if (deferred) {
                        deferred.notify(evt,xhr.status,xhr);
                    }
                }

                xhr.onloadend = onloadend;
                xhr.onabort = onabort;
                xhr.ontimeout = ontimeout;
                xhr.onprogress = onprogress;

                xhr.open(type, url, async, user, password);
               
                if (headers) {
                    for ( var key in headers) {
                        var value = headers[key];
 
                        if(key.toLowerCase() === 'content-type'){
                            contentType = value;
                        } else {
                           xhr.setRequestHeader(key, value);
                        }
                    }
                }   

                if  (contentType && contentType !== false){
                    xhr.setRequestHeader('Content-Type', contentType);
                }

                if(!headers || !('X-Requested-With' in headers)){
                    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                }


                //If basicAuthorizationToken is defined set its value into "Authorization" header
                if (basicAuthorizationToken) {
                    xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                }

                xhr.send(options.data ? options.data : null);

                return deferred.promise;

            },

            "abort": function() {
                var _ = this._,
                    xhr = _.xhr;

                if (xhr) {
                    xhr.abort();
                }    
            },


            "request": function(args) {
                return this._request(args);
            },

            get : function(args) {
                args = args || {};
                args.type = "GET";
                return this._request(args);
            },

            post : function(args) {
                args = args || {};
                args.type = "POST";
                return this._request(args);
            },

            patch : function(args) {
                args = args || {};
                args.type = "PATCH";
                return this._request(args);
            },

            put : function(args) {
                args = args || {};
                args.type = "PUT";
                return this._request(args);
            },

            del : function(args) {
                args = args || {};
                args.type = "DELETE";
                return this._request(args);
            },

            "init": function(options) {
                this._ = {
                    options : options || {}
                };
            }
        });

        ["request","get","post","put","del","patch"].forEach(function(name){
            Xhr[name] = function(url,args) {
                var xhr = new Xhr({"url" : url});
                return xhr[name](args);
            };
        });

        Xhr.defaultOptions = XhrDefaultOptions;
        Xhr.param = param;

        return Xhr;
    })();

	return http.Xhr = Xhr;	
});
define('skylark-jquery/ajax',[
    "skylark-langx/langx",
    "skylark-net-http/Xhr",
    "./core",
], function(langx,Xhr,$) {
    var jsonpID = 0;

     // Attach a bunch of functions for handling common AJAX events
    $.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( i, type ) {
        $.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );
   

    function appendQuery(url, query) {
        if (query == '') return url
        return (url + '&' + query).replace(/[&?]{1,2}/, '?')
    }
    
    $.ajaxJSONP = function(options) {
        var deferred = new langx.Deferred();
        var _callbackName = options.jsonpCallback,
            callbackName = ($.isFunction(_callbackName) ?
                _callbackName() : _callbackName) || ('jsonp' + (++jsonpID)),
            script = document.createElement('script'),
            originalCallback = window[callbackName],
            responseData,
            abort = function(errorType) {
                $(script).triggerHandler('error', errorType || 'abort')
            },
            xhr = { abort: abort },
            abortTimeout;

        for (var key in options.data) {
            options.url = appendQuery(options.url, key + "=" + options.data[key]);
        }
         
//        if (deferred) deferred.promise(xhr)

        $(script).on('load error', function(e, errorType) {
            clearTimeout(abortTimeout)
            $(script).off().remove()

            if (e.type == 'error' || !responseData) {
                deferred.reject(e);
            } else {
                deferred.resolve(responseData[0],200,xhr);
            }

            window[callbackName] = originalCallback
            if (responseData && $.isFunction(originalCallback))
                originalCallback(responseData[0])

            originalCallback = responseData = undefined
        })

        window[callbackName] = function() {
            responseData = arguments
        }

        script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
        document.head.appendChild(script)

        if (options.timeout > 0) abortTimeout = setTimeout(function() {
            abort('timeout')
        }, options.timeout)

        return deferred;
    }

    //$.ajaxSettings = Xhr.defaultOptions;
    //$.ajaxSettings.xhr = function() {
    //    return new window.XMLHttpRequest()
    //};

    $.ajaxSettings = {
        processData : true
    };


    $.ajax = function(url,options) {
        if (!url) {
            options = {
                url :  "./"
            };
        } else if (!options) {
            if (langx.isString(url)) {
                options = {
                    url :  url
                };
            } else {
                options = url;
            }
        } else {
            options.url = url;
        }

        options = langx.mixin({},$.ajaxSettings,options);

        if ('jsonp' == options.dataType) {
            var hasPlaceholder = /\?.+=\?/.test(options.url);

            if (!hasPlaceholder)
                options.url = appendQuery(options.url,
                    options.jsonp ? (options.jsonp + '=?') : options.jsonp === false ? '' : 'callback=?')
            return $.ajaxJSONP(options);
        }

        function ajaxSuccess(data,status,xhr) {
            $(document).trigger("ajaxSucess");
            if (options.success) {
                options.success.apply(this,arguments);
            }
            if (options.complete) {
                options.complete.apply(this,arguments);
            }
            return data;
        }

        function ajaxError() {
            $(document).trigger("ajaxError");
            if (options.error) {
                options.error.apply(this,arguments);
            }
        }

        var p = Xhr.request(options.url,options);
        p = p.then(ajaxSuccess,ajaxError);
        p.success = p.done;
        p.error = p.fail;
        p.complete = p.always;
        
        return p;
    };

    // handle optional data/success arguments
    function parseArguments(url, data, success, dataType) {
        if ($.isFunction(url)) {
            dataType = data, success = url, data = undefined,url = undefined;
        } else if ($.isFunction(data)) {
            dataType = success, success = data, data = undefined;
        } 
        if (!$.isFunction(success)) dataType = success, success = undefined
        return {
            url: url,
            data: data,
            success: success,
            dataType: dataType
        }
    }

    $.get = function( /* url, data, success, dataType */ ) {
        return $.ajax(parseArguments.apply(null, arguments))
    }

    $.post = function( /* url, data, success, dataType */ ) {
        var options = parseArguments.apply(null, arguments)
        options.type = 'POST'
        return $.ajax(options)
    }

    $.getJSON = function( /* url, data, success */ ) {
        var options = parseArguments.apply(null, arguments)
        options.dataType = 'json'
        return $.ajax(options)
    }

    var originalLoad = $.fn.load;

    $.fn.load = function(url, data, success) {
        if ("string" != typeof url && originalLoad) {
            return originalLoad.apply(this, arguments);
        }
        if (!this.length) return this
        var self = this,
            options = parseArguments(url, data, success),
            parts = options.url && options.url.split(/\s/),
            selector,
            callback = options.success
        if (parts && parts.length > 1) options.url = parts[0], selector = parts[1]

        if (options.data && typeof options.data === "object") {
            options.type = "POST";
        }
        options.success = function(response) {
            self.html(selector ?
                $('<div>').html(response.replace(rscript, "")).find(selector) : response)
            callback && callback.apply(self, arguments)
        }
        $.ajax(options)
        return this
    }

    $.param = Xhr.param;


    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    var
        prefilters = {},
        transports = {},
        rnotwhite = (/\S+/g);

    $.ajaxPrefilter = addToPrefiltersOrTransports(prefilters);
    $.ajaxTransport = addToPrefiltersOrTransports(transports);
    $.ajaxSetup = function(target, settings) {
        langx.mixin(Xhr.defaultOptions,target,settings);
    };

    $.getScript = function( url, callback ) {
        return $.get( url, undefined, callback, "script" );
    };

    return $;

});

define('skylark-jquery/callbacks',[
    "./core"
], function($) {

    //     This module is borrow from zepto.callback.js
    //     (c) 2010-2014 Thomas Fuchs
    //     Zepto.js may be freely distributed under the MIT license.

    // Create a collection of callbacks to be fired in a sequence, with configurable behaviour
    // Option flags:
    //   - once: Callbacks fired at most one time.
    //   - memory: Remember the most recent context and arguments
    //   - stopOnFalse: Cease iterating over callback list
    //   - unique: Permit adding at most one instance of the same callback
    $.Callbacks = function(options) {
        options = $.extend({}, options)

        var memory, // Last fire value (for non-forgettable lists)
            fired, // Flag to know if list was already fired
            firing, // Flag to know if list is currently firing
            firingStart, // First callback to fire (used internally by add and fireWith)
            firingLength, // End of the loop when firing
            firingIndex, // Index of currently firing callback (modified by remove if needed)
            list = [], // Actual callback list
            stack = !options.once && [], // Stack of fire calls for repeatable lists
            fire = function(data) {
                memory = options.memory && data
                fired = true
                firingIndex = firingStart || 0
                firingStart = 0
                firingLength = list.length
                firing = true
                for (; list && firingIndex < firingLength; ++firingIndex) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false
                        break
                    }
                }
                firing = false
                if (list) {
                    if (stack) stack.length && fire(stack.shift())
                    else if (memory) list.length = 0
                    else Callbacks.disable()
                }
            },

            Callbacks = {
                add: function() {
                    if (list) {
                        var start = list.length,
                            add = function(args) {
                                $.each(args, function(_, arg) {
                                    if (typeof arg === "function") {
                                        if (!options.unique || !Callbacks.has(arg)) list.push(arg)
                                    } else if (arg && arg.length && typeof arg !== 'string') add(arg)
                                })
                            }
                        add(arguments)
                        if (firing) firingLength = list.length
                        else if (memory) {
                            firingStart = start
                            fire(memory)
                        }
                    }
                    return this
                },
                remove: function() {
                    if (list) {
                        $.each(arguments, function(_, arg) {
                            var index
                            while ((index = $.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1)
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) --firingLength
                                    if (index <= firingIndex) --firingIndex
                                }
                            }
                        })
                    }
                    return this
                },
                has: function(fn) {
                    return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))
                },
                empty: function() {
                    firingLength = list.length = 0
                    return this
                },
                disable: function() {
                    list = stack = memory = undefined
                    return this
                },
                disabled: function() {
                    return !list
                },
                lock: function() {
                    stack = undefined;
                    if (!memory) Callbacks.disable()
                    return this
                },
                locked: function() {
                    return !stack
                },
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || []
                        args = [context, args.slice ? args.slice() : args]
                        if (firing) stack.push(args)
                        else fire(args)
                    }
                    return this
                },
                fire: function() {
                    return Callbacks.fireWith(this, arguments)
                },
                fired: function() {
                    return !!fired
                }
            }

        return Callbacks
    };

    return $;

});

define('skylark-jquery/deferred',[
    "./core",
    "skylark-langx/langx"
], function($,langx) {

    $.Deferred = function() {
        var d = new langx.Deferred(),
            ret = {
                promise : function() {
                    return d.promise;
                }
            };

        ["resolve","resolveWith","reject","rejectWith","notify","then","done","fail","progress"].forEach(function(name){
            ret[name] = function() {
              var ret2 =   d[name].apply(d,arguments);
              if (ret2 == d) {
                ret2 = ret;
              }
              return ret2;
            }
        });

        return ret;
    };
    
    $.when = function(){
        var p = langx.Deferred.all(langx.makeArray(arguments)),
            originThen = p.then;
        p.then = function(onResolved,onRejected) {
            var handler = function(results) {
                //results = results.map(function(result){
                //    return [result];
                //});
                return onResolved && onResolved.apply(null,results);
            };
            return originThen.call(p,handler,onRejected);
        };
        return p;
    };

    return $;

});

define('skylark-jquery/queue',[
    "skylark-langx/langx",
    "./core",
    "./callbacks"
], function(langx, $) {

 // jQuery Data object
  var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
      rmultiDash = /([A-Z])/g,
      expando = "Sky" + ( '1.0' + Math.random() ).replace( /\D/g, ""),
      optionsCache = {},
      core_rnotwhite = /\S+/g,
      core_deletedIds = [],
      core_push = core_deletedIds.push;

// Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    $.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
      object[ flag ] = true;
    });
    return object;
  }

  function isArraylike( obj ) {
    var length = obj.length,
        type = $.type( obj );

    if ( $.isWindow( obj ) ) {
      return false;
    }

    if ( obj.nodeType === 1 && length ) {
      return true;
    }

    return type === "array" || type !== "function" &&
        ( length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj );
  }

  

  function Data() {
    // Support: Android < 4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    Object.defineProperty( this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });

    this.expando = expando + Math.random();
  }

  Data.uid = 1;

  Data.accepts = function( owner ) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType ?
        owner.nodeType === 1 || owner.nodeType === 9 : true;
  };

  Data.prototype = {
    key: function( owner ) {
      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return the key for a frozen object.
      if ( !Data.accepts( owner ) ) {
        return 0;
      }

      var descriptor = {},
      // Check if the owner object already has a cache key
          unlock = owner[ this.expando ];

      // If not, create one
      if ( !unlock ) {
        unlock = Data.uid++;

        // Secure it in a non-enumerable, non-writable property
        try {
          descriptor[ this.expando ] = { value: unlock };
          Object.defineProperties( owner, descriptor );

          // Support: Android < 4
          // Fallback to a less secure definition
        } catch ( e ) {
          descriptor[ this.expando ] = unlock;
          $.extend( owner, descriptor );
        }
      }

      // Ensure the cache object
      if ( !this.cache[ unlock ] ) {
        this.cache[ unlock ] = {};
      }

      return unlock;
    },
    set: function( owner, data, value ) {
      var prop,
      // There may be an unlock assigned to this node,
      // if there is no entry for this "owner", create one inline
      // and set the unlock as though an owner entry had always existed
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      // Handle: [ owner, key, value ] args
      if ( typeof data === "string" ) {
        cache[ data ] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Fresh assignments by object are shallow copied
        if ( $.isEmptyObject( cache ) ) {
          $.extend( this.cache[ unlock ], data );
          // Otherwise, copy the properties one-by-one to the cache object
        } else {
          for ( prop in data ) {
            cache[ prop ] = data[ prop ];
          }
        }
      }
      return cache;
    },
    get: function( owner, key ) {
      // Either a valid cache is found, or will be created.
      // New caches will be created and the unlock returned,
      // allowing direct access to the newly created
      // empty data object. A valid owner object must be provided.
      var cache = this.cache[ this.key( owner ) ];

      return key === undefined ?
          cache : cache[ key ];
    },
    access: function( owner, key, value ) {
      var stored;
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if ( key === undefined ||
          ((key && typeof key === "string") && value === undefined) ) {

        stored = this.get( owner, key );

        return stored !== undefined ?
            stored : this.get( owner, $.camelCase(key) );
      }

      // [*]When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set( owner, key, value );

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function( owner, key ) {
      var i, name, camel,
          unlock = this.key( owner ),
          cache = this.cache[ unlock ];

      if ( key === undefined ) {
        this.cache[ unlock ] = {};

      } else {
        // Support array or space separated string of keys
        if ( $.isArray( key ) ) {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = key.concat( key.map( $.camelCase ) );
        } else {
          camel = $.camelCase( key );
          // Try the string as a key before any manipulation
          if ( key in cache ) {
            name = [ key, camel ];
          } else {
            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            name = camel;
            name = name in cache ?
                [ name ] : ( name.match( core_rnotwhite ) || [] );
          }
        }

        i = name.length;
        while ( i-- ) {
          delete cache[ name[ i ] ];
        }
      }
    },
    hasData: function( owner ) {
      return !$.isEmptyObject(
          this.cache[ owner[ this.expando ] ] || {}
      );
    },
    discard: function( owner ) {
      if ( owner[ this.expando ] ) {
        delete this.cache[ owner[ this.expando ] ];
      }
    }
  };

  var data_priv = new Data();

  $.extend($, {
    queue: function( elem, type, data ) {
      var queue;

      if ( elem ) {
        type = ( type || "fx" ) + "queue";
        queue = data_priv.get( elem, type );

        // Speed up dequeue by getting out quickly if this is just a lookup
        if ( data ) {
          if ( !queue || $.isArray( data ) ) {
            queue = data_priv.access( elem, type, $.makeArray(data) );
          } else {
            queue.push( data );
          }
        }
        return queue || [];
      }
    },

    dequeue: function( elem, type ) {
      type = type || "fx";

      var queue = $.queue( elem, type ),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = $._queueHooks( elem, type ),
          next = function() {
            $.dequeue( elem, type );
          };

      // If the fx queue is dequeued, always remove the progress sentinel
      if ( fn === "inprogress" ) {
        fn = queue.shift();
        startLength--;
      }

      if ( fn ) {

        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if ( type === "fx" ) {
          queue.unshift( "inprogress" );
        }

        // clear up the last queue stop function
        delete hooks.stop;
        fn.call( elem, next, hooks );
      }

      if ( !startLength && hooks ) {
        hooks.empty.fire();
      }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
      var key = type + "queueHooks";
      return data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: $.Callbacks("once memory").add(function() {
          data_priv.remove( elem, [ type + "queue", key ] );
        })
      });
    },

    // array operations
    makeArray: function( arr, results ) {
      var ret = results || [];

      if ( arr != null ) {
        if ( isArraylike( Object(arr) ) ) {
          $.merge( ret,
              typeof arr === "string" ?
                  [ arr ] : arr
          );
        } else {
          core_push.call( ret, arr );
        }
      }

      return ret;
    },
    merge: function( first, second ) {
      var l = second.length,
          i = first.length,
          j = 0;

      if ( typeof l === "number" ) {
        for ( ; j < l; j++ ) {
          first[ i++ ] = second[ j ];
        }
      } else {
        while ( second[j] !== undefined ) {
          first[ i++ ] = second[ j++ ];
        }
      }

      first.length = i;

      return first;
    }
  });

  $.extend($.fn, {
    queue: function( type, data ) {
      var setter = 2;

      if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
      }

      if ( arguments.length < setter ) {
        return $.queue( this[0], type );
      }

      return data === undefined ?
          this :
          this.each(function() {
            var queue = $.queue( this, type, data );

            // ensure a hooks for this queue
            $._queueHooks( this, type );

            if ( type === "fx" && queue[0] !== "inprogress" ) {
              $.dequeue( this, type );
            }
          });
    },
    dequeue: function( type ) {
      return this.each(function() {
        $.dequeue( this, type );
      });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
      time = $.fx ? $.fx.speeds[ time ] || time : time;
      type = type || "fx";

      return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
          clearTimeout( timeout );
        };
      });
    },
    clearQueue: function( type ) {
      return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
      var tmp,
          count = 1,
          defer = $.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if ( !( --count ) ) {
              defer.resolveWith( elements, [ elements ] );
            }
          };

      if ( typeof type !== "string" ) {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while( i-- ) {
        tmp = data_priv.get( elements[ i ], type + "queueHooks" );
        if ( tmp && tmp.empty ) {
          count++;
          tmp.empty.add( resolve );
        }
      }
      resolve();
      return defer.promise( obj );
    }
  });

  return $;

});

define('skylark-domx-plugins/plugins',[
    "skylark-langx/skylark",
    "skylark-langx/langx",
    "skylark-domx-noder",
    "skylark-domx-data",
    "skylark-domx-eventer",
    "skylark-domx-finder",
    "skylark-domx-geom",
    "skylark-domx-styler",
    "skylark-domx-fx",
    "skylark-domx-query",
    "skylark-domx-velm"
], function(skylark, langx, noder, datax, eventer, finder, geom, styler, fx, $, elmx) {
    "use strict";

    var slice = Array.prototype.slice,
        concat = Array.prototype.concat,
        pluginKlasses = {},
        shortcuts = {};

    /*
     * Create or get or destory a plugin instance assocated with the element.
     */
    function instantiate(elm,pluginName,options) {
        var pair = pluginName.split(":"),
            instanceDataName = pair[1];
        pluginName = pair[0];

        if (!instanceDataName) {
            instanceDataName = pluginName;
        }

        var pluginInstance = datax.data( elm, instanceDataName );

        if (options === "instance") {
            return pluginInstance;
        } else if (options === "destroy") {
            if (!pluginInstance) {
                throw new Error ("The plugin instance is not existed");
            }
            pluginInstance.destroy();
            datax.removeData( elm, pluginName);
            pluginInstance = undefined;
        } else {
            if (!pluginInstance) {
                if (options !== undefined && typeof options !== "object") {
                    throw new Error ("The options must be a plain object");
                }
                var pluginKlass = pluginKlasses[pluginName]; 
                pluginInstance = new pluginKlass(elm,options);
                datax.data( elm, instanceDataName,pluginInstance );
            } else if (options) {
                pluginInstance.reset(options);
            }
        }

        return pluginInstance;
    }


    function shortcutter(pluginName,extfn) {
       /*
        * Create or get or destory a plugin instance assocated with the element,
        * and also you can execute the plugin method directory;
        */
        return function (elm,options) {
            var  plugin = instantiate(elm, pluginName,"instance");
            if ( options === "instance" ) {
              return plugin || null;
            }

            if (!plugin) {
                plugin = instantiate(elm, pluginName,typeof options == 'object' && options || {});
                if (typeof options != "string") {
                  return this;
                }
            } 
            if (options) {
                var args = slice.call(arguments,1); //2
                if (extfn) {
                    return extfn.apply(plugin,args);
                } else {
                    if (typeof options == 'string') {
                        var methodName = options;

                        if ( !plugin ) {
                            throw new Error( "cannot call methods on " + pluginName +
                                " prior to initialization; " +
                                "attempted to call method '" + methodName + "'" );
                        }

                        if ( !langx.isFunction( plugin[ methodName ] ) || methodName.charAt( 0 ) === "_" ) {
                            throw new Error( "no such method '" + methodName + "' for " + pluginName +
                                " plugin instance" );
                        }

                        return plugin[methodName].apply(plugin,args);
                    }                
                }                
            }

        }

    }

    /*
     * Register a plugin type
     */
    function register( pluginKlass,shortcutName,instanceDataName,extfn) {
        var pluginName = pluginKlass.prototype.pluginName;
        
        pluginKlasses[pluginName] = pluginKlass;

        if (shortcutName) {
            if (instanceDataName && langx.isFunction(instanceDataName)) {
                extfn = instanceDataName;
                instanceDataName = null;
            } 
            if (instanceDataName) {
                pluginName = pluginName + ":" + instanceDataName;
            }

            var shortcut = shortcuts[shortcutName] = shortcutter(pluginName,extfn);
                
            $.fn[shortcutName] = function(options) {
                var returnValue = this;

                if ( !this.length && options === "instance" ) {
                  returnValue = undefined;
                } else {
                  var args = slice.call(arguments);
                  this.each(function () {
                    var args2 = slice.call(args);
                    args2.unshift(this);
                    var  ret  = shortcut.apply(undefined,args2);
                    if (ret !== undefined) {
                        returnValue = ret;
                        return false;
                    }
                  });
                }

                return returnValue;
            };

            elmx.partial(shortcutName,function(options) {
                var  ret  = shortcut(this._elm,options);
                if (ret === undefined) {
                    ret = this;
                }
                return ret;
            });

        }
    }

 
    var Plugin =   langx.Evented.inherit({
        klassName: "Plugin",

        _construct : function(elm,options) {
           this._elm = elm;
           this._initOptions(options);
        },

        _initOptions : function(options) {
          var ctor = this.constructor,
              cache = ctor.cache = ctor.cache || {},
              defaults = cache.defaults;
          if (!defaults) {
            var  ctors = [];
            do {
              ctors.unshift(ctor);
              if (ctor === Plugin) {
                break;
              }
              ctor = ctor.superclass;
            } while (ctor);

            defaults = cache.defaults = {};
            for (var i=0;i<ctors.length;i++) {
              ctor = ctors[i];
              if (ctor.prototype.hasOwnProperty("options")) {
                langx.mixin(defaults,ctor.prototype.options,true);
              }
              if (ctor.hasOwnProperty("options")) {
                langx.mixin(defaults,ctor.options,true);
              }
            }
          }
          Object.defineProperty(this,"options",{
            value :langx.mixin({},defaults,options,true)
          });

          //return this.options = langx.mixin({},defaults,options);
          return this.options;
        },


        destroy: function() {
            var that = this;

            this._destroy();
            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            datax.removeData(this._elm,this.pluginName );
        },

        _destroy: langx.noop,

        _delay: function( handler, delay ) {
            function handlerProxy() {
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }
            var instance = this;
            return setTimeout( handlerProxy, delay || 0 );
        },

        option: function( key, value ) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if ( arguments.length === 0 ) {

                // Don't return a reference to the internal hash
                return langx.mixin( {}, this.options );
            }

            if ( typeof key === "string" ) {

                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split( "." );
                key = parts.shift();
                if ( parts.length ) {
                    curOption = options[ key ] = langx.mixin( {}, this.options[ key ] );
                    for ( i = 0; i < parts.length - 1; i++ ) {
                        curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                        curOption = curOption[ parts[ i ] ];
                    }
                    key = parts.pop();
                    if ( arguments.length === 1 ) {
                        return curOption[ key ] === undefined ? null : curOption[ key ];
                    }
                    curOption[ key ] = value;
                } else {
                    if ( arguments.length === 1 ) {
                        return this.options[ key ] === undefined ? null : this.options[ key ];
                    }
                    options[ key ] = value;
                }
            }

            this._setOptions( options );

            return this;
        },

        _setOptions: function( options ) {
            var key;

            for ( key in options ) {
                this._setOption( key, options[ key ] );
            }

            return this;
        },

        _setOption: function( key, value ) {

            this.options[ key ] = value;

            return this;
        },

        getUID : function (prefix) {
            prefix = prefix || "plugin";
            do prefix += ~~(Math.random() * 1000000)
            while (document.getElementById(prefix))
            return prefix;
        },

        elm : function() {
            return this._elm;
        }

    });

    $.fn.plugin = function(name,options) {
        var args = slice.call( arguments, 1 ),
            self = this,
            returnValue = this;

        this.each(function(){
            returnValue = instantiate.apply(self,[this,name].concat(args));
        });
        return returnValue;
    };

    elmx.partial("plugin",function(name,options) {
        var args = slice.call( arguments, 1 );
        return instantiate.apply(this,[this.domNode,name].concat(args));
    }); 


    function plugins() {
        return plugins;
    }
     
    langx.mixin(plugins, {
        instantiate,
        Plugin,
        register,
        shortcuts
    });

    return  skylark.attach("domx.plugins",plugins);
});
define('skylark-domx-plugins/main',[
	"./plugins"
],function(plugins){
	return plugins;
});
define('skylark-domx-plugins', ['skylark-domx-plugins/main'], function (main) { return main; });

define('skylark-jquery/JqueryPlugin',[
	"skylark-langx-types",
	"skylark-langx-objects",
	"skylark-langx-arrays",
	"skylark-langx/langx",
	"skylark-domx-data",
	"skylark-domx-eventer",
	"skylark-domx-plugins",
	"skylark-domx-query",
],function(types, objects, arrays, langx, datax, eventer, plugins, $){

    var pluginUuid = 0;

	var JqPlugin = plugins.Plugin.inherit({
		klassName : "JqPlugin",

        pluginEventPrefix: "",

        options: {
            // Callbacks
            create: null
        },

        destroy: function() {
            this.overrided();

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off( this.eventNamespace );

            // Clean up events and states
            this.bindings.off( this.eventNamespace );
        },

        _construct : function(element,options) {
            //this.options = langx.mixin( {}, this.options );

            element = $( element || this.defaultElement || this )[ 0 ];
            this.element = $( element );
            this.uuid = pluginUuid++;
            this.eventNamespace = "." + this.pluginName + this.uuid;

            this.bindings = $();
            this.classesElementLookup = {};

			this.hoverable = $();
			this.focusable = $();

            if ( element !== this ) {
                datax.data( element, this.pluginName, this );
                this._on( true, this.element, {
                    remove: function( event ) {
                        if ( event.target === element ) {
                            this.destroy();
                        }
                    }
                } );
                this.document = $( element.style ?

                    // Element within the document
                    element.ownerDocument :

                    // Element is window or document
                    element.document || element );
                this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
            }

            this.overrided(element,options);

//            this.options = langx.mixin( {},
//                this.options,
//                this._getCreateOptions(),
//                options );

            this._create();

            this._trigger( "create", null, this._getCreateEventData() );

            this._init();
        },


	     _initOptions : function(options) {
	     	options = langx.mixin(this._getCreateOptions(),options);

			this.overrided(options);
		},

        _getCreateOptions: function() {
            return {};
        },

        _getCreateEventData: langx.noop,

		_super : function() {
			if (this.overrided) {
				return this.overrided.apply(this,arguments);
			}
		},

		_superApply : function ( args ) {
			if (this.overrided) {
				return this.overrided.apply(this,args);
			}
		},

        _create: langx.noop,

        _init: langx.noop,

		_classes: function( options ) {
			var full = [];
			var that = this;

			options = objects.mixin( {
				element: this.element,
				classes: this.options.classes || {}
			}, options );


			function bindRemoveEvent() {
				options.element.each( function( _, element ) {
					var isTracked = langx.map( that.classesElementLookup, function( elements ) {
						return elements;
					} )
						.some( function(elements ) {
							return $(elements).is( element );
						} );

					if ( !isTracked ) {
						that._on( $( element ), {
							remove: "_untrackClassesElement"
						} );
					}
				} );
			}

			function processClassString( classes, checkOption ) {
				var current, i;
				for ( i = 0; i < classes.length; i++ ) {
					current = that.classesElementLookup[ classes[ i ] ] || $();
					if ( options.add ) {
						bindRemoveEvent();
						current = $( langx.uniq( current.get().concat( options.element.get() ) ) );
					} else {
						current = $( current.not( options.element ).get() );
					}
					that.classesElementLookup[ classes[ i ] ] = current;
					full.push( classes[ i ] );
					if ( checkOption && options.classes[ classes[ i ] ] ) {
						full.push( options.classes[ classes[ i ] ] );
					}
				}
			}

			if ( options.keys ) {
				processClassString( options.keys.match( /\S+/g ) || [], true );
			}
			if ( options.extra ) {
				processClassString( options.extra.match( /\S+/g ) || [] );
			}

			return full.join( " " );
		},

		_untrackClassesElement: function( event ) {
			var that = this;
			langx.each( that.classesElementLookup, function( key, value ) {
				if ( arrays.inArray( event.target, value ) !== -1 ) {
					that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
				}
			} );

			this._off( $( event.target ) );
		},

		_removeClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, false );
		},

		_addClass: function( element, keys, extra ) {
			return this._toggleClass( element, keys, extra, true );
		},

		_toggleClass: function( element, keys, extra, add ) {
			add = ( typeof add === "boolean" ) ? add : extra;
			var shift = ( typeof element === "string" || element === null ),
				options = {
					extra: shift ? keys : extra,
					keys: shift ? element : keys,
					element: shift ? this.element : element,
					add: add
				};
			options.element.toggleClass( this._classes( options ), add );
			return this;
		},

		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement;
			var instance = this;

			// No suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}

			// No element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}

			objects.each( handlers, function( event, handler ) {
				function handlerProxy() {

					// Allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}

				// Copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}

				var match = event.match( /^([\w:-]*)\s*(.*)$/ );
				var eventName = match[ 1 ] + instance.eventNamespace;
				var selector = match[ 2 ];

				if ( selector ) {
					delegateElement.on( eventName, selector, handlerProxy );
				} else {
					element.on( eventName, handlerProxy );
				}
			} );
		},

		_off: function( element, eventName ) {
			eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.off( eventName );

			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},

		_trigger: function( type, event, data ) {
			var prop, orig;
			var callback = this.options[ type ];

			data = data || {};
			event = eventer.proxy( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();

			// The original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];

			// Copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}

			this.element.trigger( event, data );
			return !( types.isFunction( callback ) &&
				callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}

	});

	return JqPlugin;
});
/*!
 * jQuery UI Widget @VERSION
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

define( 'skylark-jquery/widget',[ 
	"skylark-langx/langx",
	"skylark-domx-plugins",
	"./core",
	"./JqueryPlugin"
],  function(langx,splugins, $,JqPlugin ) {

	var widgetUuid = 0;
	var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
	var widgetSlice = Array.prototype.slice;

	$.cleanData = ( function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}
			}
			orig( elems );
		};
	} )( $.cleanData );
	
	$.widget = function( name, base, prototype ) {
		var existingConstructor, constructor, basePrototype;

		// ProxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		var proxiedPrototype = {};

		var namespace = name.split( "." )[ 0 ];
		name = name.split( "." )[ 1 ];
		var fullName = namespace + "-" + name;

		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}

		if ( $.isArray( prototype ) ) {
			prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
		}

		// Create selector for plugin
		$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};

		$[ namespace ] = $[ namespace ] || {};

		existingConstructor = $[ namespace ][ name ];

		var basePrototype = base.prototype,
			newPrototype = {};

		for (var key in prototype) {
			var value = prototype[key];

			if ( $.isPlainObject( value ) ) {
				newPrototype[ key ] = $.isPlainObject( basePrototype[ key ] ) ?
					$.widget.extend( {}, basePrototype[ key ], value ) :

					// Don't extend strings, arrays, etc. with objects
					$.widget.extend( {}, value );
			} else {
				newPrototype[key] = value;
			}
		}

		var _proto = $.widget.extend({

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( base.prototype.widgetEventPrefix || name ) : name
		}, {
			options : base.prototype.options
		},newPrototype, {
			name : fullName,
			namespace: namespace,
			widgetName: name,
			pluginName : "jqueryui." + (namespace ? namespace + "." : "") + name,
			widgetFullName: fullName
		} );

		constructor = $[ namespace ][ name ] = base.inherit(_proto);
		/*

		constructor = $[ namespace ][ name ] = function( options, element ) {

			// Allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}

			// Allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		*/
		// Extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,

			// Copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: _proto,

			// Track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		} );

		/*
		basePrototype = new base();

		// We need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = ( function() {
				function _super() {
					return base.prototype[ prop ].apply( this, arguments );
				}

				function _superApply( args ) {
					return base.prototype[ prop ].apply( this, args );
				}

				return function() {
					var __super = this._super;
					var __superApply = this._superApply;
					var returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			} )();
		} );
		constructor.prototype = $.widget.extend( basePrototype, {

			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		} );
		*/
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;

				// Redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
					child._proto );
			} );

			// Remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			if (base._childConstructors) {
				base._childConstructors.push( constructor );
			}
		}

		//$.widget.bridge( name, constructor );

		splugins.register(constructor,name,fullName);

		return constructor;
	};

	$.widget.extend = function( target ) {
		var input = widgetSlice.call( arguments, 1 );
		var inputIndex = 0;
		var inputLength = input.length;
		var key;
		var value;

		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {

					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :

							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );

					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};


	$.Widget = 	 JqPlugin.inherit({
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",

		options: {
			classes: {},
			disabled: false,

			// Callbacks
			create: null
		},

		widget: function() {
			return this.element;
		},

		_setOption: function( key, value ) {
			if ( key === "classes" ) {
				this._setOptionClasses( value );
			}

			this.options[ key ] = value;

			if ( key === "disabled" ) {
				this._setOptionDisabled( value );
			}

			return this;
		},

		_setOptionClasses: function( value ) {
			var classKey, elements, currentElements;

			for ( classKey in value ) {
				currentElements = this.classesElementLookup[ classKey ];
				if ( value[ classKey ] === this.options.classes[ classKey ] ||
						!currentElements ||
						!currentElements.length ) {
					continue;
				}

				// We are doing this to create a new jQuery object because the _removeClass() call
				// on the next line is going to destroy the reference to the current elements being
				// tracked. We need to save a copy of this collection so that we can add the new classes
				// below.
				elements = $( currentElements.get() );
				this._removeClass( currentElements, classKey );

				// We don't use _addClass() here, because that uses this.options.classes
				// for generating the string of classes. We want to use the value passed in from
				// _setOption(), this is the new value of the classes option which was passed to
				// _setOption(). We pass this value directly to _classes().
				elements.addClass( this._classes( {
					element: elements,
					keys: classKey,
					classes: value,
					add: true
				} ));
			}
		},

		_setOptionDisabled: function( value ) {
			this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this._removeClass( this.hoverable, null, "ui-state-hover" );
				this._removeClass( this.focusable, null, "ui-state-focus" );
			}
		},

		enable: function() {
			return this._setOptions( { disabled: false } );
		},

		disable: function() {
			return this._setOptions( { disabled: true } );
		},


		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},

		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
				},
				mouseleave: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
				}
			} );
		},

		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
				},
				focusout: function( event ) {
					this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
				}
			} );
		}

	});

	$.Widget._childConstructors = [];

	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}

			var hasOptions;
			var effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;

			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}

			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;

			if ( options.delay ) {
				element.delay( options.delay );
			}

			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue( function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				} );
			}
		};
	} );

	return $.widget;

});

define('skylark-jquery/main',[
    "./core",
    "./ajax",
    "./callbacks",
    "./deferred",
    "./queue",
    "./JqueryPlugin",
    "./widget"
], function($) {
    return $;
});

define('skylark-jquery', ['skylark-jquery/main'], function (main) { return main; });

define('skylark-langx/main',[
    "./skylark",
    "./langx"
], function(skylark) {
    return skylark;
});

define('skylark-langx', ['skylark-langx/main'], function (main) { return main; });

define('skylark-grapejs/editor/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'gjs-',
        components: '',
        style: '',
        fromElement: 0,
        noticeOnUnload: true,
        showOffsets: false,
        showOffsetsSelected: false,
        forceClass: true,
        height: '900px',
        width: '100%',
        log: [
            'warning',
            'error'
        ],
        baseCss: `
    * {
      box-sizing: border-box;
    }
    html, body, [data-gjs-type=wrapper] {
      min-height: 100%;
    }
    body {
      margin: 0;
      height: 100%;
      background-color: #fff
    }
    [data-gjs-type=wrapper] {
      overflow: auto;
      overflow-x: hidden;
    }

    * ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1)
    }

    * ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2)
    }

    * ::-webkit-scrollbar {
      width: 10px
    }
  `,
        protectedCss: '* { box-sizing: border-box; } body {margin: 0;}',
        canvasCss: '',
        defaultCommand: 'select-comp',
        showToolbar: 1,
        allowScripts: 0,
        showDevices: 1,
        devicePreviewMode: 0,
        mediaCondition: 'max-width',
        tagVarStart: '{[ ',
        tagVarEnd: ' ]}',
        keepEmptyTextNodes: 0,
        jsInHtml: true,
        nativeDnD: 1,
        multipleSelection: 1,
        exportWrapper: 0,
        wrapperIsBody: 1,
        avoidInlineStyle: 1,
        avoidDefaults: 1,
        clearStyles: 0,
        dragMode: 0,
        cssIcons: 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css',
        el: '',
        i18n: {},
        undoManager: {},
        assetManager: {},
        canvas: {},
        layers: {},
        storageManager: {},
        richTextEditor: {},
        domComponents: {},
        modal: {},
        codeManager: {},
        panels: {},
        commands: {},
        cssComposer: {},
        selectorManager: {},
        deviceManager: {
            devices: [
                {
                    id: 'desktop',
                    name: 'Desktop',
                    width: ''
                },
                {
                    id: 'tablet',
                    name: 'Tablet',
                    width: '768px',
                    widthMedia: '992px'
                },
                {
                    id: 'mobileLandscape',
                    name: 'Mobile landscape',
                    width: '568px',
                    widthMedia: '768px'
                },
                {
                    id: 'mobilePortrait',
                    name: 'Mobile portrait',
                    width: '320px',
                    widthMedia: '480px'
                }
            ]
        },
        styleManager: {
            sectors: [
                {
                    name: 'General',
                    open: false,
                    buildProps: [
                        'float',
                        'display',
                        'position',
                        'top',
                        'right',
                        'left',
                        'bottom'
                    ]
                },
                {
                    name: 'Flex',
                    open: false,
                    buildProps: [
                        'flex-direction',
                        'flex-wrap',
                        'justify-content',
                        'align-items',
                        'align-content',
                        'order',
                        'flex-basis',
                        'flex-grow',
                        'flex-shrink',
                        'align-self'
                    ]
                },
                {
                    name: 'Dimension',
                    open: false,
                    buildProps: [
                        'width',
                        'height',
                        'max-width',
                        'min-height',
                        'margin',
                        'padding'
                    ]
                },
                {
                    name: 'Typography',
                    open: false,
                    buildProps: [
                        'font-family',
                        'font-size',
                        'font-weight',
                        'letter-spacing',
                        'color',
                        'line-height',
                        'text-align',
                        'text-shadow'
                    ],
                    properties: [{
                            property: 'text-align',
                            list: [
                                {
                                    value: 'left',
                                    className: 'fa fa-align-left'
                                },
                                {
                                    value: 'center',
                                    className: 'fa fa-align-center'
                                },
                                {
                                    value: 'right',
                                    className: 'fa fa-align-right'
                                },
                                {
                                    value: 'justify',
                                    className: 'fa fa-align-justify'
                                }
                            ]
                        }]
                },
                {
                    name: 'Decorations',
                    open: false,
                    buildProps: [
                        'border-radius-c',
                        'background-color',
                        'border-radius',
                        'border',
                        'box-shadow',
                        'background'
                    ]
                },
                {
                    name: 'Extra',
                    open: false,
                    buildProps: [
                        'transition',
                        'perspective',
                        'transform'
                    ]
                }
            ]
        },
        blockManager: {},
        traitManager: {},
        textViewCode: 'Code',
        keepUnusedStyles: 0,
        multiFrames: 0
    };
});
define('skylark-underscore/underscore',[
	"skylark-langx/skylark"
],function(skylark){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because were not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  return skylark.attach("itg.underscore",_);
});
define('skylark-underscore/main',[
	"./underscore"
],function(_){
	return _;
});
define('skylark-underscore', ['skylark-underscore/main'], function (main) { return main; });

define('skylark-data-entities/entities',[
    "skylark-langx/langx"
], function(langx) {
    function entities() {
        return entities;
    }

    langx.mixin(entities, {
        // set a `X-Http-Method-Override` header.
        emulateHTTP : false,

        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... this will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        emulateJSON : false,

        backends : {
            
        }
    });


    return entities;
});

define('skylark-data-entities/Entity',[
	"skylark-langx/langx",
	"./entities"
],function(langx,entities){
   // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

 
  var Entity = langx.Stateful.inherit({
    sync: function() {
      return entities.sync.apply(this, arguments);
    },

    // Get the HTML-escaped value of an attribute.
    //escape: function(attr) {
    //  return _.escape(this.get(attr));
    //},

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return langx.isMatch(this.attributes,attrs);
    },

    // Fetch the entity from the server, merging the response with the entity's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = langx.mixin({parse: true}, options);
      var entity = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;
        if (!entity.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, entity, resp, options);
        entity.trigger('sync', entity, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of entity attributes, and sync the entity to the server.
    // If the server returns an attributes hash that differs, the entity's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = langx.mixin({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the entity will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var entity = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        entity.attributes = attributes;
        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;
        if (wait) serverAttrs = langx.mixin({}, attrs, serverAttrs);
        if (serverAttrs && !entity.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, entity, resp, options);
        entity.trigger('sync', entity, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = langx.mixin({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this entity on the server if it was already persisted.
    // Optimistically removes the entity from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? langx.clone(options) : {};
      var entity = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        entity.stopListening();
        entity.trigger('destroy', entity, entity.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, entity, resp, options);
        if (!entity.isNew()) entity.trigger('sync', entity, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        langx.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the entity's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        langx.result(this, 'urlRoot') ||
        langx.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the entity. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    }
  });

  return entities.Entity = Entity;

});
define('skylark-data-entities/Collection',[
	"skylark-langx/langx",
	"./entities",
	"./Entity"
],function(langx,entities,Entity){
  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };


	var Collection  = langx.Evented.inherit({
		"_construct" : function(entities, options) {
			options || (options = {});
			if (options.entity) this.entity = options.entity;
			if (options.comparator !== void 0) this.comparator = options.comparator;
			this._reset();
			if (entities) this.reset(entities, langx.mixin({silent: true}, options));
		}
	}); 

	// Default options for `Collection#set`.
	var setOptions = {add: true, remove: true, merge: true};
	var addOptions = {add: true, remove: false};

	// Splices `insert` into `array` at index `at`.
	var splice = function(array, insert, at) {
		at = Math.min(Math.max(at, 0), array.length);
		var tail = Array(array.length - at);
		var length = insert.length;
		var i;
		for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
		for (i = 0; i < length; i++) array[i + at] = insert[i];
		for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
	};

  // Define the Collection's inheritable methods.
	Collection.partial({

		// The default entity for a collection is just a **Entity**.
		// This should be overridden in most cases.
		entity: Entity,

		// Initialize is an empty function by default. Override it with your own
		// initialization logic.
		initialize: function(){},

		// The JSON representation of a Collection is an array of the
		// entities' attributes.
		toJSON: function(options) {
		  return this.map(function(entity) { return entity.toJSON(options); });
		},

		// Proxy `entities.sync` by default.
		sync: function() {
		  return entities.sync.apply(this, arguments);
		},

		// Add a entity, or list of entities to the set. `entities` may be Backbone
		// Entitys or raw JavaScript objects to be converted to Entitys, or any
		// combination of the two.
		add: function(entities, options) {
		  return this.set(entities, langx.mixin({merge: false}, options, addOptions));
		},

		// Remove a entity, or a list of entities from the set.
		remove: function(entities, options) {
		  options = langx.mixin({}, options);
		  var singular = !langx.isArray(entities);
		  entities = singular ? [entities] : entities.slice();
		  var removed = this._removeEntitys(entities, options);
		  if (!options.silent && removed.length) {
		    options.changes = {added: [], merged: [], removed: removed};
		    this.trigger('update', this, options);
		  }
		  return singular ? removed[0] : removed;
		},

		// Update a collection by `set`-ing a new list of entities, adding new ones,
		// removing entities that are no longer present, and merging entities that
		// already exist in the collection, as necessary. Similar to **Entity#set**,
		// the core operation for updating the data contained by the collection.
		set: function(entities, options) {
		  if (entities == null) return;

		  options = langx.mixin({}, setOptions, options);
		  if (options.parse && !this._isEntity(entities)) {
		    entities = this.parse(entities, options) || [];
		  }

		  var singular = !langx.isArray(entities);
		  entities = singular ? [entities] : entities.slice();

		  var at = options.at;
		  if (at != null) at = +at;
		  if (at > this.length) at = this.length;
		  if (at < 0) at += this.length + 1;

		  var set = [];
		  var toAdd = [];
		  var toMerge = [];
		  var toRemove = [];
		  var modelMap = {};

		  var add = options.add;
		  var merge = options.merge;
		  var remove = options.remove;

		  var sort = false;
		  var sortable = this.comparator && at == null && options.sort !== false;
		  var sortAttr = langx.isString(this.comparator) ? this.comparator : null;

		  // Turn bare objects into entity references, and prevent invalid entities
		  // from being added.
		  var entity, i;
		  for (i = 0; i < entities.length; i++) {
		    entity = entities[i];

		    // If a duplicate is found, prevent it from being added and
		    // optionally merge it into the existing entity.
		    var existing = this.get(entity);
		    if (existing) {
		      if (merge && entity !== existing) {
		        var attrs = this._isEntity(entity) ? entity.attributes : entity;
		        if (options.parse) attrs = existing.parse(attrs, options);
		        existing.set(attrs, options);
		        toMerge.push(existing);
		        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
		      }
		      if (!modelMap[existing.cid]) {
		        modelMap[existing.cid] = true;
		        set.push(existing);
		      }
		      entities[i] = existing;

		    // If this is a new, valid entity, push it to the `toAdd` list.
		    } else if (add) {
		      entity = entities[i] = this._prepareEntity(entity, options);
		      if (entity) {
		        toAdd.push(entity);
		        this._addReference(entity, options);
		        modelMap[entity.cid] = true;
		        set.push(entity);
		      }
		    }
		  }

		  // Remove stale entities.
		  if (remove) {
		    for (i = 0; i < this.length; i++) {
		      entity = this.entities[i];
		      if (!modelMap[entity.cid]) toRemove.push(entity);
		    }
		    if (toRemove.length) this._removeEntitys(toRemove, options);
		  }

		  // See if sorting is needed, update `length` and splice in new entities.
		  var orderChanged = false;
		  var replace = !sortable && add && remove;
		  if (set.length && replace) {
		    orderChanged = this.length !== set.length || this.entities.some(function(m, index) {
		      return m !== set[index];
		    });
		    this.entities.length = 0;
		    splice(this.entities, set, 0);
		    this.length = this.entities.length;
		  } else if (toAdd.length) {
		    if (sortable) sort = true;
		    splice(this.entities, toAdd, at == null ? this.length : at);
		    this.length = this.entities.length;
		  }

		  // Silently sort the collection if appropriate.
		  if (sort) this.sort({silent: true});

		  // Unless silenced, it's time to fire all appropriate add/sort/update events.
		  if (!options.silent) {
		    for (i = 0; i < toAdd.length; i++) {
		      if (at != null) options.index = at + i;
		      entity = toAdd[i];
		      entity.trigger('add', entity, this, options);
		    }
		    if (sort || orderChanged) this.trigger('sort', this, options);
		    if (toAdd.length || toRemove.length || toMerge.length) {
		      options.changes = {
		        added: toAdd,
		        removed: toRemove,
		        merged: toMerge
		      };
		      this.trigger('update', this, options);
		    }
		  }

		  // Return the added (or merged) entity (or entities).
		  return singular ? entities[0] : entities;
		},

		// When you have more items than you want to add or remove individually,
		// you can reset the entire set with a new list of entities, without firing
		// any granular `add` or `remove` events. Fires `reset` when finished.
		// Useful for bulk operations and optimizations.
		reset: function(entities, options) {
		  options = options ? langx.clone(options) : {};
		  for (var i = 0; i < this.entities.length; i++) {
		    this._removeReference(this.entities[i], options);
		  }
		  options.previousEntitys = this.entities;
		  this._reset();
		  entities = this.add(entities, langx.mixin({silent: true}, options));
		  if (!options.silent) this.trigger('reset', this, options);
		  return entities;
		},

		// Add a entity to the end of the collection.
		push: function(entity, options) {
		  return this.add(entity, langx.mixin({at: this.length}, options));
		},

		// Remove a entity from the end of the collection.
		pop: function(options) {
		  var entity = this.at(this.length - 1);
		  return this.remove(entity, options);
		},

		// Add a entity to the beginning of the collection.
		unshift: function(entity, options) {
		  return this.add(entity, langx.mixin({at: 0}, options));
		},

		// Remove a entity from the beginning of the collection.
		shift: function(options) {
		  var entity = this.at(0);
		  return this.remove(entity, options);
		},

		// Slice out a sub-array of entities from the collection.
		slice: function() {
		  return slice.apply(this.entities, arguments);
		},

		// Get a entity from the set by id, cid, entity object with id or cid
		// properties, or an attributes object that is transformed through entityId.
		get: function(obj) {
		  if (obj == null) return void 0;
		  return this._byId[obj] ||
		    this._byId[this.entityId(obj.attributes || obj)] ||
		    obj.cid && this._byId[obj.cid];
		},

		// Returns `true` if the entity is in the collection.
		has: function(obj) {
		  return this.get(obj) != null;
		},

		// Get the entity at the given index.
		at: function(index) {
		  if (index < 0) index += this.length;
		  return this.entities[index];
		},

		// Return entities with matching attributes. Useful for simple cases of
		// `filter`.
		where: function(attrs, first) {
		  return this[first ? 'find' : 'filter'](attrs);
		},

		// Return the first entity with matching attributes. Useful for simple cases
		// of `find`.
		findWhere: function(attrs) {
		  return this.where(attrs, true);
		},

		// Force the collection to re-sort itself. You don't need to call this under
		// normal circumstances, as the set will maintain sort order as each item
		// is added.
		sort: function(options) {
		  var comparator = this.comparator;
		  if (!comparator) throw new Error('Cannot sort a set without a comparator');
		  options || (options = {});

		  var length = comparator.length;
		  if (langx.isFunction(comparator)) comparator = langx.proxy(comparator, this);

		  // Run sort based on type of `comparator`.
		  if (length === 1 || langx.isString(comparator)) {
		    this.entities = this.sortBy(comparator);
		  } else {
		    this.entities.sort(comparator);
		  }
		  if (!options.silent) this.trigger('sort', this, options);
		  return this;
		},

		// Pluck an attribute from each entity in the collection.
		pluck: function(attr) {
		  return this.map(attr + '');
		},

		// Fetch the default set of entities for this collection, resetting the
		// collection when they arrive. If `reset: true` is passed, the response
		// data will be passed through the `reset` method instead of `set`.
		fetch: function(options) {
		  options = langx.mixin({parse: true}, options);
		  var success = options.success;
		  var collection = this;
		  options.success = function(resp) {
		    var method = options.reset ? 'reset' : 'set';
		    collection[method](resp, options);
		    if (success) success.call(options.context, collection, resp, options);
		    collection.trigger('sync', collection, resp, options);
		  };
		  wrapError(this, options);
		  return this.sync('read', this, options);
		},

		// Create a new instance of a entity in this collection. Add the entity to the
		// collection immediately, unless `wait: true` is passed, in which case we
		// wait for the server to agree.
		create: function(entity, options) {
		  options = options ? langx.clone(options) : {};
		  var wait = options.wait;
		  entity = this._prepareEntity(entity, options);
		  if (!entity) return false;
		  if (!wait) this.add(entity, options);
		  var collection = this;
		  var success = options.success;
		  options.success = function(m, resp, callbackOpts) {
		    if (wait) collection.add(m, callbackOpts);
		    if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
		  };
		  entity.save(null, options);
		  return entity;
		},

		// **parse** converts a response into a list of entities to be added to the
		// collection. The default implementation is just to pass it through.
		parse: function(resp, options) {
		  return resp;
		},

		// Create a new collection with an identical list of entities as this one.
		clone: function() {
		  return new this.constructor(this.entities, {
		    entity: this.entity,
		    comparator: this.comparator
		  });
		},

		// Define how to uniquely identify entities in the collection.
		entityId: function(attrs) {
		  return attrs[this.entity.prototype.idAttribute || 'id'];
		},

		// Private method to reset all internal state. Called when the collection
		// is first initialized or reset.
		_reset: function() {
		  this.length = 0;
		  this.entities = [];
		  this._byId  = {};
		},

		// Prepare a hash of attributes (or other entity) to be added to this
		// collection.
		_prepareEntity: function(attrs, options) {
		  if (this._isEntity(attrs)) {
		    if (!attrs.collection) attrs.collection = this;
		    return attrs;
		  }
		  options = options ? langx.clone(options) : {};
		  options.collection = this;
		  var entity = new this.entity(attrs, options);
		  if (!entity.validationError) return entity;
		  this.trigger('invalid', this, entity.validationError, options);
		  return false;
		},

		// Internal method called by both remove and set.
		_removeEntitys: function(entities, options) {
		  var removed = [];
		  for (var i = 0; i < entities.length; i++) {
		    var entity = this.get(entities[i]);
		    if (!entity) continue;

		    var index = this.indexOf(entity);
		    this.entities.splice(index, 1);
		    this.length--;

		    // Remove references before triggering 'remove' event to prevent an
		    // infinite loop. #3693
		    delete this._byId[entity.cid];
		    var id = this.entityId(entity.attributes);
		    if (id != null) delete this._byId[id];

		    if (!options.silent) {
		      options.index = index;
		      entity.trigger('remove', entity, this, options);
		    }

		    removed.push(entity);
		    this._removeReference(entity, options);
		  }
		  return removed;
		},

		// Method for checking whether an object should be considered a entity for
		// the purposes of adding to the collection.
		_isEntity: function(entity) {
		  return entity instanceof Entity;
		},

		// Internal method to create a entity's ties to a collection.
		_addReference: function(entity, options) {
		  this._byId[entity.cid] = entity;
		  var id = this.entityId(entity.attributes);
		  if (id != null) this._byId[id] = entity;
		  entity.on('all', this._onEntityEvent, this);
		},

		// Internal method to sever a entity's ties to a collection.
		_removeReference: function(entity, options) {
		  delete this._byId[entity.cid];
		  var id = this.entityId(entity.attributes);
		  if (id != null) delete this._byId[id];
		  if (this === entity.collection) delete entity.collection;
		  entity.off('all', this._onEntityEvent, this);
		},

		// Internal method called every time a entity in the set fires an event.
		// Sets need to update their indexes when entities change ids. All other
		// events simply proxy through. "add" and "remove" events that originate
		// in other collections are ignored.
		_onEntityEvent: function(event, entity, collection, options) {
		  if (entity) {
		    if ((event === 'add' || event === 'remove') && collection !== this) return;
		    if (event === 'destroy') this.remove(entity, options);
		    if (event === 'change') {
		      var prevId = this.entityId(entity.previousAttributes());
		      var id = this.entityId(entity.attributes);
		      if (prevId !== id) {
		        if (prevId != null) delete this._byId[prevId];
		        if (id != null) this._byId[id] = entity;
		      }
		    }
		  }
		  this.trigger.apply(this, arguments);
		}

  	});

	return entities.Collection = Collection;
});
define('skylark-data-entities/backends/registry',[
	
],function(){
	var providers = {

	};

	function add(name,setting) {
		providers[name] = setting;
	}

	function remove(name) {
		delete provides[name];
	}

	function get(name) {
		return providers[name];
	}

	return {
		add : add,
		remove: remove,
		get : get
	}
});
define('skylark-data-entities/sync',[
	"skylark-langx/langx",
	"./entities",
  	"./backends/registry"
],function(langx,entities,registry){

	// Override 'Backbone.sync' to default to localSync,
	// the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'
	function sync(method, model, options) {
		if (!options.backend) {
			throw new Error("The backend is not specified")
		}
		var setting = registry.get(options.backend);
		if (!setting) {
			throw new Error("The backend is not defined:" + options.backend);
		}
		var syncMethod = setting.sync;
		if (!syncMethod) {
			throw new Error("The backend sync method is not defined:" + options.backend);
		}

		var options2 = langx.mixin({},setting.options,options);
	  	return syncMethod.apply(this, [method, model, options2]);
	};

  
   return entities.sync = sync;

});
define('skylark-data-entities/backends/ajaxSync',[
	"skylark-langx/langx",
	"../entities"
],function(langx,entities){
// Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  };
  

  var sync = function(method, entity, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    langx.defaults(options || (options = {}), {
      emulateHTTP: entities.emulateHTTP,
      emulateJSON: entities.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = langx.result(entity, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && entity && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || entity.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {entity: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = langx.Xhr.request(langx.mixin(params, options));
    entity.trigger('request', entity, xhr, options);
    return xhr;
  };

 
  
  return entities.backends.ajaxSync = sync;

});
define('skylark-data-entities/backends/localSync',[
  "skylark-langx/langx",
  "../entities"
],function(langx,entities){

  // A simple module to replace `Backbone.sync` with *localStorage*-based
  // persistence. Models are given GUIDS, and saved into a JSON object. Simple
  // as that.

  // Hold reference to Underscore.js and Backbone.js in the closure in order
  // to make things work even if they are removed from the global namespace

  // Generate four random hex digits.
  function S4() {
     return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
  };

  // Generate a pseudo-GUID by concatenating random hexadecimal.
  function guid() {
     return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
  };

  // Our Store is represented by a single JS object in *localStorage*. Create it
  // with a meaningful name, like the name you'd give a table.
  // window.Store is deprecated, use Backbone.LocalStorage instead
  var LocalStorage = langx.klass({
    _construct : function(name) {
      this.name = name;
      var store = this.localStorage().getItem(this.name);
      this.records = (store && store.split(",")) || [];
    },

    // Save the current state of the **Store** to *localStorage*.
    save: function() {
      this.localStorage().setItem(this.name, this.records.join(","));
    },

    // Add a model, giving it a (hopefully)-unique GUID, if it doesn't already
    // have an id of it's own.
    create: function(model) {
      if (!model.id) {
        model.id = guid();
        model.set(model.idAttribute, model.id);
      }
      this.localStorage().setItem(this.name+"-"+model.id, JSON.stringify(model));
      this.records.push(model.id.toString());
      this.save();
      return this.find(model);
    },

    // Update a model by replacing its copy in `this.data`.
    update: function(model) {
      this.localStorage().setItem(this.name+"-"+model.id, JSON.stringify(model));
      if (!_.include(this.records, model.id.toString()))
        this.records.push(model.id.toString()); this.save();
      return this.find(model);
    },

    // Retrieve a model from `this.data` by id.
    find: function(model) {
      return this.jsonData(this.localStorage().getItem(this.name+"-"+model.id));
    },

    // Return the array of all entities currently in storage.
    findAll: function() {
      return _(this.records).chain()
        .map(function(id){
          return this.jsonData(this.localStorage().getItem(this.name+"-"+id));
        }, this)
        .compact()
        .value();
    },

    // Delete a model from `this.data`, returning it.
    destroy: function(model) {
      if (model.isNew())
        return false
      this.localStorage().removeItem(this.name+"-"+model.id);
      this.records = _.reject(this.records, function(id){
        return id === model.id.toString();
      });
      this.save();
      return model;
    },

    localStorage: function() {
      return localStorage;
    },

    // fix for "illegal access" error on Android when JSON.parse is passed null
    jsonData: function (data) {
        return data && JSON.parse(data);
    }

  });

  // localSync delegate to the model or collection's
  // *localStorage* property, which should be an instance of `Store`.
  function sync(method, model, options) {
    var store = model.localStorage || model.collection.localStorage;

    var resp, errorMessage, syncDfd = langx.Deferred(); //If $ is having Deferred - use it.

    try {

      switch (method) {
        case "read":
          resp = model.id != undefined ? store.find(model) : store.findAll();
          break;
        case "create":
          resp = store.create(model);
          break;
        case "update":
          resp = store.update(model);
          break;
        case "delete":
          resp = store.destroy(model);
          break;
      }

    } catch(error) {
      if (error.code === DOMException.QUOTA_EXCEEDED_ERR && window.localStorage.length === 0)
        errorMessage = "Private browsing is unsupported";
      else
        errorMessage = error.message;
    }

    if (resp) {
      model.trigger("sync", model, resp, options);
      if (options && options.success)
        options.success(resp);
      if (syncDfd)
        syncDfd.resolve(resp);

    } else {
      errorMessage = errorMessage ? errorMessage
                                  : "Record Not Found";

      if (options && options.error)
        options.error(errorMessage);
      if (syncDfd)
        syncDfd.reject(errorMessage);
    }

    // add compatibility with $.ajax
    // always execute callback for success and error
    if (options && options.complete) options.complete(resp);

    return syncDfd && syncDfd.promise();
  };

  entities.backends.LocalStorage = sync.LocalStorage = LocalStorage;
  
  return entities.backends.localSync = sync;

});
define('skylark-data-entities/main',[
	"./entities",
	"./Collection",
	"./Entity",
	"./sync",
	"./backends/ajaxSync",
	"./backends/localSync",
	"./backends/registry"
],function(entities){
	return entities;
});
define('skylark-data-entities', ['skylark-data-entities/main'], function (main) { return main; });

define('skylark-backbone/backbone',[
	"skylark-langx/skylark",
    "skylark-data-entities",
	"skylark-jquery"
],function(skylark, models,$){
//     from Backbone.js 1.2.3

//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org
	var Backbone  = {
        // set a `X-Http-Method-Override` header.
        emulateHTTP : false,

        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... this will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        emulateJSON : false,

	};
    
    Backbone.$ = $;

    Backbone.sync =    function(method, entity, options) {
	    // Default options, unless specified.
	    langx.defaults(options || (options = {}), {
	      emulateHTTP: Backbone.emulateHTTP,
	      emulateJSON: Backbone.emulateJSON
	    });
	    return models.backends.ajaxSync.apply(this,[method,entity,options]);
	};


	return skylark.attach("itg.backbone",Backbone) ;
});
define('skylark-backbone/events',[
  "skylark-langx/langx",
  "./backbone"
],function(langx,Backbone){
  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Backbone.Events

  var EventExtends = {
      on  : function(name, callback, context){
          var fn =  function() {
            var args = slice.call(arguments,1);
            if (name=="all") {
              args.unshift(arguments[0].type);
            }
            callback.apply(this, args);
          };
          fn._ = callback
          
          return this.overrided(name,fn,context);
      },
        
      once : function(name, callback, context) {
        return this.one(name,callback,context);
      },
      bind : function(name, callback, context) {
          return this.on(name,callback,context);
      },
      
      unbind : function(name, callback, context){
          return this.off(name,callback,context);
      },
    
      stopListening : function(obj, name, callback){
        return this.unlistenTo(obj,name,callback);
      }
   },

  BackboneEvented = langx.Evented.inherit(EventExtends),

  EventedProto = BackboneEvented.prototype;
  
  var Events = Backbone.Events = {
     bind: EventedProto.bind,
     listenTo: EventedProto.listenTo,
     listenToOnce: EventedProto.listenToOnce,
     off: EventedProto.off,
     on : EventedProto.on,
     once: EventedProto.once,
     stopListening: EventedProto.stopListening,
     trigger: EventedProto.trigger,
     unbind: EventedProto.unbind,
     unlistenTo: EventedProto.unlistenTo
  };

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  langx.extend(Backbone, Events);

  return {
    EventExtends : EventExtends,
    BackboneEvented : BackboneEvented
  };

});
define('skylark-backbone/helper',[
  "skylark-langx/langx",
  "skylark-underscore/underscore",
  "./backbone"
],function(langx,_,Backbone){

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function(length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return _[method](this[attribute]);
      };
      case 2: return function(value) {
        return _[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return _[method](this[attribute], cb(iteratee, this), context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return _[method].apply(_, args);
      };
    }
  };

  var addUnderscoreMethods = function(Class, methods, attribute) {
    _.each(methods, function(length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
    return iteratee;
  };

  var modelMatcher = function(attrs) {
    var matcher = _.matches(attrs);
    return function(model) {
      return matcher(model.attributes);
    };
  };

  var extend  = Backbone.extend = function(protoProps, staticProps){
    protoProps.constructor = this._constructor;
    var child = this.inherit(protoProps);
    _.extend(child,staticProps);
  
    return child;
  };

  return {
    addUnderscoreMethods : addUnderscoreMethods,
    extend : extend
  };
});
define('skylark-backbone/Collection',[
  "skylark-langx/langx",
  "skylark-data-entities",
  "./backbone",
  "./events",
  "./helper"
],function(langx,models,Backbone,events,helper){

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.

  var Collection = Backbone.Collection = models.Collection.inherit({
      _construct : function(models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({silent: true}, options));
      },
      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // Proxy `Backbone.sync` by default.
      sync: function() {
        return Backbone.sync.apply(this, arguments);
      }

  });


  // Define the Collection's inheritable methods.
  Collection.partial(events.EventExtends);

  Object.defineProperty(Collection.prototype, "model",{
    get() { return this.entity; },
    set(newValue) { this.entity = newValue; }
  });

  Object.defineProperty(Collection.prototype, "models",{
    get() { return this.entities; },
    set(newValue) { this.entities = newValue; }
  });

  Collection.prototype.modelId = Collection.prototype.entityId;
  Collection.prototype._isModel = Collection.prototype._isEntity;


  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
      foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
      sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};

  // Mix in each Underscore method as a proxy to `Collection#models`.
  helper.addUnderscoreMethods(Collection, collectionMethods, 'models');

  Collection.extend = helper.extend;

  return Collection;

});
define('skylark-backbone/Model',[
  "skylark-langx/langx",
  "skylark-underscore/underscore",
  "skylark-data-entities",
  "./backbone",
  "./events",
  "./helper"
],function(langx,_,models,Backbone,events,helper){

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = models.Entity.inherit({
      _construct : function(attributes, options) {
        langx.Stateful.prototype._construct.apply(this,arguments);
        this.initialize.apply(this, arguments);
      },
      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // Get the HTML-escaped value of an attribute.
      escape: function(attr) {
        return _.escape(this.get(attr));
      },

      // Special-cased proxy to underscore's `_.matches` method.
      matches: function(attrs) {
        return !!_.iteratee(attrs, this)(this.attributes);
      },

      // Proxy `Backbone.sync` by default.
      sync: function() {
        return Backbone.sync.apply(this, arguments);
      }
 });



  // Attach all inheritable methods to the Model prototype.
  Model.partial(events.EventExtends);

  Model.extend = helper.extend;

  return Model;
});
define('skylark-backbone/History',[
  "skylark-langx/langx",
  "skylark-underscore/underscore",
  "./backbone",
  "./events",
  "./helper"
],function(langx,_,Backbone,events,helper){

 // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = events.BackboneEvented.inherit({
    _construct : function() {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);
    
        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
          this.location = window.location;
          this.history = window.history;
        }
    }
  });

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  History.partial({

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var rootPath = path.slice(0, this.root.length - 1) + '/';
      return rootPath === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var rootPath = this.root.slice(0, -1) || '/';
          this.location.replace(rootPath + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function(eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function(eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var rootPath = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        rootPath = rootPath.slice(0, -1) || '/';
      }
      var url = rootPath + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Set up inheritance for the model, collection, router, view and history.
  History.extend = Backbone.extend ;


  return History;

});


define('skylark-backbone/Router',[
  "skylark-langx/langx",
  "skylark-underscore/underscore",
  "./backbone",
  "./events",
  "./helper"
],function(langx,_,Backbone,events,helper){

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = events.BackboneEvented.inherit({
    _construct : function(options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    }
  });


  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  Router.partial({

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Set up inheritance for the model, collection, router, view and history.
  Router.extend = helper.extend;


  return Router;

});


define('skylark-backbone/View',[
  "skylark-langx/langx",
  "skylark-jquery",
  "skylark-domx-noder",
  "skylark-domx-plugins",
  "skylark-underscore/underscore",
  "./backbone",
  "./events",
  "./helper"
],function(langx, $,noder,plugins,_,Backbone,events,helper){
  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...

    var View = Backbone.View = plugins.Plugin.inherit({
      _construct :function(options) {
          this.cid = _.uniqueId('view');
          this.preinitialize.apply(this, arguments);
          _.extend(this, _.pick(options, viewOptions));
          this._ensureElement();
          this.initialize.apply(this, arguments);

      },

      // The default `tagName` of a View's element is `"div"`.
      tagName: 'div',

      // query delegate for element lookup, scoped to DOM elements within the
      // current view. This should be preferred to global lookups where possible.
      $: function(selector) {
        return this.$el.find(selector);
      },

      // preinitialize is an empty function by default. You can override it with a function
      // or object.  preinitialize will run before any instantiation logic is run in the View
      preinitialize: function(){},

      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // **render** is the core function that your view should override, in order
      // to populate its element (`this.el`), with the appropriate HTML. The
      // convention is for **render** to always return `this`.
      render: function() {
        return this;
      },

      // Remove this view by taking the element out of the DOM, and removing any
      // applicable Backbone.Events listeners.
      remove: function() {
        this._removeElement();
        this.unlistenTo();
        return this;
      },

      // Remove this view's element from the document and all event listeners
      // attached to it. Exposed for subclasses using an alternative DOM
      // manipulation API.
      _removeElement: function() {
        this.$el.remove();
      },

      // Change the view's element (`this.el` property) and re-delegate the
      // view's events on the new element.
      setElement: function(element) {
        this.undelegateEvents();
        this._setElement(element);
        this.delegateEvents();
        return this;
      },

      // Creates the `this.el` and `this.$el` references for this view using the
      // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
      // context or an element. Subclasses can override this to utilize an
      // alternative DOM manipulation API and are only required to set the
      // `this.el` property.
      _setElement: function(el) {
        this.$el = $(el);
        this.el = this.$el[0];
      },

      // Set callbacks, where `this.events` is a hash of
      //
      // *{"event selector": "callback"}*
      //
      //     {
      //       'mousedown .title':  'edit',
      //       'click .button':     'save',
      //       'click .open':       function(e) { ... }
      //     }
      //
      // pairs. Callbacks will be bound to the view, with `this` set properly.
      // Uses event delegation for efficiency.
      // Omitting the selector binds the event to `this.el`.
      delegateEvents: function(events) {
        events || (events = langx.result(this, 'events'));
        if (!events) return this;
        this.undelegateEvents();
        for (var key in events) {
          var method = events[key];
          if (!langx.isFunction(method)) method = this[method];
          if (!method) continue;
          var match = key.match(delegateEventSplitter);
          this.delegate(match[1], match[2], langx.proxy(method, this));
        }
        return this;
      },

      // Add a single event listener to the view's element (or a child element
      // using `selector`). This only works for delegate-able events: not `focus`,
      // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
      delegate: function(eventName, selector, listener) {
        this.$el.on(eventName + '.delegateEvents' + this.uid, selector, listener);
        return this;
      },

      // Clears all callbacks previously bound to the view by `delegateEvents`.
      // You usually don't need to use this, but may wish to if you have multiple
      // Backbone views attached to the same DOM element.
      undelegateEvents: function() {
        if (this.$el) this.$el.off('.delegateEvents' + this.uid);
        return this;
      },

      // A finer-grained `undelegateEvents` for removing a single delegated event.
      // `selector` and `listener` are both optional.
      undelegate: function(eventName, selector, listener) {
        this.$el.off(eventName + '.delegateEvents' + this.uid, selector, listener);
        return this;
      },

      // Produces a DOM element to be assigned to your view. Exposed for
      // subclasses using an alternative DOM manipulation API.
      _createElement: function(tagName,attrs) {
        return noder.createElement(tagName,attrs);
      },

      // Ensure that the View has a DOM element to render into.
      // If `this.el` is a string, pass it through `$()`, take the first
      // matching element, and re-assign it to `el`. Otherwise, create
      // an element from the `id`, `className` and `tagName` properties.
      _ensureElement: function() {
        if (!this.el) {
          var attrs = langx.mixin({}, langx.result(this, 'attributes'));
          if (this.id) attrs.id = langx.result(this, 'id');
          if (this.className) attrs['class'] = langx.result(this, 'className');
          this.setElement(this._createElement(langx.result(this, 'tagName'),attrs));
          this._setAttributes(attrs);
        } else {
          this.setElement(langx.result(this, 'el'));
        }
      },

      // Set attributes from a hash on this view's element.  Exposed for
      // subclasses using an alternative DOM manipulation API.
      _setAttributes: function(attributes) {
        this.$el.attr(attributes);
      },
      
    });


  View.partial(events.EventExtends);

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  View.extend = helper.extend;

  return View;
});
define('skylark-backbone/UndoManager',[
  "skylark-langx/langx",
  "skylark-underscore/underscore",
  "./backbone",
  "./Model",
  "./Collection"

],function(langx,_,Backbone,Model,Collection){

	var core_slice = Array.prototype.slice;

	/**
	 * As call is faster than apply, this is a faster version of apply as it uses call.
	 * 
	 * @param  {Function} fn 	The function to execute 
	 * @param  {Object}   ctx 	The context the function should be called in
	 * @param  {Array}    args 	The array of arguments that should be applied to the function
	 * @return Forwards whatever the called function returns
	 */
	function apply (fn, ctx, args) {
		return args.length <= 4 ?
			fn.call(ctx, args[0], args[1], args[2], args[3]) :
			fn.apply(ctx, args);
	}

	/**
	 * Uses slice on an array or an array-like object.
	 * 
	 * @param  {Array|Object} 	arr 	The array or array-like object.
	 * @param  {Number} 		[index]	The index from where the array should be sliced. Default is 0.
	 * @return {Array} The sliced array
	 */
	function slice (arr, index) {
		return core_slice.call(arr, index);
	}

	/**
	 * Checks if an object has one or more specific keys. The keys 
	 * don't have to be an owned property.
	 * You can call this function either this way:
	 * hasKeys(obj, ["a", "b", "c"])
	 * or this way:
	 * hasKeys(obj, "a", "b", "c")
	 * 
	 * @param  {Object}  	obj 	The object to check on
	 * @param  {Array}  	keys 	The keys to check for
	 * @return {Boolean} True, if the object has all those keys
	 */
	function hasKeys (obj, keys) {
		if (obj == null) return false;
		if (!_.isArray(keys)) {
			keys = slice(arguments, 1);
		}
		return _.all(keys, function (key) {
			return key in obj;
		});
	}

	/**
	 * Returns a number that is unique per call stack. The number gets 
	 * changed after the call stack has been completely processed.
	 * 
	 * @return {number} MagicFusionIndex
	 */
	var getMagicFusionIndex = (function () {
		// If you add several models to a collection or set several
		// attributes on a model all in sequence and yet all for
		// example in one function, then several Undo-Actions are
		// generated.
		// If you want to undo your last action only the last model
		// would be removed from the collection or the last set
		// attribute would be changed back to its previous value.
		// To prevent that we have to figure out a way to combine
		// all those actions that happened "at the same time". 
		// Timestamps aren't exact enough. A complex routine could 
		// run several milliseconds and in that time produce a lot 
		// of actions with different timestamps.
		// Instead we take advantage of the single-threadedness of
		// JavaScript:

		var callstackWasIndexed = false, magicFusionIndex = -1;
		function indexCycle() {
			magicFusionIndex++;
			callstackWasIndexed = true;
			_.defer(function () {
				// Here comes the magic. With a Timeout of 0 
				// milliseconds this function gets called whenever
				// the current callstack is completed
				callstackWasIndexed = false;
			})
		}
		return function () {
			if (!callstackWasIndexed) {
				indexCycle();
			}
			return magicFusionIndex;
		}
	})();

	/**
	 * To prevent binding a listener several times to one 
	 * object, we register the objects in an ObjectRegistry
	 *
	 * @constructor
	 */
	function ObjectRegistry () {
		// This uses two different ways of storing
		// objects: In case the object has a cid
		// (which Backbone objects typically have)
		// it uses this cid as an index. That way
		// the Array's length attribute doesn't 
		// change and the object isn't an item 
		// in the array, but an object-property.
		// Otherwise it's added to the Array as an
		// item.
		// That way we can use the fast property-
		// lookup and only have to fall back to 
		// iterating over the array in case 
		// non-Backbone-objects are registered.
		this.registeredObjects = [];
		// To return a list of all registered 
		// objects in the 'get' method we have to
		// store the objects that have a cid in
		// an additional array. 
		this.cidIndexes = [];
	}
	ObjectRegistry.prototype = {
		/**
		 * Returns whether the object is already registered in this ObjectRegistry or not.
		 * 
		 * @this 	{ObjectRegistry}
		 * @param  	{Object} 		 obj 	The object to check
		 * @return 	{Boolean} True if the object is already registered
		 */
		isRegistered: function (obj) {
			// This is where we get a performance boost 
			// by using the two different ways of storing 
			// objects.
			return obj && obj.cid ? this.registeredObjects[obj.cid] : _.contains(this.registeredObjects, obj);
		},
		/**
		 * Registers an object in this ObjectRegistry.
		 * 
		 * @this 	{ObjectRegistry}
		 * @param  	{Object} 		 obj 	The object to register
		 * @return 	{undefined}
		 */
		register: function (obj) {
			if (!this.isRegistered(obj)) {
				if (obj && obj.cid) {
					this.registeredObjects[obj.cid] = obj;
					this.cidIndexes.push(obj.cid);
				} else {
					this.registeredObjects.push(obj);
				}
				return true;
			}
			return false;
		},
		/**
		 * Unregisters an object from this ObjectRegistry.
		 * 
		 * @this {ObjectRegistry}
		 * @param  {Object} obj The object to unregister
		 * @return {undefined}
		 */
		unregister: function (obj) {
			if (this.isRegistered(obj)) {
				if (obj && obj.cid) {
					delete this.registeredObjects[obj.cid];
					this.cidIndexes.splice(_.indexOf(this.cidIndexes, obj.cid), 1);
				} else {
					var i = _.indexOf(this.registeredObjects, obj);
					this.registeredObjects.splice(i, 1);
				}
				return true;
			}
			return false;
		},
		/**
		 * Returns an array of all objects that are currently in this ObjectRegistry.
		 * 
		 * @return {Array} An array of all the objects which are currently in the ObjectRegistry
		 */
		get: function () {
			return (_.map(this.cidIndexes, function (cid) {return this.registeredObjects[cid];}, this)).concat(this.registeredObjects);
		}
	}

	/**
	 * Binds or unbinds the "all"-listener for one or more objects.
	 * 
	 * @param  {String}   which 	Either "on" or "off"
	 * @param  {Object[]} objects 	Array of the objects on which the "all"-listener should be bound / unbound to
	 * @param  {Function} [fn] 		The function that should be bound / unbound. Optional in case of "off"
	 * @param  {Object}   [ctx] 	The context the function should be called in
	 * @return {undefined}
	 */
	function onoff(which, objects, fn, ctx) {
		for (var i = 0, l = objects.length, obj; i < l; i++) {
			obj = objects[i];
			if (!obj) continue;
			if (which === "on") {
				if (!ctx.objectRegistry.register(obj)) {
					// register returned false, so obj was already registered
					continue;
				}
			} else {
				if (!ctx.objectRegistry.unregister(obj)) {
					// unregister returned false, so obj wasn't registered
					continue;
				}
			}
			if (_.isFunction(obj[which])) {
				obj[which]("all", fn, ctx);
			}
		}
	}

	/**
	 * Calls the undo/redo-function for a specific action.
	 * 
	 * @param  {String} which 	Either "undo" or "redo"
	 * @param  {Object} action 	The Action's attributes
	 * @return {undefined}
	 */
	function actionUndoRedo (which, action) {
		var type = action.type, undoTypes = action.undoTypes, fn = !undoTypes[type] || undoTypes[type][which];
		if (_.isFunction(fn)) {
			fn(action.object, action.before, action.after, action.options);
		}
	}

	/**
	 * The main undo/redo function.
	 *
	 * @param  {String} 		which 	    Either "undo" or "redo"
	 * @param  {UndoManager} 	manager	    The UndoManager-instance on which an "undo"/"redo"-Event is triggered afterwards
	 * @param  {UndoStack} 		stack 	    The UndoStack on which we perform
	 * @param  {Boolean} 		magic 	    If true, undoes / redoes all actions with the same magicFusionIndex
	 * @param  {Boolean} 		everything  If true, undoes / redoes every action that had been tracked
	 * @return {undefined}
	 */
	function managerUndoRedo (which, manager, stack, magic, everything) {
		if (stack.isCurrentlyUndoRedoing || 
			(which === "undo" && stack.pointer === -1) ||
			(which === "redo" && stack.pointer === stack.length - 1)) {
			// We're either currently in an undo- / redo-process or 
			// we reached the end of the stack
			return;
		}
		stack.isCurrentlyUndoRedoing = true;
		var action, actions, isUndo = which === "undo";
		if (everything) {
			// Undo / Redo all steps until you reach the stack's beginning / end
			actions = isUndo && stack.pointer === stack.length - 1 || // If at the stack's end calling undo
					  !isUndo && stack.pointer === -1 ? // or at the stack's beginning calling redo
					  _.clone(stack.models) : // => Take all the models. Otherwise:
					  core_slice.apply(stack.models, isUndo ? [0, stack.pointer] : [stack.pointer, stack.length - 1]);
		} else {
			// Undo / Redo only one step
			action = stack.at(isUndo ? stack.pointer : stack.pointer + 1);
			actions = magic ? stack.where({"magicFusionIndex": action.get("magicFusionIndex")}) : [action];
		}
		
		stack.pointer += (isUndo ? -1 : 1) * actions.length;
		while (action = isUndo ? actions.pop() : actions.shift()) {
			// Here we're calling the Action's undo / redo method
			action[which]();
		}
		stack.isCurrentlyUndoRedoing = false;

		manager.trigger(which, manager);
	}

	/**
	 * Checks whether an UndoAction should be created or not. Therefore it checks
	 * whether a "condition" property is set in the undoTypes-object of the specific
	 * event type. If not, it returns true. If it's set and a boolean, it returns it.
	 * If it's a function, it returns its result, converting it into a boolean. 
	 * Otherwise it returns true.
	 * 
	 * @param  {Object} 	undoTypesType 	The object within the UndoTypes that holds the function for this event type (i.e. "change")
	 * @param  {Arguments} 	args       		The arguments the "condition" function is called with
	 * @return {Boolean} 	True, if an UndoAction should be created
	 */
	function validateUndoActionCreation (undoTypesType, args) {
		var condition = undoTypesType.condition, type = typeof condition;
		return type === "function" ? !!apply(condition, undoTypesType, args) :
			type === "boolean" ? condition : true;
	}

	/**
	 * Adds an Undo-Action to the stack.
	 * 
	 * @param {UndoStack} 		stack 		The undostack the action should be added to.
	 * @param {String} 			type 		The event type (i.e. "change")
	 * @param {Arguments} 		args 		The arguments passed to the undoTypes' "on"-handler
	 * @param {OwnedUndoTypes} 	undoTypes 	The undoTypes-object which has the "on"-handler
	 * @return {undefined}
	 */
	function addToStack(stack, type, args, undoTypes) {
		if (stack.track && !stack.isCurrentlyUndoRedoing && type in undoTypes &&
			validateUndoActionCreation(undoTypes[type], args)) {
			// An UndoAction should be created
			var res = apply(undoTypes[type]["on"], undoTypes[type], args), diff;
			if (hasKeys(res, "object", "before", "after")) {
				res.type = type;
				res.magicFusionIndex = getMagicFusionIndex();
				res.undoTypes = undoTypes;
				if (stack.pointer < stack.length - 1) {
					// New Actions must always be added to the end of the stack.
					// If the pointer is not pointed to the last action in the
					// stack, presumably because actions were undone before, then
					// all following actions must be discarded
					var diff = stack.length - stack.pointer - 1;
					while (diff--) {
						stack.pop();
					}
				}
				stack.pointer = stack.length;
				stack.add(res);
				if (stack.length > stack.maximumStackLength) {
					stack.shift();
					stack.pointer--;
				}
			}
		}
	}


	/**
	 * Predefined UndoTypes object with default handlers for the most common events.
	 * @type {Object}
	 */
	var UndoTypes = {
		"add": {
			"undo": function (collection, ignore, model, options) {
				// Undo add = remove
				collection.remove(model, options);
			},
			"redo": function (collection, ignore, model, options) {
				// Redo add = add
				if (options.index) {
					options.at = options.index;
				}
				collection.add(model, options);
			},
			"on": function (model, collection, options) {
				return {
					object: collection,
					before: undefined,
					after: model,
					options: _.clone(options)
				};
			}
		},
		"remove": {
			"undo": function (collection, model, ignore, options) {
				if ("index" in options) {
					options.at = options.index;
				}
				collection.add(model, options);
			},
			"redo": function (collection, model, ignore, options) {
				collection.remove(model, options);
			},
			"on": function (model, collection, options) {
				return {
					object: collection,
					before: model,
					after: undefined,
					options: _.clone(options)
				};
			}
		},
		"change": {
			"undo": function (model, before, after, options) {
				if (_.isEmpty(before)) {
					_.each(_.keys(after), model.unset, model);
				} else {
					model.set(before);
					if (options && options.unsetData && options.unsetData.before && options.unsetData.before.length) {
						_.each(options.unsetData.before, model.unset, model);
					}
				}
			},
			"redo": function (model, before, after, options) {
				if (_.isEmpty(after)) {
					_.each(_.keys(before), model.unset, model);
				} else {
					model.set(after);
					if (options && options.unsetData && options.unsetData.after && options.unsetData.after.length) {
						_.each(options.unsetData.after, model.unset, model);
					}
				}
			},
			"on": function (model, options) {
				var
				afterAttributes = model.changedAttributes(),
				keysAfter = _.keys(afterAttributes),
				previousAttributes = _.pick(model.previousAttributes(), keysAfter),
				keysPrevious = _.keys(previousAttributes),
				unsetData = (options || (options = {})).unsetData = {
					after: [],
					before: []
				};

				if (keysAfter.length != keysPrevious.length) {
					// There are new attributes or old attributes have been unset
					if (keysAfter.length > keysPrevious.length) {
						// New attributes have been added
						_.each(keysAfter, function (val) {
							if (!(val in previousAttributes)) {
								unsetData.before.push(val);
							}
						}, this);
					} else {
						// Old attributes have been unset
						_.each(keysPrevious, function (val) {
							if (!(val in afterAttributes)) {
								unsetData.after.push(val);
							}
						})
					}
				}
				return {
					object: model,
					before: previousAttributes,
					after: afterAttributes,
					options: _.clone(options)
				};
			}
		},
		"reset": {
			"undo": function (collection, before, after) {
				collection.reset(before);
			},
			"redo": function (collection, before, after) {
				collection.reset(after);
			},
			"on": function (collection, options) {
				return {
					object: collection,
					before: options.previousModels,
					after: _.clone(collection.models)
				};
			}
		}
	};

	/**
	 * Every UndoManager instance has an own undoTypes object
	 * which is an instance of OwnedUndoTypes. OwnedUndoTypes' 
	 * prototype is the global UndoTypes object. Changes to the 
	 * global UndoTypes object take effect on every instance of
	 * UndoManager as the object is its prototype. And yet every 
	 * local UndoTypes object can be changed individually.
	 *
	 * @constructor
	 */
	function OwnedUndoTypes () {}
	OwnedUndoTypes.prototype = UndoTypes;

	/**
	 * Adds, changes or removes an undo-type from an UndoTypes-object.
	 * You can call it this way:
	 * manipulateUndoType (1, "reset", {"on": function () {}}, undoTypes)
	 * or this way to perform bulk actions:
	 * manipulateUndoType (1, {"reset": {"on": function () {}}}, undoTypes)
	 * In case of removing undo-types you can pass an Array for performing
	 * bulk actions:
	 * manipulateUndoType(2, ["reset", "change"], undoTypes)
	 * 
	 * @param  {Number} 				  manipType 		Indicates the kind of action to execute: 0 for add, 1 for change, 2 for remove
	 * @param  {String|Object|Array} 	  undoType 			The type of undoType that should be added/changed/removed. Can be an object / array to perform bulk actions
	 * @param  {Object} 				  [fns] 			Object with the functions to add / change. Is optional in case you passed an object as undoType that contains these functions
	 * @param  {OwnedUndoTypes|UndoTypes} undoTypesInstance The undoTypes object to act on
	 * @return {undefined}
	 */
	function manipulateUndoType (manipType, undoType, fns, undoTypesInstance) {
		// manipType, passed by the calling function
		// 0: add
		// 1: change
		// 2: remove
		if (typeof undoType === "object") {
			// bulk action. Iterate over this data.
			return _.each(undoType, function (val, key) {
					if (manipType === 2) { // remove
						// undoType is an array
						manipulateUndoType (manipType, val, fns, undoTypesInstance);
					} else {
						// undoType is an object
						manipulateUndoType (manipType, key, val, fns);
					}
				})
		}

		switch (manipType) {
			case 0: // add
				if (hasKeys(fns, "undo", "redo", "on") && _.all(_.pick(fns, "undo", "redo", "on"), _.isFunction)) {
					undoTypesInstance[undoType] = fns;
				} 
			break;
			case 1: // change
				if (undoTypesInstance[undoType] && _.isObject(fns)) {
					// undoTypeInstance[undoType] may be a prototype's property
					// So, if we did this _.extend(undoTypeInstance[undoType], fns)
					// we would extend the object on the prototype which means
					// that this change would have a global effect
					// Instead we just want to manipulate this instance. That's why
					// we're doing this:
					undoTypesInstance[undoType] = _.extend({}, undoTypesInstance[undoType], fns);
				} 
			break;
			case 2: // remove
				delete undoTypesInstance[undoType]; 
			break;
		}
		return this;
	}

	/**
	 * Instantiating "Action" creates the UndoActions that 
	 * are collected in an UndoStack. It holds all relevant 
	 * data to undo / redo an action and has an undo / redo 
	 * method.
	 */
	var Action = Model.extend({
		defaults: {
			type: null, // "add", "change", "reset", etc.
			object: null, // The object on which the action occurred
			before: null, // The previous values which were changed with this action
			after: null, // The values after this action
			magicFusionIndex: null // The magicFusionIndex helps to combine 
			// all actions that occurred "at the same time" to undo/redo them altogether
		},
		/**
		 * Undoes this action.
		 * @param  {OwnedUndoTypes|UndoTypes} undoTypes The undoTypes object which contains the "undo"-handler that should be used
		 * @return {undefined}
		 */
		undo: function (undoTypes) {
			actionUndoRedo("undo", this.attributes);
		},
		/**
		 * Redoes this action.
		 * @param  {OwnedUndoTypes|UndoTypes} undoTypes The undoTypes object which contains the "redo"-handler that should be used
		 * @return {undefined}
		 */
		redo: function (undoTypes) {
			actionUndoRedo("redo", this.attributes);
		}
	}),
	/**
	 * An UndoStack is a collection of UndoActions in 
	 * chronological order.
	 */
	UndoStack = Collection.extend({
		model: Action,
		pointer: -1, // The pointer indicates the index where we are located within the stack. We start at -1
		track: false,
		isCurrentlyUndoRedoing: false,
		maximumStackLength: Infinity,
		setMaxLength: function (val) {
			this.maximumStackLength = val;
		}
	}),
	/**
	 * An instance of UndoManager can keep track of 
	 * changes to objects and helps to undo them.
	 */
	UndoManager = Model.extend({
		defaults: {
			maximumStackLength: Infinity,
			track: false
		},
		/**
		 * The constructor function.
		 * @param  {attr} 		[attr] Object with parameters. The available parameters are:
		 *                         	   - maximumStackLength {number} 	Set the undo-stack's maximum size
		 *                             - track 				{boolean}	Start tracking changes right away
		 * @return {undefined}
		 */
		initialize: function (attr) {
			this.stack = new UndoStack;
			this.objectRegistry = new ObjectRegistry();
			this.undoTypes = new OwnedUndoTypes();

			// sync the maximumStackLength attribute with our stack
			this.stack.setMaxLength(this.get("maximumStackLength"));
			this.on("change:maximumStackLength", function (model, value) {
				this.stack.setMaxLength(value);
			}, this);

			// Start tracking, if attr.track == true
			if (attr && attr.track) {
				this.startTracking();
			}

			// Register objects passed in the "register" attribute
			if (attr && attr.register) {
				if (_.isArray(attr.register) || _.isArguments(attr.register)) {
					apply(this.register, this, attr.register);
				} else {
					this.register(attr.register);
				}
			}
		},
		/**
		 * Starts tracking. Changes of registered objects won't be processed until you've called this function
		 * @return {undefined}
		 */
		startTracking: function () {
			this.set("track", true);
			this.stack.track = true;
		},
		/**
		 * Stops tracking. Afterwards changes of registered objects won't be processed.
		 * @return {undefined}
		 */
		stopTracking: function () {
			this.set("track", false);
			this.stack.track = false;
		},
		/**
		 * Return the state of the tracking
		 * @return {boolean}
		 */
		isTracking: function () {
			return this.get("track");
		},
		/**
		 * This is the "all"-handler which is bound to registered 
		 * objects. It creates an UndoAction from the event and adds 
		 * it to the stack.
		 * 
		 * @param  {String} 	type 	The event type
		 * @return {undefined}
		 */
		_addToStack: function (type) {
			addToStack(this.stack, type, slice(arguments, 1), this.undoTypes);
		},
		/**
		 * Registers one or more objects to track their changes.
		 * @param {...Object} 	obj 	The object or objects of which changes should be tracked
		 * @return {undefined}
		 */
		register: function () {
			onoff("on", arguments, this._addToStack, this);
		},
		/**
		 * Unregisters one or more objects.
		 * @param {...Object} 	obj 	The object or objects of which changes shouldn't be tracked any longer
		 * @return {undefined}
		 */
		unregister: function () {
			onoff("off", arguments, this._addToStack, this);
		},
		/**
		 * Unregisters all previously registered objects.
		 * @return {undefined}
		 */
		unregisterAll: function () {
			apply(this.unregister, this, this.objectRegistry.get());
		},
		/**
		 * Undoes the last action or the last set of actions in case 'magic' is true.
		 * @param {Boolean} 	[magic] 	If true, all actions that happened basically at the same time are undone together
		 * @return {undefined}
		 */
		undo: function (magic) {
			managerUndoRedo("undo", this, this.stack, magic);
		},

		/**
		 * Undoes all actions ever tracked by the undo manager
		 * @return {undefined}
		 */
		undoAll: function () {
			managerUndoRedo("undo", this, this.stack, false, true);
		},

		/**
		 * Redoes a previously undone action or a set of actions.
		 * @param {Boolean} 	[magic] 	If true, all actions that happened basically at the same time are redone together
		 * @return {undefined}
		 */
		redo: function (magic) {
			managerUndoRedo("redo", this, this.stack, magic);
		},

		/**
		 * Redoes all actions ever tracked by the undo manager
		 * @return {undefined}
		 */
		redoAll: function () {
			managerUndoRedo("redo", this, this.stack, false, true);
		},
		/**
		 * Checks if there's an action in the stack that can be undone / redone
		 * @param  {String} 	type 	Either "undo" or "redo"
		 * @return {Boolean} True if there is a set of actions which can be undone / redone
		 */
		isAvailable: function (type) {
			var s = this.stack, l = s.length;

			switch (type) {
				case "undo": return l > 0 && s.pointer > -1;
				case "redo": return l > 0 && s.pointer < l - 1;
				default: return false;
			}
		},
		/**
		 * Sets the stack-reference to the stack of another undoManager.
		 * @param  {UndoManager} 	undoManager 	The undoManager whose stack-reference is set to this stack
		 * @return {undefined}
		 */
		merge: function (undoManager) {
			// This sets the stack-reference to the stack of another 
			// undoManager so that the stack of this other undoManager 
			// is used by two different managers.
			// This enables to set up a main-undoManager and besides it
			// several others for special, exceptional cases (by using
			// instance-based custom UndoTypes). Models / collections 
			// which need this special treatment are only registered at 
			// those special undoManagers. Those special ones are then 
			// merged into the main-undoManager to write on its stack. 
			// That way it's easier to manage exceptional cases.
			var args = _.isArray(undoManager) ? undoManager : slice(arguments), manager;
			while (manager = args.pop()) {
				if (manager instanceof UndoManager &&
					manager.stack instanceof UndoStack) {
					// set the stack reference to our stack
					manager.stack = this.stack;
				}
			}
		},
		/**
		 * Add an UndoType to this specific UndoManager-instance.
		 * @param {String} type The event this UndoType is made for
		 * @param {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. Must have the properties "undo", "redo" and "on". Can have the property "condition".
		 * @return {undefined}
		 */
		addUndoType: function (type, fns) {
			manipulateUndoType(0, type, fns, this.undoTypes);
		},
		/**
		 * Overwrite properties of an existing UndoType for this specific UndoManager-instance.
		 * @param  {String} type The event the UndoType is made for
		 * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. It extends the existing object.
		 * @return {undefined}
		 */
		changeUndoType: function (type, fns) {
			manipulateUndoType(1, type, fns, this.undoTypes);
		},
		/**
		 * Remove one or more UndoTypes of this specific UndoManager-instance to fall back to the global UndoTypes.
		 * @param  {String|Array} type The event the UndoType that should be removed is made for. You can also pass an array of events.
		 * @return {undefined}
		 */
		removeUndoType: function (type) {
			manipulateUndoType(2, type, undefined, this.undoTypes);
		},

		/**
		 * Removes all actions from the stack.
		 * @return {undefined}
		 */
		clear: function() {
			this.stack.reset();
			this.stack.pointer = -1;
		}
	});

	_.extend(UndoManager, {
		/**
		 * Change the UndoManager's default attributes
		 * @param  {Object} defaultAttributes An object with the new default values.
		 * @return {undefined}
		 */
		defaults: function (defaultAttributes) {
			_.extend(UndoManager.prototype.defaults, defaultAttributes);
		},
		/**
		 * Add an UndoType to the global UndoTypes-object.
		 * @param  {String} type The event this UndoType is made for
		 * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. Must have the properties "undo", "redo" and "on". Can have the property "condition".
		 * @return {undefined}
		 */
		"addUndoType": function (type, fns) {
			manipulateUndoType(0, type, fns, UndoTypes);
		},
		/**
		 * Overwrite properties of an existing UndoType in the global UndoTypes-object.
		 * @param  {String} type The event the UndoType is made for
		 * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. It extends the existing object.
		 * @return {undefined}
		 */
		"changeUndoType": function (type, fns) {
			manipulateUndoType(1, type, fns, UndoTypes)
		},
		/**
		 * Remove one or more UndoTypes of this specific UndoManager-instance to fall back to the global UndoTypes.
		 * @param  {String|Array} type The event the UndoType that should be removed is made for. You can also pass an array of events.
		 * @return {undefined}
		 */
		"removeUndoType": function (type) {
			manipulateUndoType(2, type, undefined, UndoTypes);
		}
	})

	return Backbone.UndoManager = UndoManager;

});

define('skylark-backbone/main',[
	"./backbone",
	"./events",
	"./Collection",
	"./Model",
	"./History",
	"./Router",
	"./View",
	"./UndoManager"
],function(backbone){
	return backbone;
});
define('skylark-backbone', ['skylark-backbone/main'], function (main) { return main; });

define('skylark-grapejs/utils/extender',['skylark-underscore'], function (_) {
    'use strict';
    return ({$}) => {
        return;//modified by lwf
        if ($ && $.prototype.constructor.name !== 'jQuery') {
            const fn = $.fn;
            fn.hide = function () {
                return this.css('display', 'none');
            };
            fn.show = function () {
                return this.css('display', 'block');
            };
            fn.focus = function () {
                const el = this.get(0);
                el && el.focus();
                return this;
            };
            fn.bind = function (ev, h) {
                return this.on(ev, h);
            };
            fn.unbind = function (ev, h) {
                if (_.isObject(ev)) {
                    for (let name in ev) {
                        ev.hasOwnProperty(name) && this.off(name, ev[name]);
                    }
                    return this;
                } else {
                    return this.off(ev, h);
                }
            };
            fn.click = function (h) {
                return h ? this.on('click', h) : this.trigger('click');
            };
            fn.change = function (h) {
                return h ? this.on('change', h) : this.trigger('change');
            };
            fn.keydown = function (h) {
                return h ? this.on('keydown', h) : this.trigger('keydown');
            };
            fn.delegate = function (selector, events, data, handler) {
                if (!handler) {
                    handler = data;
                }
                return this.on(events, selector, function (e) {
                    e.data = data;
                    handler(e);
                });
            };
            fn.scrollLeft = function () {
                let el = this.get(0);
                el = el.nodeType == 9 ? el.defaultView : el;
                let win = el instanceof Window ? el : null;
                return win ? win.pageXOffset : el.scrollLeft || 0;
            };
            fn.scrollTop = function () {
                let el = this.get(0);
                el = el.nodeType == 9 ? el.defaultView : el;
                let win = el instanceof Window ? el : null;
                return win ? win.pageYOffset : el.scrollTop || 0;
            };
            const offset = $.prototype.offset;
            fn.offset = function (coords) {
                let top, left;
                if (coords) {
                    top = coords.top;
                    left = coords.left;
                }
                if (typeof top != 'undefined') {
                    this.css('top', `${ top }px`);
                }
                if (typeof left != 'undefined') {
                    this.css('left', `${ left }px`);
                }
                return offset.call(this);
            };
            $.map = function (items, clb) {
                const ar = [];
                for (var i = 0; i < items.length; i++) {
                    ar.push(clb(items[i], i));
                }
                return ar;
            };
            const indexOf = Array.prototype.indexOf;
            $.inArray = function (val, arr, i) {
                return arr == null ? -1 : indexOf.call(arr, val, i);
            };
            $.Event = function (src, props) {
                if (!(this instanceof $.Event)) {
                    return new $.Event(src, props);
                }
                this.type = src;
                this.isDefaultPrevented = () => false;
            };
        }
    };
});
define('skylark-grapejs/utils/mixins',['skylark-underscore'], function (_) {
    'use strict';
    const elProt = window.Element.prototype;
    const matches = elProt.matches || elProt.webkitMatchesSelector || elProt.mozMatchesSelector || elProt.msMatchesSelector;
    const appendStyles = (styles, opts = {}) => {
        const stls = _.isArray(styles) ? [...styles] : [styles];
        if (stls.length) {
            const href = stls.shift();
            if (href && (!opts.unique || !document.querySelector(`link[href="${ href }"]`))) {
                const {head} = document;
                const link = document.createElement('link');
                link.href = href;
                link.rel = 'stylesheet';
                if (opts.prepand) {
                    head.insertBefore(link, head.firstChild);
                } else {
                    head.appendChild(link);
                }
            }
            appendStyles(stls);
        }
    };
    const shallowDiff = (objOrig, objNew) => {
        const result = {};
        const keysNew = _.keys(objNew);
        for (let prop in objOrig) {
            if (objOrig.hasOwnProperty(prop)) {
                const origValue = objOrig[prop];
                const newValue = objNew[prop];
                if (keysNew.indexOf(prop) >= 0) {
                    if (origValue !== newValue) {
                        result[prop] = newValue;
                    }
                } else {
                    result[prop] = null;
                }
            }
        }
        for (let prop in objNew) {
            if (objNew.hasOwnProperty(prop)) {
                if (_.isUndefined(objOrig[prop])) {
                    result[prop] = objNew[prop];
                }
            }
        }
        return result;
    };
    const on = (el, ev, fn) => {
        ev = ev.split(/\s+/);
        el = el instanceof Array ? el : [el];
        for (let i = 0; i < ev.length; ++i) {
            el.forEach(elem => elem.addEventListener(ev[i], fn));
        }
    };
    const off = (el, ev, fn) => {
        ev = ev.split(/\s+/);
        el = el instanceof Array ? el : [el];
        for (let i = 0; i < ev.length; ++i) {
            el.forEach(elem => elem.removeEventListener(ev[i], fn));
        }
    };
    const getUnitFromValue = value => {
        return value.replace(parseFloat(value), '');
    };
    const upFirst = value => value[0].toUpperCase() + value.toLowerCase().slice(1);
    const camelCase = value => {
        const values = value.split('-').filter(String);
        return values[0].toLowerCase() + values.slice(1).map(upFirst);
    };
    const normalizeFloat = (value, step = 1, valueDef = 0) => {
        let stepDecimals = 0;
        if (isNaN(value))
            return valueDef;
        value = parseFloat(value);
        if (Math.floor(value) !== value) {
            const side = step.toString().split('.')[1];
            stepDecimals = side ? side.length : 0;
        }
        return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
    };
    const hasDnd = em => {
        return 'draggable' in document.createElement('i') && (em ? em.get('Config').nativeDnD : 1);
    };
    const getElement = el => {
        if (_.isElement(el) || isTextNode(el)) {
            return el;
        } else if (el && el.getEl) {
            return el.getEl();
        }
    };
    const isTextNode = el => el && el.nodeType === 3;
    const isCommentNode = el => el && el.nodeType === 8;
    const isTaggableNode = el => el && !isTextNode(el) && !isCommentNode(el);
    const getModel = (el, $) => {
        let model = el;
        _.isElement(el) && (model = $(el).data('model'));
        return model;
    };
    const getElRect = el => {
        const def = {
            top: 0,
            left: 0,
            width: 0,
            height: 0
        };
        if (!el)
            return def;
        let rectText;
        if (isTextNode(el)) {
            const range = document.createRange();
            range.selectNode(el);
            rectText = range.getBoundingClientRect();
            range.detach();
        }
        return rectText || (el.getBoundingClientRect ? el.getBoundingClientRect() : def);
    };
    const getPointerEvent = ev => ev.touches && ev.touches[0] ? ev.touches[0] : ev;
    const getKeyCode = ev => ev.which || ev.keyCode;
    const getKeyChar = ev => String.fromCharCode(getKeyCode(ev));
    const isEscKey = ev => getKeyCode(ev) === 27;
    const capitalize = str => str && str.charAt(0).toUpperCase() + str.substring(1);
    const isComponent = obj => obj && obj.toHTML;
    const isRule = obj => obj && obj.toCSS;
    const getViewEl = el => el.__gjsv;
    const setViewEl = (el, view) => {
        el.__gjsv = view;
    };
    return {
        isCommentNode: isCommentNode,
        isTaggableNode: isTaggableNode,
        on,
        off,
        hasDnd,
        upFirst,
        matches,
        getModel,
        getElRect,
        camelCase,
        isTextNode,
        getKeyCode,
        getKeyChar,
        isEscKey,
        getElement,
        shallowDiff,
        normalizeFloat,
        getPointerEvent,
        getUnitFromValue,
        capitalize,
        getViewEl,
        setViewEl,
        appendStyles,
        isComponent,
        isRule
    };
});
define('skylark-grapejs/utils/Dragger',[
    "skylark-langx/langx",
    'skylark-underscore',
    './mixins'
], function (langx,_, mixins) {
    'use strict';
    const resetPos = () => ({
        x: 0,
        y: 0
    });
    return class Dragger {
        constructor(opts = {}) {
            this.opts = {
                container: null,
                onStart: null,
                onDrag: null,
                onEnd: null,
                setPosition: null,
                getPosition: null,
                guidesStatic: null,
                guidesTarget: null,
                snapOffset: 5,
                doc: 0,
                scale: 1
            };
            _.bindAll(this, 'drag', 'stop', 'keyHandle', 'handleScroll');
            this.setOptions(opts);
            this.delta = resetPos();
            return this;
        }
        setOptions(opts = {}) {
            this.opts = langx.mixin({},this.opts,opts);
        }
        toggleDrag(enable) {
            const docs = this.getDocumentEl();
            const container = this.getContainerEl();
            const win = this.getWindowEl();
            const method = enable ? 'on' : 'off';

            mixins[method](container, 'mousemove dragover', this.drag);
            mixins[method](docs, 'mouseup dragend touchend', this.stop);
            mixins[method](docs, 'keydown', this.keyHandle);
            mixins[method](win, 'scroll', this.handleScroll);
        }
        handleScroll() {
            const {lastScroll, delta} = this;
            const actualScroll = this.getScrollInfo();
            const scrollDiff = {
                x: actualScroll.x - lastScroll.x,
                y: actualScroll.y - lastScroll.y
            };
            this.move(delta.x + scrollDiff.x, delta.y + scrollDiff.y);
            this.lastScrollDiff = scrollDiff;
        }
        start(ev) {
            const {opts} = this;
            const {onStart} = opts;
            this.toggleDrag(1);
            this.startPointer = this.getPointerPos(ev);
            this.guidesStatic = _.result(opts, 'guidesStatic') || [];
            this.guidesTarget = _.result(opts, 'guidesTarget') || [];
            _.isFunction(onStart) && onStart(ev, this);
            this.startPosition = this.getStartPosition();
            this.lastScrollDiff = resetPos();
            this.globScrollDiff = resetPos();
            this.drag(ev);
        }
        drag(ev) {
            const {opts, lastScrollDiff, globScrollDiff} = this;
            const {onDrag} = opts;
            const {startPointer} = this;
            const currentPos = this.getPointerPos(ev);
            const glDiff = {
                x: globScrollDiff.x + lastScrollDiff.x,
                y: globScrollDiff.y + lastScrollDiff.y
            };
            this.globScrollDiff = glDiff;
            const delta = {
                x: currentPos.x - startPointer.x + glDiff.x,
                y: currentPos.y - startPointer.y + glDiff.y
            };
            this.lastScrollDiff = resetPos();
            let {lockedAxis} = this;
            if (ev.shiftKey) {
                lockedAxis = !lockedAxis && this.detectAxisLock(delta.x, delta.y);
            } else {
                lockedAxis = null;
            }
            if (lockedAxis === 'x') {
                delta.x = startPointer.x;
            } else if (lockedAxis === 'y') {
                delta.y = startPointer.y;
            }
            const moveDelta = delta => {
                [
                    'x',
                    'y'
                ].forEach(co => delta[co] = delta[co] * _.result(opts, 'scale'));
                this.delta = delta;
                this.move(delta.x, delta.y);
                _.isFunction(onDrag) && onDrag(ev, this);
            };
            const deltaPre = langx.clone(delta);
            this.currentPointer = currentPos;
            this.lockedAxis = lockedAxis;
            this.lastScroll = this.getScrollInfo();
            moveDelta(delta);
            if (this.guidesTarget.length) {
                const {newDelta, trgX, trgY} = this.snapGuides(deltaPre);
                (trgX || trgY) && moveDelta(newDelta);
            }
            ev.which === 0 && this.stop(ev);
        }
        snapGuides(delta) {
            const newDelta = delta;
            let {trgX, trgY} = this;
            this.guidesTarget.forEach(trg => {
                if (trg.x && this.trgX || trg.y && this.trgY)
                    return;
                trg.active = 0;
                this.guidesStatic.forEach(stat => {
                    if (trg.y && stat.x || trg.x && stat.y)
                        return;
                    const isY = trg.y && stat.y;
                    const axs = isY ? 'y' : 'x';
                    const trgPoint = trg[axs];
                    const statPoint = stat[axs];
                    const deltaPoint = delta[axs];
                    const trgGuide = isY ? trgY : trgX;
                    if (this.isPointIn(trgPoint, statPoint)) {
                        if (_.isUndefined(trgGuide)) {
                            const trgValue = deltaPoint - (trgPoint - statPoint);
                            this.setGuideLock(trg, trgValue);
                        }
                    }
                });
            });
            trgX = this.trgX;
            trgY = this.trgY;
            [
                'x',
                'y'
            ].forEach(co => {
                const axis = co.toUpperCase();
                let trg = this[`trg${ axis }`];
                if (trg && !this.isPointIn(delta[co], trg.lock)) {
                    this.setGuideLock(trg, null);
                    trg = null;
                }
                if (trg && !_.isUndefined(trg.lock)) {
                    newDelta[co] = trg.lock;
                }
            });
            return {
                newDelta,
                trgX: this.trgX,
                trgY: this.trgY
            };
        }
        isPointIn(src, trg, {offset} = {}) {
            const ofst = offset || this.opts.snapOffset;
            return src >= trg && src <= trg + ofst || src <= trg && src >= trg - ofst;
        }
        setGuideLock(guide, value) {
            const axis = !_.isUndefined(guide.x) ? 'X' : 'Y';
            const trgName = `trg${ axis }`;
            if (value !== null) {
                guide.active = 1;
                guide.lock = value;
                this[trgName] = guide;
            } else {
                delete guide.active;
                delete guide.lock;
                delete this[trgName];
            }
            return guide;
        }
        stop(ev, opts = {}) {
            const {delta} = this;
            const cancelled = opts.cancel;
            const x = cancelled ? 0 : delta.x;
            const y = cancelled ? 0 : delta.y;
            this.toggleDrag();
            this.lockedAxis = null;
            this.move(x, y, 1);
            const {onEnd} = this.opts;
            _.isFunction(onEnd) && onEnd(ev, this, { cancelled });
        }
        keyHandle(ev) {
            if (mixins.isEscKey(ev)) {
                this.stop(ev, { cancel: 1 });
            }
        }
        move(x, y, end) {
            const {el, opts} = this;
            const pos = this.startPosition;
            if (!pos)
                return;
            const {setPosition} = opts;
            const xPos = pos.x + x;
            const yPos = pos.y + y;
            this.position = {
                x: xPos,
                y: yPos,
                end
            };
            _.isFunction(setPosition) && setPosition(this.position);
            if (el) {
                el.style.left = `${ xPos }px`;
                el.style.top = `${ yPos }px`;
            }
        }
        getContainerEl() {
            const {container} = this.opts;
            return container ? [container] : this.getDocumentEl();
        }
        getWindowEl() {
            const cont = this.getContainerEl();
            return cont.map(item => {
                const doc = item.ownerDocument || item;
                return doc.defaultView || doc.parentWindow;
            });
        }
        getDocumentEl(el) {
            const {doc} = this.opts;
            el = el || this.el;
            if (!this.docs) {
                const docs = [document];
                el && docs.push(el.ownerDocument);
                doc && docs.push(doc);
                this.docs = docs;
            }
            return this.docs;
        }
        getPointerPos(ev) {
            const getPos = this.opts.getPointerPosition;
            const pEv = mixins.getPointerEvent(ev);
            return getPos ? getPos(ev) : {
                x: pEv.clientX,
                y: pEv.clientY
            };
        }
        getStartPosition() {
            const {el, opts} = this;
            const getPos = opts.getPosition;
            let result = resetPos();
            if (_.isFunction(getPos)) {
                result = getPos();
            } else if (el) {
                result = {
                    x: parseFloat(el.style.left),
                    y: parseFloat(el.style.top)
                };
            }
            return result;
        }
        getScrollInfo() {
            const {doc} = this.opts;
            const body = doc && doc.body;
            return {
                y: body ? body.scrollTop : 0,
                x: body ? body.scrollLeft : 0
            };
        }
        detectAxisLock(x, y) {
            const relX = x;
            const relY = y;
            const absX = Math.abs(relX);
            const absY = Math.abs(relY);
            if (relY >= absX || relY <= -absX) {
                return 'x';
            } else if (relX > absY || relX < -absY) {
                return 'y';
            }
        }
    };
});
define('skylark-grapejs/utils/Sorter',[
    'skylark-backbone',
    'skylark-underscore',
    './mixins'
], function (Backbone, _, mixins) {
    'use strict';
    const $ = Backbone.$;
    return Backbone.View.extend({
        initialize(opt) {
            this.opt = opt || {};
            _.bindAll(this, 'startSort', 'onMove', 'endMove', 'rollback', 'updateOffset', 'moveDragHelper');
            var o = opt || {};
            this.elT = 0;
            this.elL = 0;
            this.borderOffset = o.borderOffset || 10;
            var el = o.container;
            this.el = typeof el === 'string' ? document.querySelector(el) : el;
            this.$el = $(this.el);
            this.containerSel = o.containerSel || 'div';
            this.itemSel = o.itemSel || 'div';
            this.draggable = o.draggable || true;
            this.nested = o.nested || 0;
            this.pfx = o.pfx || '';
            this.ppfx = o.ppfx || '';
            this.freezeClass = o.freezeClass || this.pfx + 'freezed';
            this.onStart = o.onStart || '';
            this.onEndMove = o.onEndMove || '';
            this.direction = o.direction || 'v';
            this.onMoveClb = o.onMove || '';
            this.relative = o.relative || 0;
            this.ignoreViewChildren = o.ignoreViewChildren || 0;
            this.ignoreModels = o.ignoreModels || 0;
            this.plh = o.placer || '';
            this.wmargin = o.wmargin || 0;
            this.offTop = o.offsetTop || 0;
            this.offLeft = o.offsetLeft || 0;
            this.document = o.document || document;
            this.$document = $(this.document);
            this.dropContent = null;
            this.em = o.em || '';
            this.dragHelper = null;
            this.canvasRelative = o.canvasRelative || 0;
            this.selectOnEnd = !o.avoidSelectOnEnd;
            this.scale = o.scale;
            this.activeTextModel = null;
            if (this.em && this.em.undefined) {
                this.em.undefined('change:canvasOffset', this.updateOffset);
                this.updateOffset();
            }
        },
        getScale() {
            return _.result(this, scale) || 1;
        },
        getContainerEl(elem) {
            if (elem)
                this.el = elem;
            if (!this.el) {
                var el = this.opt.container;
                this.el = typeof el === 'string' ? document.querySelector(el) : el;
                this.$el = $(this.el);
            }
            return this.el;
        },
        getDocuments(el) {
            const em = this.em;
            const elDoc = el ? el.ownerDocument : em && em.get('Canvas').getBody().ownerDocument;
            const docs = [document];
            elDoc && docs.push(elDoc);
            return docs;
        },
        updateOffset() {
            const offset = this.em.get('canvasOffset') || {};
            this.offTop = offset.top;
            this.offLeft = offset.left;
        },
        setDropContent(content) {
            this.dropModel = null;
            this.dropContent = content;
        },
        updateTextViewCursorPosition(e) {
            const Canvas = this.em.get('Canvas');
            const targetDoc = Canvas.getDocument();
            let range = null;
            if (targetDoc.caretRangeFromPoint) {
                const poiner = mixins.getPointerEvent(e);
                range = targetDoc.caretRangeFromPoint(poiner.clientX, poiner.clientY);
            } else if (e.rangeParent) {
                range = targetDoc.createRange();
                range.setStart(e.rangeParent, e.rangeOffset);
            }
            const sel = Canvas.getWindow().getSelection();
            Canvas.getFrameEl().focus();
            sel.removeAllRanges();
            range && sel.addRange(range);
        },
        setContentEditable(model, mode) {
            if (model) {
                const el = model.getEl();
                if (el.contentEditable != mode)
                    el.contentEditable = mode;
            }
        },
        toggleSortCursor(active) {
            const {em} = this;
            const cv = em && em.get('Canvas');
            cv && (active ? cv.startAutoscroll() : cv.stopAutoscroll());
        },
        setDragHelper(el, event) {
            const ev = event || '';
            const clonedEl = el.cloneNode(1);
            const rect = el.getBoundingClientRect();
            const computed = getComputedStyle(el);
            let style = '';
            for (var i = 0; i < computed.length; i++) {
                const prop = computed[i];
                style += `${ prop }:${ computed.getPropertyValue(prop) };`;
            }
            document.body.appendChild(clonedEl);
            clonedEl.className += ` ${ this.pfx }bdrag`;
            clonedEl.setAttribute('style', style);
            this.dragHelper = clonedEl;
            clonedEl.style.width = `${ rect.width }px`;
            clonedEl.style.height = `${ rect.height }px`;
            ev && this.moveDragHelper(ev);
            if (this.em) {
                $(this.em.get('Canvas').getBody().ownerDocument).undefined('mousemove', this.moveDragHelper).undefined('mousemove', this.moveDragHelper);
            }
            $(document).undefined('mousemove', this.moveDragHelper).undefined('mousemove', this.moveDragHelper);
        },
        moveDragHelper(e) {
            const doc = e.target.ownerDocument;
            if (!this.dragHelper || !doc) {
                return;
            }
            let posY = e.pageY;
            let posX = e.pageX;
            let addTop = 0;
            let addLeft = 0;
            const window = doc.defaultView || doc.parentWindow;
            const frame = window.frameElement;
            const dragHelperStyle = this.dragHelper.style;
            if (frame) {
                const frameRect = frame.getBoundingClientRect();
                addTop = frameRect.top + document.documentElement.scrollTop;
                addLeft = frameRect.left + document.documentElement.scrollLeft;
                posY = e.clientY;
                posX = e.clientX;
            }
            dragHelperStyle.top = posY + addTop + 'px';
            dragHelperStyle.left = posX + addLeft + 'px';
        },
        matches(el, selector, useBody) {
            return mixins.matches.call(el, selector);
        },
        closest(el, selector) {
            if (!el)
                return;
            var elem = el.parentNode;
            while (elem && elem.nodeType === 1) {
                if (this.undefined(elem, selector))
                    return elem;
                elem = elem.parentNode;
            }
            return null;
        },
        offset(el) {
            var rect = el.getBoundingClientRect();
            return {
                top: rect.top + document.body.scrollTop,
                left: rect.left + document.body.scrollLeft
            };
        },
        createPlaceholder() {
            var pfx = this.pfx;
            var el = document.createElement('div');
            var ins = document.createElement('div');
            el.className = pfx + 'placeholder';
            el.style.display = 'none';
            el.style['pointer-events'] = 'none';
            ins.className = pfx + 'placeholder-int';
            el.appendChild(ins);
            return el;
        },
        startSort(src, opts = {}) {
            const em = this.em;
            const itemSel = this.itemSel;
            const contSel = this.containerSel;
            const container = this.getContainerEl(opts.container);
            const docs = this.getDocuments(src);
            const onStart = this.onStart;
            let srcModel;
            let plh = this.plh;
            this.dropModel = null;
            this.target = null;
            this.prevTarget = null;
            this.moved = 0;
            if (src && !this.undefined(src, `${ itemSel }, ${ contSel }`)) {
                src = this.closest(src, itemSel);
            }
            this.eV = src;
            if (!plh) {
                plh = this.createPlaceholder();
                container.appendChild(plh);
                this.plh = plh;
            }
            if (src) {
                srcModel = this.getSourceModel(src);
                srcModel && srcModel.set && srcModel.set('status', 'freezed');
                this.srcModel = srcModel;
            }
            mixins.on(container, 'mousemove dragover', this.onMove);
            mixins.on(docs, 'mouseup dragend touchend', this.endMove);
            mixins.on(docs, 'keydown', this.rollback);
            onStart && onStart({
                target: srcModel,
                parent: srcModel && srcModel.parent(),
                index: srcModel && srcModel.index()
            });
            em && em.clearSelection();
            this.toggleSortCursor(1);
            em && em.trigger('sorter:drag:start', src, srcModel);
        },
        getTargetModel(el) {
            let elem = el || this.target;
            return $(elem).data('model');
        },
        getSourceModel(source, {target, avoidChildren = 1} = {}) {
            const {em, eV} = this;
            const src = source || eV;
            let {dropModel, dropContent} = this;
            const isTextable = src => src && target && src.opt && src.opt.avoidChildren && this.isTextableActive(src, target);
            if (dropContent && em) {
                if (isTextable(dropModel)) {
                    dropModel = null;
                }
                if (!dropModel) {
                    const comps = em.get('DomComponents').getComponents();
                    const opts = {
                        avoidChildren,
                        avoidStore: 1,
                        avoidUpdateStyle: 1
                    };
                    const tempModel = comps.add(dropContent, langx.mixin({},opts,{
                        temporary: 1
                    }));
                    dropModel = comps.remove(tempModel, opts);
                    dropModel = dropModel instanceof Array ? dropModel[0] : dropModel;
                    this.dropModel = dropModel;
                    if (isTextable(dropModel)) {
                        return this.getSourceModel(src, {
                            target,
                            avoidChildren: 0
                        });
                    }
                }
                return dropModel;
            }
            return src && $(src).data('model');
        },
        selectTargetModel(model) {
            if (model instanceof Backbone.Collection) {
                return;
            }
            const {targetModel} = this;
            if (targetModel && targetModel !== this.srcModel) {
                targetModel.set('status', '');
            }
            if (model && model.set) {
                model.set('status', 'selected-parent');
                this.targetModel = model;
            }
        },
        onMove(e) {
            const ev = e;
            const {em, onMoveClb, plh} = this;
            this.moved = 1;
            var dsp = plh.style.display;
            if (!dsp || dsp === 'none')
                plh.style.display = 'block';
            var eO = this.offset(this.el);
            this.elT = this.wmargin ? Math.abs(eO.top) : eO.top;
            this.elL = this.wmargin ? Math.abs(eO.left) : eO.left;
            var rY = e.pageY - this.elT + this.el.scrollTop;
            var rX = e.pageX - this.elL + this.el.scrollLeft;
            if (this.canvasRelative && em) {
                const mousePos = em.get('Canvas').getMouseRelativeCanvas(e, { noScroll: 1 });
                rX = mousePos.x;
                rY = mousePos.y;
            }
            this.rX = rX;
            this.rY = rY;
            this.eventMove = e;
            const sourceModel = this.getSourceModel();
            const dims = this.dimsFromTarget(e.target, rX, rY);
            const target = this.target;
            const targetModel = target && this.getTargetModel(target);
            this.selectTargetModel(targetModel);
            if (!targetModel)
                plh.style.display = 'none';
            if (!target)
                return;
            this.lastDims = dims;
            const pos = this.findPosition(dims, rX, rY);
            if (this.isTextableActive(sourceModel, targetModel)) {
                this.activeTextModel = targetModel;
                this.setContentEditable(targetModel, true);
                plh.style.display = 'none';
                this.lastPos = pos;
                this.updateTextViewCursorPosition(ev);
            } else {
                this.disableTextable();
                this.activeTextModel = null;
                if (!this.lastPos || (this.lastPos.index != pos.index || this.lastPos.method != pos.method)) {
                    this.movePlaceholder(this.plh, dims, pos, this.prevTargetDim);
                    if (!this.$plh)
                        this.$plh = $(this.plh);
                    if (!this.canvasRelative) {
                        if (this.offTop)
                            this.$plh.css('top', '+=' + this.offTop + 'px');
                        if (this.offLeft)
                            this.$plh.css('left', '+=' + this.offLeft + 'px');
                    }
                    this.lastPos = pos;
                }
            }
            _.isFunction(onMoveClb) && onMoveClb({
                event: e,
                target: sourceModel,
                parent: targetModel,
                index: pos.index + (pos.method == 'after' ? 1 : 0)
            });
            em && em.trigger('sorter:drag', {
                target,
                targetModel,
                sourceModel,
                dims,
                pos,
                x: rX,
                y: rY
            });
        },
        isTextableActive(src, trg) {
            return src && src.get && src.get('textable') && trg && trg.is('text');
        },
        disableTextable() {
            const {activeTextModel} = this;
            activeTextModel && activeTextModel.getView().disableEditing();
        },
        isInFlow(el, parent) {
            if (!el)
                return false;
            parent = parent || document.body;
            var ch = -1, h;
            var elem = el;
            h = elem.offsetHeight;
            if (!this.styleInFlow(elem, parent))
                return false;
            else
                return true;
        },
        styleInFlow(el, parent) {
            if (mixins.isTextNode(el))
                return;
            const style = el.style || {};
            const $el = $(el);
            const $parent = parent && $(parent);
            if (style.overflow && style.overflow !== 'visible')
                return;
            if ($el.css('float') !== 'none')
                return;
            if ($parent && $parent.css('display') == 'flex' && $parent.css('flex-direction') !== 'column')
                return;
            switch (style.position) {
            case 'static':
            case 'relative':
            case '':
                break;
            default:
                return;
            }
            switch (el.tagName) {
            case 'TR':
            case 'TBODY':
            case 'THEAD':
            case 'TFOOT':
                return true;
            }
            switch ($el.css('display')) {
            case 'block':
            case 'list-item':
            case 'table':
            case 'flex':
                return true;
            }
            return;
        },
        validTarget(trg, src) {
            const trgModel = this.getTargetModel(trg);
            const srcModel = this.getSourceModel(src, { target: trgModel });
            src = srcModel && srcModel.view && srcModel.view.el;
            trg = trgModel && trgModel.view && trgModel.view.el;
            let result = {
                valid: true,
                src,
                srcModel,
                trg,
                trgModel
            };
            if (!src || !trg) {
                result.valid = false;
                return result;
            }
            let draggable = srcModel.get('draggable');
            draggable = draggable instanceof Array ? draggable.join(', ') : draggable;
            result.dragInfo = draggable;
            draggable = _.isString(draggable) ? this.undefined(trg, draggable) : draggable;
            result.draggable = draggable;
            let droppable = trgModel.get('droppable');
            droppable = droppable instanceof Backbone.Collection ? 1 : droppable;
            droppable = droppable instanceof Array ? droppable.join(', ') : droppable;
            result.dropInfo = droppable;
            droppable = _.isString(droppable) ? this.undefined(src, droppable) : droppable;
            droppable = draggable && this.isTextableActive(srcModel, trgModel) ? 1 : droppable;
            result.droppable = droppable;
            if (!droppable || !draggable) {
                result.valid = false;
            }
            return result;
        },
        dimsFromTarget(target, rX, rY) {
            const em = this.em;
            var dims = [];
            if (!target) {
                return dims;
            }
            if (!this.undefined(target, `${ this.itemSel }, ${ this.containerSel }`)) {
                target = this.closest(target, this.itemSel);
            }
            if (this.draggable instanceof Array) {
                target = this.closest(target, this.draggable.join(','));
            }
            if (!target) {
                return dims;
            }
            if (this.prevTarget && this.prevTarget != target) {
                this.prevTarget = null;
            }
            if (!this.prevTarget) {
                this.targetP = this.closest(target, this.containerSel);
                let validResult = this.validTarget(target);
                em && em.trigger('sorter:drag:validation', validResult);
                if (!validResult.valid && this.targetP) {
                    return this.dimsFromTarget(this.targetP, rX, rY);
                }
                this.prevTarget = target;
                this.prevTargetDim = this.getDim(target);
                this.cacheDimsP = this.getChildrenDim(this.targetP);
                this.cacheDims = this.getChildrenDim(target);
            }
            if (this.prevTarget == target)
                dims = this.cacheDims;
            this.target = this.prevTarget;
            if (this.nearBorders(this.prevTargetDim, rX, rY) || !this.nested && !this.cacheDims.length) {
                const targetParent = this.targetP;
                if (targetParent && this.validTarget(targetParent).valid) {
                    dims = this.cacheDimsP;
                    this.target = targetParent;
                }
            }
            this.lastPos = null;
            return dims;
        },
        getTargetFromEl(el) {
            let target = el;
            let targetParent;
            let targetPrev = this.targetPrev;
            const em = this.em;
            const containerSel = this.containerSel;
            const itemSel = this.itemSel;
            if (!this.undefined(target, `${ itemSel }, ${ containerSel }`)) {
                target = this.closest(target, itemSel);
            }
            if (this.draggable instanceof Array) {
                target = this.closest(target, this.draggable.join(','));
            }
            if (targetPrev && targetPrev != target) {
                this.targetPrev = '';
            }
            if (!this.targetPrev) {
                targetParent = this.closest(target, containerSel);
                const validResult = this.validTarget(target);
                em && em.trigger('sorter:drag:validation', validResult);
                if (!validResult.valid && targetParent) {
                    return this.getTargetFromEl(targetParent);
                }
                this.targetPrev = target;
            }
            if (this.nearElBorders(target)) {
                targetParent = this.closest(target, containerSel);
                if (targetParent && this.validTarget(targetParent).valid) {
                    target = targetParent;
                }
            }
            return target;
        },
        nearElBorders(el) {
            const off = 10;
            const rect = el.getBoundingClientRect();
            const body = el.ownerDocument.body;
            const {x, y} = this.getCurrentPos();
            const top = rect.top + body.scrollTop;
            const left = rect.left + body.scrollLeft;
            const width = rect.width;
            const height = rect.height;
            if (y < top + off || y > top + height - off || x < left + off || x > left + width - off) {
                return 1;
            }
        },
        getCurrentPos() {
            const ev = this.eventMove;
            const x = ev.pageX || 0;
            const y = ev.pageY || 0;
            return {
                x,
                y
            };
        },
        getDim(el) {
            const {em, canvasRelative} = this;
            var top, left, height, width;
            if (canvasRelative && em) {
                const canvas = em.get('Canvas');
                const pos = canvas.getElementPos(el, { noScroll: 1 });
                const elOffsets = canvas.getElementOffsets(el);
                top = pos.top - elOffsets.marginTop;
                left = pos.left - elOffsets.marginLeft;
                height = pos.height + elOffsets.marginTop + elOffsets.marginBottom;
                width = pos.width + elOffsets.marginLeft + elOffsets.marginRight;
            } else {
                var o = this.offset(el);
                top = this.relative ? el.offsetTop : o.top - (this.wmargin ? -1 : 1) * this.elT;
                left = this.relative ? el.offsetLeft : o.left - (this.wmargin ? -1 : 1) * this.elL;
                height = el.offsetHeight;
                width = el.offsetWidth;
            }
            return [
                top,
                left,
                height,
                width
            ];
        },
        getChildrenDim(trg) {
            const dims = [];
            if (!trg)
                return dims;
            const trgModel = this.getTargetModel(trg);
            if (trgModel && trgModel.view && !this.ignoreViewChildren) {
                const view = trgModel.getCurrentView ? trgModel.getCurrentView() : trgModel.view;
                trg = view.getChildrenContainer();
            }
            _.each(trg.children, (el, i) => {
                const model = mixins.getModel(el, $);
                const elIndex = model && model.index ? model.index() : i;
                if (!mixins.isTextNode(el) && !this.undefined(el, this.itemSel)) {
                    return;
                }
                const dim = this.getDim(el);
                let dir = this.direction;
                if (dir == 'v')
                    dir = true;
                else if (dir == 'h')
                    dir = false;
                else
                    dir = this.isInFlow(el, trg);
                dim.push(dir, el, elIndex);
                dims.push(dim);
            });
            return dims;
        },
        nearBorders(dim, rX, rY) {
            var result = 0;
            var off = this.borderOffset;
            var x = rX || 0;
            var y = rY || 0;
            var t = dim[0];
            var l = dim[1];
            var h = dim[2];
            var w = dim[3];
            if (t + off > y || y > t + h - off || l + off > x || x > l + w - off)
                result = 1;
            return !!result;
        },
        findPosition(dims, posX, posY) {
            var result = {
                index: 0,
                indexEl: 0,
                method: 'before'
            };
            var leftLimit = 0, xLimit = 0, dimRight = 0, yLimit = 0, xCenter = 0, yCenter = 0, dimDown = 0, dim = 0;
            for (var i = 0, len = dims.length; i < len; i++) {
                dim = dims[i];
                dimRight = dim[1] + dim[3];
                dimDown = dim[0] + dim[2];
                xCenter = dim[1] + dim[3] / 2;
                yCenter = dim[0] + dim[2] / 2;
                if (xLimit && dim[1] > xLimit || yLimit && yCenter >= yLimit || leftLimit && dimRight < leftLimit)
                    continue;
                result.index = i;
                result.indexEl = dim[6];
                if (!dim[4]) {
                    if (posY < dimDown)
                        yLimit = dimDown;
                    if (posX < xCenter) {
                        xLimit = xCenter;
                        result.method = 'before';
                    } else {
                        leftLimit = xCenter;
                        result.method = 'after';
                    }
                } else {
                    if (posY < yCenter) {
                        result.method = 'before';
                        break;
                    } else
                        result.method = 'after';
                }
            }
            return result;
        },
        movePlaceholder(plh, dims, pos, trgDim) {
            var marg = 0, t = 0, l = 0, w = 0, h = 0, un = 'px', margI = 5, brdCol = '#62c462', brd = 3, method = pos.method;
            var elDim = dims[pos.index];
            plh.style.borderColor = 'transparent ' + brdCol;
            plh.style.borderWidth = brd + un + ' ' + (brd + 2) + un;
            plh.style.margin = '-' + brd + 'px 0 0';
            if (elDim) {
                if (!elDim[4]) {
                    w = 'auto';
                    h = elDim[2] - marg * 2 + un;
                    t = elDim[0] + marg;
                    l = method == 'before' ? elDim[1] - marg : elDim[1] + elDim[3] - marg;
                    plh.style.borderColor = brdCol + ' transparent';
                    plh.style.borderWidth = brd + 2 + un + ' ' + brd + un;
                    plh.style.margin = '0 0 0 -' + brd + 'px';
                } else {
                    w = elDim[3] + un;
                    h = 'auto';
                    t = method == 'before' ? elDim[0] - marg : elDim[0] + elDim[2] - marg;
                    l = elDim[1];
                }
            } else {
                if (!this.nested) {
                    plh.style.display = 'none';
                    return;
                }
                if (trgDim) {
                    t = trgDim[0] + margI;
                    l = trgDim[1] + margI;
                    w = parseInt(trgDim[3]) - margI * 2 + un;
                    h = 'auto';
                }
            }
            plh.style.top = t + un;
            plh.style.left = l + un;
            if (w)
                plh.style.width = w;
            if (h)
                plh.style.height = h;
        },
        endMove(e) {
            const src = this.eV;
            const moved = [];
            const docs = this.getDocuments();
            const container = this.getContainerEl();
            const onEndMove = this.onEndMove;
            const {target, lastPos} = this;
            let srcModel;
            mixins.off(container, 'mousemove dragover', this.onMove);
            mixins.off(docs, 'mouseup dragend touchend', this.endMove);
            mixins.off(docs, 'keydown', this.rollback);
            this.plh.style.display = 'none';
            if (src) {
                srcModel = this.getSourceModel();
                if (this.selectOnEnd && srcModel && srcModel.set) {
                    srcModel.set('status', '');
                    srcModel.set('status', 'selected');
                }
            }
            if (this.moved) {
                const toMove = this.toMove;
                const toMoveArr = _.isArray(toMove) ? toMove : toMove ? [toMove] : [src];
                toMoveArr.forEach(model => {
                    moved.push(this.move(target, model, lastPos));
                });
            }
            if (this.plh)
                this.plh.style.display = 'none';
            var dragHelper = this.dragHelper;
            if (dragHelper) {
                dragHelper.parentNode.removeChild(dragHelper);
                this.dragHelper = null;
            }
            this.disableTextable();
            this.selectTargetModel();
            this.toggleSortCursor();
            this.toMove = null;
            if (_.isFunction(onEndMove)) {
                const data = {
                    target: srcModel,
                    parent: srcModel && srcModel.parent(),
                    index: srcModel && srcModel.index()
                };
                moved.length ? moved.forEach(m => onEndMove(m, this, data)) : onEndMove(null, this, langx.mixin({},
                    data, {
                    cancelled: 1
                }));
            }
        },
        move(dst, src, pos) {
            const {em, activeTextModel, dropContent} = this;
            const srcEl = mixins.getElement(src);
            em && em.trigger('component:dragEnd:before', dst, srcEl, pos);
            var warns = [];
            var index = pos.indexEl;
            var modelToDrop, modelTemp, created;
            var validResult = this.validTarget(dst, srcEl);
            var targetCollection = $(dst).data('collection');
            var model = validResult.srcModel;
            var droppable = validResult.droppable;
            var draggable = validResult.draggable;
            var dropInfo = validResult.dropInfo;
            var dragInfo = validResult.dragInfo;
            const {trgModel} = validResult;
            droppable = trgModel instanceof Backbone.Collection ? 1 : droppable;
            const isTextableActive = this.isTextableActive(model, trgModel);
            if (targetCollection && droppable && draggable) {
                index = pos.method === 'after' ? index + 1 : index;
                var opts = {
                    at: index,
                    noIncrement: 1
                };
                if (!dropContent) {
                    opts.temporary = 1;
                    modelTemp = targetCollection.add({}, langx.mixin({},opts ));
                    if (model.collection) {
                        modelToDrop = model.collection.remove(model, { temporary: 1 });
                    }
                } else {
                    modelToDrop = dropContent;
                    opts.silent = false;
                    opts.avoidUpdateStyle = 1;
                }
                if (isTextableActive) {
                    const viewActive = activeTextModel.getView();
                    activeTextModel.trigger('active');
                    const {activeRte} = viewActive;
                    const modelEl = model.getEl();
                    delete model.opt.temporary;
                    model.getView().render();
                    modelEl.setAttribute('data-gjs-textable', 'true');
                    const {outerHTML} = modelEl;
                    activeRte.insertHTML && activeRte.insertHTML(outerHTML);
                } else {
                    created = targetCollection.add(modelToDrop, opts);
                }
                if (!dropContent) {
                    targetCollection.remove(modelTemp);
                } else {
                    this.dropContent = null;
                }
                this.prevTarget = null;
            } else {
                if (!targetCollection) {
                    warns.push('Target collection not found');
                }
                if (!droppable) {
                    warns.push(`Target is not droppable, accepts [${ dropInfo }]`);
                }
                if (!draggable) {
                    warns.push(`Component not draggable, acceptable by [${ dragInfo }]`);
                }
                console.warn('Invalid target position: ' + warns.join(', '));
            }
            em && em.trigger('component:dragEnd', targetCollection, modelToDrop, warns);
            em && em.trigger('sorter:drag:end', {
                targetCollection,
                modelToDrop,
                warns,
                validResult,
                dst,
                srcEl
            });
            return created;
        },
        rollback(e) {
            mixins.off(this.getDocuments(), 'keydown', this.rollback);
            const key = e.which || e.keyCode;
            if (key == 27) {
                this.moved = 0;
                this.endMove();
            }
        }
    });
});
define('skylark-grapejs/utils/Resizer',[
    "skylark-langx/langx",
    'skylark-underscore',
    './mixins'
], function (langx,_, mixins) {
    'use strict';
    var defaultOpts = {
        mousePosFetcher: null,
        updateTarget: null,
        ratioDefault: 0,
        posFetcher: null,
        onStart: null,
        onMove: null,
        onEnd: null,
        onUpdateContainer: () => {
        },
        step: 1,
        minDim: 32,
        maxDim: '',
        unitHeight: 'px',
        unitWidth: 'px',
        keyHeight: 'height',
        keyWidth: 'width',
        currentUnit: 1,
        silentFrames: 0,
        avoidContainerUpdate: 0,
        keepAutoHeight: false,
        keepAutoWidth: false,
        autoHeight: false,
        autoWidth: false,
        tl: 1,
        tc: 1,
        tr: 1,
        cl: 1,
        cr: 1,
        bl: 1,
        bc: 1,
        br: 1
    };
    var createHandler = (name, opts) => {
        var pfx = opts.prefix || '';
        var el = document.createElement('i');
        el.className = pfx + 'resizer-h ' + pfx + 'resizer-h-' + name;
        el.setAttribute('data-' + pfx + 'handler', name);
        return el;
    };
    var getBoundingRect = (el, win) => {
        var w = win || window;
        var rect = el.getBoundingClientRect();
        return {
            left: rect.left + w.pageXOffset,
            top: rect.top + w.pageYOffset,
            width: rect.width,
            height: rect.height
        };
    };
    class Resizer {
        constructor(opts = {}) {
            this.setOptions(opts);
            _.bindAll(this, 'handleKeyDown', 'handleMouseDown', 'move', 'stop');
            return this;
        }
        getConfig() {
            return this.opts;
        }
        setOptions(options = {}) {
            this.opts = _.defaults(options, defaultOpts);
            this.setup();
        }
        setup() {
            const opts = this.opts;
            const pfx = opts.prefix || '';
            const appendTo = opts.appendTo || document.body;
            let container = this.container;
            if (!container) {
                container = document.createElement('div');
                container.className = `${ pfx }resizer-c`;
                appendTo.appendChild(container);
                this.container = container;
            }
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            const handlers = {};
            [
                'tl',
                'tc',
                'tr',
                'cl',
                'cr',
                'bl',
                'bc',
                'br'
            ].forEach(hdl => handlers[hdl] = opts[hdl] ? createHandler(hdl, opts) : '');
            for (let n in handlers) {
                const handler = handlers[n];
                handler && container.appendChild(handler);
            }
            this.handlers = handlers;
            this.mousePosFetcher = opts.mousePosFetcher;
            this.updateTarget = opts.updateTarget;
            this.posFetcher = opts.posFetcher;
            this.onStart = opts.onStart;
            this.onMove = opts.onMove;
            this.onEnd = opts.onEnd;
            this.onUpdateContainer = opts.onUpdateContainer;
        }
        toggleFrames(silent) {
            if (this.opts.silentFrames) {
                const frames = document.querySelectorAll('iframe');
                _.each(frames, frame => frame.style.pointerEvents = silent ? 'none' : '');
            }
        }
        isHandler(el) {
            var handlers = this.handlers;
            for (var n in handlers) {
                if (handlers[n] === el)
                    return true;
            }
            return false;
        }
        getFocusedEl() {
            return this.el;
        }
        getDocumentEl() {
            return [
                this.el.ownerDocument,
                document
            ];
        }
        getElementPos(el, opts = {}) {
            var posFetcher = this.posFetcher || '';
            return posFetcher ? posFetcher(el, opts) : getBoundingRect(el);
        }
        focus(el) {
            if (el && el === this.el) {
                return;
            }
            this.el = el;
            this.updateContainer({ forceShow: 1 });
            mixins.on(this.getDocumentEl(), 'mousedown', this.handleMouseDown);
        }
        blur() {
            this.container.style.display = 'none';
            if (this.el) {
                mixins.off(this.getDocumentEl(), 'mousedown', this.handleMouseDown);
                this.el = null;
            }
        }
        start(e) {
            if (e.button !== 0)
                return;
            e.preventDefault();
            e.stopPropagation();
            const el = this.el;
            const resizer = this;
            const config = this.opts || {};
            var attrName = 'data-' + config.prefix + 'handler';
            var rect = this.getElementPos(el, { target: 'el' });
            this.handlerAttr = e.target.getAttribute(attrName);
            this.clickedHandler = e.target;
            this.startDim = {
                t: rect.top,
                l: rect.left,
                w: rect.width,
                h: rect.height
            };
            this.rectDim = {
                t: rect.top,
                l: rect.left,
                w: rect.width,
                h: rect.height
            };
            this.startPos = {
                x: e.clientX,
                y: e.clientY
            };
            var doc = this.getDocumentEl();
            mixins.on(doc, 'mousemove', this.move);
            mixins.on(doc, 'keydown', this.handleKeyDown);
            mixins.on(doc, 'mouseup', this.stop);
            _.isFunction(this.onStart) && this.onStart(e, {
                docs: doc,
                config,
                el,
                resizer
            });
            this.toggleFrames(1);
            this.move(e);
        }
        move(e) {
            const onMove = this.onMove;
            var mouseFetch = this.mousePosFetcher;
            var currentPos = mouseFetch ? mouseFetch(e) : {
                x: e.clientX,
                y: e.clientY
            };
            this.currentPos = currentPos;
            this.delta = {
                x: currentPos.x - this.startPos.x,
                y: currentPos.y - this.startPos.y
            };
            this.keys = {
                shift: e.shiftKey,
                ctrl: e.ctrlKey,
                alt: e.altKey
            };
            this.rectDim = this.calc(this);
            this.updateRect(0);
            onMove && onMove(e);
            if (e.which === 0) {
                this.stop(e);
            }
        }
        stop(e) {
            const config = this.opts;
            var doc = this.getDocumentEl();
            mixins.off(doc, 'mousemove', this.move);
            mixins.off(doc, 'keydown', this.handleKeyDown);
            mixins.off(doc, 'mouseup', this.stop);
            this.updateRect(1);
            this.toggleFrames();
            _.isFunction(this.onEnd) && this.onEnd(e, {
                docs: doc,
                config
            });
        }
        updateRect(store) {
            const el = this.el;
            const resizer = this;
            const config = this.opts;
            const rect = this.rectDim;
            const updateTarget = this.updateTarget;
            const selectedHandler = this.getSelectedHandler();
            const {unitHeight, unitWidth, keyWidth, keyHeight} = config;
            if (_.isFunction(updateTarget)) {
                updateTarget(el, rect, {
                    store,
                    selectedHandler,
                    resizer,
                    config
                });
            } else {
                const elStyle = el.style;
                elStyle[keyWidth] = rect.w + unitWidth;
                elStyle[keyHeight] = rect.h + unitHeight;
            }
            this.updateContainer();
        }
        updateContainer(opt = {}) {
            const {opts, container, el} = this;
            const {style} = container;
            if (!opts.avoidContainerUpdate && el) {
                if (opt.forceShow)
                    style.display = 'block';
            }
            this.onUpdateContainer({
                el: container,
                resizer: this,
                opts: langx.mixin({},opts,opt)
            });
        }
        getSelectedHandler() {
            var handlers = this.handlers;
            if (!this.selectedHandler) {
                return;
            }
            for (let n in handlers) {
                if (handlers[n] === this.selectedHandler)
                    return n;
            }
        }
        handleKeyDown(e) {
            if (e.keyCode === 27) {
                this.rectDim = this.startDim;
                this.stop(e);
            }
        }
        handleMouseDown(e) {
            var el = e.target;
            if (this.isHandler(el)) {
                this.selectedHandler = el;
                this.start(e);
            } else if (el !== this.el) {
                this.selectedHandler = '';
                this.blur();
            }
        }
        calc(data) {
            let value;
            const opts = this.opts || {};
            const step = opts.step;
            const startDim = this.startDim;
            const minDim = opts.minDim;
            const maxDim = opts.maxDim;
            const deltaX = data.delta.x;
            const deltaY = data.delta.y;
            const startW = startDim.w;
            const startH = startDim.h;
            var box = {
                t: 0,
                l: 0,
                w: startW,
                h: startH
            };
            if (!data)
                return;
            var attr = data.handlerAttr;
            if (~attr.indexOf('r')) {
                value = mixins.normalizeFloat(startW + deltaX * step, step);
                value = Math.max(minDim, value);
                maxDim && (value = Math.min(maxDim, value));
                box.w = value;
            }
            if (~attr.indexOf('b')) {
                value = mixins.normalizeFloat(startH + deltaY * step, step);
                value = Math.max(minDim, value);
                maxDim && (value = Math.min(maxDim, value));
                box.h = value;
            }
            if (~attr.indexOf('l')) {
                value = mixins.normalizeFloat(startW - deltaX * step, step);
                value = Math.max(minDim, value);
                maxDim && (value = Math.min(maxDim, value));
                box.w = value;
            }
            if (~attr.indexOf('t')) {
                value = mixins.normalizeFloat(startH - deltaY * step, step);
                value = Math.max(minDim, value);
                maxDim && (value = Math.min(maxDim, value));
                box.h = value;
            }
            var ratioActive = opts.ratioDefault ? !data.keys.shift : data.keys.shift;
            if (attr.indexOf('c') < 0 && ratioActive) {
                var ratio = startDim.w / startDim.h;
                if (box.w / box.h > ratio) {
                    box.h = Math.round(box.w / ratio);
                } else {
                    box.w = Math.round(box.h * ratio);
                }
            }
            if (~attr.indexOf('l')) {
                box.l = startDim.w - box.w;
            }
            if (~attr.indexOf('t')) {
                box.t = startDim.h - box.h;
            }
            return box;
        }
    }
    return {
        init(opts) {
            return new Resizer(opts);
        }
    };
});
define('skylark-grapejs/utils/index',[
    './Dragger',
    './Sorter',
    './Resizer'
], function (Dragger, Sorter, Resizer) {
    'use strict';
    return () => {
        return {
            name: 'Utils',
            init() {
                return this;
            },
            Sorter,
            Resizer,
            Dragger
        };
    };
});
define('skylark-grapejs/i18n/locale/en',[],function () {
    'use strict';
    const traitInputAttr = { placeholder: 'eg. Text here' };
    return {
        assetManager: {
            addButton: 'Add image',
            inputPlh: 'http://path/to/the/image.jpg',
            modalTitle: 'Select Image',
            uploadTitle: 'Drop files here or click to upload'
        },
        blockManager: {
            labels: {},
            categories: {}
        },
        domComponents: {
            names: {
                '': 'Box',
                wrapper: 'Body',
                text: 'Text',
                comment: 'Comment',
                image: 'Image',
                video: 'Video',
                label: 'Label',
                link: 'Link',
                map: 'Map',
                tfoot: 'Table foot',
                tbody: 'Table body',
                thead: 'Table head',
                table: 'Table',
                row: 'Table row',
                cell: 'Table cell'
            }
        },
        deviceManager: {
            device: 'Device',
            devices: {
                desktop: 'Desktop',
                tablet: 'Tablet',
                mobileLandscape: 'Mobile Landscape',
                mobilePortrait: 'Mobile Portrait'
            }
        },
        panels: {
            buttons: {
                titles: {
                    preview: 'Preview',
                    fullscreen: 'Fullscreen',
                    'sw-visibility': 'View components',
                    'export-template': 'View code',
                    'open-sm': 'Open Style Manager',
                    'open-tm': 'Settings',
                    'open-layers': 'Open Layer Manager',
                    'open-blocks': 'Open Blocks'
                }
            }
        },
        selectorManager: {
            label: 'Classes',
            selected: 'Selected',
            emptyState: '- State -',
            states: {
                hover: 'Hover',
                active: 'Click',
                'nth-of-type(2n)': 'Even/Odd'
            }
        },
        styleManager: {
            empty: 'Select an element before using Style Manager',
            layer: 'Layer',
            fileButton: 'Images',
            sectors: {
                general: 'General',
                layout: 'Layout',
                typography: 'Typography',
                decorations: 'Decorations',
                extra: 'Extra',
                flex: 'Flex',
                dimension: 'Dimension'
            },
            properties: {}
        },
        traitManager: {
            empty: 'Select an element before using Trait Manager',
            label: 'Component settings',
            traits: {
                labels: {},
                attributes: {
                    id: traitInputAttr,
                    alt: traitInputAttr,
                    title: traitInputAttr,
                    href: { placeholder: 'eg. https://google.com' }
                },
                options: {
                    target: {
                        false: 'This window',
                        _blank: 'New window'
                    }
                }
            }
        }
    };
});
define('skylark-grapejs/i18n/config',['./locale/en'], function (en) {
    'use strict';
    return {
        locale: 'en',
        localeFallback: 'en',
        detectLocale: 1,
        debug: 0,
        messages: { en }
    };
});
define('skylark-grapejs/i18n/index',[
    "skylark-langx/langx",
    'skylark-underscore',
    './config'
], function (langx,_, config) {
    'use strict';
    const isObj = el => !Array.isArray(el) && el !== null && typeof el === 'object';
    const deepAssign = (...args) => {
        const target = lang.mixin({},args[0] );
        for (let i = 1; i < args.length; i++) {
            const source = lang.mixin({},args[i] );
            for (let key in source) {
                const targValue = target[key];
                const srcValue = source[key];
                if (isObj(targValue) && isObj(srcValue)) {
                    target[key] = deepAssign(targValue, srcValue);
                } else {
                    target[key] = srcValue;
                }
            }
        }
        return target;
    };
    return () => {
        return {
            name: 'I18n',
            config,
            init(opts = {}) {
                this.config = langx.mixin({},config,opts,{
                    messages: langx.mixin({},
                        config.messages,
                        opts.messages
                    )
                });
                if (this.config.detectLocale) {
                    this.config.locale = this._localLang();
                }
                this.em = opts.em;
                return this;
            },
            getConfig() {
                return this.config;
            },
            setLocale(locale) {
                const {em, config} = this;
                const evObj = {
                    value: locale,
                    valuePrev: config.locale
                };
                em && em.trigger('i18n:locale', evObj);
                config.locale = locale;
                return this;
            },
            getLocale() {
                return this.config.locale;
            },
            getMessages(lang, opts = {}) {
                const {messages} = this.config;
                lang && !messages[lang] && this._debug(`'${ lang }' i18n lang not found`, opts);
                return lang ? messages[lang] : messages;
            },
            setMessages(msg) {
                const {em, config} = this;
                config.messages = msg;
                em && em.trigger('i18n:update', msg);
                return this;
            },
            addMessages(msg) {
                const {em} = this;
                const {messages} = this.config;
                em && em.trigger('i18n:add', msg);
                this.setMessages(deepAssign(messages, msg));
                return this;
            },
            t(key, opts = {}) {
                const {config} = this;
                const param = opts.params || {};
                const locale = opts.l || this.getLocale();
                const localeFlb = opts.lFlb || config.localeFallback;
                let result = this._getMsg(key, locale, opts);
                if (!result)
                    result = this._getMsg(key, localeFlb, opts);
                !result && this._debug(`'${ key }' i18n key not found in '${ locale }' lang`, opts);
                result = result && _.isString(result) ? this._addParams(result, param) : result;
                return result;
            },
            _localLang() {
                const nav = window.navigator || {};
                const lang = nav.language || nav.userLanguage;
                return lang ? lang.split('-')[0] : 'en';
            },
            _addParams(str, params) {
                const reg = new RegExp(`\{([\\w\\d-]*)\}`, 'g');
                return str.replace(reg, (m, val) => params[val] || '').trim();
            },
            _getMsg(key, locale, opts = {}) {
                const msgSet = this.getMessages(locale, opts);
                if (!msgSet)
                    return;
                let result = msgSet[key];
                if (!result && key.indexOf('.') > 0) {
                    result = key.split('.').reduce((lang, key) => {
                        if (_.isUndefined(lang))
                            return;
                        return lang[key];
                    }, msgSet);
                }
                return result;
            },
            _debug(str, opts = {}) {
                const {em, config} = this;
                (opts.debug || config.debug) && em && em.logWarning(str);
            }
        };
    };
});
define('skylark-grapejs/keymaps/keymaster',[],function(){
  var k,
    _handlers = {},
    _mods = { 16: false, 18: false, 17: false, 91: false },
    _scope = 'all',
    // modifier keys
    _MODIFIERS = {
      '': 16, shift: 16,
      '': 18, alt: 18, option: 18,
      '': 17, ctrl: 17, control: 17,
      '': 91, command: 91
    },
    // special keys
    _MAP = {
      backspace: 8, tab: 9, clear: 12,
      enter: 13, 'return': 13,
      esc: 27, escape: 27, space: 32,
      left: 37, up: 38,
      right: 39, down: 40,
      del: 46, 'delete': 46,
      home: 36, end: 35,
      pageup: 33, pagedown: 34,
      ',': 188, '.': 190, '/': 191,
      '`': 192, '-': 189, '=': 187,
      ';': 186, '\'': 222,
      '[': 219, ']': 221, '\\': 220
    },
    code = function(x){
      return _MAP[x] || x.toUpperCase().charCodeAt(0);
    },
    _downKeys = [];

  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

  // IE doesn't support Array#indexOf, so have a simple replacement
  function index(array, item){
    var i = array.length;
    while(i--) if(array[i]===item) return i;
    return -1;
  }

  // for comparing mods before unassignment
  function compareArray(a1, a2) {
    if (a1.length != a2.length) return false;
    for (var i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  var modifierMap = {
      16:'shiftKey',
      18:'altKey',
      17:'ctrlKey',
      91:'metaKey'
  };
  function updateModifierKey(event) {
      for(k in _mods) _mods[k] = event[modifierMap[k]];
  };

  // handle keydown event
  function dispatch(event) {
    var key, handler, k, i, modifiersMatch, scope;
    key = event.keyCode;

    if (index(_downKeys, key) == -1) {
        _downKeys.push(key);
    }

    // if a modifier key, set the key.<modifierkeyname> property to true and return
    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
    if(key in _mods) {
      _mods[key] = true;
      // 'assignKey' from inside this closure is exported to window.key
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
      return;
    }
    updateModifierKey(event);

    // see if we need to ignore the keypress (filter() can can be overridden)
    // by default ignore key presses if a select, textarea, or input is focused
    if(!assignKey.filter.call(this, event)) return;

    // abort if no potentially matching shortcuts found
    if (!(key in _handlers)) return;

    scope = getScope();

    // for each potential shortcut
    for (i = 0; i < _handlers[key].length; i++) {
      handler = _handlers[key][i];

      // see if it's in the current scope
      if(handler.scope == scope || handler.scope == 'all'){
        // check if modifiers match if any
        modifiersMatch = handler.mods.length > 0;
        for(k in _mods)
          if((!_mods[k] && index(handler.mods, +k) > -1) ||
            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
        // call the handler and stop the event if neccessary
        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
          if(handler.method(event, handler)===false){
            if(event.preventDefault) event.preventDefault();
              else event.returnValue = false;
            if(event.stopPropagation) event.stopPropagation();
            if(event.cancelBubble) event.cancelBubble = true;
          }
        }
      }
    }
  };

  // unset modifier keys on keyup
  function clearModifier(event){
    var key = event.keyCode, k,
        i = index(_downKeys, key);

    // remove key from _downKeys
    if (i >= 0) {
        _downKeys.splice(i, 1);
    }

    if(key == 93 || key == 224) key = 91;
    if(key in _mods) {
      _mods[key] = false;
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
    }
  };

  function resetModifiers() {
    for(k in _mods) _mods[k] = false;
    for(k in _MODIFIERS) assignKey[k] = false;
  };

  // parse and assign shortcut
  function assignKey(key, scope, method){
    var keys, mods;
    keys = getKeys(key);
    if (method === undefined) {
      method = scope;
      scope = 'all';
    }

    // for each shortcut
    for (var i = 0; i < keys.length; i++) {
      // set modifier keys if any
      mods = [];
      key = keys[i].split('+');
      if (key.length > 1){
        mods = getMods(key);
        key = [key[key.length-1]];
      }
      // convert to keycode and...
      key = key[0]
      key = code(key);
      // ...store handler
      if (!(key in _handlers)) _handlers[key] = [];
      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
    }
  };

  // unbind all handlers for given key in current scope
  function unbindKey(key, scope) {
    var multipleKeys, keys,
      mods = [],
      i, j, obj;

    multipleKeys = getKeys(key);

    for (j = 0; j < multipleKeys.length; j++) {
      keys = multipleKeys[j].split('+');

      if (keys.length > 1) {
        mods = getMods(keys);
        key = keys[keys.length - 1];
      }

      key = code(key);

      if (scope === undefined) {
        scope = getScope();
      }
      if (!_handlers[key]) {
        return;
      }
      for (i = 0; i < _handlers[key].length; i++) {
        obj = _handlers[key][i];
        // only clear handlers if correct scope and mods match
        if (obj.scope === scope && compareArray(obj.mods, mods)) {
          _handlers[key][i] = {};
        }
      }
    }
  };

  // Returns true if the key with code 'keyCode' is currently down
  // Converts strings into key codes.
  function isPressed(keyCode) {
      if (typeof(keyCode)=='string') {
        keyCode = code(keyCode);
      }
      return index(_downKeys, keyCode) != -1;
  }

  function getPressedKeyCodes() {
      return _downKeys.slice(0);
  }

  function filter(event){
    var tagName = (event.target || event.srcElement).tagName;
    // ignore keypressed in any elements that support keyboard data input
    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
  }

  // initialize key.<modifier> to false
  for(k in _MODIFIERS) assignKey[k] = false;

  // set current scope (default 'all')
  function setScope(scope){ _scope = scope || 'all' };
  function getScope(){ return _scope || 'all' };

  // delete all handlers for a given scope
  function deleteScope(scope){
    var key, handlers, i;

    for (key in _handlers) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);
        else i++;
      }
    }
  };

  // abstract key logic for assign and unassign
  function getKeys(key) {
    var keys;
    key = key.replace(/\s/g, '');
    keys = key.split(',');
    if ((keys[keys.length - 1]) == '') {
      keys[keys.length - 2] += ',';
    }
    return keys;
  }

  // abstract mods logic for assign and unassign
  function getMods(key) {
    var mods = key.slice(0, key.length - 1);
    for (var mi = 0; mi < mods.length; mi++)
    mods[mi] = _MODIFIERS[mods[mi]];
    return mods;
  }

  // cross-browser events
  function addEvent(object, event, method) {
    if (object.addEventListener)
      object.addEventListener(event, method, false);
    else if(object.attachEvent)
      object.attachEvent('on'+event, function(){ method(window.event) });
  };

  // set the handlers globally on document
  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
  addEvent(document, 'keyup', clearModifier);

  // reset modifiers to false whenever the window is (re)focused.
  addEvent(window, 'focus', resetModifiers);

  // store previously defined key
  var previousKey = global.key;

  // restore previously defined key and return reference to our key object
  function noConflict() {
    var k = global.key;
    global.key = previousKey;
    return k;
  }

  /*
  // set window.key and window.key.set/get/deleteScope, and the default filter
  global.key = assignKey;
  global.key.setScope = setScope;
  global.key.getScope = getScope;
  global.key.deleteScope = deleteScope;
  global.key.filter = filter;
  global.key.isPressed = isPressed;
  global.key.getPressedKeyCodes = getPressedKeyCodes;
  global.key.noConflict = noConflict;
  global.key.unbind = unbindKey;
*/
  return assignKey;

});

define('skylark-grapejs/keymaps/index',[
    "skylark-langx/langx",
    'skylark-underscore',
    './keymaster'
], function (langx,_, keymaster) {
    'use strict';
    return () => {
        let em;
        let config;
        const keymaps = {};
        const configDef = {
            defaults: {
                'core:undo': {
                    keys: '\u2318+z, ctrl+z',
                    handler: 'core:undo'
                },
                'core:redo': {
                    keys: '\u2318+shift+z, ctrl+shift+z',
                    handler: 'core:redo'
                },
                'core:copy': {
                    keys: '\u2318+c, ctrl+c',
                    handler: 'core:copy'
                },
                'core:paste': {
                    keys: '\u2318+v, ctrl+v',
                    handler: 'core:paste'
                },
                'core:component-next': {
                    keys: 's',
                    handler: 'core:component-next'
                },
                'core:component-prev': {
                    keys: 'w',
                    handler: 'core:component-prev'
                },
                'core:component-enter': {
                    keys: 'd',
                    handler: 'core:component-enter'
                },
                'core:component-exit': {
                    keys: 'a',
                    handler: 'core:component-exit'
                },
                'core:component-delete': {
                    keys: 'backspace, delete',
                    handler: 'core:component-delete'
                }
            }
        };
        return {
            keymaster,
            name: 'Keymaps',
            getConfig() {
                return config;
            },
            init(opts = {}) {
                config = langx.mixin({},
                    configDef,
                    opts
                );
                em = config.em;
                this.em = em;
                return this;
            },
            onLoad() {
                const defKeys = config.defaults;
                for (let id in defKeys) {
                    const value = defKeys[id];
                    this.add(id, value.keys, value.handler);
                }
            },
            add(id, keys, handler, opts = {}) {
                const {em} = this;
                const cmd = em.get('Commands');
                const editor = em.getEditor();
                const canvas = em.get('Canvas');
                const keymap = {
                    id,
                    keys,
                    handler
                };
                const pk = keymaps[id];
                pk && this.remove(id);
                keymaps[id] = keymap;
                keymaster(keys, (e, h) => {
                    const opt = {
                        event: e,
                        h
                    };
                    handler = _.isString(handler) ? cmd.get(handler) : handler;
                    opts.prevent && canvas.getCanvasView().preventDefault(e);
                    const ableTorun = !em.isEditing() && !editor.Canvas.isInputFocused();
                    if (ableTorun || opts.force) {
                        typeof handler == 'object' ? handler.run(editor, 0, opt) : handler(editor, 0, opt);
                        const args = [
                            id,
                            h.shortcut,
                            e
                        ];
                        em.trigger('keymap:emit', ...args);
                        em.trigger(`keymap:emit:${ id }`, ...args);
                    }
                });
                em.trigger('keymap:add', keymap);
                return keymap;
            },
            get(id) {
                return keymaps[id];
            },
            getAll() {
                return keymaps;
            },
            remove(id) {
                const em = this.em;
                const keymap = this.get(id);
                if (keymap) {
                    delete keymaps[id];
                    keymaster.unbind(keymap.keys);
                    em && em.trigger('keymap:remove', keymap);
                    return keymap;
                }
            },
            removeAll() {
                Object.keys(keymaps).forEach(keymap => this.remove(keymap));
                return this;
            }
        };
    };
});
define('skylark-grapejs/undo_manager/index',[
    "skylark-langx/langx",
    'skylark-backbone/UndoManager'
], function (langx,UndoManager) {
    'use strict';
    return () => {
        let em;
        let um;
        let config;
        let beforeCache;
        const configDef = {};
        return {
            name: 'UndoManager',
            init(opts = {}) {
                config = langx.mixin({},opts,configDef);
                em = config.em;
                this.em = em;
                um = new UndoManager(langx.mixin({
                            track: true,
                            register: [],
                        },config
                ));
                um.changeUndoType('change', { condition: false });
                um.changeUndoType('add', {
                    on(model, collection, options = {}) {
                        if (options.avoidStore)
                            return;
                        return {
                            object: collection,
                            before: undefined,
                            after: model,
                            options: langx.clone(options)
                        };
                    }
                });
                um.changeUndoType('remove', {
                    on(model, collection, options = {}) {
                        if (options.avoidStore)
                            return;
                        return {
                            object: collection,
                            before: model,
                            after: undefined,
                            options: langx.clone(options)
                        };
                    }
                });
                const customUndoType = {
                    on(object, value, opt = {}) {
                        !beforeCache && (beforeCache = object.previousAttributes());
                        if (opt.avoidStore) {
                            return;
                        } else {
                            const result = {
                                object,
                                before: beforeCache,
                                after: object.toJSON()
                            };
                            beforeCache = null;
                            return result;
                        }
                    },
                    undo(model, bf, af, opt) {
                        model.set(bf);
                    },
                    redo(model, bf, af, opt) {
                        model.set(af);
                    }
                };
                const events = [
                    'style',
                    'attributes',
                    'content',
                    'src'
                ];
                events.forEach(ev => um.addUndoType(`change:${ ev }`, customUndoType));
                um.on('undo redo', () => em.trigger('component:toggled change:canvasOffset'));
                [
                    'undo',
                    'redo'
                ].forEach(ev => um.on(ev, () => em.trigger(ev)));
                return this;
            },
            getConfig() {
                return config;
            },
            add(entity) {
                um.register(entity);
                return this;
            },
            remove(entity) {
                um.unregister(entity);
                return this;
            },
            removeAll() {
                um.unregisterAll();
                return this;
            },
            start() {
                um.startTracking();
                return this;
            },
            stop() {
                um.stopTracking();
                return this;
            },
            undo() {
                !em.isEditing() && um.undo(1);
                return this;
            },
            undoAll() {
                um.undoAll();
                return this;
            },
            redo() {
                !em.isEditing() && um.redo(1);
                return this;
            },
            redoAll() {
                um.redoAll();
                return this;
            },
            hasUndo() {
                return um.isAvailable('undo');
            },
            hasRedo() {
                return um.isAvailable('redo');
            },
            getStack() {
                return um.stack;
            },
            clear() {
                um.clear();
                return this;
            },
            getInstance() {
                return um;
            }
        };
    };
});
define('skylark-grapejs/storage_manager/config/config',[],function () {
    'use strict';
    return {
        id: 'gjs-',
        autosave: 1,
        autoload: 1,
        type: 'local',
        stepsBeforeSave: 1,
        storeComponents: 1,
        storeStyles: 1,
        storeHtml: 1,
        storeCss: 1,
        checkLocal: 1,
        params: {},
        headers: {},
        urlStore: '',
        urlLoad: '',
        beforeSend(jqXHR, settings) {
        },
        onComplete(jqXHR, status) {
        },
        contentTypeJson: true,
        credentials: 'include',
        fetchOptions: ''
    };
});
define('skylark-grapejs/storage_manager/model/LocalStorage',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.Model.extend({
        defaults: { checkLocal: true },
        store(data, clb) {
            this.checkStorageEnvironment();
            for (var key in data)
                localStorage.setItem(key, data[key]);
            if (typeof clb == 'function') {
                clb();
            }
        },
        load(keys, clb) {
            this.checkStorageEnvironment();
            var result = {};
            for (var i = 0, len = keys.length; i < len; i++) {
                var value = localStorage.getItem(keys[i]);
                if (value)
                    result[keys[i]] = value;
            }
            if (typeof clb == 'function') {
                clb(result);
            }
            return result;
        },
        remove(keys) {
            this.checkStorageEnvironment();
            for (var i = 0, len = keys.length; i < len; i++)
                localStorage.removeItem(keys[i]);
        },
        checkStorageEnvironment() {
            if (this.get('checkLocal') && !localStorage)
                console.warn("Your browser doesn't support localStorage");
        }
    });
});
define('skylark-grapejs/utils/fetch',[
], function () {
    'use strict';
    return typeof fetch == 'function' ? fetch.bind() : (url, options) => {
        return new Promise((res, rej) => {
            const req = new XMLHttpRequest();
            req.open(options.method || 'get', url);
            req.withCredentials = options.credentials == 'include';
            for (let k in options.headers || {}) {
                req.setRequestHeader(k, options.headers[k]);
            }
            req.onload = e => res({
                status: req.status,
                statusText: req.statusText,
                text: () => Promise.resolve(req.responseText)
            });
            req.onerror = rej;
            if (req.upload && options.onProgress) {
                req.upload.onprogress = options.onProgress;
            }
            options.body ? req.send(options.body) : req.send();
        });
    };
});
define('skylark-grapejs/storage_manager/model/RemoteStorage',[
    "skylark-langx/langx",
    'skylark-backbone',
    '../../utils/fetch',
    'skylark-underscore'
], function (langx,Backbone, fetch, a) {
    'use strict';
    return Backbone.Model.extend({
        fetch,
        defaults: {
            urlStore: '',
            urlLoad: '',
            params: {},
            beforeSend() {
            },
            onComplete() {
            },
            contentTypeJson: false,
            credentials: 'include',
            fetchOptions: ''
        },
        onStart() {
            const em = this.get('em');
            const before = this.get('beforeSend');
            before && before();
        },
        onError(err, clbErr) {
            if (clbErr) {
                clbErr(err);
            } else {
                const em = this.get('em');
                console.error(err);
                em && em.trigger('storage:error', err);
            }
        },
        onResponse(text, clb) {
            const em = this.get('em');
            const complete = this.get('onComplete');
            const typeJson = this.get('contentTypeJson');
            const parsable = text && typeof text === 'string';
            const res = typeJson && parsable ? JSON.parse(text) : text;
            complete && complete(res);
            clb && clb(res);
            em && em.trigger('storage:response', res);
        },
        store(data, clb, clbErr) {
            const body = {};
            for (let key in data) {
                body[key] = data[key];
            }
            this.request(this.get('urlStore'), { body }, clb, clbErr);
        },
        load(keys, clb, clbErr) {
            this.request(this.get('urlLoad'), { method: 'get' }, clb, clbErr);
        },
        request(url, opts = {}, clb = null, clbErr = null) {
            const typeJson = this.get('contentTypeJson');
            const headers = this.get('headers') || {};
            const params = this.get('params');
            const reqHead = 'X-Requested-With';
            const typeHead = 'Content-Type';
            const bodyObj = opts.body || {};
            let fetchOptions;
            let body;
            for (let param in params) {
                bodyObj[param] = params[param];
            }
            if (a.isUndefined(headers[reqHead])) {
                headers[reqHead] = 'XMLHttpRequest';
            }
            if (a.isUndefined(headers[typeHead]) && typeJson) {
                headers[typeHead] = 'application/json; charset=utf-8';
            }
            if (typeJson) {
                body = JSON.stringify(bodyObj);
            } else {
                body = new FormData();
                for (let bodyKey in bodyObj) {
                    body.append(bodyKey, bodyObj[bodyKey]);
                }
            }
            fetchOptions = {
                method: opts.method || 'post',
                credentials: this.get('credentials'),
                headers
            };
            if (fetchOptions.method === 'post') {
                fetchOptions.body = body;
            }
            const fetchOpts = this.get('fetchOptions') || {};
            const addOpts = a.isFunction(fetchOpts) ? fetchOpts(fetchOptions) : fetchOptions;
            this.onStart();
            this.fetch(url, langx.mixin({},fetchOptions,addOpts)).then(
                res => (res.status / 200 | 0) == 1 ? res.text() : res.text().then(text => Promise.reject(text))).then(text => this.onResponse(text, clb)).catch(err => this.onError(err, clbErr));
        }
    });
});
define('skylark-grapejs/storage_manager/index',[
    "skylark-langx/langx",
    './config/config',
    './model/LocalStorage',
    './model/RemoteStorage'
], function (langx,defaults, LocalStorage, RemoteStorage) {
    'use strict';
    return () => {
        var c = {};
        let em;
        var storages = {};
        var defaultStorages = {};
        const eventStart = 'storage:start';
        const eventEnd = 'storage:end';
        const eventError = 'storage:error';
        return {
            name: 'StorageManager',
            init(config = {}) {
                c = langx.mixin({},defaults,config);
                em = c.em;
                if (c._disable)
                    c.type = 0;
                defaultStorages.remote = new RemoteStorage(c);
                defaultStorages.local = new LocalStorage(c);
                c.currentStorage = c.type;
                this.loadDefaultProviders().setCurrent(c.type);
                return this;
            },
            getConfig() {
                return c;
            },
            isAutosave() {
                return !!c.autosave;
            },
            setAutosave(v) {
                c.autosave = !!v;
                return this;
            },
            getStepsBeforeSave() {
                return c.stepsBeforeSave;
            },
            setStepsBeforeSave(v) {
                c.stepsBeforeSave = v;
                return this;
            },
            add(id, storage) {
                storages[id] = storage;
                return this;
            },
            get(id) {
                return storages[id] || null;
            },
            getStorages() {
                return storages;
            },
            getCurrent() {
                return c.currentStorage;
            },
            setCurrent(id) {
                c.currentStorage = id;
                return this;
            },
            store(data, clb) {
                const st = this.get(this.getCurrent());
                const toStore = {};
                this.onStart('store', data);
                for (let key in data) {
                    toStore[c.id + key] = data[key];
                }
                return st ? st.store(toStore, res => {
                    clb && clb(res);
                    this.onEnd('store', res);
                }, err => {
                    this.onError('store', err);
                }) : null;
            },
            load(keys, clb) {
                var st = this.get(this.getCurrent());
                var keysF = [];
                var result = {};
                if (typeof keys === 'string')
                    keys = [keys];
                this.onStart('load', keys);
                for (var i = 0, len = keys.length; i < len; i++) {
                    keysF.push(c.id + keys[i]);
                }
                if (st) {
                    st.load(keysF, res => {
                        var reg = new RegExp('^' + c.id + '');
                        for (var itemKey in res) {
                            var itemKeyR = itemKey.replace(reg, '');
                            result[itemKeyR] = res[itemKey];
                        }
                        clb && clb(result);
                        this.onEnd('load', result);
                    }, err => {
                        clb && clb(result);
                        this.onError('load', err);
                    });
                } else {
                    clb && clb(result);
                }
            },
            loadDefaultProviders() {
                for (var id in defaultStorages)
                    this.add(id, defaultStorages[id]);
                return this;
            },
            getCurrentStorage() {
                return this.get(this.getCurrent());
            },
            onStart(ctx, data) {
                if (em) {
                    em.trigger(eventStart);
                    ctx && em.trigger(`${ eventStart }:${ ctx }`, data);
                }
            },
            onEnd(ctx, data) {
                if (em) {
                    em.trigger(eventEnd);
                    ctx && em.trigger(`${ eventEnd }:${ ctx }`, data);
                }
            },
            onError(ctx, data) {
                if (em) {
                    em.trigger(eventError, data);
                    ctx && em.trigger(`${ eventError }:${ ctx }`, data);
                    this.onEnd(ctx, data);
                }
            },
            canAutoload() {
                const storage = this.getCurrentStorage();
                return storage && this.getConfig().autoload;
            }
        };
    };
});
define('skylark-grapejs/device_manager/config/config',[],function () {
    'use strict';
    return { devices: [] };
});
define('skylark-grapejs/device_manager/model/Device',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.Model.extend({
        idAttribute: 'name',
        defaults: {
            name: '',
            width: null,
            height: '',
            widthMedia: null,
            priority: null
        },
        initialize() {
            this.get('widthMedia') === null && this.set('widthMedia', this.get('width'));
            this.get('width') === null && this.set('width', this.get('widthMedia'));
            !this.get('priority') && this.set('priority', parseFloat(this.get('widthMedia')) || 0);
            const toCheck = [
                'width',
                'height',
                'widthMedia'
            ];
            toCheck.forEach(prop => this.checkUnit(prop));
        },
        checkUnit(prop) {
            const pr = this.get(prop) || '';
            const noUnit = (parseFloat(pr) || 0).toString() === pr.toString();
            noUnit && this.set(prop, `${ pr }px`);
        }
    });
});
define('skylark-grapejs/device_manager/model/Devices',[
    'skylark-backbone',
    './Device'
], function (Backbone, Device) {
    'use strict';
    return Backbone.Collection.extend({
        model: Device,
        comparator: (left, right) => {
            const max = Number.MAX_VALUE;
            return (right.get('priority') || max) - (left.get('priority') || max);
        },
        getSorted() {
            return this.sort();
        }
    });
});
define('skylark-grapejs/device_manager/view/DevicesView',[
    'skylark-underscore',
    'skylark-backbone'
], function (_, Backbone) {
    'use strict';
    return Backbone.View.extend({
        template: _.template(`
    <div class="<%= ppfx %>device-label"><%= deviceLabel %></div>
    <div class="<%= ppfx %>field <%= ppfx %>select">
      <span id="<%= ppfx %>input-holder">
        <select class="<%= ppfx %>devices"></select>
      </span>
      <div class="<%= ppfx %>sel-arrow">
        <div class="<%= ppfx %>d-s-arrow"></div>
      </div>
    </div>
    <button style="display:none" class="<%= ppfx %>add-trasp">+</button>`),
        events: { change: 'updateDevice' },
        initialize(o) {
            this.config = o.config || {};
            this.em = this.config.em;
            this.ppfx = this.config.pStylePrefix || '';
            this.events['click .' + this.ppfx + 'add-trasp'] = this.startAdd;
            this.listenTo(this.em, 'change:device', this.updateSelect);
            this.delegateEvents();
        },
        startAdd() {
        },
        updateDevice() {
            var em = this.em;
            if (em) {
                var devEl = this.devicesEl;
                var val = devEl ? devEl.val() : '';
                em.set('device', val);
            }
        },
        updateSelect() {
            var em = this.em;
            var devEl = this.devicesEl;
            if (em && em.getDeviceModel && devEl) {
                var device = em.getDeviceModel();
                var name = device ? device.get('name') : '';
                devEl.val(name);
            }
        },
        getOptions() {
            const {collection, em} = this;
            let result = '';
            collection.each(device => {
                const {name, id} = device.attributes;
                const label = em && em.t && em.t(`deviceManager.devices.${ id }`) || name;
                result += `<option value="${ name }">${ label }</option>`;
            });
            return result;
        },
        render() {
            const {em, ppfx, $el, el} = this;
            $el.html(this.undefined({
                ppfx,
                deviceLabel: em && em.t && em.t('deviceManager.device')
            }));
            this.devicesEl = $el.find(`.${ ppfx }devices`);
            this.devicesEl.append(this.getOptions());
            el.className = `${ ppfx }devices-c`;
            return this;
        }
    });
});
define('skylark-grapejs/device_manager/index',[
    "skylark-langx/langx",
    './config/config',
    './model/Devices',
    './view/DevicesView'
], function (langx,defaults, Devices, DevicesView) {
    'use strict';
    return () => {
        var c = {};
        var devices, view;
        return {
            name: 'DeviceManager',
            init(config) {
                c = config || {};
                for (var name in defaults) {
                    if (!(name in c))
                        c[name] = defaults[name];
                }
                devices = new Devices();
                (c.devices || []).forEach(dv => this.add(dv.id || dv.name, dv.width, dv));
                view = new DevicesView({
                    collection: devices,
                    config: c
                });
                return this;
            },
            add(id, width, opts = {}) {
                const obj = langx.mixin({},opts,{
                    id,
                    name: opts.name || id,
                    width: width
                });
                return devices.add(obj);
            },
            get(name) {
                return devices.get(name);
            },
            getAll() {
                return devices;
            },
            render() {
                return view.render().el;
            }
        };
    };
});
define('skylark-grapejs/parser/config/config',[],function () {
    'use strict';
    return {
        textTags: [
            'br',
            'b',
            'i',
            'u',
            'a',
            'ul',
            'ol'
        ],
        parserCss: null,
        parserHtml: null
    };
});
define('skylark-grapejs/parser/model/BrowserParserCss',['skylark-underscore'], function (_) {
    'use strict';
    const atRules = {
        4: 'media',
        5: 'font-face',
        6: 'page',
        7: 'keyframes',
        11: 'counter-style',
        12: 'supports',
        13: 'document',
        14: 'font-feature-values',
        15: 'viewport'
    };
    const atRuleKeys = _.keys(atRules);
    const singleAtRules = [
        '5',
        '6',
        '11',
        '15'
    ];
    const singleAtRulesNames = [
        'font-face',
        'page',
        'counter-style',
        'viewport'
    ];
    const parseSelector = (str = '') => {
        const add = [];
        const result = [];
        const sels = str.split(',');
        for (var i = 0, len = sels.length; i < len; i++) {
            var sel = sels[i].trim();
            if (/^(\.{1}[\w\-]+)+(:{1,2}[\w\-()]+)?$/gi.test(sel) || /^(#{1}[\w\-]+){1}(:{1,2}[\w\-()]+)?$/gi.test(sel)) {
                var cls = sel.split('.').filter(Boolean);
                result.push(cls);
            } else {
                add.push(sel);
            }
        }
        return {
            result,
            add
        };
    };
    const parseStyle = node => {
        const stl = node.style;
        const style = {};
        for (var i = 0, len = stl.length; i < len; i++) {
            const propName = stl[i];
            const propValue = stl.getPropertyValue(propName);
            const important = stl.getPropertyPriority(propName);
            style[propName] = `${ propValue }${ important ? ` !${ important }` : '' }`;
        }
        return style;
    };
    const parseCondition = node => {
        const condition = node.conditionText || node.media && node.media.mediaText || node.name || node.selectorText || '';
        return condition.trim();
    };
    const createNode = (selectors, style = {}, opts = {}) => {
        const node = {};
        const selLen = selectors.length;
        const lastClass = selectors[selLen - 1];
        const stateArr = lastClass ? lastClass.split(/:(.+)/) : [];
        const state = stateArr[1];
        const {atRule, selectorsAdd, mediaText} = opts;
        const singleAtRule = singleAtRulesNames.indexOf(atRule) >= 0;
        singleAtRule && (node.singleAtRule = 1);
        atRule && (node.atRuleType = atRule);
        selectorsAdd && (node.selectorsAdd = selectorsAdd);
        mediaText && (node.mediaText = mediaText);
        if (state) {
            selectors[selLen - 1] = stateArr[0];
            node.state = state;
            stateArr.splice(stateArr.length - 1, 1);
        }
        node.selectors = selectors;
        node.style = style;
        return node;
    };
    const parseNode = el => {
        var result = [];
        var nodes = el.cssRules || [];
        for (var i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            const type = node.type.toString();
            let singleAtRule = 0;
            let atRuleType = '';
            let condition = '';
            let sels = node.selectorText || node.keyText;
            const isSingleAtRule = singleAtRules.indexOf(type) >= 0;
            if (isSingleAtRule) {
                singleAtRule = 1;
                atRuleType = atRules[type];
                condition = parseCondition(node);
            } else if (atRuleKeys.indexOf(type) >= 0) {
                var subRules = parseNode(node);
                condition = parseCondition(node);
                for (var s = 0, lens = subRules.length; s < lens; s++) {
                    var subRule = subRules[s];
                    condition && (subRule.mediaText = condition);
                    subRule.atRuleType = atRules[type];
                }
                result = result.concat(subRules);
            }
            if (!sels && !isSingleAtRule)
                continue;
            const style = parseStyle(node);
            const selsParsed = parseSelector(sels);
            const selsAdd = selsParsed.add;
            sels = selsParsed.result;
            let lastRule;
            for (var k = 0, len3 = sels.length; k < len3; k++) {
                const model = createNode(sels[k], style, { atRule: atRules[type] });
                result.push(model);
                lastRule = model;
            }
            if (selsAdd.length) {
                var selsAddStr = selsAdd.join(', ');
                if (lastRule) {
                    lastRule.selectorsAdd = selsAddStr;
                } else {
                    const model = {
                        selectors: [],
                        selectorsAdd: selsAddStr,
                        style
                    };
                    singleAtRule && (model.singleAtRule = singleAtRule);
                    atRuleType && (model.atRuleType = atRuleType);
                    condition && (model.mediaText = condition);
                    result.push(model);
                }
            }
        }
        return result;
    };
    var parser =  str => {
        const el = document.createElement('style');
        el.innerHTML = str;
        document.head.appendChild(el);
        const sheet = el.sheet;
        document.head.removeChild(el);
        return parseNode(sheet);
    };


    parser.parseSelector = parseSelector;
    parser.parseStyle = parseStyle;
    parser.parseCondition = parseCondition;
    parser.createNode = createNode;
    parser.parseNode = parseNode;

    return parser;
});
define('skylark-grapejs/parser/model/ParserCss',[
    'skylark-underscore',
    './BrowserParserCss',
    './BrowserParserCss'
], function (a, BrowserCssParser, b) {
    'use strict';
    return (config = {}) => ({
        parse(str) {
            let result = [];
            const {parserCss, em = {}} = config;
            const editor = em && em.get && em.get('Editor');
            const nodes = parserCss ? parserCss(str, editor) : BrowserCssParser(str);
            nodes.forEach(node => result = result.concat(this.checkNode(node)));
            return result;
        },
        checkNode(node) {
            const {selectors, style} = node;
            if (a.isString(selectors)) {
                const nodes = [];
                const selsParsed = b.parseSelector(selectors);
                const classSets = selsParsed.result;
                const selectorsAdd = selsParsed.add.join(', ');
                const opts = {
                    atRule: node.atRule,
                    mediaText: node.params
                };
                if (classSets.length) {
                    classSets.forEach(classSet => {
                        nodes.push(b.createNode(classSet, style, opts));
                    });
                } else {
                    nodes.push(b.createNode([], style, opts));
                }
                if (selectorsAdd) {
                    const lastNode = nodes[nodes.length - 1];
                    lastNode.selectorsAdd = selectorsAdd;
                }
                node = nodes;
            }
            return node;
        }
    });
});
define('skylark-grapejs/parser/model/ParserHtml',['skylark-underscore'], function (a) {
    'use strict';
    return config => {
        var TEXT_NODE = 'span';
        var c = config;
        var modelAttrStart = 'data-gjs-';
        return {
            compTypes: '',
            modelAttrStart,
            splitPropsFromAttr(attr = {}) {
                const props = {};
                const attrs = {};
                a.each(attr, (value, key) => {
                    if (key.indexOf(this.modelAttrStart) === 0) {
                        const modelAttr = key.replace(modelAttrStart, '');
                        const valueLen = value.length;
                        const valStr = value && a.isString(value);
                        const firstChar = valStr && value.substr(0, 1);
                        const lastChar = valStr && value.substr(valueLen - 1);
                        value = value === 'true' ? true : value;
                        value = value === 'false' ? false : value;
                        try {
                            value = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(value) : value;
                        } catch (e) {
                        }
                        props[modelAttr] = value;
                    } else {
                        attrs[key] = value;
                    }
                });
                return {
                    props,
                    attrs
                };
            },
            parseStyle(str) {
                var result = {};
                var decls = str.split(';');
                for (var i = 0, len = decls.length; i < len; i++) {
                    var decl = decls[i].trim();
                    if (!decl)
                        continue;
                    var prop = decl.split(':');
                    result[prop[0].trim()] = prop.slice(1).join(':').trim();
                }
                return result;
            },
            parseClass(str) {
                const result = [];
                const cls = str.split(' ');
                for (let i = 0, len = cls.length; i < len; i++) {
                    const cl = cls[i].trim();
                    if (!cl)
                        continue;
                    result.push(cl);
                }
                return result;
            },
            parseNode(el) {
                const result = [];
                const nodes = el.childNodes;
                for (var i = 0, len = nodes.length; i < len; i++) {
                    const node = nodes[i];
                    const attrs = node.attributes || [];
                    const attrsLen = attrs.length;
                    const nodePrev = result[result.length - 1];
                    const nodeChild = node.childNodes.length;
                    const ct = this.compTypes;
                    let model = {};
                    if (ct) {
                        let obj = '';
                        let type = node.getAttribute && node.getAttribute(`${ modelAttrStart }type`);
                        if (type) {
                            model = { type };
                        } else {
                            for (let it = 0; it < ct.length; it++) {
                                const compType = ct[it];
                                obj = compType.model.isComponent(node);
                                if (obj) {
                                    if (typeof obj !== 'object') {
                                        obj = { type: compType.id };
                                    }
                                    break;
                                }
                            }
                            model = obj;
                        }
                    }
                    if (!model.tagName) {
                        model.tagName = node.tagName ? node.tagName.toLowerCase() : '';
                    }
                    if (attrsLen) {
                        model.attributes = {};
                    }
                    for (let j = 0; j < attrsLen; j++) {
                        const nodeName = attrs[j].nodeName;
                        let nodeValue = attrs[j].nodeValue;
                        if (nodeName == 'style') {
                            model.style = this.parseStyle(nodeValue);
                        } else if (nodeName == 'class') {
                            model.classes = this.parseClass(nodeValue);
                        } else if (nodeName == 'contenteditable') {
                            continue;
                        } else if (nodeName.indexOf(modelAttrStart) === 0) {
                            const modelAttr = nodeName.replace(modelAttrStart, '');
                            const valueLen = nodeValue.length;
                            const firstChar = nodeValue && nodeValue.substr(0, 1);
                            const lastChar = nodeValue && nodeValue.substr(valueLen - 1);
                            nodeValue = nodeValue === 'true' ? true : nodeValue;
                            nodeValue = nodeValue === 'false' ? false : nodeValue;
                            try {
                                nodeValue = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(nodeValue) : nodeValue;
                            } catch (e) {
                            }
                            model[modelAttr] = nodeValue;
                        } else {
                            model.attributes[nodeName] = nodeValue;
                        }
                    }
                    if (nodeChild && !model.components) {
                        const firstChild = node.childNodes[0];
                        if (nodeChild === 1 && firstChild.nodeType === 3) {
                            !model.type && (model.type = 'text');
                            model.content = firstChild.nodeValue;
                        } else {
                            model.components = this.parseNode(node);
                        }
                    }
                    if (model.type == 'textnode') {
                        if (nodePrev && nodePrev.type == 'textnode') {
                            nodePrev.content += model.content;
                            continue;
                        }
                        if (!config.keepEmptyTextNodes) {
                            const content = node.nodeValue;
                            if (content != ' ' && !content.trim()) {
                                continue;
                            }
                        }
                    }
                    const comps = model.components;
                    if (!model.type && comps) {
                        let allTxt = 1;
                        let foundTextNode = 0;
                        for (let ci = 0; ci < comps.length; ci++) {
                            const comp = comps[ci];
                            const cType = comp.type;
                            if ([
                                    'text',
                                    'textnode'
                                ].indexOf(cType) < 0 && c.textTags.indexOf(comp.tagName) < 0) {
                                allTxt = 0;
                                break;
                            }
                            if (cType == 'textnode') {
                                foundTextNode = 1;
                            }
                        }
                        if (allTxt && foundTextNode) {
                            model.type = 'text';
                        }
                    }
                    if (!model.tagName && model.type != 'textnode') {
                        continue;
                    }
                    result.push(model);
                }
                return result;
            },
            parse(str, parserCss) {
                var config = c.em && c.em.get('Config') || {};
                var res = {
                    html: '',
                    css: ''
                };
                var el = document.createElement('div');
                el.innerHTML = str;
                var scripts = el.querySelectorAll('script');
                var i = scripts.length;
                if (!config.allowScripts) {
                    while (i--)
                        scripts[i].parentNode.removeChild(scripts[i]);
                }
                if (parserCss) {
                    var styleStr = '';
                    var styles = el.querySelectorAll('style');
                    var j = styles.length;
                    while (j--) {
                        styleStr = styles[j].innerHTML + styleStr;
                        styles[j].parentNode.removeChild(styles[j]);
                    }
                    if (styleStr)
                        res.css = parserCss.parse(styleStr);
                }
                var result = this.parseNode(el);
                if (result.length == 1)
                    result = result[0];
                res.html = result;
                return res;
            }
        };
    };
});
define('skylark-grapejs/parser/index',[
    "skylark-langx/langx",
    './config/config',
    './model/ParserCss',
    './model/ParserHtml'
], function (langx,defaults, parserCss, parserHtml) {
    'use strict';
    return () => {
        let conf = {};
        let pHtml, pCss;
        return {
            compTypes: '',
            parserCss: null,
            parserHtml: null,
            name: 'Parser',
            getConfig() {
                return conf;
            },
            init(config = {}) {
                conf = langx.mixin({},defaults,config);
                conf.Parser = this;
                pHtml = new parserHtml(conf);
                pCss = new parserCss(conf);
                this.em = conf.em;
                this.parserCss = pCss;
                this.parserHtml = pHtml;
                return this;
            },
            parseHtml(str) {
                const {em, compTypes} = this;
                pHtml.compTypes = em ? em.get('DomComponents').getTypes() : compTypes;
                return pHtml.parse(str, pCss);
            },
            parseCss(str) {
                return pCss.parse(str);
            }
        };
    };
});
define('utils/mixins',['skylark-underscore'], function (_) {
    'use strict';
    const elProt = window.Element.prototype;
    const matches = elProt.matches || elProt.webkitMatchesSelector || elProt.mozMatchesSelector || elProt.msMatchesSelector;
    const appendStyles = (styles, opts = {}) => {
        const stls = _.isArray(styles) ? [...styles] : [styles];
        if (stls.length) {
            const href = stls.shift();
            if (href && (!opts.unique || !document.querySelector(`link[href="${ href }"]`))) {
                const {head} = document;
                const link = document.createElement('link');
                link.href = href;
                link.rel = 'stylesheet';
                if (opts.prepand) {
                    head.insertBefore(link, head.firstChild);
                } else {
                    head.appendChild(link);
                }
            }
            appendStyles(stls);
        }
    };
    const shallowDiff = (objOrig, objNew) => {
        const result = {};
        const keysNew = _.keys(objNew);
        for (let prop in objOrig) {
            if (objOrig.hasOwnProperty(prop)) {
                const origValue = objOrig[prop];
                const newValue = objNew[prop];
                if (keysNew.indexOf(prop) >= 0) {
                    if (origValue !== newValue) {
                        result[prop] = newValue;
                    }
                } else {
                    result[prop] = null;
                }
            }
        }
        for (let prop in objNew) {
            if (objNew.hasOwnProperty(prop)) {
                if (_.isUndefined(objOrig[prop])) {
                    result[prop] = objNew[prop];
                }
            }
        }
        return result;
    };
    const on = (el, ev, fn) => {
        ev = ev.split(/\s+/);
        el = el instanceof Array ? el : [el];
        for (let i = 0; i < ev.length; ++i) {
            el.forEach(elem => elem.addEventListener(ev[i], fn));
        }
    };
    const off = (el, ev, fn) => {
        ev = ev.split(/\s+/);
        el = el instanceof Array ? el : [el];
        for (let i = 0; i < ev.length; ++i) {
            el.forEach(elem => elem.removeEventListener(ev[i], fn));
        }
    };
    const getUnitFromValue = value => {
        return value.replace(parseFloat(value), '');
    };
    const upFirst = value => value[0].toUpperCase() + value.toLowerCase().slice(1);
    const camelCase = value => {
        const values = value.split('-').filter(String);
        return values[0].toLowerCase() + values.slice(1).map(upFirst);
    };
    const normalizeFloat = (value, step = 1, valueDef = 0) => {
        let stepDecimals = 0;
        if (isNaN(value))
            return valueDef;
        value = parseFloat(value);
        if (Math.floor(value) !== value) {
            const side = step.toString().split('.')[1];
            stepDecimals = side ? side.length : 0;
        }
        return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
    };
    const hasDnd = em => {
        return 'draggable' in document.createElement('i') && (em ? em.get('Config').nativeDnD : 1);
    };
    const getElement = el => {
        if (_.isElement(el) || isTextNode(el)) {
            return el;
        } else if (el && el.getEl) {
            return el.getEl();
        }
    };
    const isTextNode = el => el && el.nodeType === 3;
    const isCommentNode = el => el && el.nodeType === 8;
    const isTaggableNode = el => el && !isTextNode(el) && !isCommentNode(el);
    const getModel = (el, $) => {
        let model = el;
        _.isElement(el) && (model = $(el).data('model'));
        return model;
    };
    const getElRect = el => {
        const def = {
            top: 0,
            left: 0,
            width: 0,
            height: 0
        };
        if (!el)
            return def;
        let rectText;
        if (isTextNode(el)) {
            const range = document.createRange();
            range.selectNode(el);
            rectText = range.getBoundingClientRect();
            range.detach();
        }
        return rectText || (el.getBoundingClientRect ? el.getBoundingClientRect() : def);
    };
    const getPointerEvent = ev => ev.touches && ev.touches[0] ? ev.touches[0] : ev;
    const getKeyCode = ev => ev.which || ev.keyCode;
    const getKeyChar = ev => String.fromCharCode(getKeyCode(ev));
    const isEscKey = ev => getKeyCode(ev) === 27;
    const capitalize = str => str && str.charAt(0).toUpperCase() + str.substring(1);
    const isComponent = obj => obj && obj.toHTML;
    const isRule = obj => obj && obj.toCSS;
    const getViewEl = el => el.__gjsv;
    const setViewEl = (el, view) => {
        el.__gjsv = view;
    };
    return {
        isCommentNode: isCommentNode,
        isTaggableNode: isTaggableNode,
        on,
        off,
        hasDnd,
        upFirst,
        matches,
        getModel,
        getElRect,
        camelCase,
        isTextNode,
        getKeyCode,
        getKeyChar,
        isEscKey,
        getElement,
        shallowDiff,
        normalizeFloat,
        getPointerEvent,
        getUnitFromValue,
        capitalize,
        getViewEl,
        setViewEl,
        appendStyles,
        isComponent,
        isRule
    };
});
define('skylark-grapejs/selector_manager/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'clm-',
        appendTo: '',
        selectors: [],
        states: [
            { name: 'hover' },
            { name: 'active' },
            { name: 'nth-of-type(2n)' }
        ],
        escapeName: 0,
        selectedName: 0,
        iconAdd: '<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>',
        iconSync: '<svg viewBox="0 0 24 24"><path d="M12 18c-3.31 0-6-2.69-6-6 0-1 .25-1.97.7-2.8L5.24 7.74A7.93 7.93 0 0 0 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4m0-11V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1-.25 1.97-.7 2.8l1.46 1.46A7.93 7.93 0 0 0 20 12c0-4.42-3.58-8-8-8z"></path></svg>',
        iconTagOn: '<svg viewBox="0 0 24 24"><path d="M19 19H5V5h10V3H5c-1.11 0-2 .89-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8h-2m-11.09-.92L6.5 11.5 11 16 21 6l-1.41-1.42L11 13.17l-3.09-3.09z"></path></svg>',
        iconTagOff: '<svg viewBox="0 0 24 24"><path d="M19 3H5c-1.11 0-2 .89-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5a2 2 0 0 0-2-2m0 2v14H5V5h14z"></path></svg>',
        iconTagRemove: '<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path></svg>',
        render: 0,
        componentFirst: 0
    };
});
define('skylark-grapejs/selector_manager/model/Selector',['skylark-backbone'], function (Backbone) {
    'use strict';
    const TYPE_CLASS = 1;
    const TYPE_ID = 2;
    const Selector = Backbone.Model.extend({
        idAttribute: 'name',
        defaults: {
            name: '',
            label: '',
            type: TYPE_CLASS,
            active: true,
            private: false,
            protected: false
        },
        initialize(props, opts = {}) {
            const {
                config = {}
            } = opts;
            const name = this.get('name');
            const label = this.get('label');
            if (!name) {
                this.set('name', label);
            } else if (!label) {
                this.set('label', name);
            }
            const namePreEsc = this.get('name');
            const {escapeName} = config;
            const nameEsc = escapeName ? escapeName(namePreEsc) : Selector.escapeName(namePreEsc);
            this.set('name', nameEsc);
        },
        getFullName(opts = {}) {
            const {escape} = opts;
            const name = this.get('name');
            let init = '';
            switch (this.get('type')) {
            case TYPE_CLASS:
                init = '.';
                break;
            case TYPE_ID:
                init = '#';
                break;
            }
            return init + (escape ? escape(name) : name);
        }
    }, {
        TYPE_CLASS,
        TYPE_ID,
        escapeName(name) {
            return `${ name }`.trim().replace(/([^a-z0-9\w-\:]+)/gi, '-');
        }
    });
    return Selector;
});
define('skylark-grapejs/selector_manager/model/Selectors',[
    'skylark-underscore',
    'skylark-backbone',
    './Selector'
], function (a, Backbone, Selector) {
    'use strict';
    return Backbone.Collection.extend({
        model: Selector,
        modelId: attr => `${ attr.name }_${ attr.type || Selector.TYPE_CLASS }`,
        getStyleable() {
            return a.filter(this.models, item => item.get('active') && !item.get('private'));
        },
        getValid({noDisabled} = {}) {
            return a.filter(this.models, item => !item.get('private')).undefined(item => noDisabled ? item.get('active') : 1);
        },
        getFullString(collection, opts = {}) {
            const result = [];
            const coll = collection || this;
            coll.forEach(selector => result.push(selector.getFullName(opts)));
            return result.join('').trim();
        }
    });
});
define('skylark-grapejs/selector_manager/view/ClassTagView',['skylark-backbone'], function (Backbone) {
    'use strict';
    const inputProp = 'contentEditable';
    return Backbone.View.extend({
        template() {
            const {pfx, model, config} = this;
            const label = model.get('label') || '';
            return `
      <span id="${ pfx }checkbox" class="${ pfx }tag-status" data-tag-status></span>
      <span id="${ pfx }tag-label" data-tag-name>${ label }</span>
      <span id="${ pfx }close" class="${ pfx }tag-close" data-tag-remove>
        ${ config.iconTagRemove }
      </span>
    `;
        },
        events: {
            'click [data-tag-remove]': 'removeTag',
            'click [data-tag-status]': 'changeStatus',
            'dblclick [data-tag-name]': 'startEditTag',
            'focusout [data-tag-name]': 'endEditTag'
        },
        initialize(o) {
            const config = o.config || {};
            this.config = config;
            this.coll = o.coll || null;
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.em = config.em;
            this.listenTo(this.model, 'change:active', this.updateStatus);
        },
        getInputEl() {
            if (!this.inputEl) {
                this.inputEl = this.el.querySelector('[data-tag-name]');
            }
            return this.inputEl;
        },
        startEditTag() {
            const {em} = this;
            const inputEl = this.getInputEl();
            inputEl[inputProp] = true;
            inputEl.focus();
            em && em.setEditing(1);
        },
        endEditTag() {
            const model = this.model;
            const inputEl = this.getInputEl();
            const label = inputEl.textContent;
            const em = this.em;
            const sm = em && em.get('SelectorManager');
            inputEl[inputProp] = false;
            em && em.setEditing(0);
            if (sm) {
                const name = sm.escapeName(label);
                if (sm.get(name)) {
                    inputEl.innerText = model.get('label');
                } else {
                    model.set({
                        name,
                        label
                    });
                }
            }
        },
        changeStatus() {
            const {model} = this;
            model.set('active', !model.get('active'));
        },
        removeTag() {
            const {em, model} = this;
            const targets = em && em.getSelectedAll();
            targets.forEach(sel => {
                !model.get('protected') && sel && sel.getSelectors().remove(model);
            });
        },
        updateStatus() {
            const {model, $el, config} = this;
            const {iconTagOn, iconTagOff} = config;
            const $chk = $el.find('[data-tag-status]');
            if (model.get('active')) {
                $chk.html(iconTagOn);
                $el.removeClass('opac50');
            } else {
                $chk.html(iconTagOff);
                $el.addClass('opac50');
            }
        },
        render() {
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            this.$el.html(this.template());
            this.$el.attr('class', `${ pfx }tag ${ ppfx }three-bg`);
            this.updateStatus();
            return this;
        }
    });
});
define('skylark-grapejs/selector_manager/view/ClassTagsView',[
    'skylark-underscore',
    'skylark-backbone',
    './ClassTagView'
], function (a, Backbone, ClassTagView) {
    'use strict';
    return Backbone.View.extend({
        template({labelInfo, labelStates, labelHead, iconSync, iconAdd, pfx, ppfx}) {
            return `
    <div id="${ pfx }up" class="${ pfx }header">
      <div id="${ pfx }label" class="${ pfx }header-label">${ labelHead }</div>
      <div id="${ pfx }status-c" class="${ pfx }header-status">
        <span id="${ pfx }input-c" data-states-c>
          <div class="${ ppfx }field ${ ppfx }select">
            <span id="${ ppfx }input-holder">
              <select id="${ pfx }states" data-states>
                <option value="">${ labelStates }</option>
              </select>
            </span>
            <div class="${ ppfx }sel-arrow">
              <div class="${ ppfx }d-s-arrow"></div>
            </div>
          </div>
        </span>
      </div>
    </div>
    <div id="${ pfx }tags-field" class="${ ppfx }field">
      <div id="${ pfx }tags-c" data-selectors></div>
      <input id="${ pfx }new" data-input/>
      <span id="${ pfx }add-tag" class="${ pfx }tags-btn ${ pfx }tags-btn__add" data-add>
        ${ iconAdd }
      </span>
      <span class="${ pfx }tags-btn ${ pfx }tags-btn__sync" style="display: none" data-sync-style>
        ${ iconSync }
      </span>
    </div>
    <div class="${ pfx }sels-info">
      <div class="${ pfx }label-sel">${ labelInfo }:</div>
      <div class="${ pfx }sels" data-selected></div>
      <div style="clear:both"></div>
    </div>`;
        },
        events: {
            'change [data-states]': 'stateChanged',
            'click [data-add]': 'startNewTag',
            'focusout [data-input]': 'endNewTag',
            'keyup [data-input]': 'onInputKeyUp',
            'click [data-sync-style]': 'syncStyle'
        },
        initialize(o = {}) {
            this.config = o.config || {};
            this.pfx = this.config.stylePrefix || '';
            this.ppfx = this.config.pStylePrefix || '';
            this.className = this.pfx + 'tags';
            this.stateInputId = this.pfx + 'states';
            this.stateInputC = this.pfx + 'input-c';
            this.states = this.config.states || [];
            const {em} = this.config;
            const emitter = this.getStyleEmitter();
            const coll = this.collection;
            this.target = this.config.em;
            this.em = em;
            const toList = 'component:toggled component:update:classes';
            const toListCls = 'component:update:classes change:state';
            this.listenTo(em, toList, this.componentChanged);
            this.listenTo(emitter, 'styleManager:update', this.componentChanged);
            this.listenTo(em, toListCls, this.__handleStateChange);
            this.listenTo(em, 'styleable:change change:device', this.checkSync);
            this.listenTo(coll, 'add', this.addNew);
            this.listenTo(coll, 'reset', this.renderClasses);
            this.listenTo(coll, 'remove', this.tagRemoved);
            this.delegateEvents();
        },
        syncStyle() {
            const {em} = this;
            const target = this.getTarget();
            const cssC = em.get('CssComposer');
            const opts = { noDisabled: 1 };
            const selectors = this.getCommonSelectors({ opts });
            const state = em.get('state');
            const mediaText = em.getCurrentMedia();
            const ruleComponents = [];
            const rule = cssC.get(selectors, state, mediaText) || cssC.add(selectors, state, mediaText);
            let style;
            this.getTargets().forEach(target => {
                const ruleComponent = cssC.getIdRule(target.getId(), {
                    state,
                    mediaText
                });
                style = ruleComponent.getStyle();
                ruleComponent.setStyle({});
                ruleComponents.push(ruleComponent);
            });
            style && rule.addStyle(style);
            em.trigger('component:toggled');
            em.trigger('component:sync-style', {
                component: target,
                selectors,
                mediaText,
                rule,
                ruleComponents,
                state
            });
        },
        getStyleEmitter() {
            const {em} = this;
            const sm = em && em.get('StyleManager');
            const emitter = sm && sm.getEmitter();
            return emitter || {};
        },
        tagRemoved(model) {
            this.updateStateVis();
        },
        getStateOptions() {
            const {states, em} = this;
            let result = [];
            states.forEach(state => result.push(`<option value="${ state.name }">${ em.t(`selectorManager.states.${ state.name }`) || state.label || state.name }</option>`));
            return result.join('');
        },
        addNew(model) {
            this.addToClasses(model);
        },
        startNewTag() {
            this.$addBtn.css({ display: 'none' });
            this.$input.show().focus();
        },
        endNewTag() {
            this.$addBtn.css({ display: '' });
            this.$input.hide().val('');
        },
        onInputKeyUp(e) {
            if (e.keyCode === 13)
                this.addNewTag(this.$input.val());
            else if (e.keyCode === 27)
                this.endNewTag();
        },
        checkStates() {
            const state = this.em.getState();
            const statesEl = this.getStates();
            statesEl && statesEl.val(state);
        },
        componentChanged: a.debounce(function ({targets} = {}) {
            this.updateSelection(targets);
        }),
        updateSelection(targets) {
            let trgs = targets || this.getTargets();
            trgs = a.isArray(trgs) ? trgs : [trgs];
            let selectors = [];
            if (trgs && trgs.length) {
                selectors = this.getCommonSelectors({ targets: trgs });
                this.checkSync({ validSelectors: selectors });
            }
            this.collection.reset(selectors);
            this.updateStateVis(trgs);
            return selectors;
        },
        getCommonSelectors({targets, opts = {}} = {}) {
            const trgs = targets || this.getTargets();
            const selectors = trgs.map(tr => tr.getSelectors && tr.getSelectors().getValid(opts)).filter(i => i);
            return this._commonSelectors(...selectors);
        },
        _commonSelectors(...args) {
            if (!args.length)
                return [];
            if (args.length === 1)
                return args[0];
            if (args.length === 2)
                return args[0].filter(item => args[1].indexOf(item) >= 0);
            return args.slice(1).reduce((acc, item) => this._commonSelectors(acc, item), args[0]);
        },
        checkSync: a.debounce(function () {
            const {$btnSyncEl, config, collection} = this;
            const target = this.getTarget();
            let hasStyle;
            if (target && config.componentFirst && collection.length) {
                const style = target.getStyle();
                hasStyle = !a.isEmpty(style);
            }
            $btnSyncEl && $btnSyncEl[hasStyle ? 'show' : 'hide']();
        }),
        getTarget() {
            return this.target.getSelected();
        },
        getTargets() {
            return this.target.getSelectedAll();
        },
        updateStateVis(target) {
            const em = this.em;
            const avoidInline = em && em.getConfig('avoidInlineStyle');
            const display = this.collection.length || avoidInline ? '' : 'none';
            this.getStatesC().css('display', display);
            this.updateSelector(target);
        },
        __handleStateChange() {
            this.updateSelector(this.getTargets());
        },
        updateSelector(targets) {
            const elSel = this.el.querySelector('[data-selected]');
            const result = [];
            let trgs = targets || this.getTargets();
            trgs = a.isArray(trgs) ? trgs : [trgs];
            trgs.forEach(target => result.push(this.__getName(target)));
            elSel && (elSel.innerHTML = result.join(', '));
            this.checkStates();
        },
        __getName(target) {
            const {pfx, config, em} = this;
            const {selectedName, componentFirst} = config;
            let result;
            if (a.isString(target)) {
                result = `<span class="${ pfx }sel-gen">${ target }</span>`;
            } else {
                if (!target || !target.get)
                    return;
                const selectors = target.getSelectors().getStyleable();
                const state = em.get('state');
                const idRes = target.getId ? `<span class="${ pfx }sel-cmp">${ target.getName() }</span><span class="${ pfx }sel-id">#${ target.getId() }</span>` : '';
                result = this.collection.getFullString(selectors);
                result = result ? `<span class="${ pfx }sel-rule">${ result }</span>` : target.get('selectorsAdd') || idRes;
                result = componentFirst && idRes ? idRes : result;
                result += state ? `<span class="${ pfx }sel-state">:${ state }</span>` : '';
                result = selectedName ? selectedName({
                    result,
                    state,
                    target
                }) : result;
            }
            return result && `<span class="${ pfx }sel">${ result }</span>`;
        },
        stateChanged(ev) {
            const {em} = this;
            const {value} = ev.target;
            em.set('state', value);
        },
        addNewTag(label) {
            const {em} = this;
            if (!label.trim())
                return;
            if (em) {
                const sm = em.get('SelectorManager');
                const model = sm.add({ label });
                this.getTargets().forEach(target => {
                    target.getSelectors().add(model);
                    this.collection.add(model);
                    this.updateStateVis();
                });
            }
            this.endNewTag();
        },
        addToClasses(model, fragmentEl = null) {
            const fragment = fragmentEl;
            const classes = this.getClasses();
            const rendered = new ClassTagView({
                model,
                config: this.config,
                coll: this.collection
            }).render().el;
            fragment ? fragment.appendChild(rendered) : classes.append(rendered);
            return rendered;
        },
        renderClasses() {
            const frag = document.createDocumentFragment();
            const classes = this.getClasses();
            classes.empty();
            this.collection.each(model => this.addToClasses(model, frag));
            classes.append(frag);
        },
        getClasses() {
            return this.$el.find('[data-selectors]');
        },
        getStates() {
            if (!this.$states) {
                const el = this.$el.find('[data-states]');
                this.$states = el[0] && el;
            }
            return this.$states;
        },
        getStatesC() {
            if (!this.$statesC)
                this.$statesC = this.$el.find('#' + this.stateInputC);
            return this.$statesC;
        },
        render() {
            const {em, pfx, ppfx, config, $el, el} = this;
            const {render, iconSync, iconAdd} = config;
            const tmpOpts = {
                iconSync,
                iconAdd,
                labelHead: em.t('selectorManager.label'),
                labelStates: em.t('selectorManager.emptyState'),
                labelInfo: em.t('selectorManager.selected'),
                ppfx,
                pfx,
                el
            };
            $el.html(this.template(tmpOpts));
            const renderRes = render && render(tmpOpts);
            renderRes && renderRes !== el && $el.empty().append(renderRes);
            this.$input = $el.find('[data-input]');
            this.$addBtn = $el.find('[data-add]');
            this.$classes = $el.find('#' + pfx + 'tags-c');
            this.$btnSyncEl = $el.find('[data-sync-style]');
            this.$input.hide();
            const statesEl = this.getStates();
            statesEl && statesEl.append(this.getStateOptions());
            this.renderClasses();
            $el.attr('class', `${ this.className } ${ ppfx }one-bg ${ ppfx }two-color`);
            return this;
        }
    });
});
define('skylark-grapejs/selector_manager/index',[
    "skylark-langx/langx",
    'skylark-underscore',
    '../../utils/mixins',
    './config/config',
    './model/Selector',
    './model/Selectors',
    './view/ClassTagsView'
], function (langx,_, b, defaults, Selector, Selectors, ClassTagsView) {
    'use strict';
    const isId = str => _.isString(str) && str[0] == '#';
    const isClass = str => _.isString(str) && str[0] == '.';
    return config => {
        var c = config || {};
        var selectors;
        return {
            Selector,
            Selectors,
            name: 'SelectorManager',
            getConfig() {
                return c;
            },
            init(conf = {}) {
                c = langx.mxinin({},defaults,conf);
                const em = c.em;
                const ppfx = c.pStylePrefix;
                this.em = em;
                if (ppfx) {
                    c.stylePrefix = ppfx + c.stylePrefix;
                }
                this.selectorTags = new ClassTagsView({
                    collection: new Selectors([], {
                        em,
                        config: c
                    }),
                    config: c
                });
                selectors = new Selectors(c.selectors);
                selectors.on('add', model => em.trigger('selector:add', model));
                selectors.on('remove', model => em.trigger('selector:remove', model));
                selectors.on('change', model => em.trigger('selector:update', model, model.previousAttributes(), model.changedAttributes()));
                em.on('change:state', (m, value) => em.trigger('selector:state', value));
                return this;
            },
            postRender() {
                const elTo = this.getConfig().appendTo;
                if (elTo) {
                    const el = _.isElement(elTo) ? elTo : document.querySelector(elTo);
                    el.appendChild(this.render([]));
                }
            },
            select(value, opts = {}) {
                const targets = Array.undefined(value) ? value : [value];
                const toSelect = this.em.get('StyleManager').setTarget(targets, opts);
                const res = toSelect.filter(i => i).map(sel => b.isComponent(sel) ? sel : b.isRule(sel) && !sel.get('selectorsAdd') ? sel : sel.getSelectorsString());
                this.selectorTags.componentChanged({ targets: res });
                return this;
            },
            setState(value) {
                this.em.setState(value);
                return this;
            },
            getState() {
                return this.em.setState();
            },
            addSelector(name, opt = {}) {
                let opts = langx.clone(opt);
                if (_.isObject(name)) {
                    opts = name;
                } else {
                    opts.name = name;
                }
                if (isId(opts.name)) {
                    opts.name = opts.name.substr(1);
                    opts.type = Selector.TYPE_ID;
                } else if (isClass(opts.name)) {
                    opts.name = opts.name.substr(1);
                }
                if (opts.label && !opts.name) {
                    opts.name = this.escapeName(opts.label);
                }
                const cname = opts.name;
                const selector = cname ? this.get(cname, opts.type) : selectors.where(opts)[0];
                if (!selector) {
                    return selectors.add(opts, { config: c });
                }
                return selector;
            },
            getSelector(name, type = Selector.TYPE_CLASS) {
                if (isId(name)) {
                    name = name.substr(1);
                    type = Selector.TYPE_ID;
                } else if (isClass(name)) {
                    name = name.substr(1);
                }
                return selectors.where({
                    name,
                    type
                })[0];
            },
            add(name, opts = {}) {
                if (_.isArray(name)) {
                    return name.map(item => this.addSelector(item, opts));
                } else {
                    return this.addSelector(name, opts);
                }
            },
            addClass(classes) {
                const added = [];
                if (_.isString(classes)) {
                    classes = classes.trim().split(' ');
                }
                classes.forEach(name => added.push(this.addSelector(name)));
                return added;
            },
            get(name, type) {
                if (_.isArray(name)) {
                    const result = [];
                    const selectors = name.map(item => this.getSelector(item)).filter(item => item);
                    selectors.forEach(item => result.indexOf(item) < 0 && result.push(item));
                    return result;
                } else {
                    return this.getSelector(name, type);
                }
            },
            getAll() {
                return selectors;
            },
            escapeName(name) {
                const {escapeName} = c;
                return escapeName ? escapeName(name) : Selector.escapeName(name);
            },
            render(selectors) {
                if (selectors) {
                    this.selectorTags = new ClassTagsView({
                        collection: new Selectors(selectors),
                        config: c
                    });
                    return this.selectorTags.render().el;
                } else
                    return this.selectorTags.render().el;
            }
        };
    };
});
define('skylark-grapejs/style_manager/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'sm-',
        sectors: [],
        appendTo: '',
        hideNotStylable: true,
        highlightChanged: true,
        highlightComputed: true,
        showComputed: true,
        clearProperties: 0,
        avoidComputed: [
            'width',
            'height'
        ]
    };
});
define('skylark-grapejs/domain_abstract/model/TypeableCollection',[
    'skylark-underscore',
    'skylark-backbone'
], function (a, Backbone) {
    'use strict';
    const Model = Backbone.Model;
    const View = Backbone.View;
    return {
        types: [],
        initialize(models, opts) {
            this.model = (attrs = {}, options = {}) => {
                let Model, View, type;
                if (attrs && attrs.type) {
                    const baseType = this.getBaseType();
                    type = this.getType(attrs.type);
                    Model = type ? type.model : baseType.model;
                    View = type ? type.view : baseType.view;
                } else {
                    const typeFound = this.recognizeType(attrs);
                    type = typeFound.type;
                    Model = type.model;
                    View = type.view;
                    attrs = typeFound.attributes;
                }
                const model = new Model(attrs, options);
                model.typeView = View;
                return model;
            };
            const init = this.init && this.init.bind(this);
            init && init();
        },
        recognizeType(value) {
            const types = this.getTypes();
            for (let i = 0; i < types.length; i++) {
                const type = types[i];
                let typeFound = type.isType(value);
                typeFound = typeof typeFound == 'boolean' && typeFound ? { type: type.id } : typeFound;
                if (typeFound) {
                    return {
                        type,
                        attributes: typeFound
                    };
                }
            }
            return {
                type: this.getBaseType(),
                attributes: value
            };
        },
        getBaseType() {
            const types = this.getTypes();
            return types[types.length - 1];
        },
        getTypes() {
            return this.types;
        },
        getType(id) {
            const types = this.getTypes();
            for (let i = 0; i < types.length; i++) {
                const type = types[i];
                if (type.id === id) {
                    return type;
                }
            }
        },
        addType(id, definition) {
            const type = this.getType(id);
            const baseType = this.getBaseType();
            const ModelInst = type ? type.model : baseType.model;
            const ViewInst = type ? type.view : baseType.view;
            let {model, view, isType} = definition;
            model = model instanceof Model || a.isFunction(model) ? model : ModelInst.extend(model || {});
            view = view instanceof View || a.isFunction(view) ? view : ViewInst.extend(view || {});
            if (type) {
                type.model = model;
                type.view = view;
                type.isType = isType || type.isType;
            } else {
                definition.id = id;
                definition.model = model;
                definition.view = view;
                definition.isType = isType || function (value) {
                    if (value && value.type == id) {
                        return true;
                    }
                };
                this.getTypes().unshift(definition);
            }
        }
    };
});
define('skylark-grapejs/style_manager/model/Property',[
    "skylark-langx/langx",
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins'
], function (langx,Backbone, a, b) {
    'use strict';
    const Property = Backbone.Model.extend({
        defaults: {
            name: '',
            property: '',
            type: '',
            defaults: '',
            info: '',
            value: '',
            icon: '',
            functionName: '',
            status: '',
            visible: true,
            fixedValues: [
                'initial',
                'inherit'
            ],
            full: 0,
            important: 0,
            toRequire: 0,
            requires: null,
            requiresParent: null
        },
        initialize(props = {}, opts = {}) {
            const id = this.get('id') || '';
            const name = this.get('name') || '';
            !this.get('property') && this.set('property', (name || id).replace(/ /g, '-'));
            const prop = this.get('property');
            !this.get('id') && this.set('id', prop);
            !name && this.set('name', b.capitalize(prop).replace(/-/g, ' '));
            Property.callInit(this, props, opts);
        },
        init() {
        },
        clearValue(opts = {}) {
            this.set({
                value: undefined,
                status: ''
            }, opts);
            return this;
        },
        setValue(value, complete = 1, opts = {}) {
            const parsed = this.parseValue(value);
            this.set(parsed, langx.mixin({},opts,{
                avoidStore: !complete
            }));
        },
        setValueFromInput(value, complete, opts = {}) {
            this.setValue(value, complete, langx.mixin({},opts,{
                fromInput: 1
            }));
        },
        parseValue(value, opts = {}) {
            const result = { value };
            const imp = '!important';
            if (a.isString(value) && value.indexOf(imp) !== -1) {
                result.value = value.replace(imp, '').trim();
                result.important = 1;
            }
            if (!this.get('functionName') && !opts.complete) {
                return result;
            }
            const args = [];
            let valueStr = `${ result.value }`;
            let start = valueStr.indexOf('(') + 1;
            let end = valueStr.lastIndexOf(')');
            const functionName = valueStr.substring(0, start - 1);
            if (functionName)
                result.functionName = functionName;
            args.push(start);
            if (end >= 0) {
                args.push(end);
            }
            result.value = String.prototype.substring.apply(valueStr, args);
            if (opts.numeric) {
                const num = parseFloat(result.value);
                result.unit = result.value.replace(num, '');
                result.value = num;
            }
            return result;
        },
        splitValues(values, separator = ',') {
            const res = [];
            const op = '(';
            const cl = ')';
            let curr = '';
            let acc = 0;
            (values || '').split('').forEach(str => {
                if (str == op) {
                    acc++;
                    curr = curr + op;
                } else if (str == cl && acc > 0) {
                    acc--;
                    curr = curr + cl;
                } else if (str === separator && acc == 0) {
                    res.push(curr);
                    curr = '';
                } else {
                    curr = curr + str;
                }
            });
            curr !== '' && res.push(curr);
            return res.map(i => i.trim());
        },
        getDefaultValue() {
            return this.get('defaults');
        },
        getFullValue(val) {
            const fn = this.get('functionName');
            const def = this.getDefaultValue();
            let value = a.isUndefined(val) ? this.get('value') : val;
            const hasValue = !a.isUndefined(value) && value !== '';
            if (value && def && value === def) {
                return def;
            }
            if (fn && hasValue) {
                value = `${ fn }(${ value })`;
            }
            if (hasValue && this.get('important')) {
                value = `${ value } !important`;
            }
            return value || '';
        }
    }, {
        callParentInit(property, ctx, props, opts = {}) {
            property.prototype.initialize.apply(ctx, [
                props,
                langx.mixin({},opts,{
                    skipInit: 1
                })
            ]);
        },
        callInit(context, props, opts = {}) {
            !opts.skipInit && context.init(props, opts);
        }
    });
    return Property;
});
define('skylark-grapejs/style_manager/model/PropertyComposite',[
    "skylark-langx/langx",
    './Property'
], function (langx,Property) {
    'use strict';
    return Property.extend({
        defaults: {
            ...Property.prototype.defaults,
            detached: 0,
            properties: [],
            separator: ' '
        },
        initialize(props = {}, opts = {}) {
            Property.callParentInit(Property, this, props, opts);
            const properties = this.get('properties') || [];
            const Properties = require('./Properties').default;
            this.set('properties', new Properties(properties));
            this.listenTo(this, 'change:value', this.updateValues);
            Property.callInit(this, props, opts);
        },
        clearValue(opts = {}) {
            this.get('properties').each(property => property.clearValue());
            return Property.prototype.clearValue.apply(this, arguments);
        },
        updateValues() {
            const values = this.getFullValue().split(this.getSplitSeparator());
            this.get('properties').each((property, i) => {
                const len = values.length;
                const value = values[i] || values[i % len + (len != 1 && len % 2 ? 1 : 0)];
            });
        },
        getSplitSeparator() {
            return new RegExp(`${ this.get('separator') }(?![^\\(]*\\))`);
        },
        getDefaultValue(defaultProps) {
            let value = this.get('defaults');
            if (value && !defaultProps) {
                return value;
            }
            value = '';
            const properties = this.get('properties');
            properties.each((prop, index) => value += `${ prop.getDefaultValue() } `);
            return value.trim();
        },
        getFullValue() {
            if (this.get('detached')) {
                return '';
            }
            return this.get('properties').getFullValue();
        },
        getPropertyAt(index) {
            return this.get('properties').at(index);
        }
    });
});
define('skylark-grapejs/style_manager/model/Layer',[
    'skylark-backbone',
    './Properties'
], function (Backbone, Properties) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            index: '',
            value: '',
            values: {},
            active: false,
            preview: false,
            properties: []
        },
        initialize() {
            const prp = this.get('properties');
            var value = this.get('value');
            this.set('properties', prp instanceof Properties ? prp : new Properties(prp));
            const props = this.get('properties');
            props.forEach(this.onPropAdd, this);
            this.listenTo(props, 'add', this.onPropAdd);
            if (!value) {
                var val = '';
                var values = this.get('values');
                for (var prop in values) {
                    val += ' ' + values[prop];
                }
                this.set('value', val.trim());
            }
        },
        onPropAdd(prop) {
            const coll = this.collection;
            prop.parent = coll && coll.property;
        },
        getPropertyAt(index) {
            return this.get('properties').at(index);
        },
        getPropertyValue(property) {
            let result = '';
            this.get('properties').each(prop => {
                if (prop.get('property') == property) {
                    result = prop.getFullValue();
                }
            });
            return result;
        },
        getFullValue() {
            let result = [];
            this.get('properties').each(prop => result.push(prop.getFullValue()));
            return result.join(' ').trim();
        }
    });
});
define('skylark-grapejs/style_manager/model/Layers',[
    'skylark-underscore',
    'skylark-backbone',
    './Layer'
], function (a, Backbone, Layer) {
    'use strict';
    return Backbone.Collection.extend({
        model: Layer,
        initialize() {
            this.idx = 1;
            this.on('add', this.onAdd);
            this.on('reset', this.onReset);
        },
        onAdd(model, c, opts) {
            if (!opts.noIncrement)
                model.set('index', this.idx++);
            opts.active && this.active(this.indexOf(model));
        },
        onReset() {
            this.idx = 1;
        },
        getSeparator() {
            const {property} = this;
            return property ? property.get('layerSeparator') : ', ';
        },
        getLayersFromValue(value) {
            const layers = [];
            value.replace(/\(([\w\s,.]*)\)/g, match => {
                var cleaned = match.replace(/,\s*/g, ',');
                value = value.replace(match, cleaned);
            });
            const layerValues = value ? value.split(this.getSeparator()) : [];
            layerValues.forEach(layerValue => {
                layers.push({ properties: this.properties.parseValue(layerValue) });
            });
            return layers;
        },
        getLayersFromStyle(styleObj) {
            const layers = [];
            const properties = this.properties;
            const propNames = properties.pluck('property');
            properties.each(propModel => {
                const style = styleObj[propModel.get('property')];
                const values = style ? style.split(', ') : [];
                values.forEach((value, i) => {
                    value = propModel.parseValue(value.trim()).value;
                    const layer = layers[i];
                    const propertyObj = {
                        ...propModel.attributes,
                        ...{ value }
                    };
                    if (layer) {
                        layer.properties.push(propertyObj);
                    } else {
                        layers[i] = { properties: [propertyObj] };
                    }
                });
            });
            layers.forEach(layer => {
                const layerProprs = layer.properties.map(prop => prop.property);
                properties.each(propModel => {
                    const propertyName = propModel.get('property');
                    if (layerProprs.indexOf(propertyName) < 0) {
                        layer.properties.push({ ...propModel.attributes });
                    }
                });
            });
            return layers;
        },
        active(index) {
            this.each(layer => layer.set('active', 0));
            const layer = this.at(index);
            layer && layer.set('active', 1);
        },
        getFullValue() {
            let result = [];
            this.each(layer => result.push(layer.getFullValue()));
            return result.join(this.getSeparator());
        },
        getPropertyValues(property, defValue) {
            const result = [];
            this.each(layer => {
                const value = layer.getPropertyValue(property);
                value ? result.push(value) : !a.isUndefined(defValue) && result.push(defValue);
            });
            return result.join(', ');
        }
    });
});
define('skylark-grapejs/style_manager/model/PropertyStack',[
    "skylark-langx/langx",
    './PropertyComposite',
    './Layers'
], function (langx,Property, Layers) {
    'use strict';
    return Property.extend({
        defaults: langx.mixin({},
            ...Property.prototype.defaults,{
            layers: [],
            layerSeparator: ', ',
            prepend: 0,
            preview: 0
        }),
        initialize(props = {}, opts = {}) {
            Property.callParentInit(Property, this, props, opts);
            const layers = this.get('layers');
            const layersColl = new Layers(layers);
            layersColl.property = this;
            layersColl.properties = this.get('properties');
            this.set('layers', layersColl);
            Property.callInit(this, props, opts);
        },
        getLayers() {
            return this.get('layers');
        },
        getCurrentLayer() {
            return this.getLayers().filter(layer => layer.get('active'))[0];
        },
        getFullValue() {
            return this.get('detached') ? '' : this.get('layers').getFullValue();
        },
        getValueFromStyle(styles = {}) {
            const layers = this.getLayers().getLayersFromStyle(styles);
            return new Layers(layers).getFullValue();
        },
        clearValue() {
            this.getLayers().reset();
            return Property.prototype.clearValue.apply(this, arguments);
        },
        getLayersFromTarget(target) {
            return;
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyView',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins'
], function (Backbone, a, b) {
    'use strict';
    const clearProp = 'data-clear-style';
    return Backbone.View.extend({
        template(model) {
            const pfx = this.pfx;
            return `
      <div class="${ pfx }label">
        ${ this.templateLabel(model) }
      </div>
      <div class="${ this.ppfx }fields">
        ${ this.templateInput(model) }
      </div>
    `;
        },
        templateLabel(model) {
            const {pfx, em} = this;
            const {parent} = model;
            const {icon = '', info = '', id, name} = model.attributes;
            const label = em && em.t(`styleManager.properties.${ id }`) || name;
            return `
      <span class="${ pfx }icon ${ icon }" title="${ info }">
        ${ label }
      </span>
      ${ !parent ? `<b class="${ pfx }clear" ${ clearProp }>&Cross;</b>` : '' }
    `;
        },
        templateInput(model) {
            return `
      <div class="${ this.ppfx }field">
        <input placeholder="${ model.getDefaultValue() }"/>
      </div>
    `;
        },
        events: {
            change: 'inputValueChanged',
            [`click [${ clearProp }]`]: 'clear'
        },
        initialize(o = {}) {
            a.bindAll(this, 'targetUpdated');
            this.config = o.config || {};
            const em = this.config.em;
            this.em = em;
            this.pfx = this.config.stylePrefix || '';
            this.ppfx = this.config.pStylePrefix || '';
            this.target = o.target || {};
            this.propTarget = o.propTarget || {};
            this.onChange = o.onChange;
            this.onInputRender = o.onInputRender || {};
            this.customValue = o.customValue || {};
            const model = this.model;
            this.property = model.get('property');
            this.input = null;
            const pfx = this.pfx;
            this.inputHolderId = '#' + pfx + 'input-holder';
            this.sector = model.collection && model.collection.sector;
            model.view = this;
            if (!model.get('value')) {
                model.set('value', model.getDefaultValue());
            }
            em && em.on(`update:component:style:${ this.property }`, this.targetUpdated);
            const requires = model.get('requires');
            requires && Object.keys(requires).forEach(property => {
                em && em.on(`component:styleUpdate:${ property }`, this.targetUpdated);
            });
            this.listenTo(this.propTarget, 'update styleManager:update', this.targetUpdated);
            this.listenTo(model, 'destroy remove', this.remove);
            this.listenTo(model, 'change:value', this.modelValueChanged);
            this.listenTo(model, 'targetUpdated', this.targetUpdated);
            this.listenTo(model, 'change:visible', this.updateVisibility);
            this.listenTo(model, 'change:status', this.updateStatus);
            this.listenTo(model, 'change:name change:className change:full', this.render);
            const init = this.init && this.init.bind(this);
            init && init();
        },
        updateStatus() {
            const {model} = this;
            const status = model.get('status');
            const parent = model.parent;
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            const config = this.config;
            const updatedCls = `${ ppfx }four-color`;
            const computedCls = `${ ppfx }color-warn`;
            const labelEl = this.$el.children(`.${ pfx }label`);
            const clearStyleEl = this.getClearEl();
            const clearStyle = clearStyleEl ? clearStyleEl.style : {};
            labelEl.removeClass(`${ updatedCls } ${ computedCls }`);
            clearStyle.display = 'none';
            switch (status) {
            case 'updated':
                !parent && labelEl.addClass(updatedCls);
                if (config.clearProperties) {
                    clearStyle.display = 'inline';
                }
                break;
            case 'computed':
                labelEl.addClass(computedCls);
                break;
            }
        },
        clear(ev) {
            ev && ev.stopPropagation();
            this.model.clearValue();
            setTimeout(() => this.targetUpdated());
        },
        getClearEl() {
            if (!this.clearEl) {
                this.clearEl = this.el.querySelector(`[${ clearProp }]`);
            }
            return this.clearEl;
        },
        getTarget() {
            return this.getTargetModel();
        },
        getTargets() {
            const {targets} = this.propTarget;
            return targets || [this.getTarget()];
        },
        getTargetModel() {
            return this.propTarget && this.propTarget.model;
        },
        getHelperModel() {
            return this.propTarget && this.propTarget.helper;
        },
        inputValueChanged(e) {
            e && e.stopPropagation();
            this.model.setValue(this.getInputValue(), 1, { fromInput: 1 });
            this.elementUpdated();
        },
        elementUpdated() {
            this.setStatus('updated');
        },
        setStatus(value) {
            this.model.set('status', value);
            const parent = this.model.parent;
            parent && value == 'updated' && parent.set('status', value);
        },
        emitUpdateTarget: a.debounce(function () {
            const em = this.config.em;
            em && em.trigger('styleManager:update:target', this.getTarget());
        }),
        _getTargetData() {
            const {model, config} = this;
            const targetValue = this.getTargetValue({ ignoreDefault: 1 });
            const defaultValue = model.getDefaultValue();
            const computedValue = this.getComputedValue();
            let value = '';
            let status = '';
            if (targetValue) {
                value = targetValue;
                if (config.highlightChanged) {
                    status = 'updated';
                }
            } else if (computedValue && config.showComputed && computedValue != defaultValue) {
                value = computedValue;
                if (config.highlightComputed) {
                    status = 'computed';
                }
            } else {
                value = defaultValue;
                status = '';
            }
            return {
                value,
                status,
                targetValue,
                defaultValue,
                computedValue
            };
        },
        targetUpdated(mod, val, opts = {}) {
            this.emitUpdateTarget();
            if (!this.checkVisibility()) {
                return;
            }
            const config = this.config;
            const em = config.em;
            const {model} = this;
            const property = model.get('property');
            
            //const {
            //    status,
            //    value,
            //    ...targetData
            //} = this._getTargetData();

            const targetData = this._getTargetData()
            this.setStatus(targetData.status);
            model.setValue(targetData.value, 0, {
                fromTarget: 1,
                ...opts
            });
            if (em) {
                const data = {
                //    status,
                //    value,
                    ...targetData
                };
                em.trigger('styleManager:change', this, property, targetData.value, data);
                em.trigger(`styleManager:change:${ property }`, this, targetData.value, data);
                this._emitUpdate(data);
            }
        },
        _emitUpdate(addData = {}) {
            const {em, model} = this;
            if (!em)
                return;
            const property = model.get('property');
            const data = {
                ...this._getEventData(),
                ...addData
            };
            const {id} = data;
            em.trigger('style:update', data);
            em.trigger(`style:update:${ property }`, data);
            property !== id && em.trigger(`style:update:${ id }`, data);
        },
        _getEventData() {
            const {model} = this;
            return {
                propertyView: this,
                targets: this.getTargets(),
                value: model.getFullValue(),
                property: model,
                id: model.get('id'),
                name: model.get('property')
            };
        },
        checkVisibility() {
            var result = 1;
            if (this.config.hideNotStylable) {
                if (!this.isTargetStylable() || !this.isComponentStylable()) {
                    this.hide();
                    result = 0;
                } else {
                    this.show();
                }
                if (this.sector) {
                    this.sector.trigger('updateVisibility');
                }
            }
            return result;
        },
        getTargetValue(opts = {}) {
            let result;
            const {model} = this;
            const target = this.getTargetModel();
            const customFetchValue = this.customValue;
            if (!target) {
                return result;
            }
            result = target.getStyle()[model.get('property')];
            if (!result && !opts.ignoreDefault) {
                result = model.getDefaultValue();
            }
            if (typeof customFetchValue == 'function' && !opts.ignoreCustomValue) {
                let index = model.collection.indexOf(model);
                let customValue = customFetchValue(this, index, result);
                if (customValue) {
                    result = customValue;
                }
            }
            return result;
        },
        getComputedValue() {
            const target = this.propTarget;
            const computed = target.computed || {};
            const computedDef = target.computedDefault || {};
            const avoid = this.config.avoidComputed || [];
            const property = this.model.get('property');
            const notToSkip = avoid.indexOf(property) < 0;
            const value = computed[property];
            const valueDef = computedDef[b.camelCase(property)];
            return computed && notToSkip && valueDef !== value && value || '';
        },
        getInputValue() {
            const input = this.getInputEl();
            return input ? input.value : '';
        },
        modelValueChanged(e, val, opt = {}) {
            const model = this.model;
            const value = model.getFullValue();
            if (!opt.fromInput) {
                this.setValue(value);
            }
            this.getTargets().forEach(target => this.__updateTarget(target, opt));
        },
        __updateTarget(target, opt = {}) {
            const {model} = this;
            const {em} = this.config;
            const prop = model.get('property');
            const value = model.getFullValue();
            const onChange = this.onChange;
            if (!target || !this.isTargetStylable(target) || !this.isComponentStylable()) {
                return;
            }
            if (!opt.fromTarget) {
                if (onChange && !opt.fromParent) {
                    onChange(target, this, opt);
                } else {
                    this.updateTargetStyle(value, null, {
                        ...opt,
                        target
                    });
                }
            }
            const component = em && em.getSelected();
            if (em && component) {
                !opt.noEmit && em.trigger('component:update', component);
                em.trigger('component:styleUpdate', component, prop);
                em.trigger(`component:styleUpdate:${ prop }`, component);
            }
            this._emitUpdate();
        },
        updateTargetStyle(value, name = '', opts = {}) {
            const property = name || this.model.get('property');
            const target = opts.target || this.getTarget();
            const style = target.getStyle();
            if (value) {
                style[property] = value;
            } else {
                delete style[property];
            }
            target.setStyle(style, opts);
            const helper = this.getHelperModel();
            helper && helper.setStyle(style, opts);
        },
        isTargetStylable(target) {
            const trg = target || this.getTarget();
            const model = this.model;
            const id = model.get('id');
            const property = model.get('property');
            const toRequire = model.get('toRequire');
            const unstylable = trg.get('unstylable');
            const stylableReq = trg.get('stylable-require');
            const requires = model.get('requires');
            const requiresParent = model.get('requiresParent');
            const sectors = this.sector ? this.sector.collection : null;
            const selected = this.em ? this.em.getSelected() : null;
            let stylable = trg.get('stylable');
            if (a.isArray(stylable)) {
                stylable = stylable.indexOf(property) >= 0;
            }
            if (a.isArray(unstylable)) {
                stylable = unstylable.indexOf(property) < 0;
            }
            if (toRequire) {
                stylable = !target || stylableReq && (stylableReq.indexOf(id) >= 0 || stylableReq.indexOf(property) >= 0);
            }
            if (sectors && requires) {
                const properties = Object.keys(requires);
                sectors.undefined(sector => {
                    sector.get('properties').undefined(model => {
                        if (a.includes(properties, model.id)) {
                            const values = requires[model.id];
                            stylable = stylable && a.includes(values, model.get('value'));
                        }
                    });
                });
            }
            if (requiresParent) {
                const parent = selected && selected.parent();
                const parentEl = parent && parent.getEl();
                if (parentEl) {
                    const styles = window.getComputedStyle(parentEl);
                    a.each(requiresParent, (values, property) => {
                        stylable = stylable && styles[property] && a.includes(values, styles[property]);
                    });
                } else {
                    stylable = false;
                }
            }
            return stylable;
        },
        isComponentStylable() {
            const em = this.em;
            const component = em && em.getSelected();
            if (!component) {
                return true;
            }
            return this.isTargetStylable(component);
        },
        setRawValue(value) {
            this.setValue(this.model.parseValue(value));
        },
        setValue(value) {
            const model = this.model;
            let val = a.isUndefined(value) ? model.getDefaultValue() : value;
            const input = this.getInputEl();
            input && (input.value = val);
        },
        getInputEl() {
            if (!this.input) {
                this.input = this.el.querySelector('input');
            }
            return this.input;
        },
        updateVisibility() {
            this.el.style.display = this.model.get('visible') ? 'block' : 'none';
        },
        show() {
            this.model.set('visible', 1);
        },
        hide() {
            this.model.set('visible', 0);
        },
        cleanValue() {
            this.setValue('');
        },
        clearCached() {
            this.clearEl = null;
            this.input = null;
            this.$input = null;
        },
        render() {
            this.clearCached();
            const pfx = this.pfx;
            const model = this.model;
            const el = this.el;
            const property = model.get('property');
            const full = model.get('full');
            const cls = model.get('className') || '';
            const className = `${ pfx }property`;
            el.innerHTML = this.template(model);
            el.className = `${ className } ${ pfx }${ model.get('type') } ${ className }__${ property } ${ cls }`.trim();
            el.className += full ? ` ${ className }--full` : '';
            this.updateStatus();
            const onRender = this.onRender && this.onRender.bind(this);
            onRender && onRender();
            this.setValue(model.get('value'), { targetUpdate: 1 });
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyCompositeView',[
    'skylark-backbone',
    './PropertyView'
], function (Backbone, PropertyView) {
    'use strict';
    const $ = Backbone.$;
    return PropertyView.extend({
        templateInput() {
            const pfx = this.pfx;
            return `
      <div class="${ pfx }field ${ pfx }composite">
        <span id="${ pfx }input-holder"></span>
      </div>
    `;
        },
        inputValueChanged(...args) {
            if (!this.model.get('detached')) {
                PropertyView.prototype.inputValueChanged.apply(this, args);
            }
        },
        clear(e) {
            const props = this.properties;
            props && props.forEach(propView => propView.clear());
            PropertyView.prototype.clear.apply(this, arguments);
        },
        onRender() {
            var model = this.model;
            var props = model.get('properties') || [];
            var self = this;
            this.properties = [];
            if (props.length) {
                if (!this.$input) {
                    this.$input = $('<input type="hidden" value="0">');
                    this.input = this.$input.get(0);
                }
                if (!this.props) {
                    this.props = model.get('properties');
                }
                if (!this.$props) {
                    this.props.each(function (prop, index) {
                        if (prop && prop.get('type') == 'composite') {
                            this.props.remove(prop);
                            console.warn('Nested composite types not yet allowed.');
                        }
                        prop.parent = model;
                    }, this);
                    var PropertiesView = require('./PropertiesView').default;
                    var propsView = new PropertiesView(this.getPropsConfig());
                    this.$props = propsView.render().$el;
                    this.properties = propsView.properties;
                    this.$el.find(`#${ this.pfx }input-holder`).append(this.$props);
                }
            }
        },
        getPropsConfig(opts) {
            var that = this;
            const model = this.model;
            var result = {
                config: {
                    ...this.config,
                    highlightComputed: 0
                },
                collection: this.props,
                target: this.target,
                propTarget: this.propTarget,
                onChange(el, view, opts) {
                    model.set('value', model.getFullValue(), opts);
                },
                customValue(property, mIndex) {
                    return that.valueOnIndex(mIndex, property);
                }
            };
            if (model.get('detached')) {
                delete result.onChange;
            }
            return result;
        },
        valueOnIndex(index, view) {
            let value;
            const targetValue = this.getTargetValue({ ignoreDefault: 1 });
            if (targetValue) {
                const values = targetValue.split(this.model.getSplitSeparator());
                value = values[index];
            } else {
                value = view && view.getTargetValue({
                    ignoreCustomValue: 1,
                    ignoreDefault: 1
                });
            }
            return value;
        },
        clearCached() {
            PropertyView.prototype.clearCached.apply(this, arguments);
            this.$input = null;
            this.props = null;
            this.$props = null;
        }
    });
});
define('skylark-grapejs/utils/dom',['skylark-underscore'], function (_) {
    'use strict';
    const KEY_TAG = 'tag';
    const KEY_ATTR = 'attributes';
    const KEY_CHILD = 'children';
    const motionsEv = 'transitionend oTransitionEnd transitionend webkitTransitionEnd';
    const empty = node => {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    };
    const replaceWith = (oldEl, newEl) => {
        oldEl.parentNode.replaceChild(newEl, oldEl);
    };
    const appendAtIndex = (parent, child, index) => {
        const {childNodes} = parent;
        const total = childNodes.length;
        const at = _.isUndefined(index) ? total : index;
        if (_.isString(child)) {
            parent.insertAdjacentHTML('beforeEnd', child);
            child = parent.lastChild;
            parent.removeChild(child);
        }
        if (at >= total) {
            parent.appendChild(child);
        } else {
            parent.insertBefore(child, childNodes[at]);
        }
    };
    const append = (parent, child) => appendAtIndex(parent, child);
    const createEl = (tag, attrs = '', child) => {
        const el = document.createElement(tag);
        attrs && _.each(attrs, (value, key) => el.setAttribute(key, value));
        if (child) {
            if (_.isString(child))
                el.innerHTML = child;
            else
                el.appendChild(child);
        }
        return el;
    };
    const createCustomEvent = (e, cls) => {
        let oEvent;
        try {
            oEvent = new window[cls](e.type, e);
        } catch (e) {
            oEvent = document.createEvent(cls);
            oEvent.initEvent(e.type, true, true);
        }
        oEvent.keyCodeVal = e.keyCode;
        oEvent._parentEvent = e;
        [
            'keyCode',
            'which'
        ].forEach(prop => {
            Object.defineProperty(oEvent, prop, {
                get() {
                    return this.keyCodeVal;
                }
            });
        });
        return oEvent;
    };
    const appendVNodes = (node, vNodes = []) => {
        const vNodesArr = Array.isArray(vNodes) ? vNodes : [vNodes];
        vNodesArr.forEach(vnode => {
            const tag = vnode[KEY_TAG] || 'div';
            const attr = vnode[KEY_ATTR] || {};
            const el = document.createElement(tag);
            _.each(attr, (value, key) => {
                el.setAttribute(key, value);
            });
            node.appendChild(el);
        });
    };
    return {
        motionsEv: motionsEv,
        empty: empty,
        replaceWith: replaceWith,
        appendAtIndex: appendAtIndex,
        append: append,
        createEl: createEl,
        createCustomEvent: createCustomEvent,
        appendVNodes: appendVNodes
    };
});
define('skylark-grapejs/style_manager/view/PropertiesView',[
    'skylark-backbone',
    '../../utils/dom'
], function (Backbone, a) {
    'use strict';
    return Backbone.View.extend({
        initialize(o) {
            this.config = o.config || {};
            this.pfx = this.config.stylePrefix || '';
            this.target = o.target || {};
            this.propTarget = o.propTarget || {};
            this.onChange = o.onChange;
            this.onInputRender = o.onInputRender || {};
            this.customValue = o.customValue || {};
            this.properties = [];
            const coll = this.collection;
            this.listenTo(coll, 'add', this.addTo);
            this.listenTo(coll, 'reset', this.render);
        },
        addTo(model, coll, opts) {
            this.add(model, null, opts);
        },
        add(model, frag, opts = {}) {
            const appendTo = frag || this.el;
            const view = new model.typeView({
                model,
                name: model.get('name'),
                id: this.pfx + model.get('property'),
                target: this.target,
                propTarget: this.propTarget,
                onChange: this.onChange,
                onInputRender: this.onInputRender,
                config: this.config
            });
            if (model.get('type') != 'composite') {
                view.customValue = this.customValue;
            }
            view.render();
            const rendered = view.el;
            this.properties.push(view);
            view.updateVisibility();
            a.appendAtIndex(appendTo, rendered, opts.at);
        },
        render() {
            const {$el} = this;
            this.properties = [];
            const fragment = document.createDocumentFragment();
            this.collection.each(model => this.add(model, fragment));
            $el.empty();
            $el.append(fragment);
            $el.attr('class', `${ this.pfx }properties`);
            return this;
        }
    });
});
define('skylark-grapejs/style_manager/view/LayerView',[
    'skylark-underscore',
    'skylark-backbone',
    './PropertiesView'
], function (a, Backbone, PropertiesView) {
    'use strict';
    return Backbone.View.extend({
        events: {
            click: 'active',
            'click [data-close-layer]': 'remove',
            'mousedown [data-move-layer]': 'initSorter',
            'touchstart [data-move-layer]': 'initSorter'
        },
        template(model) {
            const {pfx, ppfx, em} = this;
            const label = `${ em && em.t('styleManager.layer') } ${ model.get('index') }`;
            return `
      <div id="${ pfx }move" class="${ ppfx }no-touch-actions" data-move-layer>
        <i class="fa fa-arrows"></i>
      </div>
      <div id="${ pfx }label">${ label }</div>
      <div id="${ pfx }preview-box">
      	<div id="${ pfx }preview" data-preview></div>
      </div>
      <div id="${ pfx }close-layer" class="${ pfx }btn-close" data-close-layer>
        &Cross;
      </div>
      <div id="${ pfx }inputs" data-properties></div>
      <div style="clear:both"></div>
    `;
        },
        initialize(o = {}) {
            let model = this.model;
            this.stackModel = o.stackModel;
            this.config = o.config || {};
            this.em = this.config.em;
            this.pfx = this.config.stylePrefix || '';
            this.ppfx = this.config.pStylePrefix || '';
            this.sorter = o.sorter || null;
            this.propsConfig = o.propsConfig || {};
            this.customPreview = o.onPreview;
            this.listenTo(model, 'destroy remove', this.remove);
            this.listenTo(model, 'change:active', this.updateVisibility);
            this.listenTo(model.get('properties'), 'change', this.updatePreview);
            model.view = this;
            model.set({
                droppable: 0,
                draggable: 1
            });
            this.$el.data('model', model);
        },
        initSorter(e) {
            if (this.sorter)
                this.sorter.startSort(this.el);
        },
        remove(e) {
            if (e && e.stopPropagation)
                e.stopPropagation();
            const model = this.model;
            const collection = model.collection;
            const stackModel = this.stackModel;
            Backbone.View.prototype.remove.apply(this, arguments);
            if (collection.contains(model)) {
                collection.remove(model);
            }
            if (stackModel && stackModel.set) {
                stackModel.set({ stackIndex: null }, { silent: true });
                stackModel.trigger('updateValue');
            }
        },
        onPreview(value) {
            const {stackModel} = this;
            const detach = stackModel && stackModel.get('detached');
            const values = value.split(' ');
            const lim = 3;
            const result = [];
            const resultObj = {};
            this.model.get('properties').undefined((prop, index) => {
                const property = prop.get('property');
                let value = detach ? prop.getFullValue() : values[index] || '';
                if (value) {
                    if (prop.get('type') == 'integer') {
                        let valueInt = parseInt(value, 10);
                        let unit = value.replace(valueInt, '');
                        valueInt = !isNaN(valueInt) ? valueInt : 0;
                        valueInt = valueInt > lim ? lim : valueInt;
                        valueInt = valueInt < -lim ? -lim : valueInt;
                        value = valueInt + unit;
                    }
                }
                result.push(value);
                resultObj[property] = value;
            });
            return detach ? resultObj : result.join(' ');
        },
        updatePreview() {
            const stackModel = this.stackModel;
            const customPreview = this.customPreview;
            const previewEl = this.getPreviewEl();
            const value = this.model.getFullValue();
            const preview = customPreview ? customPreview(value) : this.onPreview(value);
            if (preview && stackModel && previewEl) {
                const {style} = previewEl;
                if (a.isString(preview)) {
                    style[stackModel.get('property')] = preview;
                } else {
                    let prvStr = [];
                    a.each(preview, (val, prop) => prvStr.push(`${ prop }:${ val }`));
                    previewEl.setAttribute('style', prvStr.join(';'));
                }
            }
        },
        getPropertiesWrapper() {
            if (!this.propsWrapEl) {
                this.propsWrapEl = this.el.querySelector('[data-properties]');
            }
            return this.propsWrapEl;
        },
        getPreviewEl() {
            if (!this.previewEl) {
                this.previewEl = this.el.querySelector('[data-preview]');
            }
            return this.previewEl;
        },
        active() {
            const model = this.model;
            const collection = model.collection;
            collection.active(collection.indexOf(model));
        },
        updateVisibility() {
            const pfx = this.pfx;
            const wrapEl = this.getPropertiesWrapper();
            const active = this.model.get('active');
            wrapEl.style.display = active ? '' : 'none';
            this.$el[active ? 'addClass' : 'removeClass'](`${ pfx }active`);
        },
        render() {
            const propsConfig = this.propsConfig;
            const {model, el, pfx} = this;
            const preview = model.get('preview');
            const properties = new PropertiesView({
                collection: model.get('properties'),
                config: this.config,
                target: propsConfig.target,
                customValue: propsConfig.customValue,
                propTarget: propsConfig.propTarget,
                onChange: propsConfig.onChange
            }).render().el;
            el.innerHTML = this.template(model);
            el.className = `${ pfx }layer${ !preview ? ` ${ pfx }no-preview` : '' }`;
            this.getPropertiesWrapper().appendChild(properties);
            this.updateVisibility();
            this.updatePreview();
            return this;
        }
    });
});
define('skylark-grapejs/style_manager/view/LayersView',[
    'skylark-backbone',
    './LayerView'
], function (Backbone, LayerView) {
    'use strict';
    return Backbone.View.extend({
        initialize(o) {
            this.config = o.config || {};
            this.stackModel = o.stackModel;
            this.preview = o.preview;
            this.pfx = this.config.stylePrefix || '';
            this.ppfx = this.config.pStylePrefix || '';
            this.propsConfig = o.propsConfig;
            let pfx = this.pfx;
            let ppfx = this.ppfx;
            let collection = this.collection;
            this.className = `${ pfx }layers ${ ppfx }field`;
            this.listenTo(collection, 'add', this.addTo);
            this.listenTo(collection, 'deselectAll', this.deselectAll);
            this.listenTo(collection, 'reset', this.render);
            var em = this.config.em || '';
            var utils = em ? em.get('Utils') : '';
            this.sorter = utils ? new utils.Sorter({
                container: this.el,
                ignoreViewChildren: 1,
                containerSel: `.${ pfx }layers`,
                itemSel: `.${ pfx }layer`,
                pfx: this.config.pStylePrefix
            }) : '';
            collection.view = this;
            this.$el.data('model', collection);
            this.$el.data('collection', collection);
        },
        addTo(model) {
            var i = this.collection.indexOf(model);
            this.addToCollection(model, null, i);
        },
        addToCollection(model, fragmentEl, index) {
            var fragment = fragmentEl || null;
            const stackModel = this.stackModel;
            const config = this.config;
            const sorter = this.sorter;
            const propsConfig = this.propsConfig;
            if (typeof this.preview !== 'undefined') {
                model.set('preview', this.preview);
            }
            var view = new LayerView({
                model,
                config,
                sorter,
                stackModel,
                propsConfig
            });
            var rendered = view.render().el;
            if (fragment) {
                fragment.appendChild(rendered);
            } else {
                if (typeof index != 'undefined') {
                    var method = 'before';
                    if (this.$el.children().length == index) {
                        index--;
                        method = 'after';
                    }
                    if (index < 0) {
                        this.$el.append(rendered);
                    } else
                        this.$el.children().eq(index)[method](rendered);
                } else
                    this.$el.append(rendered);
            }
            return rendered;
        },
        deselectAll() {
            this.$el.find('.' + this.pfx + 'layer').removeClass(this.pfx + 'active');
        },
        render() {
            var fragment = document.createDocumentFragment();
            this.$el.empty();
            this.collection.each(function (model) {
                this.addToCollection(model, fragment);
            }, this);
            this.$el.append(fragment);
            this.$el.attr('class', this.className);
            if (this.sorter)
                this.sorter.plh = null;
            return this;
        }
    });
});
define('skylark-grapejs/code_manager/model/CssGenerator',[
    'skylark-backbone',
    'skylark-underscore'
], function (Backbone, a) {
    'use strict';
    const maxValue = Number.MAX_VALUE;
    return Backbone.Model.extend({
        initialize() {
            this.compCls = [];
            this.ids = [];
        },
        buildFromModel(model, opts = {}) {
            let code = '';
            const em = this.em;
            const avoidInline = em && em.getConfig('avoidInlineStyle');
            const style = model.styleToString();
            const classes = model.get('classes');
            const wrapperIsBody = opts.wrapperIsBody;
            const isWrapper = model.get('wrapper');
            this.ids.push(`#${ model.getId() }`);
            classes.undefined(model => this.compCls.push(model.getFullName()));
            if (!avoidInline && style) {
                let selector = `#${ model.getId() }`;
                selector = wrapperIsBody && isWrapper ? 'body' : selector;
                code = `${ selector }{${ style }}`;
            }
            const components = model.components();
            components.undefined(model => code += this.buildFromModel(model, opts));
            return code;
        },
        build(model, opts = {}) {
            const cssc = opts.cssc;
            const em = opts.em || '';
            this.em = em;
            this.compCls = [];
            this.ids = [];
            var code = this.buildFromModel(model, opts);
            const clearStyles = a.isUndefined(opts.clearStyles) && em ? em.getConfig('clearStyles') : opts.clearStyles;
            if (cssc) {
                const rules = cssc.getAll();
                const atRules = {};
                const dump = [];
                rules.undefined(rule => {
                    const atRule = rule.getAtRule();
                    if (atRule) {
                        const mRules = atRules[atRule];
                        if (mRules) {
                            mRules.push(rule);
                        } else {
                            atRules[atRule] = [rule];
                        }
                        return;
                    }
                    code += this.buildFromRule(rule, dump, opts);
                });
                this.sortMediaObject(atRules).forEach(item => {
                    let rulesStr = '';
                    const atRule = item.key;
                    const mRules = item.value;
                    mRules.forEach(rule => {
                        const ruleStr = this.buildFromRule(rule, dump, opts);
                        if (rule.get('singleAtRule')) {
                            code += `${ atRule }{${ ruleStr }}`;
                        } else {
                            rulesStr += ruleStr;
                        }
                    });
                    if (rulesStr) {
                        code += `${ atRule }{${ rulesStr }}`;
                    }
                });
                em && clearStyles && rules.remove(dump);
            }
            return code;
        },
        buildFromRule(rule, dump, opts = {}) {
            let result = '';
            const selectorStrNoAdd = rule.selectorsToString({ skipAdd: 1 });
            const selectorsAdd = rule.get('selectorsAdd');
            const singleAtRule = rule.get('singleAtRule');
            let found;
            rule.get('selectors').undefined(selector => {
                const name = selector.getFullName();
                if (this.compCls.indexOf(name) >= 0 || this.ids.indexOf(name) >= 0 || opts.keepUnusedStyles) {
                    found = 1;
                }
            });
            if (selectorStrNoAdd && found || selectorsAdd || singleAtRule) {
                const block = rule.getDeclaration();
                block && (result += block);
            } else {
                dump.push(rule);
            }
            return result;
        },
        getQueryLength(mediaQuery) {
            const length = /(-?\d*\.?\d+)\w{0,}/.exec(mediaQuery);
            if (!length)
                return maxValue;
            return parseFloat(length[1]);
        },
        sortMediaObject(items = {}) {
            const itemsArr = [];
            a.each(items, (value, key) => itemsArr.push({
                key,
                value
            }));
            return itemsArr.sort((a, b) => {
                const isMobFirst = [
                    a.key,
                    b.key
                ].every(mquery => mquery.indexOf('min-width') !== -1);
                const left = isMobFirst ? a.key : b.key;
                const right = isMobFirst ? b.key : a.key;
                return this.getQueryLength(left) - this.getQueryLength(right);
            });
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyStackView',[
    'skylark-underscore',
    './PropertyCompositeView',
    './LayersView',
    '../../code_manager/model/CssGenerator'
], function (a, PropertyCompositeView, LayersView, CssGenerator) {
    'use strict';
    const cssGen = new CssGenerator();
    return PropertyCompositeView.extend({
        templateInput() {
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            return `
      <div class="${ pfx }field ${ pfx }stack">
        <button type="button" id="${ pfx }add" data-add-layer>+</button>
        <div data-layers-wrapper></div>
      </div>
    `;
        },
        init() {
            const model = this.model;
            const pfx = this.pfx;
            model.set('stackIndex', null);
            this.events[`click [data-add-layer]`] = 'addLayer';
            this.listenTo(model, 'change:stackIndex', this.indexChanged);
            this.listenTo(model, 'updateValue', this.inputValueChanged);
            this.delegateEvents();
        },
        targetUpdated(...args) {
            if (!this.model.get('detached')) {
                PropertyCompositeView.prototype.targetUpdated.apply(this, args);
            } else {
                const {status} = this._getTargetData();
                this.setStatus(status);
                this.checkVisibility();
            }
            this.refreshLayers();
        },
        getLayers() {
            return this.model.get('layers');
        },
        indexChanged(e) {
            const model = this.model;
            this.getLayers().active(model.get('stackIndex'));
        },
        addLayer() {
            const model = this.model;
            const layers = this.getLayers();
            const prepend = model.get('prepend');
            const properties = model.get('properties').deepClone();
            properties.each(property => property.set('value', ''));
            const layer = layers.add({ properties }, {
                active: 1,
                ...prepend && { at: 0 }
            });
            this.inputValueChanged();
            model.set('stackIndex', layers.indexOf(layer));
        },
        inputValueChanged() {
            const model = this.model;
            this.elementUpdated();
            if (!model.get('detached')) {
                model.set('value', this.getLayerValues());
            } else {
                model.get('properties').each(prop => prop.trigger('change:value'));
            }
        },
        setValue() {
        },
        getLayerValues() {
            return this.getLayers().getFullValue();
        },
        _getClassRule(opts = {}) {
            const {em} = this;
            const {
                skipAdd = 1
            } = opts;
            const selected = em.getSelected();
            const targetAlt = em.get('StyleManager').getModelToStyle(selected, {
                skipAdd,
                useClasses: 1
            });
            return targetAlt !== selected && targetAlt;
        },
        _getParentTarget(target, opts = {}) {
            const {em, model} = this;
            const property = model.get('property');
            const isValid = opts.isValid || (rule => rule.getStyle()[property]);
            const targetsDevice = em.get('CssComposer').getAll().filter(rule => rule.selectorsToString() === target.getSelectorsString());
            const map = targetsDevice.reduce((acc, rule) => {
                acc[rule.getAtRule()] = rule;
                return acc;
            }, {});
            const mapSorted = cssGen.sortMediaObject(map);
            const sortedRules = mapSorted.map(item => item.value);
            const currIndex = sortedRules.indexOf(target);
            const rulesToCheck = sortedRules.splice(0, currIndex);
            let result;
            for (let i = rulesToCheck.length - 1; i > -1; i--) {
                const rule = rulesToCheck[i];
                if (isValid(rule)) {
                    result = rule;
                    break;
                }
            }
            return result;
        },
        refreshLayers() {
            let layersObj = [];
            const {model, em} = this;
            const layers = this.getLayers();
            const detached = model.get('detached');
            const property = model.get('property');
            const target = this.getTarget();
            const valueComput = this.getComputedValue();
            const selected = em.getSelected();
            let resultValue, style, targetAlt, targetAltDevice, valueTargetAlt, valueTrgAltDvc;
            if (detached) {
                style = target ? target.getStyle() : {};
                const hasDetachedStyle = rule => {
                    const name = model.get('properties').at(0).get('property');
                    return rule && !a.isUndefined(rule.getStyle()[name]);
                };
                if (!a.keys(style).length && valueComput && selected) {
                    const parentOpts = { isValid: rule => hasDetachedStyle(rule) };
                    targetAltDevice = this._getParentTarget(target, parentOpts);
                    if (targetAltDevice) {
                        style = targetAltDevice.getStyle();
                    } else {
                        targetAlt = this._getClassRule();
                        valueTargetAlt = hasDetachedStyle(targetAlt) && targetAlt.getStyle();
                        targetAltDevice = !valueTargetAlt && this._getParentTarget(this._getClassRule({ skipAdd: 0 }), parentOpts);
                        valueTrgAltDvc = hasDetachedStyle(targetAltDevice) && targetAltDevice.getStyle();
                        style = valueTargetAlt || valueTrgAltDvc || {};
                    }
                }
                resultValue = style;
                layersObj = layers.getLayersFromStyle(style);
            } else {
                const valueTrg = this.getTargetValue({ ignoreDefault: 1 });
                let value = valueTrg;
                if (!value && valueComput) {
                    targetAltDevice = this._getParentTarget(target);
                    if (targetAltDevice) {
                        value = targetAltDevice.getStyle()[property];
                    } else {
                        targetAlt = this._getClassRule();
                        valueTargetAlt = targetAlt && targetAlt.getStyle()[property];
                        targetAltDevice = !valueTargetAlt && this._getParentTarget(this._getClassRule({ skipAdd: 0 }));
                        valueTrgAltDvc = targetAltDevice && targetAltDevice.getStyle()[property];
                        value = valueTargetAlt || valueTrgAltDvc || valueComput;
                    }
                }
                value = value == model.getDefaultValue() ? '' : value;
                resultValue = value;
                layersObj = layers.getLayersFromValue(value);
            }
            const toAdd = model.getLayersFromTarget(target, {
                resultValue,
                layersObj
            }) || layersObj;
            layers.reset();
            layers.add(toAdd);
            model.set({ stackIndex: null }, { silent: true });
        },
        getTargetValue(opts = {}) {
            let result = PropertyCompositeView.prototype.getTargetValue.call(this, opts);
            const {detached} = this.model.attributes;
            if (a.isUndefined(result) && !detached) {
                result = this.model.getValueFromStyle(this.getTarget().getStyle());
            }
            return result;
        },
        onRender() {
            const self = this;
            const model = this.model;
            const fieldEl = this.el.querySelector('[data-layers-wrapper]');
            const PropertiesView = require('./PropertiesView').default;
            const propsConfig = {
                target: this.target,
                propTarget: this.propTarget,
                onChange(el, view, opt) {
                    const subModel = view.model;
                    if (model.get('detached')) {
                        const subProp = subModel.get('property');
                        const defVal = subModel.getDefaultValue();
                        const values = self.getLayers().getPropertyValues(subProp, defVal);
                        view.updateTargetStyle(values, null, opt);
                    } else {
                        if (model.get('status') == 'updated') {
                            const value = model.getFullValue();
                            model.set('value', value, opt);
                            !value && view.updateTargetStyle(value, null, opt);
                        }
                    }
                }
            };
            const layers = new LayersView({
                collection: this.getLayers(),
                stackModel: model,
                preview: model.get('preview'),
                config: this.config,
                propsConfig
            }).render().el;
            new PropertiesView({
                target: this.target,
                collection: this.model.get('properties'),
                stackModel: model,
                config: this.config,
                onChange: propsConfig.onChange,
                propTarget: propsConfig.propTarget
            }).render();
            fieldEl.appendChild(layers);
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyFileView',[
    'skylark-underscore',
    'skylark-backbone',
    './PropertyView'
], function (a, Backbone, PropertyView) {
    'use strict';
    const $ = Backbone.$;
    return PropertyView.extend({
        templateInput() {
            const {pfx, em} = this;
            return `
    <div class="${ pfx }field ${ pfx }file">
      <div id='${ pfx }input-holder'>
        <div class="${ pfx }btn-c">
          <button class="${ pfx }btn" id="${ pfx }images" type="button">
            ${ em.t('styleManager.fileButton') }
          </button>
        </div>
        <div style="clear:both;"></div>
      </div>
      <div id="${ pfx }preview-box">
        <div id="${ pfx }preview-file"></div>
        <div id="${ pfx }close">&Cross;</div>
      </div>
    </div>
    `;
        },
        init() {
            const em = this.em;
            this.modal = em.get('Modal');
            this.am = em.get('AssetManager');
            this.events['click #' + this.pfx + 'close'] = 'removeFile';
            this.events['click #' + this.pfx + 'images'] = 'openAssetManager';
            this.delegateEvents();
        },
        onRender() {
            if (!this.$input) {
                const plh = this.model.getDefaultValue();
                this.$input = $(`<input placeholder="${ plh }">`);
            }
            if (!this.$preview) {
                this.$preview = this.$el.find('#' + this.pfx + 'preview-file');
            }
            if (!this.$previewBox) {
                this.$previewBox = this.$el.find('#' + this.pfx + 'preview-box');
            }
            this.setValue(this.componentValue, 0);
        },
        clearCached() {
            PropertyView.prototype.clearCached.apply(this, arguments);
            this.$preview = null;
            this.$previewBox = null;
        },
        setValue(value, f) {
            PropertyView.prototype.setValue.apply(this, arguments);
            this.setPreviewView(value && value != this.model.getDefaultValue());
            this.setPreview(value);
        },
        setPreviewView(v) {
            const pv = this.$previewBox;
            pv && pv[v ? 'addClass' : 'removeClass'](`${ this.pfx }show`);
            pv && pv.css({ display: v ? 'block' : 'none' });
        },
        spreadUrl(url) {
            this.model.set('value', url);
            this.setPreviewView(1);
        },
        setPreview(value) {
            const preview = this.$preview;
            value = value && value.indexOf('url(') < 0 ? `url(${ value })` : value;
            preview && preview.css('background-image', value);
        },
        cleanValue() {
            this.setPreviewView(0);
            this.model.set({ value: '' }, { silent: true });
        },
        removeFile(...args) {
            this.model.set('value', this.model.getDefaultValue());
            PropertyView.prototype.cleanValue.apply(this, args);
            this.setPreviewView(0);
        },
        openAssetManager(e) {
            const {em, modal} = this;
            const editor = em ? em.get('Editor') : '';
            if (editor) {
                editor.runCommand('open-assets', {
                    types: ['image'],
                    accept: 'image/*',
                    target: this.getTargetModel(),
                    onClick() {
                    },
                    onDblClick() {
                    },
                    onSelect: asset => {
                        modal.close();
                        const url = a.isString(asset) ? asset : asset.get('src');
                        this.spreadUrl(url);
                    }
                });
            }
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyIntegerView',[
    'skylark-backbone',
    './PropertyView'
], function (Backbone, PropertyView) {
    'use strict';
    const $ = Backbone.$;
    return PropertyView.extend({
        templateInput() {
            return '';
        },
        init() {
            const model = this.model;
            this.listenTo(model, 'change:unit', this.modelValueChanged);
            this.listenTo(model, 'el:change', this.elementUpdated);
            this.listenTo(model, 'change:units', this.render);
        },
        setValue(value) {
            const parsed = this.model.parseValue(value);
            value = `${ parsed.value }${ parsed.unit }`;
            this.inputInst.setValue(value, { silent: 1 });
        },
        onRender() {
            const ppfx = this.ppfx;
            if (!this.input) {
                const input = this.model.input;
                input.ppfx = ppfx;
                input.render();
                const fields = this.el.querySelector(`.${ ppfx }fields`);
                fields.appendChild(input.el);
                this.$input = input.inputEl;
                this.unit = input.unitEl;
                this.$unit = $(this.unit);
                this.input = this.$input.get(0);
                this.inputInst = input;
            }
        },
        clearCached() {
            PropertyView.prototype.clearCached.apply(this, arguments);
            this.unit = null;
            this.$unit = null;
        }
    });
});
define('skylark-grapejs/utils/ColorPicker',[],function () {
    'use strict';
    return function ($, undefined) {
        'use strict';
        var defaultOpts = {
                beforeShow: noop,
                move: noop,
                change: noop,
                show: noop,
                hide: noop,
                color: false,
                flat: false,
                showInput: false,
                allowEmpty: false,
                showButtons: true,
                clickoutFiresChange: true,
                showInitial: false,
                showPalette: false,
                showPaletteOnly: false,
                hideAfterPaletteSelect: false,
                togglePaletteOnly: false,
                showSelectionPalette: true,
                localStorageKey: false,
                appendTo: 'body',
                maxSelectionSize: 7,
                cancelText: 'cancel',
                chooseText: 'choose',
                togglePaletteMoreText: 'more',
                togglePaletteLessText: 'less',
                clearText: 'Clear Color Selection',
                noColorSelectedText: 'No Color Selected',
                preferredFormat: false,
                className: '',
                containerClassName: '',
                replacerClassName: '',
                showAlpha: false,
                theme: 'sp-light',
                palette: [[
                        '#ffffff',
                        '#000000',
                        '#ff0000',
                        '#ff8000',
                        '#ffff00',
                        '#008000',
                        '#0000ff',
                        '#4b0082',
                        '#9400d3'
                    ]],
                selectionPalette: [],
                disabled: false,
                offset: null
            }, spectrums = [], IE = !!/msie/i.exec(window.navigator.userAgent), rgbaSupport = function () {
                function contains(str, substr) {
                    return !!~('' + str).indexOf(substr);
                }
                var elem = document.createElement('div');
                var style = elem.style;
                style.cssText = 'background-color:rgba(0,0,0,.5)';
                return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
            }(), replaceInput = [
                "<div class='sp-replacer'>",
                "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
                "<div class='sp-dd'>&#9660;</div>",
                '</div>'
            ].join(''), markup = function () {
                var gradientFix = '';
                if (IE) {
                    for (var i = 1; i <= 6; i++) {
                        gradientFix += "<div class='sp-" + i + "'></div>";
                    }
                }
                return [
                    "<div class='sp-container sp-hidden'>",
                    "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                    "<div class='sp-palette-button-container sp-cf'>",
                    "<button type='button' class='sp-palette-toggle'></button>",
                    '</div>',
                    '</div>',
                    "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                    "<div class='sp-fill'></div>",
                    "<div class='sp-top-inner'>",
                    "<div class='sp-color'>",
                    "<div class='sp-sat'>",
                    "<div class='sp-val'>",
                    "<div class='sp-dragger'></div>",
                    '</div>',
                    '</div>',
                    '</div>',
                    "<div class='sp-clear sp-clear-display'>",
                    '</div>',
                    "<div class='sp-hue'>",
                    "<div class='sp-slider'></div>",
                    gradientFix,
                    '</div>',
                    '</div>',
                    "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    '</div>',
                    "<div class='sp-input-container sp-cf'>",
                    "<input class='sp-input' type='text' spellcheck='false'  />",
                    '</div>',
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                    "<a class='sp-cancel' href='#'></a>",
                    "<button type='button' class='sp-choose'></button>",
                    '</div>',
                    '</div>',
                    '</div>'
                ].join('');
            }();
        function paletteTemplate(p, color, className, opts) {
            var html = [];
            for (var i = 0; i < p.length; i++) {
                var current = p[i];
                if (current) {
                    var tiny = tinycolor(current);
                    var c = tiny.toHsl().l < 0.5 ? 'sp-thumb-el sp-thumb-dark' : 'sp-thumb-el sp-thumb-light';
                    c += tinycolor.equals(color, current) ? ' sp-thumb-active' : '';
                    var formattedString = tiny.toString(opts.preferredFormat || 'rgb');
                    var swatchStyle = rgbaSupport ? 'background-color:' + tiny.toRgbString() : 'filter:' + tiny.toFilter();
                    html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';"></span></span>');
                } else {
                    var cls = 'sp-clear-display';
                    html.push($('<div />').append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>').attr('title', opts.noColorSelectedText)).html());
                }
            }
            return "<div class='sp-cf " + className + "'>" + html.join('') + '</div>';
        }
        function hideAll() {
            for (var i = 0; i < spectrums.length; i++) {
                if (spectrums[i]) {
                    spectrums[i].hide();
                }
            }
        }
        function instanceOptions(o, callbackContext) {
            var opts = $.extend({}, defaultOpts, o);
            opts.callbacks = {
                move: bind(opts.move, callbackContext),
                change: bind(opts.change, callbackContext),
                show: bind(opts.show, callbackContext),
                hide: bind(opts.hide, callbackContext),
                beforeShow: bind(opts.beforeShow, callbackContext)
            };
            return opts;
        }
        function spectrum(element, o) {
            var opts = instanceOptions(o, element), flat = opts.flat, showSelectionPalette = opts.showSelectionPalette, localStorageKey = opts.localStorageKey, theme = opts.theme, callbacks = opts.callbacks, resize = throttle(reflow, 10), visible = false, isDragging = false, dragWidth = 0, dragHeight = 0, dragHelperHeight = 0, slideHeight = 0, slideWidth = 0, alphaWidth = 0, alphaSlideHelperWidth = 0, slideHelperHeight = 0, currentHue = 0, currentSaturation = 0, currentValue = 0, currentAlpha = 1, palette = [], paletteArray = [], paletteLookup = {}, selectionPalette = opts.selectionPalette.slice(0), maxSelectionSize = opts.maxSelectionSize, draggingClass = 'sp-dragging', shiftMovementDirection = null;
            var doc = element.ownerDocument, body = doc.body, boundElement = $(element), disabled = false, container = $(markup, doc).addClass(theme), pickerContainer = container.find('.sp-picker-container'), dragger = container.find('.sp-color'), dragHelper = container.find('.sp-dragger'), slider = container.find('.sp-hue'), slideHelper = container.find('.sp-slider'), alphaSliderInner = container.find('.sp-alpha-inner'), alphaSlider = container.find('.sp-alpha'), alphaSlideHelper = container.find('.sp-alpha-handle'), textInput = container.find('.sp-input'), paletteContainer = container.find('.sp-palette'), initialColorContainer = container.find('.sp-initial'), cancelButton = container.find('.sp-cancel'), clearButton = container.find('.sp-clear'), chooseButton = container.find('.sp-choose'), toggleButton = container.find('.sp-palette-toggle'), isInput = boundElement.is('input'), isInputTypeColor = isInput && boundElement.attr('type') === 'color' && inputTypeColorSupport(), shouldReplace = isInput && !flat, replacer = shouldReplace ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]), offsetElement = shouldReplace ? replacer : boundElement, previewElement = replacer.find('.sp-preview-inner'), initialColor = opts.color || isInput && boundElement.val(), colorOnShow = false, currentPreferredFormat = opts.preferredFormat, clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange, isEmpty = !initialColor, allowEmpty = opts.allowEmpty && !isInputTypeColor;
            function applyOptions() {
                if (opts.showPaletteOnly) {
                    opts.showPalette = true;
                }
                toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
                if (opts.palette) {
                    palette = opts.palette.slice(0);
                    paletteArray = $.isArray(palette[0]) ? palette : [palette];
                    paletteLookup = {};
                    for (var i = 0; i < paletteArray.length; i++) {
                        for (var j = 0; j < paletteArray[i].length; j++) {
                            var rgb = tinycolor(paletteArray[i][j]).toRgbString();
                            paletteLookup[rgb] = true;
                        }
                    }
                }
                container.toggleClass('sp-flat', flat);
                container.toggleClass('sp-input-disabled', !opts.showInput);
                container.toggleClass('sp-alpha-enabled', opts.showAlpha);
                container.toggleClass('sp-clear-enabled', allowEmpty);
                container.toggleClass('sp-buttons-disabled', !opts.showButtons);
                container.toggleClass('sp-palette-buttons-disabled', !opts.togglePaletteOnly);
                container.toggleClass('sp-palette-disabled', !opts.showPalette);
                container.toggleClass('sp-palette-only', opts.showPaletteOnly);
                container.toggleClass('sp-initial-disabled', !opts.showInitial);
                container.addClass(opts.className).addClass(opts.containerClassName);
                reflow();
            }
            function initialize() {
                if (IE) {
                    container.find('*:not(input)').attr('unselectable', 'on');
                }
                applyOptions();
                if (shouldReplace) {
                    boundElement.after(replacer).hide();
                }
                if (!allowEmpty) {
                    clearButton.hide();
                }
                if (flat) {
                    boundElement.after(container).hide();
                } else {
                    var appendTo = opts.appendTo === 'parent' ? boundElement.parent() : $(opts.appendTo);
                    if (appendTo.length !== 1) {
                        appendTo = $('body');
                    }
                    appendTo.append(container);
                }
                updateSelectionPaletteFromStorage();
                offsetElement.bind('click.spectrum touchstart.spectrum', function (e) {
                    if (!disabled) {
                        toggle();
                    }
                    e.stopPropagation();
                    if (!$(e.target).is('input')) {
                        e.preventDefault();
                    }
                });
                if (boundElement.is(':disabled') || opts.disabled === true) {
                    disable();
                }
                container.click(stopPropagation);
                textInput.change(setFromTextInput);
                textInput.bind('paste', function () {
                    setTimeout(setFromTextInput, 1);
                });
                textInput.keydown(function (e) {
                    if (e.keyCode == 13) {
                        setFromTextInput();
                    }
                });
                cancelButton.text(opts.cancelText);
                cancelButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    revert();
                    hide();
                });
                clearButton.attr('title', opts.clearText);
                clearButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    isEmpty = true;
                    move();
                    if (flat) {
                        updateOriginalInput(true);
                    }
                });
                chooseButton.text(opts.chooseText);
                chooseButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    if (IE && textInput.is(':focus')) {
                        textInput.trigger('change');
                    }
                    if (isValid()) {
                        updateOriginalInput(true);
                        hide();
                    }
                });
                toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
                toggleButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    opts.showPaletteOnly = !opts.showPaletteOnly;
                    if (!opts.showPaletteOnly && !flat) {
                        container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
                    }
                    applyOptions();
                });
                draggable(alphaSlider, function (dragX, dragY, e) {
                    currentAlpha = dragX / alphaWidth;
                    isEmpty = false;
                    if (e.shiftKey) {
                        currentAlpha = Math.round(currentAlpha * 10) / 10;
                    }
                    move();
                }, dragStart, dragStop);
                draggable(slider, function (dragX, dragY) {
                    currentHue = parseFloat(dragY / slideHeight);
                    isEmpty = false;
                    if (!opts.showAlpha) {
                        currentAlpha = 1;
                    }
                    move();
                }, dragStart, dragStop);
                draggable(dragger, function (dragX, dragY, e) {
                    if (!e.shiftKey) {
                        shiftMovementDirection = null;
                    } else if (!shiftMovementDirection) {
                        var oldDragX = currentSaturation * dragWidth;
                        var oldDragY = dragHeight - currentValue * dragHeight;
                        var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
                        shiftMovementDirection = furtherFromX ? 'x' : 'y';
                    }
                    var setSaturation = !shiftMovementDirection || shiftMovementDirection === 'x';
                    var setValue = !shiftMovementDirection || shiftMovementDirection === 'y';
                    if (setSaturation) {
                        currentSaturation = parseFloat(dragX / dragWidth);
                    }
                    if (setValue) {
                        currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                    }
                    isEmpty = false;
                    if (!opts.showAlpha) {
                        currentAlpha = 1;
                    }
                    move();
                }, dragStart, dragStop);
                if (!!initialColor) {
                    set(initialColor);
                    updateUI();
                    currentPreferredFormat = opts.preferredFormat || tinycolor(initialColor).format;
                    addColorToSelectionPalette(initialColor);
                } else {
                    updateUI();
                }
                if (flat) {
                    show();
                }
                function paletteElementClick(e) {
                    if (e.data && e.data.ignore) {
                        set($(e.target).closest('.sp-thumb-el').data('color'));
                        move();
                    } else {
                        set($(e.target).closest('.sp-thumb-el').data('color'));
                        move();
                        updateOriginalInput(true);
                        if (opts.hideAfterPaletteSelect) {
                            hide();
                        }
                    }
                    return false;
                }
                var paletteEvent = IE ? 'mousedown.spectrum' : 'click.spectrum touchstart.spectrum';
                paletteContainer.delegate('.sp-thumb-el', paletteEvent, paletteElementClick);
                initialColorContainer.delegate('.sp-thumb-el:nth-child(1)', paletteEvent, { ignore: true }, paletteElementClick);
            }
            function updateSelectionPaletteFromStorage() {
                if (localStorageKey && window.localStorage) {
                    try {
                        var oldPalette = window.localStorage[localStorageKey].split(',#');
                        if (oldPalette.length > 1) {
                            delete window.localStorage[localStorageKey];
                            $.each(oldPalette, function (i, c) {
                                addColorToSelectionPalette(c);
                            });
                        }
                    } catch (e) {
                    }
                    try {
                        selectionPalette = window.localStorage[localStorageKey].split(';');
                    } catch (e) {
                    }
                }
            }
            function addColorToSelectionPalette(color) {
                if (showSelectionPalette) {
                    var rgb = tinycolor(color).toRgbString();
                    if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
                        selectionPalette.push(rgb);
                        while (selectionPalette.length > maxSelectionSize) {
                            selectionPalette.shift();
                        }
                    }
                    if (localStorageKey && window.localStorage) {
                        try {
                            window.localStorage[localStorageKey] = selectionPalette.join(';');
                        } catch (e) {
                        }
                    }
                }
            }
            function getUniqueSelectionPalette() {
                var unique = [];
                if (opts.showPalette) {
                    for (var i = 0; i < selectionPalette.length; i++) {
                        var rgb = tinycolor(selectionPalette[i]).toRgbString();
                        if (!paletteLookup[rgb]) {
                            unique.push(selectionPalette[i]);
                        }
                    }
                }
                return unique.reverse().slice(0, opts.maxSelectionSize);
            }
            function drawPalette() {
                var currentColor = get();
                var html = $.map(paletteArray, function (palette, i) {
                    return paletteTemplate(palette, currentColor, 'sp-palette-row sp-palette-row-' + i, opts);
                });
                updateSelectionPaletteFromStorage();
                if (selectionPalette) {
                    html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, 'sp-palette-row sp-palette-row-selection', opts));
                }
                paletteContainer.html(html.join(''));
            }
            function drawInitial() {
                if (opts.showInitial) {
                    var initial = colorOnShow;
                    var current = get();
                    initialColorContainer.html(paletteTemplate([
                        initial,
                        current
                    ], current, 'sp-palette-row-initial', opts));
                }
            }
            function dragStart() {
                if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                    reflow();
                }
                isDragging = true;
                container.addClass(draggingClass);
                shiftMovementDirection = null;
                boundElement.trigger('dragstart.spectrum', [get()]);
            }
            function dragStop() {
                isDragging = false;
                container.removeClass(draggingClass);
                boundElement.trigger('dragstop.spectrum', [get()]);
            }
            function setFromTextInput() {
                var value = textInput.val();
                if ((value === null || value === '') && allowEmpty) {
                    set(null);
                    updateOriginalInput(true);
                } else {
                    var tiny = tinycolor(value);
                    if (tiny.isValid()) {
                        set(tiny);
                        updateOriginalInput(true);
                    } else {
                        textInput.addClass('sp-validation-error');
                    }
                }
            }
            function toggle() {
                if (visible) {
                    hide();
                } else {
                    show();
                }
            }
            function show() {
                var event = $.Event('beforeShow.spectrum');
                if (visible) {
                    reflow();
                    return;
                }
                boundElement.trigger('beforeShow.spectrum', [get()]);
                if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                    return;
                }
                hideAll();
                visible = true;
                var $doc = $(doc);
                $doc.bind('keydown.spectrum', onkeydown);
                $doc.bind('click.spectrum', clickout);
                $(window).bind('resize.spectrum', resize);
                replacer.addClass('sp-active');
                container.removeClass('sp-hidden');
                reflow();
                updateUI();
                colorOnShow = get();
                drawInitial();
                callbacks.show(colorOnShow);
                boundElement.trigger('show.spectrum', [colorOnShow]);
            }
            function onkeydown(e) {
                if (e.keyCode === 27) {
                    hide();
                }
            }
            function clickout(e) {
                if (e.button == 2) {
                    return;
                }
                if (isDragging) {
                    return;
                }
                if (clickoutFiresChange) {
                    updateOriginalInput(true);
                } else {
                    revert();
                }
                hide();
            }
            function hide() {
                if (!visible || flat) {
                    return;
                }
                visible = false;
                $(doc).unbind('keydown.spectrum', onkeydown);
                $(doc).unbind('click.spectrum', clickout);
                $(window).unbind('resize.spectrum', resize);
                replacer.removeClass('sp-active');
                container.addClass('sp-hidden');
                callbacks.hide(get());
                boundElement.trigger('hide.spectrum', [get()]);
            }
            function revert() {
                set(colorOnShow, true);
            }
            function set(color, ignoreFormatChange) {
                if (tinycolor.equals(color, get())) {
                    updateUI();
                    return;
                }
                var newColor, newHsv;
                if (!color && allowEmpty) {
                    isEmpty = true;
                } else {
                    isEmpty = false;
                    newColor = tinycolor(color);
                    newHsv = newColor.toHsv();
                    currentHue = newHsv.h % 360 / 360;
                    currentSaturation = newHsv.s;
                    currentValue = newHsv.v;
                    currentAlpha = newHsv.a;
                }
                updateUI();
                if (newColor && newColor.isValid() && !ignoreFormatChange) {
                    currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
                }
            }
            function get(opts) {
                opts = opts || {};
                if (allowEmpty && isEmpty) {
                    return null;
                }
                return tinycolor.fromRatio({
                    h: currentHue,
                    s: currentSaturation,
                    v: currentValue,
                    a: Math.round(currentAlpha * 100) / 100
                }, { format: opts.format || currentPreferredFormat });
            }
            function isValid() {
                return !textInput.hasClass('sp-validation-error');
            }
            function move() {
                updateUI();
                callbacks.move(get());
                boundElement.trigger('move.spectrum', [get()]);
            }
            function updateUI() {
                textInput.removeClass('sp-validation-error');
                updateHelperLocations();
                var flatColor = tinycolor.fromRatio({
                    h: currentHue,
                    s: 1,
                    v: 1
                });
                dragger.css('background-color', flatColor.toHexString());
                var format = currentPreferredFormat;
                if (currentAlpha < 1 && !(currentAlpha === 0 && format === 'name')) {
                    if (format === 'hex' || format === 'hex3' || format === 'hex6' || format === 'name') {
                        format = 'rgb';
                    }
                }
                var realColor = get({ format: format }), displayColor = '';
                previewElement.removeClass('sp-clear-display');
                previewElement.css('background-color', 'transparent');
                if (!realColor && allowEmpty) {
                    previewElement.addClass('sp-clear-display');
                } else {
                    var realHex = realColor.toHexString(), realRgb = realColor.toRgbString();
                    if (rgbaSupport || realColor.alpha === 1) {
                        previewElement.css('background-color', realRgb);
                    } else {
                        previewElement.css('background-color', 'transparent');
                        previewElement.css('filter', realColor.toFilter());
                    }
                    if (opts.showAlpha) {
                        var rgb = realColor.toRgb();
                        rgb.a = 0;
                        var realAlpha = tinycolor(rgb).toRgbString();
                        var gradient = 'linear-gradient(left, ' + realAlpha + ', ' + realHex + ')';
                        if (IE) {
                            alphaSliderInner.css('filter', tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                        } else {
                            alphaSliderInner.css('background', '-webkit-' + gradient);
                            alphaSliderInner.css('background', '-moz-' + gradient);
                            alphaSliderInner.css('background', '-ms-' + gradient);
                            alphaSliderInner.css('background', 'linear-gradient(to right, ' + realAlpha + ', ' + realHex + ')');
                        }
                    }
                    displayColor = realColor.toString(format);
                }
                if (opts.showInput) {
                    textInput.val(displayColor);
                }
                if (opts.showPalette) {
                    drawPalette();
                }
                drawInitial();
            }
            function updateHelperLocations() {
                var s = currentSaturation;
                var v = currentValue;
                if (allowEmpty && isEmpty) {
                    alphaSlideHelper.hide();
                    slideHelper.hide();
                    dragHelper.hide();
                } else {
                    alphaSlideHelper.show();
                    slideHelper.show();
                    dragHelper.show();
                    var dragX = s * dragWidth;
                    var dragY = dragHeight - v * dragHeight;
                    dragX = Math.max(-dragHelperHeight, Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight));
                    dragY = Math.max(-dragHelperHeight, Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight));
                    dragHelper.css({
                        top: dragY + 'px',
                        left: dragX + 'px'
                    });
                    var alphaX = currentAlpha * alphaWidth;
                    alphaSlideHelper.css({ left: alphaX - alphaSlideHelperWidth / 2 + 'px' });
                    var slideY = currentHue * slideHeight;
                    slideHelper.css({ top: slideY - slideHelperHeight + 'px' });
                }
            }
            function updateOriginalInput(fireCallback) {
                var color = get(), displayColor = '', hasChanged = !tinycolor.equals(color, colorOnShow);
                if (color) {
                    displayColor = color.toString(currentPreferredFormat);
                    addColorToSelectionPalette(color);
                }
                if (isInput) {
                    boundElement.val(displayColor);
                }
                if (fireCallback && hasChanged) {
                    callbacks.change(color);
                    boundElement.trigger('change', [color]);
                }
            }
            function reflow() {
                if (!visible) {
                    return;
                }
                dragWidth = dragger.width();
                dragHeight = dragger.height();
                dragHelperHeight = dragHelper.height();
                slideWidth = slider.width();
                slideHeight = slider.height();
                slideHelperHeight = slideHelper.height();
                alphaWidth = alphaSlider.width();
                alphaSlideHelperWidth = alphaSlideHelper.width();
                if (!flat) {
                    container.css('position', 'absolute');
                    if (opts.offset) {
                        container.offset(opts.offset);
                    } else {
                        container.offset(getOffset(container, offsetElement));
                    }
                }
                updateHelperLocations();
                if (opts.showPalette) {
                    drawPalette();
                }
                boundElement.trigger('reflow.spectrum');
            }
            function destroy() {
                boundElement.show();
                offsetElement.unbind('click.spectrum touchstart.spectrum');
                container.remove();
                replacer.remove();
                spectrums[spect.id] = null;
            }
            function option(optionName, optionValue) {
                if (optionName === undefined) {
                    return $.extend({}, opts);
                }
                if (optionValue === undefined) {
                    return opts[optionName];
                }
                opts[optionName] = optionValue;
                if (optionName === 'preferredFormat') {
                    currentPreferredFormat = opts.preferredFormat;
                }
                applyOptions();
            }
            function enable() {
                disabled = false;
                boundElement.attr('disabled', false);
                offsetElement.removeClass('sp-disabled');
            }
            function disable() {
                hide();
                disabled = true;
                boundElement.attr('disabled', true);
                offsetElement.addClass('sp-disabled');
            }
            function setOffset(coord) {
                opts.offset = coord;
                reflow();
            }
            initialize();
            var spect = {
                show: show,
                hide: hide,
                toggle: toggle,
                reflow: reflow,
                option: option,
                enable: enable,
                disable: disable,
                offset: setOffset,
                set: function (c) {
                    set(c);
                    updateOriginalInput();
                },
                get: get,
                destroy: destroy,
                container: container
            };
            spect.id = spectrums.push(spect) - 1;
            return spect;
        }
        function getOffset(picker, input) {
            var extraY = 0;
            var dpWidth = picker.outerWidth();
            var dpHeight = picker.outerHeight();
            var inputHeight = input.outerHeight();
            var doc = picker[0].ownerDocument;
            var docElem = doc.documentElement;
            var cW = docElem.clientWidth;
            var cH = docElem.clientHeight;
            var scL = $(doc).scrollLeft();
            var scT = $(doc).scrollTop();
            var viewWidth = cW + scL;
            var viewHeight = cH + scT;
            var offset = input.offset();
            offset.top += inputHeight;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight - extraY) : extraY);
            return offset;
        }
        function noop() {
        }
        function stopPropagation(e) {
            e.stopPropagation();
        }
        function bind(func, obj) {
            var slice = Array.prototype.slice;
            var args = slice.call(arguments, 2);
            return function () {
                return func.apply(obj, args.concat(slice.call(arguments)));
            };
        }
        function draggable(element, onmove, onstart, onstop) {
            onmove = onmove || function () {
            };
            onstart = onstart || function () {
            };
            onstop = onstop || function () {
            };
            var doc = document;
            var dragging = false;
            var offset = {};
            var maxHeight = 0;
            var maxWidth = 0;
            var hasTouch = 'ontouchstart' in window;
            var duringDragEvents = {};
            duringDragEvents['selectstart'] = prevent;
            duringDragEvents['dragstart'] = prevent;
            duringDragEvents['touchmove mousemove'] = move;
            duringDragEvents['touchend mouseup'] = stop;
            function prevent(e) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                if (e.preventDefault) {
                    e.preventDefault();
                }
                e.returnValue = false;
            }
            function move(e) {
                if (dragging) {
                    if (IE && doc.documentMode < 9 && !e.button) {
                        return stop();
                    }
                    var t0 = e && e.touches && e.touches[0];
                    var pageX = t0 && t0.pageX || e.pageX;
                    var pageY = t0 && t0.pageY || e.pageY;
                    var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                    var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
                    if (hasTouch) {
                        prevent(e);
                    }
                    onmove.apply(element, [
                        dragX,
                        dragY,
                        e
                    ]);
                }
            }
            function start(e) {
                var rightclick = e.which ? e.which == 3 : e.button == 2;
                if (!rightclick && !dragging) {
                    if (onstart.apply(element, arguments) !== false) {
                        dragging = true;
                        maxHeight = $(element).height();
                        maxWidth = $(element).width();
                        offset = $(element).offset();
                        $(doc).bind(duringDragEvents);
                        $(doc.body).addClass('sp-dragging');
                        move(e);
                        prevent(e);
                    }
                }
            }
            function stop() {
                if (dragging) {
                    $(doc).unbind(duringDragEvents);
                    $(doc.body).removeClass('sp-dragging');
                    setTimeout(function () {
                        onstop.apply(element, arguments);
                    }, 0);
                }
                dragging = false;
            }
            $(element).bind('touchstart mousedown', start);
        }
        function throttle(func, wait, debounce) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var throttler = function () {
                    timeout = null;
                    func.apply(context, args);
                };
                if (debounce)
                    clearTimeout(timeout);
                if (debounce || !timeout)
                    timeout = setTimeout(throttler, wait);
            };
        }
        function inputTypeColorSupport() {
            return $.fn.spectrum.inputTypeColorSupport();
        }
        var dataID = 'spectrum.id';
        $.fn.spectrum = function (opts, extra) {
            if (typeof opts == 'string') {
                var returnValue = this;
                var args = Array.prototype.slice.call(arguments, 1);
                this.each(function () {
                    var spect = spectrums[$(this).data(dataID)];
                    if (spect) {
                        var method = spect[opts];
                        if (!method) {
                            throw new Error("Spectrum: no such method: '" + opts + "'");
                        }
                        if (opts == 'get') {
                            returnValue = spect.get();
                        } else if (opts == 'container') {
                            returnValue = spect.container;
                        } else if (opts == 'option') {
                            returnValue = spect.option.apply(spect, args);
                        } else if (opts == 'destroy') {
                            spect.destroy();
                            $(this).removeData(dataID);
                        } else {
                            method.apply(spect, args);
                        }
                    }
                });
                return returnValue;
            }
            return this.spectrum('destroy').each(function () {
                var options = $.extend({}, opts, $(this).data());
                var spect = spectrum(this, options);
                $(this).data(dataID, spect.id);
            });
        };
        $.fn.spectrum.load = true;
        $.fn.spectrum.loadOpts = {};
        $.fn.spectrum.draggable = draggable;
        $.fn.spectrum.defaults = defaultOpts;
        $.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport() {
            if (typeof inputTypeColorSupport._cachedResult === 'undefined') {
                var colorInput = $("<input type='color'/>")[0];
                inputTypeColorSupport._cachedResult = colorInput.type === 'color' && colorInput.value !== '';
            }
            return inputTypeColorSupport._cachedResult;
        };
        $.spectrum = {};
        $.spectrum.localization = {};
        $.spectrum.palettes = {};
        $.fn.spectrum.processNativeColorInputs = function () {
            var colorInputs = $('input[type=color]');
            if (colorInputs.length && !inputTypeColorSupport()) {
                colorInputs.spectrum({ preferredFormat: 'hex6' });
            }
        };
        var trimLeft = /^[\s,#]+/, trimRight = /\s+$/, tinyCounter = 0, math = Math, mathRound = math.round, mathMin = math.min, mathMax = math.max, mathRandom = math.random;
        var tinycolor = function (color, opts) {
            color = color ? color : '';
            opts = opts || {};
            if (color instanceof tinycolor) {
                return color;
            }
            if (!(this instanceof tinycolor)) {
                return new tinycolor(color, opts);
            }
            var rgb = inputToRGB(color);
            this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
            this._gradientType = opts.gradientType;
            if (this._r < 1) {
                this._r = mathRound(this._r);
            }
            if (this._g < 1) {
                this._g = mathRound(this._g);
            }
            if (this._b < 1) {
                this._b = mathRound(this._b);
            }
            this._ok = rgb.ok;
            this._tc_id = tinyCounter++;
        };
        tinycolor.prototype = {
            isDark: function () {
                return this.getBrightness() < 128;
            },
            isLight: function () {
                return !this.isDark();
            },
            isValid: function () {
                return this._ok;
            },
            getOriginalInput: function () {
                return this._originalInput;
            },
            getFormat: function () {
                return this._format;
            },
            getAlpha: function () {
                return this._a;
            },
            getBrightness: function () {
                var rgb = this.toRgb();
                return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            },
            setAlpha: function (value) {
                this._a = boundAlpha(value);
                this._roundA = mathRound(100 * this._a) / 100;
                return this;
            },
            toHsv: function () {
                var hsv = rgbToHsv(this._r, this._g, this._b);
                return {
                    h: hsv.h * 360,
                    s: hsv.s,
                    v: hsv.v,
                    a: this._a
                };
            },
            toHsvString: function () {
                var hsv = rgbToHsv(this._r, this._g, this._b);
                var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
                return this._a == 1 ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)' : 'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + this._roundA + ')';
            },
            toHsl: function () {
                var hsl = rgbToHsl(this._r, this._g, this._b);
                return {
                    h: hsl.h * 360,
                    s: hsl.s,
                    l: hsl.l,
                    a: this._a
                };
            },
            toHslString: function () {
                var hsl = rgbToHsl(this._r, this._g, this._b);
                var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
                return this._a == 1 ? 'hsl(' + h + ', ' + s + '%, ' + l + '%)' : 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + this._roundA + ')';
            },
            toHex: function (allow3Char) {
                return rgbToHex(this._r, this._g, this._b, allow3Char);
            },
            toHexString: function (allow3Char) {
                return '#' + this.toHex(allow3Char);
            },
            toHex8: function () {
                return rgbaToHex(this._r, this._g, this._b, this._a);
            },
            toHex8String: function () {
                return '#' + this.toHex8();
            },
            toRgb: function () {
                return {
                    r: mathRound(this._r),
                    g: mathRound(this._g),
                    b: mathRound(this._b),
                    a: this._a
                };
            },
            toRgbString: function () {
                return this._a == 1 ? 'rgb(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ')' : 'rgba(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ', ' + this._roundA + ')';
            },
            toPercentageRgb: function () {
                return {
                    r: mathRound(bound01(this._r, 255) * 100) + '%',
                    g: mathRound(bound01(this._g, 255) * 100) + '%',
                    b: mathRound(bound01(this._b, 255) * 100) + '%',
                    a: this._a
                };
            },
            toPercentageRgbString: function () {
                return this._a == 1 ? 'rgb(' + mathRound(bound01(this._r, 255) * 100) + '%, ' + mathRound(bound01(this._g, 255) * 100) + '%, ' + mathRound(bound01(this._b, 255) * 100) + '%)' : 'rgba(' + mathRound(bound01(this._r, 255) * 100) + '%, ' + mathRound(bound01(this._g, 255) * 100) + '%, ' + mathRound(bound01(this._b, 255) * 100) + '%, ' + this._roundA + ')';
            },
            toName: function () {
                if (this._a === 0) {
                    return 'transparent';
                }
                if (this._a < 1) {
                    return false;
                }
                return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
            },
            toFilter: function (secondColor) {
                var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
                var secondHex8String = hex8String;
                var gradientType = this._gradientType ? 'GradientType = 1, ' : '';
                if (secondColor) {
                    var s = tinycolor(secondColor);
                    secondHex8String = s.toHex8String();
                }
                return 'progid:DXImageTransform.Microsoft.gradient(' + gradientType + 'startColorstr=' + hex8String + ',endColorstr=' + secondHex8String + ')';
            },
            toString: function (format) {
                var formatSet = !!format;
                format = format || this._format;
                var formattedString = false;
                var hasAlpha = this._a < 1 && this._a >= 0;
                var needsAlphaFormat = !formatSet && hasAlpha && (format === 'hex' || format === 'hex6' || format === 'hex3' || format === 'name');
                if (needsAlphaFormat) {
                    if (format === 'name' && this._a === 0) {
                        return this.toName();
                    }
                    return this.toRgbString();
                }
                if (format === 'rgb') {
                    formattedString = this.toRgbString();
                }
                if (format === 'prgb') {
                    formattedString = this.toPercentageRgbString();
                }
                if (format === 'hex' || format === 'hex6') {
                    formattedString = this.toHexString();
                }
                if (format === 'hex3') {
                    formattedString = this.toHexString(true);
                }
                if (format === 'hex8') {
                    formattedString = this.toHex8String();
                }
                if (format === 'name') {
                    formattedString = this.toName();
                }
                if (format === 'hsl') {
                    formattedString = this.toHslString();
                }
                if (format === 'hsv') {
                    formattedString = this.toHsvString();
                }
                return formattedString || this.toHexString();
            },
            _applyModification: function (fn, args) {
                var color = fn.apply(null, [this].concat([].slice.call(args)));
                this._r = color._r;
                this._g = color._g;
                this._b = color._b;
                this.setAlpha(color._a);
                return this;
            },
            lighten: function () {
                return this._applyModification(lighten, arguments);
            },
            brighten: function () {
                return this._applyModification(brighten, arguments);
            },
            darken: function () {
                return this._applyModification(darken, arguments);
            },
            desaturate: function () {
                return this._applyModification(desaturate, arguments);
            },
            saturate: function () {
                return this._applyModification(saturate, arguments);
            },
            greyscale: function () {
                return this._applyModification(greyscale, arguments);
            },
            spin: function () {
                return this._applyModification(spin, arguments);
            },
            _applyCombination: function (fn, args) {
                return fn.apply(null, [this].concat([].slice.call(args)));
            },
            analogous: function () {
                return this._applyCombination(analogous, arguments);
            },
            complement: function () {
                return this._applyCombination(complement, arguments);
            },
            monochromatic: function () {
                return this._applyCombination(monochromatic, arguments);
            },
            splitcomplement: function () {
                return this._applyCombination(splitcomplement, arguments);
            },
            triad: function () {
                return this._applyCombination(triad, arguments);
            },
            tetrad: function () {
                return this._applyCombination(tetrad, arguments);
            }
        };
        tinycolor.fromRatio = function (color, opts) {
            if (typeof color == 'object') {
                var newColor = {};
                for (var i in color) {
                    if (color.hasOwnProperty(i)) {
                        if (i === 'a') {
                            newColor[i] = color[i];
                        } else {
                            newColor[i] = convertToPercentage(color[i]);
                        }
                    }
                }
                color = newColor;
            }
            return tinycolor(color, opts);
        };
        function inputToRGB(color) {
            var rgb = {
                r: 0,
                g: 0,
                b: 0
            };
            var a = 1;
            var ok = false;
            var format = false;
            if (typeof color == 'string') {
                color = stringInputToObject(color);
            }
            if (typeof color == 'object') {
                if (color.hasOwnProperty('r') && color.hasOwnProperty('g') && color.hasOwnProperty('b')) {
                    rgb = rgbToRgb(color.r, color.g, color.b);
                    ok = true;
                    format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
                } else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('v')) {
                    color.s = convertToPercentage(color.s);
                    color.v = convertToPercentage(color.v);
                    rgb = hsvToRgb(color.h, color.s, color.v);
                    ok = true;
                    format = 'hsv';
                } else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('l')) {
                    color.s = convertToPercentage(color.s);
                    color.l = convertToPercentage(color.l);
                    rgb = hslToRgb(color.h, color.s, color.l);
                    ok = true;
                    format = 'hsl';
                }
                if (color.hasOwnProperty('a')) {
                    a = color.a;
                }
            }
            a = boundAlpha(a);
            return {
                ok: ok,
                format: color.format || format,
                r: mathMin(255, mathMax(rgb.r, 0)),
                g: mathMin(255, mathMax(rgb.g, 0)),
                b: mathMin(255, mathMax(rgb.b, 0)),
                a: a
            };
        }
        function rgbToRgb(r, g, b) {
            return {
                r: bound01(r, 255) * 255,
                g: bound01(g, 255) * 255,
                b: bound01(b, 255) * 255
            };
        }
        function rgbToHsl(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max == min) {
                h = s = 0;
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                }
                h /= 6;
            }
            return {
                h: h,
                s: s,
                l: l
            };
        }
        function hslToRgb(h, s, l) {
            var r, g, b;
            h = bound01(h, 360);
            s = bound01(s, 100);
            l = bound01(l, 100);
            function hue2rgb(p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }
            if (s === 0) {
                r = g = b = l;
            } else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return {
                r: r * 255,
                g: g * 255,
                b: b * 255
            };
        }
        function rgbToHsv(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, v = max;
            var d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max == min) {
                h = 0;
            } else {
                switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                }
                h /= 6;
            }
            return {
                h: h,
                s: s,
                v: v
            };
        }
        function hsvToRgb(h, s, v) {
            h = bound01(h, 360) * 6;
            s = bound01(s, 100);
            v = bound01(v, 100);
            var i = math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [
                    v,
                    q,
                    p,
                    p,
                    t,
                    v
                ][mod], g = [
                    t,
                    v,
                    v,
                    q,
                    p,
                    p
                ][mod], b = [
                    p,
                    p,
                    t,
                    v,
                    v,
                    q
                ][mod];
            return {
                r: r * 255,
                g: g * 255,
                b: b * 255
            };
        }
        function rgbToHex(r, g, b, allow3Char) {
            var hex = [
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];
            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
                return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }
            return hex.join('');
        }
        function rgbaToHex(r, g, b, a) {
            var hex = [
                pad2(convertDecimalToHex(a)),
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];
            return hex.join('');
        }
        tinycolor.equals = function (color1, color2) {
            if (!color1 || !color2) {
                return false;
            }
            return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function () {
            return tinycolor.fromRatio({
                r: mathRandom(),
                g: mathRandom(),
                b: mathRandom()
            });
        };
        function desaturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
        }
        function saturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
        }
        function greyscale(color) {
            return tinycolor(color).desaturate(100);
        }
        function lighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
        }
        function brighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var rgb = tinycolor(color).toRgb();
            rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
            rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
            return tinycolor(rgb);
        }
        function darken(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
        }
        function spin(color, amount) {
            var hsl = tinycolor(color).toHsl();
            var hue = (mathRound(hsl.h) + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return tinycolor(hsl);
        }
        function complement(color) {
            var hsl = tinycolor(color).toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return tinycolor(hsl);
        }
        function triad(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({
                    h: (h + 120) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 240) % 360,
                    s: hsl.s,
                    l: hsl.l
                })
            ];
        }
        function tetrad(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({
                    h: (h + 90) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 180) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 270) % 360,
                    s: hsl.s,
                    l: hsl.l
                })
            ];
        }
        function splitcomplement(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({
                    h: (h + 72) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 216) % 360,
                    s: hsl.s,
                    l: hsl.l
                })
            ];
        }
        function analogous(color, results, slices) {
            results = results || 6;
            slices = slices || 30;
            var hsl = tinycolor(color).toHsl();
            var part = 360 / slices;
            var ret = [tinycolor(color)];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
                hsl.h = (hsl.h + part) % 360;
                ret.push(tinycolor(hsl));
            }
            return ret;
        }
        function monochromatic(color, results) {
            results = results || 6;
            var hsv = tinycolor(color).toHsv();
            var h = hsv.h, s = hsv.s, v = hsv.v;
            var ret = [];
            var modification = 1 / results;
            while (results--) {
                ret.push(tinycolor({
                    h: h,
                    s: s,
                    v: v
                }));
                v = (v + modification) % 1;
            }
            return ret;
        }
        tinycolor.mix = function (color1, color2, amount) {
            amount = amount === 0 ? 0 : amount || 50;
            var rgb1 = tinycolor(color1).toRgb();
            var rgb2 = tinycolor(color2).toRgb();
            var p = amount / 100;
            var w = p * 2 - 1;
            var a = rgb2.a - rgb1.a;
            var w1;
            if (w * a == -1) {
                w1 = w;
            } else {
                w1 = (w + a) / (1 + w * a);
            }
            w1 = (w1 + 1) / 2;
            var w2 = 1 - w1;
            var rgba = {
                r: rgb2.r * w1 + rgb1.r * w2,
                g: rgb2.g * w1 + rgb1.g * w2,
                b: rgb2.b * w1 + rgb1.b * w2,
                a: rgb2.a * p + rgb1.a * (1 - p)
            };
            return tinycolor(rgba);
        };
        tinycolor.readability = function (color1, color2) {
            var c1 = tinycolor(color1);
            var c2 = tinycolor(color2);
            var rgb1 = c1.toRgb();
            var rgb2 = c2.toRgb();
            var brightnessA = c1.getBrightness();
            var brightnessB = c2.getBrightness();
            var colorDiff = Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) + Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) + Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b);
            return {
                brightness: Math.abs(brightnessA - brightnessB),
                color: colorDiff
            };
        };
        tinycolor.isReadable = function (color1, color2) {
            var readability = tinycolor.readability(color1, color2);
            return readability.brightness > 125 && readability.color > 500;
        };
        tinycolor.mostReadable = function (baseColor, colorList) {
            var bestColor = null;
            var bestScore = 0;
            var bestIsReadable = false;
            for (var i = 0; i < colorList.length; i++) {
                var readability = tinycolor.readability(baseColor, colorList[i]);
                var readable = readability.brightness > 125 && readability.color > 500;
                var score = 3 * (readability.brightness / 125) + readability.color / 500;
                if (readable && !bestIsReadable || readable && bestIsReadable && score > bestScore || !readable && !bestIsReadable && score > bestScore) {
                    bestIsReadable = readable;
                    bestScore = score;
                    bestColor = tinycolor(colorList[i]);
                }
            }
            return bestColor;
        };
        var names = tinycolor.names = {
            aliceblue: 'f0f8ff',
            antiquewhite: 'faebd7',
            aqua: '0ff',
            aquamarine: '7fffd4',
            azure: 'f0ffff',
            beige: 'f5f5dc',
            bisque: 'ffe4c4',
            black: '000',
            blanchedalmond: 'ffebcd',
            blue: '00f',
            blueviolet: '8a2be2',
            brown: 'a52a2a',
            burlywood: 'deb887',
            burntsienna: 'ea7e5d',
            cadetblue: '5f9ea0',
            chartreuse: '7fff00',
            chocolate: 'd2691e',
            coral: 'ff7f50',
            cornflowerblue: '6495ed',
            cornsilk: 'fff8dc',
            crimson: 'dc143c',
            cyan: '0ff',
            darkblue: '00008b',
            darkcyan: '008b8b',
            darkgoldenrod: 'b8860b',
            darkgray: 'a9a9a9',
            darkgreen: '006400',
            darkgrey: 'a9a9a9',
            darkkhaki: 'bdb76b',
            darkmagenta: '8b008b',
            darkolivegreen: '556b2f',
            darkorange: 'ff8c00',
            darkorchid: '9932cc',
            darkred: '8b0000',
            darksalmon: 'e9967a',
            darkseagreen: '8fbc8f',
            darkslateblue: '483d8b',
            darkslategray: '2f4f4f',
            darkslategrey: '2f4f4f',
            darkturquoise: '00ced1',
            darkviolet: '9400d3',
            deeppink: 'ff1493',
            deepskyblue: '00bfff',
            dimgray: '696969',
            dimgrey: '696969',
            dodgerblue: '1e90ff',
            firebrick: 'b22222',
            floralwhite: 'fffaf0',
            forestgreen: '228b22',
            fuchsia: 'f0f',
            gainsboro: 'dcdcdc',
            ghostwhite: 'f8f8ff',
            gold: 'ffd700',
            goldenrod: 'daa520',
            gray: '808080',
            green: '008000',
            greenyellow: 'adff2f',
            grey: '808080',
            honeydew: 'f0fff0',
            hotpink: 'ff69b4',
            indianred: 'cd5c5c',
            indigo: '4b0082',
            ivory: 'fffff0',
            khaki: 'f0e68c',
            lavender: 'e6e6fa',
            lavenderblush: 'fff0f5',
            lawngreen: '7cfc00',
            lemonchiffon: 'fffacd',
            lightblue: 'add8e6',
            lightcoral: 'f08080',
            lightcyan: 'e0ffff',
            lightgoldenrodyellow: 'fafad2',
            lightgray: 'd3d3d3',
            lightgreen: '90ee90',
            lightgrey: 'd3d3d3',
            lightpink: 'ffb6c1',
            lightsalmon: 'ffa07a',
            lightseagreen: '20b2aa',
            lightskyblue: '87cefa',
            lightslategray: '789',
            lightslategrey: '789',
            lightsteelblue: 'b0c4de',
            lightyellow: 'ffffe0',
            lime: '0f0',
            limegreen: '32cd32',
            linen: 'faf0e6',
            magenta: 'f0f',
            maroon: '800000',
            mediumaquamarine: '66cdaa',
            mediumblue: '0000cd',
            mediumorchid: 'ba55d3',
            mediumpurple: '9370db',
            mediumseagreen: '3cb371',
            mediumslateblue: '7b68ee',
            mediumspringgreen: '00fa9a',
            mediumturquoise: '48d1cc',
            mediumvioletred: 'c71585',
            midnightblue: '191970',
            mintcream: 'f5fffa',
            mistyrose: 'ffe4e1',
            moccasin: 'ffe4b5',
            navajowhite: 'ffdead',
            navy: '000080',
            oldlace: 'fdf5e6',
            olive: '808000',
            olivedrab: '6b8e23',
            orange: 'ffa500',
            orangered: 'ff4500',
            orchid: 'da70d6',
            palegoldenrod: 'eee8aa',
            palegreen: '98fb98',
            paleturquoise: 'afeeee',
            palevioletred: 'db7093',
            papayawhip: 'ffefd5',
            peachpuff: 'ffdab9',
            peru: 'cd853f',
            pink: 'ffc0cb',
            plum: 'dda0dd',
            powderblue: 'b0e0e6',
            purple: '800080',
            rebeccapurple: '663399',
            red: 'f00',
            rosybrown: 'bc8f8f',
            royalblue: '4169e1',
            saddlebrown: '8b4513',
            salmon: 'fa8072',
            sandybrown: 'f4a460',
            seagreen: '2e8b57',
            seashell: 'fff5ee',
            sienna: 'a0522d',
            silver: 'c0c0c0',
            skyblue: '87ceeb',
            slateblue: '6a5acd',
            slategray: '708090',
            slategrey: '708090',
            snow: 'fffafa',
            springgreen: '00ff7f',
            steelblue: '4682b4',
            tan: 'd2b48c',
            teal: '008080',
            thistle: 'd8bfd8',
            tomato: 'ff6347',
            turquoise: '40e0d0',
            violet: 'ee82ee',
            wheat: 'f5deb3',
            white: 'fff',
            whitesmoke: 'f5f5f5',
            yellow: 'ff0',
            yellowgreen: '9acd32'
        };
        var hexNames = tinycolor.hexNames = flip(names);
        function flip(o) {
            var flipped = {};
            for (var i in o) {
                if (o.hasOwnProperty(i)) {
                    flipped[o[i]] = i;
                }
            }
            return flipped;
        }
        function boundAlpha(a) {
            a = parseFloat(a);
            if (isNaN(a) || a < 0 || a > 1) {
                a = 1;
            }
            return a;
        }
        function bound01(n, max) {
            if (isOnePointZero(n)) {
                n = '100%';
            }
            var processPercent = isPercentage(n);
            n = mathMin(max, mathMax(0, parseFloat(n)));
            if (processPercent) {
                n = parseInt(n * max, 10) / 100;
            }
            if (math.abs(n - max) < 0.000001) {
                return 1;
            }
            return n % max / parseFloat(max);
        }
        function clamp01(val) {
            return mathMin(1, mathMax(0, val));
        }
        function parseIntFromHex(val) {
            return parseInt(val, 16);
        }
        function isOnePointZero(n) {
            return typeof n == 'string' && n.indexOf('.') != -1 && parseFloat(n) === 1;
        }
        function isPercentage(n) {
            return typeof n === 'string' && n.indexOf('%') != -1;
        }
        function pad2(c) {
            return c.length == 1 ? '0' + c : '' + c;
        }
        function convertToPercentage(n) {
            if (n <= 1) {
                n = n * 100 + '%';
            }
            return n;
        }
        function convertDecimalToHex(d) {
            return Math.round(parseFloat(d) * 255).toString(16);
        }
        function convertHexToDecimal(h) {
            return parseIntFromHex(h) / 255;
        }
        var matchers = function () {
            var CSS_INTEGER = '[-\\+]?\\d+%?';
            var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';
            var CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';
            var PERMISSIVE_MATCH3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
            var PERMISSIVE_MATCH4 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
            return {
                rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
                rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
                hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
                hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
                hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
                hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
                hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
        }();
        function stringInputToObject(color) {
            color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
            var named = false;
            if (names[color]) {
                color = names[color];
                named = true;
            } else if (color == 'transparent') {
                return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    format: 'name'
                };
            }
            var match;
            if (match = matchers.rgb.exec(color)) {
                return {
                    r: match[1],
                    g: match[2],
                    b: match[3]
                };
            }
            if (match = matchers.rgba.exec(color)) {
                return {
                    r: match[1],
                    g: match[2],
                    b: match[3],
                    a: match[4]
                };
            }
            if (match = matchers.hsl.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    l: match[3]
                };
            }
            if (match = matchers.hsla.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    l: match[3],
                    a: match[4]
                };
            }
            if (match = matchers.hsv.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    v: match[3]
                };
            }
            if (match = matchers.hsva.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    v: match[3],
                    a: match[4]
                };
            }
            if (match = matchers.hex8.exec(color)) {
                return {
                    a: convertHexToDecimal(match[1]),
                    r: parseIntFromHex(match[2]),
                    g: parseIntFromHex(match[3]),
                    b: parseIntFromHex(match[4]),
                    format: named ? 'name' : 'hex8'
                };
            }
            if (match = matchers.hex6.exec(color)) {
                return {
                    r: parseIntFromHex(match[1]),
                    g: parseIntFromHex(match[2]),
                    b: parseIntFromHex(match[3]),
                    format: named ? 'name' : 'hex'
                };
            }
            if (match = matchers.hex3.exec(color)) {
                return {
                    r: parseIntFromHex(match[1] + '' + match[1]),
                    g: parseIntFromHex(match[2] + '' + match[2]),
                    b: parseIntFromHex(match[3] + '' + match[3]),
                    format: named ? 'name' : 'hex'
                };
            }
            return false;
        }
        window.tinycolor = tinycolor;
        $(function () {
            if ($.fn.spectrum.load) {
                $.fn.spectrum.processNativeColorInputs();
            }
        });
    };
});
define('skylark-grapejs/domain_abstract/ui/Input',['skylark-backbone'], function (Backbone) {
    'use strict';
    const $ = Backbone.$;
    return Backbone.View.extend({
        events: { change: 'handleChange' },
        template() {
            return `<span class="${ this.holderClass() }"></span>`;
        },
        inputClass() {
            return `${ this.ppfx }field`;
        },
        holderClass() {
            return `${ this.ppfx }input-holder`;
        },
        initialize(opts = {}) {
            const ppfx = opts.ppfx || '';
            this.opts = opts;
            this.ppfx = ppfx;
            this.em = opts.target || {};
            this.listenTo(this.model, 'change:value', this.handleModelChange);
        },
        elementUpdated() {
            this.model.trigger('el:change');
        },
        setValue(value) {
            const model = this.model;
            let val = value || model.get('defaults');
            const input = this.getInputEl();
            input && (input.value = val);
        },
        handleModelChange(model, value, opts) {
            this.setValue(value, opts);
        },
        handleChange(e) {
            e.stopPropagation();
            const value = this.getInputEl().value;
            this.model.set({ value }, { fromInput: 1 });
            this.elementUpdated();
        },
        getInputEl() {
            if (!this.inputEl) {
                const {model} = this;
                const plh = model.get('placeholder') || model.get('defaults') || '';
                this.inputEl = $(`<input type="text" placeholder="${ plh }">`);
            }
            return this.inputEl.get(0);
        },
        render() {
            this.inputEl = null;
            const el = this.$el;
            el.addClass(this.inputClass());
            el.html(this.template());
            el.find(`.${ this.holderClass() }`).append(this.getInputEl());
            return this;
        }
    });
});
define('skylark-grapejs/domain_abstract/ui/InputColor',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/ColorPicker',
    './Input'
], function (Backbone, a, ColorPicker, Input) {
    'use strict';
    const $ = Backbone.$;
    ColorPicker($);
    return Input.extend({
        template() {
            const ppfx = this.ppfx;
            return `
      <div class="${ this.holderClass() }"></div>
      <div class="${ ppfx }field-colorp">
        <div class="${ ppfx }field-colorp-c" data-colorp-c>
          <div class="${ ppfx }checker-bg"></div>
        </div>
      </div>
    `;
        },
        inputClass() {
            const ppfx = this.ppfx;
            return `${ ppfx }field ${ ppfx }field-color`;
        },
        holderClass() {
            return `${ this.ppfx }input-holder`;
        },
        setValue(val, opts = {}) {
            const model = this.model;
            const def = model.get('defaults');
            const value = !a.isUndefined(val) ? val : !a.isUndefined(def) ? def : '';
            const inputEl = this.getInputEl();
            const colorEl = this.getColorEl();
            const valueClr = value != 'none' ? value : '';
            inputEl.value = value;
            colorEl.get(0).style.backgroundColor = valueClr;
            if (opts.fromTarget) {
                colorEl.spectrum('set', valueClr);
                this.noneColor = value == 'none';
            }
        },
        getColorEl() {
            if (!this.colorEl) {
                const self = this;
                const ppfx = this.ppfx;
                var model = this.model;
                var colorEl = $(`<div class="${ this.ppfx }field-color-picker"></div>`);
                var cpStyle = colorEl.get(0).style;
                var elToAppend = this.em && this.em.config ? this.em.config.el : '';
                var colorPickerConfig = this.em && this.em.getConfig && this.em.getConfig('colorPicker') || {};
                const getColor = color => {
                    let cl = color.getAlpha() == 1 ? color.toHexString() : color.toRgbString();
                    return cl.replace(/ /g, '');
                };
                let changed = 0;
                let previousColor;
                this.$el.find(`[data-colorp-c]`).append(colorEl);
                colorEl.spectrum({
                    containerClassName: `${ ppfx }one-bg ${ ppfx }two-color`,
                    appendTo: elToAppend || 'body',
                    maxSelectionSize: 8,
                    showPalette: true,
                    showAlpha: true,
                    chooseText: 'Ok',
                    cancelText: '\u2A2F',
                    palette: [],
                    ...colorPickerConfig,
                    move(color) {
                        const cl = getColor(color);
                        cpStyle.backgroundColor = cl;
                        model.setValueFromInput(cl, 0);
                    },
                    change(color) {
                        changed = 1;
                        const cl = getColor(color);
                        cpStyle.backgroundColor = cl;
                        model.setValueFromInput(0, 0);
                        model.setValueFromInput(cl);
                        self.noneColor = 0;
                    },
                    show(color) {
                        changed = 0;
                        previousColor = getColor(color);
                    },
                    hide(color) {
                        if (!changed && previousColor) {
                            if (self.noneColor) {
                                previousColor = '';
                            }
                            cpStyle.backgroundColor = previousColor;
                            colorEl.spectrum('set', previousColor);
                            model.setValueFromInput(previousColor, 0);
                        }
                    }
                });
                this.colorEl = colorEl;
            }
            return this.colorEl;
        },
        render() {
            Input.prototype.render.call(this);
            this.getColorEl();
            return this;
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyColorView',[
    './PropertyIntegerView',
    '../../domain_abstract/ui/InputColor'
], function (PropertyIntegerView, InputColor) {
    'use strict';
    return PropertyIntegerView.extend({
        setValue(value, opts = {}) {
            opts = {
                ...opts,
                silent: 1
            };
            this.inputInst.setValue(value, opts);
        },
        onRender() {
            if (!this.input) {
                const ppfx = this.ppfx;
                const inputColor = new InputColor({
                    target: this.target,
                    model: this.model,
                    ppfx
                });
                const input = inputColor.render();
                this.el.querySelector(`.${ ppfx }fields`).appendChild(input.el);
                this.$input = input.inputEl;
                this.$color = input.colorEl;
                this.input = this.$input.get(0);
                this.inputInst = input;
            }
        }
    });
});
define('skylark-grapejs/style_manager/model/PropertyRadio',[
    "skylark-langx/langx",
    './Property'
], function (Property) {
    'use strict';
    return Property.extend({
        defaults: () => ({
            ...Property.prototype.defaults,
            options: [],
            full: 1
        }),
        initialize(...args) {
            Property.prototype.initialize.apply(this, args);
            this.listenTo(this, 'change:options', this.onOptionChange);
        },
        onOptionChange() {
            this.set('list', this.get('options'));
        },
        getOptions() {
            const {options, list} = this.attributes;
            return options && options.length ? options : list;
        },
        setOptions(opts = []) {
            this.set('options', opts);
            return this;
        },
        addOption(opt) {
            if (opt) {
                const opts = this.getOptions();
                this.setOptions([
                    ...opts,
                    opt
                ]);
            }
            return this;
        }
    });
});
define('skylark-grapejs/style_manager/model/PropertySelect',[
    "skylark-langx/langx",
	'./PropertyRadio'
], function (Property) {
    'use strict';
    return Property.extend({
        defaults: () => ({
            ...Property.prototype.defaults(),
            full: 0
        })
    });
});
define('skylark-grapejs/style_manager/view/PropertySelectView',[
    'skylark-backbone',
    './PropertyView'
], function (Backbone, PropertyView) {
    'use strict';
    const $ = Backbone.$;
    return PropertyView.extend({
        templateInput() {
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            return `
      <div class="${ ppfx }field ${ ppfx }select">
        <span id="${ pfx }input-holder"></span>
        <div class="${ ppfx }sel-arrow">
          <div class="${ ppfx }d-s-arrow"></div>
        </div>
      </div>
    `;
        },
        initialize(...args) {
            PropertyView.prototype.initialize.apply(this, args);
            this.listenTo(this.model, 'change:options', this.updateOptions);
        },
        updateOptions() {
            this.input = null;
            this.onRender();
        },
        onRender() {
            var pfx = this.pfx;
            const options = this.model.getOptions();
            if (!this.input) {
                let optionsStr = '';
                options.forEach(option => {
                    let name = option.name || option.value;
                    let style = option.style ? option.style.replace(/"/g, '&quot;') : '';
                    let styleAttr = style ? `style="${ style }"` : '';
                    let value = option.value.replace(/"/g, '&quot;');
                    optionsStr += `<option value="${ value }" ${ styleAttr }>${ name }</option>`;
                });
                const inputH = this.el.querySelector(`#${ pfx }input-holder`);
                inputH.innerHTML = `<select>${ optionsStr }</select>`;
                this.input = inputH.firstChild;
            }
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertyRadioView',['./PropertyView'], function (PropertyView) {
    'use strict';
    return PropertyView.extend({
        templateInput() {
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            return `
      <div class="${ ppfx }field ${ ppfx }field-radio">
      </div>
    `;
        },
        onRender() {
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            const itemCls = `${ ppfx }radio-item-label`;
            const model = this.model;
            const prop = model.get('property');
            const options = model.get('list') || model.get('options') || [];
            const {cid} = model;
            const clsInput = `${ pfx }radio ${ pfx }radio-${ prop }`;
            if (!this.input) {
                if (options && options.length) {
                    let inputStr = '';
                    options.forEach(el => {
                        let cl = el.className ? `${ el.className } ${ pfx }icon ${ itemCls }` : '';
                        let id = `${ prop }-${ el.value }-${ cid }`;
                        let labelTxt = el.name || el.value;
                        let titleAttr = el.title ? `title="${ el.title }"` : '';
                        inputStr += `
            <div class="${ ppfx }radio-item">
              <input type="radio" class="${ clsInput }" id="${ id }" name="${ prop }-${ cid }" value="${ el.value }"/>
              <label class="${ cl || itemCls }" ${ titleAttr } for="${ id }">${ cl ? '' : labelTxt }</label>
            </div>
          `;
                    });
                    const inputHld = this.el.querySelector(`.${ ppfx }field`);
                    inputHld.innerHTML = `<div class="${ ppfx }radio-items">${ inputStr }</div>`;
                    this.input = inputHld.firstChild;
                }
            }
        },
        getInputValue() {
            const inputChk = this.getCheckedEl();
            return inputChk ? inputChk.value : '';
        },
        getCheckedEl() {
            const input = this.getInputEl();
            return input ? input.querySelector('input:checked') : '';
        },
        setValue(value) {
            const model = this.model;
            let val = value || model.get('value') || model.getDefaultValue();
            const input = this.getInputEl();
            const inputIn = input ? input.querySelector(`[value="${ val }"]`) : '';
            if (inputIn) {
                inputIn.checked = true;
            } else {
                const inputChk = this.getCheckedEl();
                inputChk && (inputChk.checked = false);
            }
        }
    });
});
define('skylark-grapejs/domain_abstract/ui/InputNumber',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins',
    './Input'
], function (Backbone, a, b, Input) {
    'use strict';
    const $ = Backbone.$;
    return Input.extend({
        events: {
            'change input': 'handleChange',
            'change select': 'handleUnitChange',
            'click [data-arrow-up]': 'upArrowClick',
            'click [data-arrow-down]': 'downArrowClick',
            'mousedown [data-arrows]': 'downIncrement'
        },
        template() {
            const ppfx = this.ppfx;
            return `
      <span class="${ ppfx }input-holder"></span>
      <span class="${ ppfx }field-units"></span>
      <div class="${ ppfx }field-arrows" data-arrows>
        <div class="${ ppfx }field-arrow-u" data-arrow-up></div>
        <div class="${ ppfx }field-arrow-d" data-arrow-down></div>
      </div>
    `;
        },
        inputClass() {
            const ppfx = this.ppfx;
            return this.opts.contClass || `${ ppfx }field ${ ppfx }field-integer`;
        },
        initialize(opts = {}) {
            Input.prototype.initialize.apply(this, arguments);
            a.bindAll(this, 'moveIncrement', 'upIncrement');
            this.doc = document;
            this.listenTo(this.model, 'change:unit', this.handleModelChange);
        },
        setValue(value, opts) {
            var opt = opts || {};
            var valid = this.validateInputValue(value, { deepCheck: 1 });
            var validObj = { value: valid.value };
            if (valid.unit || valid.force) {
                validObj.unit = valid.unit;
            }
            this.model.set(validObj, opt);
            if (opt.silent) {
                this.handleModelChange();
            }
        },
        handleChange(e) {
            e.stopPropagation();
            this.setValue(this.getInputEl().value);
            this.elementUpdated();
        },
        handleUnitChange(e) {
            e.stopPropagation();
            var value = this.getUnitEl().value;
            this.model.set('unit', value);
            this.elementUpdated();
        },
        elementUpdated() {
            this.model.trigger('el:change');
        },
        handleModelChange() {
            const model = this.model;
            this.getInputEl().value = model.get('value');
            const unitEl = this.getUnitEl();
            unitEl && (unitEl.value = model.get('unit') || '');
        },
        getUnitEl() {
            if (!this.unitEl) {
                const model = this.model;
                const units = model.get('units') || [];
                if (units.length) {
                    const options = [];
                    units.forEach(unit => {
                        const selected = unit == model.get('unit') ? 'selected' : '';
                        options.push(`<option ${ selected }>${ unit }</option>`);
                    });
                    const temp = document.createElement('div');
                    temp.innerHTML = `<select class="${ this.ppfx }input-unit">${ options.join('') }</select>`;
                    this.unitEl = temp.firstChild;
                }
            }
            return this.unitEl;
        },
        upArrowClick() {
            const model = this.model;
            const step = model.get('step');
            let value = parseInt(model.get('value'), 10);
            value = this.normalizeValue(value + step);
            var valid = this.validateInputValue(value);
            model.set('value', valid.value);
            this.elementUpdated();
        },
        downArrowClick() {
            const model = this.model;
            const step = model.get('step');
            const value = parseInt(model.get('value'), 10);
            const val = this.normalizeValue(value - step);
            var valid = this.validateInputValue(val);
            model.set('value', valid.value);
            this.elementUpdated();
        },
        downIncrement(e) {
            e.preventDefault();
            this.moved = 0;
            var value = this.model.get('value');
            value = this.normalizeValue(value);
            this.current = {
                y: e.pageY,
                val: value
            };
            b.on(this.doc, 'mousemove', this.moveIncrement);
            b.on(this.doc, 'mouseup', this.upIncrement);
        },
        moveIncrement(ev) {
            this.moved = 1;
            const model = this.model;
            const step = model.get('step');
            const data = this.current;
            var pos = this.normalizeValue(data.val + (data.y - ev.pageY) * step);
            this.prValue = this.validateInputValue(pos).value;
            model.set('value', this.prValue, { avoidStore: 1 });
            return false;
        },
        upIncrement() {
            const model = this.model;
            const step = model.get('step');
            b.off(this.doc, 'mouseup', this.upIncrement);
            b.off(this.doc, 'mousemove', this.moveIncrement);
            if (this.prValue && this.moved) {
                var value = this.prValue - step;
                model.set('value', value, { avoidStore: 1 }).set('value', value + step);
                this.elementUpdated();
            }
        },
        normalizeValue(value, defValue = 0) {
            const model = this.model;
            const step = model.get('step');
            let stepDecimals = 0;
            if (isNaN(value)) {
                return defValue;
            }
            value = parseFloat(value);
            if (Math.floor(value) !== value) {
                const side = step.toString().split('.')[1];
                stepDecimals = side ? side.length : 0;
            }
            return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
        },
        validateInputValue(value, opts) {
            var force = 0;
            var opt = opts || {};
            var model = this.model;
            const defValue = '';
            var val = !a.isUndefined(value) ? value : defValue;
            var units = model.get('units') || [];
            var unit = model.get('unit') || units.length && units[0] || '';
            var max = model.get('max');
            var min = model.get('min');
            if (opt.deepCheck) {
                var fixed = model.get('fixedValues') || [];
                if (val) {
                    var regFixed = new RegExp('^' + fixed.join('|'), 'g');
                    if (fixed.length && regFixed.test(val)) {
                        val = val.match(regFixed)[0];
                        unit = '';
                        force = 1;
                    } else {
                        var valCopy = val + '';
                        val += '';
                        val = parseFloat(val.replace(',', '.'));
                        val = !isNaN(val) ? val : defValue;
                        var uN = valCopy.replace(val, '');
                        if (a.indexOf(units, uN) >= 0)
                            unit = uN;
                    }
                }
            }
            if (!a.isUndefined(max) && max !== '')
                val = val > max ? max : val;
            if (!a.isUndefined(min) && min !== '')
                val = val < min ? min : val;
            return {
                force,
                value: val,
                unit
            };
        },
        render() {
            Input.prototype.render.call(this);
            this.unitEl = null;
            const unit = this.getUnitEl();
            unit && this.$el.find(`.${ this.ppfx }field-units`).get(0).appendChild(unit);
            return this;
        }
    });
});
define('skylark-grapejs/style_manager/model/PropertyInteger',[
    "skylark-langx/langx",
    'skylark-underscore',
    './Property',
    '../../domain_abstract/ui/InputNumber'
], function (a, Property, InputNumber) {
    'use strict';
    return Property.extend({
        defaults: {
            ...Property.prototype.defaults,
            units: [],
            unit: '',
            step: 1,
            min: '',
            max: ''
        },
        initialize(props = {}, opts = {}) {
            Property.callParentInit(Property, this, props, opts);
            const unit = this.get('unit');
            const units = this.get('units');
            this.input = new InputNumber({ model: this });
            if (units.length && !unit) {
                this.set('unit', units[0]);
            }
            Property.callInit(this, props, opts);
        },
        clearValue(opts = {}) {
            this.set({
                value: undefined,
                unit: undefined
            }, opts);
            return this;
        },
        parseValue(val) {
            const parsed = Property.prototype.parseValue.apply(this, arguments);
            const {value, unit} = this.input.validateInputValue(parsed.value, { deepCheck: 1 });
            parsed.value = value;
            parsed.unit = unit;
            return parsed;
        },
        getFullValue() {
            let value = this.get('value');
            let unit = this.get('unit');
            value = !a.isUndefined(value) ? value : '';
            unit = !a.isUndefined(unit) && value ? unit : '';
            value = `${ value }${ unit }`;
            return Property.prototype.getFullValue.apply(this, [value]);
        }
    });
});
define('skylark-grapejs/style_manager/model/PropertySlider',[
    "skylark-langx/langx",
	'./PropertyInteger'
], function (Property) {
    'use strict';
    return Property.extend({
        defaults: {
            ...Property.prototype.defaults,
            showInput: 1
        }
    });
});
define('skylark-grapejs/style_manager/view/PropertySliderView',['./PropertyIntegerView'], function (Property) {
    'use strict';
    return Property.extend({
        events() {
            return {
                ...Property.prototype.events,
                'change [type=range]': 'inputValueChanged',
                'input [type=range]': 'inputValueChangedSoft',
                change: ''
            };
        },
        templateInput(model) {
            const ppfx = this.ppfx;
            return `
      <div class="${ ppfx }field ${ ppfx }field-range">
        <input type="range"
          min="${ model.get('min') }"
          max="${ model.get('max') }"
          step="${ model.get('step') }"/>
      </div>
    `;
        },
        getSliderEl() {
            if (!this.slider) {
                this.slider = this.el.querySelector('input[type=range]');
            }
            return this.slider;
        },
        inputValueChanged() {
            const model = this.model;
            const step = model.get('step');
            this.getInputEl().value = this.getSliderEl().value;
            const value = this.getInputValue() - step;
            model.set('value', value, { avoidStore: 1 }).set('value', value + step);
            this.elementUpdated();
        },
        inputValueChangedSoft() {
            this.getInputEl().value = this.getSliderEl().value;
            this.model.set('value', this.getInputValue(), { avoidStore: 1 });
            this.elementUpdated();
        },
        setValue(value) {
            const parsed = this.model.parseValue(value);
            this.getSliderEl().value = parseFloat(parsed.value);
            Property.prototype.setValue.apply(this, arguments);
        },
        onRender() {
            Property.prototype.onRender.apply(this, arguments);
            if (!this.model.get('showInput')) {
                this.inputInst.el.style.display = 'none';
            }
        },
        clearCached() {
            Property.prototype.clearCached.apply(this, arguments);
            this.slider = null;
        }
    });
});
define('skylark-grapejs/style_manager/model/Properties',[
    "skylark-langx/langx",
    'skylark-backbone',
    '../../domain_abstract/model/TypeableCollection',
    './Property',
    './PropertyStack',
    './../view/PropertyStackView',
    './PropertyComposite',
    './../view/PropertyCompositeView',
    './../view/PropertyFileView',
    './../view/PropertyColorView',
    './PropertySelect',
    './../view/PropertySelectView',
    './PropertyRadio',
    './../view/PropertyRadioView',
    './PropertySlider',
    './../view/PropertySliderView',
    './PropertyInteger',
    './../view/PropertyIntegerView',
    './../view/PropertyView'
], function (langx,Backbone, TypeableCollection, Property, PropertyStack, PropertyStackView, PropertyComposite, PropertyCompositeView, PropertyFileView, PropertyColorView, PropertySelect, PropertySelectView, PropertyRadio, PropertyRadioView, PropertySlider, PropertySliderView, PropertyInteger, PropertyIntegerView, PropertyView) {
    'use strict';
    return Backbone.Collection.extend(TypeableCollection).extend({
        types: [
            {
                id: 'stack',
                model: PropertyStack,
                view: PropertyStackView,
                isType(value) {
                    if (value && value.type == 'stack') {
                        return value;
                    }
                }
            },
            {
                id: 'composite',
                model: PropertyComposite,
                view: PropertyCompositeView,
                isType(value) {
                    if (value && value.type == 'composite') {
                        return value;
                    }
                }
            },
            {
                id: 'file',
                model: Property,
                view: PropertyFileView,
                isType(value) {
                    if (value && value.type == 'file') {
                        return value;
                    }
                }
            },
            {
                id: 'color',
                model: Property,
                view: PropertyColorView,
                isType(value) {
                    if (value && value.type == 'color') {
                        return value;
                    }
                }
            },
            {
                id: 'select',
                model: PropertySelect,
                view: PropertySelectView,
                isType(value) {
                    if (value && value.type == 'select') {
                        return value;
                    }
                }
            },
            {
                id: 'radio',
                model: PropertyRadio,
                view: PropertyRadioView,
                isType(value) {
                    if (value && value.type == 'radio') {
                        return value;
                    }
                }
            },
            {
                id: 'slider',
                model: PropertySlider,
                view: PropertySliderView,
                isType(value) {
                    if (value && value.type == 'slider') {
                        return value;
                    }
                }
            },
            {
                id: 'integer',
                model: PropertyInteger,
                view: PropertyIntegerView,
                isType(value) {
                    if (value && value.type == 'integer') {
                        return value;
                    }
                }
            },
            {
                id: 'base',
                model: Property,
                view: PropertyView,
                isType(value) {
                    value.type = 'base';
                    return value;
                }
            }
        ],
        deepClone() {
            const collection = this.clone();
            collection.reset(collection.map(model => {
                const cloned = model.clone();
                cloned.typeView = model.typeView;
                return cloned;
            }));
            return collection;
        },
        parseValue(value) {
            const properties = [];
            const values = value.split(' ');
            values.forEach((value, i) => {
                const property = this.at(i);
                if (!property)
                    return;
                properties.push(langx.mixin({},property.attributes,{ value }));
            });
            return properties;
        },
        getFullValue() {
            let result = '';
            this.each(model => result += `${ model.getFullValue() } `);
            return result.trim();
        }
    });
});
define('skylark-grapejs/style_manager/model/PropertyFactory',[],function () {
    'use strict';
    return () => ({
        build(props) {
            var objs = [];
            var dftFixedValues = [
                'initial',
                'inherit'
            ];
            if (typeof props === 'string')
                props = [props];
            for (var i = 0, len = props.length; i < len; i++) {
                var obj = {};
                var prop = props[i];
                obj.property = prop;
                switch (prop) {
                case 'border-radius-c':
                    obj.property = 'border-radius';
                    break;
                }
                switch (prop) {
                case 'top':
                case 'right':
                case 'bottom':
                case 'left':
                case 'margin-top':
                case 'margin-right':
                case 'margin-bottom':
                case 'margin-left':
                case 'padding-top':
                case 'padding-right':
                case 'padding-bottom':
                case 'padding-left':
                case 'width':
                case 'max-width':
                case 'min-width':
                case 'height':
                case 'max-height':
                case 'min-height':
                case 'flex-basis':
                    obj.fixedValues = [
                        'initial',
                        'inherit',
                        'auto'
                    ];
                    break;
                case 'font-size':
                    obj.fixedValues = [
                        'medium',
                        'xx-small',
                        'x-small',
                        'small',
                        'large',
                        'x-large',
                        'xx-large',
                        'smaller',
                        'larger',
                        'length',
                        'initial',
                        'inherit'
                    ];
                    break;
                case 'letter-spacing':
                case 'line-height':
                    obj.fixedValues = [
                        'normal',
                        'initial',
                        'inherit'
                    ];
                    break;
                }
                switch (prop) {
                case 'float':
                case 'position':
                case 'text-align':
                    obj.type = 'radio';
                    break;
                case 'display':
                case 'flex-direction':
                case 'flex-wrap':
                case 'justify-content':
                case 'align-items':
                case 'align-content':
                case 'align-self':
                case 'font-family':
                case 'font-weight':
                case 'border-style':
                case 'box-shadow-type':
                case 'background-repeat':
                case 'background-position':
                case 'background-attachment':
                case 'background-size':
                case 'transition-property':
                case 'transition-timing-function':
                case 'cursor':
                case 'overflow':
                case 'overflow-x':
                case 'overflow-y':
                    obj.type = 'select';
                    break;
                case 'top':
                case 'right':
                case 'bottom':
                case 'left':
                case 'margin-top':
                case 'margin-right':
                case 'margin-bottom':
                case 'margin-left':
                case 'padding-top':
                case 'padding-right':
                case 'padding-bottom':
                case 'padding-left':
                case 'min-height':
                case 'min-width':
                case 'max-height':
                case 'max-width':
                case 'width':
                case 'height':
                case 'font-size':
                case 'letter-spacing':
                case 'line-height':
                case 'text-shadow-h':
                case 'text-shadow-v':
                case 'text-shadow-blur':
                case 'border-radius-c':
                case 'border-top-left-radius':
                case 'border-top-right-radius':
                case 'border-bottom-left-radius':
                case 'border-bottom-right-radius':
                case 'border-width':
                case 'box-shadow-h':
                case 'box-shadow-v':
                case 'box-shadow-blur':
                case 'box-shadow-spread':
                case 'transition-duration':
                case 'perspective':
                case 'transform-rotate-x':
                case 'transform-rotate-y':
                case 'transform-rotate-z':
                case 'transform-scale-x':
                case 'transform-scale-y':
                case 'transform-scale-z':
                case 'order':
                case 'flex-grow':
                case 'flex-shrink':
                case 'flex-basis':
                    obj.type = 'integer';
                    break;
                case 'margin':
                case 'padding':
                case 'border-radius':
                case 'border':
                case 'transform':
                    obj.type = 'composite';
                    break;
                case 'color':
                case 'text-shadow-color':
                case 'background-color':
                case 'border-color':
                case 'box-shadow-color':
                    obj.type = 'color';
                    break;
                case 'text-shadow':
                case 'box-shadow':
                case 'background':
                case 'transition':
                    obj.type = 'stack';
                    break;
                case 'background-image':
                    obj.type = 'file';
                    break;
                }
                switch (prop) {
                case 'float':
                case 'background-color':
                case 'text-shadow':
                    obj.defaults = 'none';
                    break;
                case 'display':
                    obj.defaults = 'block';
                    break;
                case 'flex-direction':
                    obj.defaults = 'row';
                    break;
                case 'flex-wrap':
                    obj.defaults = 'nowrap';
                    break;
                case 'justify-content':
                    obj.defaults = 'flex-start';
                    break;
                case 'align-items':
                    obj.defaults = 'stretch';
                    break;
                case 'align-content':
                    obj.defaults = 'stretch';
                    break;
                case 'align-self':
                    obj.defaults = 'auto';
                    break;
                case 'position':
                    obj.defaults = 'static';
                    break;
                case 'margin-top':
                case 'margin-right':
                case 'margin-bottom':
                case 'margin-left':
                case 'padding-top':
                case 'padding-right':
                case 'padding-bottom':
                case 'padding-left':
                case 'text-shadow-h':
                case 'text-shadow-v':
                case 'text-shadow-blur':
                case 'border-radius-c':
                case 'box-shadow-h':
                case 'box-shadow-v':
                case 'box-shadow-spread':
                case 'perspective':
                case 'transform-rotate-x':
                case 'transform-rotate-y':
                case 'transform-rotate-z':
                case 'order':
                case 'flex-grow':
                    obj.defaults = 0;
                    break;
                case 'border-top-left-radius':
                case 'border-top-right-radius':
                case 'border-bottom-left-radius':
                case 'border-bottom-right-radius':
                    obj.defaults = '0px';
                    break;
                case 'transform-scale-x':
                case 'transform-scale-y':
                case 'transform-scale-z':
                case 'flex-shrink':
                    obj.defaults = 1;
                    break;
                case 'box-shadow-blur':
                    obj.defaults = '5px';
                    break;
                case 'top':
                case 'right':
                case 'bottom':
                case 'left':
                case 'min-height':
                case 'min-width':
                case 'max-height':
                case 'max-width':
                case 'width':
                case 'height':
                case 'background-size':
                case 'cursor':
                case 'flex-basis':
                    obj.defaults = 'auto';
                    break;
                case 'font-family':
                    obj.defaults = 'Arial, Helvetica, sans-serif';
                    break;
                case 'font-size':
                case 'border-width':
                    obj.defaults = 'medium';
                    break;
                case 'font-weight':
                    obj.defaults = '400';
                    break;
                case 'letter-spacing':
                case 'line-height':
                    obj.defaults = 'normal';
                    break;
                case 'color':
                case 'text-shadow-color':
                case 'border-color':
                case 'box-shadow-color':
                    obj.defaults = 'black';
                    break;
                case 'text-align':
                    obj.defaults = 'left';
                    break;
                case 'border-style':
                    obj.defaults = 'solid';
                    break;
                case 'box-shadow-type':
                    obj.defaults = '';
                    break;
                case 'background-repeat':
                    obj.defaults = 'repeat';
                    break;
                case 'background-position':
                    obj.defaults = 'left top';
                    break;
                case 'background-attachment':
                    obj.defaults = 'scroll';
                    break;
                case 'transition-property':
                    obj.defaults = 'width';
                    break;
                case 'transition-duration':
                    obj.defaults = '2';
                    break;
                case 'transition-timing-function':
                    obj.defaults = 'ease';
                    break;
                case 'overflow':
                case 'overflow-x':
                case 'overflow-y':
                    obj.defaults = 'visible';
                    break;
                }
                switch (prop) {
                case 'flex-direction':
                case 'flex-wrap':
                case 'justify-content':
                case 'align-items':
                case 'align-content':
                    obj.requires = { display: ['flex'] };
                    break;
                case 'order':
                case 'flex-basis':
                case 'flex-grow':
                case 'flex-shrink':
                case 'align-self':
                    obj.requiresParent = { display: ['flex'] };
                    break;
                }
                switch (prop) {
                case 'top':
                case 'bottom':
                case 'margin-top':
                case 'margin-bottom':
                case 'padding-top':
                case 'padding-bottom':
                case 'min-height':
                case 'max-height':
                case 'height':
                    obj.units = [
                        'px',
                        '%',
                        'vh'
                    ];
                    break;
                case 'right':
                case 'left':
                case 'margin-right':
                case 'margin-left':
                case 'padding-right':
                case 'padding-left':
                case 'min-width':
                case 'max-width':
                case 'width':
                    obj.units = [
                        'px',
                        '%',
                        'vw'
                    ];
                    break;
                case 'flex-basis':
                    obj.units = [
                        'px',
                        '%',
                        'vw',
                        'vh'
                    ];
                    break;
                case 'text-shadow-v':
                case 'text-shadow-h':
                case 'text-shadow-blur':
                case 'border-radius-c':
                case 'border-top-left-radius':
                case 'border-top-right-radius':
                case 'border-bottom-left-radius':
                case 'border-bottom-right-radius':
                case 'box-shadow-h':
                case 'box-shadow-v':
                    obj.units = [
                        'px',
                        '%'
                    ];
                    break;
                case 'font-size':
                case 'letter-spacing':
                case 'line-height':
                    obj.units = [
                        'px',
                        'em',
                        'rem',
                        '%'
                    ];
                    break;
                case 'border-width':
                    obj.units = [
                        'px',
                        'em'
                    ];
                    break;
                case 'box-shadow-blur':
                case 'box-shadow-spread':
                case 'perspective':
                    obj.units = ['px'];
                    break;
                case 'transition-duration':
                    obj.units = ['s'];
                    break;
                case 'transform-rotate-x':
                case 'transform-rotate-y':
                case 'transform-rotate-z':
                    obj.units = ['deg'];
                    break;
                }
                switch (prop) {
                case 'padding-top':
                case 'padding-right':
                case 'padding-bottom':
                case 'padding-left':
                case 'min-height':
                case 'min-width':
                case 'max-height':
                case 'max-width':
                case 'width':
                case 'height':
                case 'font-size':
                case 'text-shadow-blur':
                case 'border-radius-c':
                case 'border-top-left-radius':
                case 'border-top-right-radius':
                case 'border-bottom-left-radius':
                case 'border-bottom-right-radius':
                case 'border-width':
                case 'box-shadow-blur':
                case 'transition-duration':
                case 'perspective':
                case 'flex-basis':
                    obj.min = 0;
                    break;
                }
                switch (prop) {
                case 'text-shadow':
                case 'box-shadow':
                case 'background':
                    obj.preview = true;
                    break;
                }
                switch (prop) {
                case 'background':
                    obj.detached = true;
                    break;
                }
                switch (prop) {
                case 'transform-rotate-x':
                    obj.functionName = 'rotateX';
                    break;
                case 'transform-rotate-y':
                    obj.functionName = 'rotateY';
                    break;
                case 'transform-rotate-z':
                    obj.functionName = 'rotateZ';
                    break;
                case 'transform-scale-x':
                    obj.functionName = 'scaleX';
                    break;
                case 'transform-scale-y':
                    obj.functionName = 'scaleY';
                    break;
                case 'transform-scale-z':
                    obj.functionName = 'scaleZ';
                    break;
                case 'background-image':
                    obj.functionName = 'url';
                    break;
                }
                switch (prop) {
                case 'float':
                    obj.list = [
                        { value: 'none' },
                        { value: 'left' },
                        { value: 'right' }
                    ];
                    break;
                case 'display':
                    obj.list = [
                        { value: 'block' },
                        { value: 'inline' },
                        { value: 'inline-block' },
                        { value: 'flex' },
                        { value: 'none' }
                    ];
                    break;
                case 'flex-direction':
                    obj.list = [
                        { value: 'row' },
                        { value: 'row-reverse' },
                        { value: 'column' },
                        { value: 'column-reverse' }
                    ];
                    break;
                case 'flex-wrap':
                    obj.list = [
                        { value: 'nowrap' },
                        { value: 'wrap' },
                        { value: 'wrap-reverse' }
                    ];
                    break;
                case 'justify-content':
                    obj.list = [
                        { value: 'flex-start' },
                        { value: 'flex-end' },
                        { value: 'center' },
                        { value: 'space-between' },
                        { value: 'space-around' },
                        { value: 'space-evenly' }
                    ];
                    break;
                case 'align-items':
                    obj.list = [
                        { value: 'flex-start' },
                        { value: 'flex-end' },
                        { value: 'center' },
                        { value: 'baseline' },
                        { value: 'stretch' }
                    ];
                    break;
                case 'align-content':
                    obj.list = [
                        { value: 'flex-start' },
                        { value: 'flex-end' },
                        { value: 'center' },
                        { value: 'space-between' },
                        { value: 'space-around' },
                        { value: 'stretch' }
                    ];
                    break;
                case 'align-self':
                    obj.list = [
                        { value: 'auto' },
                        { value: 'flex-start' },
                        { value: 'flex-end' },
                        { value: 'center' },
                        { value: 'baseline' },
                        { value: 'stretch' }
                    ];
                    break;
                case 'position':
                    obj.list = [
                        { value: 'static' },
                        { value: 'relative' },
                        { value: 'absolute' },
                        { value: 'fixed' }
                    ];
                    break;
                case 'font-family':
                    var ss = ', sans-serif';
                    var fonts = [
                        'Arial, Helvetica' + ss,
                        'Arial Black, Gadget' + ss,
                        'Brush Script MT' + ss,
                        'Comic Sans MS, cursive' + ss,
                        'Courier New, Courier, monospace',
                        'Georgia, serif',
                        'Helvetica, serif',
                        'Impact, Charcoal' + ss,
                        'Lucida Sans Unicode, Lucida Grande' + ss,
                        'Tahoma, Geneva' + ss,
                        'Times New Roman, Times, serif',
                        'Trebuchet MS, Helvetica' + ss,
                        'Verdana, Geneva' + ss
                    ];
                    obj.list = [];
                    for (var j = 0, l = fonts.length; j < l; j++) {
                        var font = {};
                        font.value = fonts[j];
                        font.name = fonts[j].split(',')[0];
                        obj.list.push(font);
                    }
                    break;
                case 'font-weight':
                    obj.list = [
                        {
                            value: '100',
                            name: 'Thin'
                        },
                        {
                            value: '200',
                            name: 'Extra-Light'
                        },
                        {
                            value: '300',
                            name: 'Light'
                        },
                        {
                            value: '400',
                            name: 'Normal'
                        },
                        {
                            value: '500',
                            name: 'Medium'
                        },
                        {
                            value: '600',
                            name: 'Semi-Bold'
                        },
                        {
                            value: '700',
                            name: 'Bold'
                        },
                        {
                            value: '800',
                            name: 'Extra-Bold'
                        },
                        {
                            value: '900',
                            name: 'Ultra-Bold'
                        }
                    ];
                    break;
                case 'text-align':
                    obj.list = [
                        { value: 'left' },
                        { value: 'center' },
                        { value: 'right' },
                        { value: 'justify' }
                    ];
                    break;
                case 'border-style':
                    obj.list = [
                        { value: 'none' },
                        { value: 'solid' },
                        { value: 'dotted' },
                        { value: 'dashed' },
                        { value: 'double' },
                        { value: 'groove' },
                        { value: 'ridge' },
                        { value: 'inset' },
                        { value: 'outset' }
                    ];
                    break;
                case 'box-shadow-type':
                    obj.list = [
                        {
                            value: '',
                            name: 'Outside'
                        },
                        {
                            value: 'inset',
                            name: 'Inside'
                        }
                    ];
                    break;
                case 'background-repeat':
                    obj.list = [
                        { value: 'repeat' },
                        { value: 'repeat-x' },
                        { value: 'repeat-y' },
                        { value: 'no-repeat' }
                    ];
                    break;
                case 'background-position':
                    obj.list = [
                        { value: 'left top' },
                        { value: 'left center' },
                        { value: 'left bottom' },
                        { value: 'right top' },
                        { value: 'right center' },
                        { value: 'right bottom' },
                        { value: 'center top' },
                        { value: 'center center' },
                        { value: 'center bottom' }
                    ];
                    break;
                case 'background-attachment':
                    obj.list = [
                        { value: 'scroll' },
                        { value: 'fixed' },
                        { value: 'local' }
                    ];
                    break;
                case 'background-size':
                    obj.list = [
                        { value: 'auto' },
                        { value: 'cover' },
                        { value: 'contain' }
                    ];
                    break;
                case 'transition-property':
                    obj.list = [
                        { value: 'all' },
                        { value: 'width' },
                        { value: 'height' },
                        { value: 'background-color' },
                        { value: 'transform' },
                        { value: 'box-shadow' },
                        { value: 'opacity' }
                    ];
                    break;
                case 'transition-timing-function':
                    obj.list = [
                        { value: 'linear' },
                        { value: 'ease' },
                        { value: 'ease-in' },
                        { value: 'ease-out' },
                        { value: 'ease-in-out' }
                    ];
                    break;
                case 'cursor':
                    obj.list = [
                        { value: 'auto' },
                        { value: 'pointer' },
                        { value: 'copy' },
                        { value: 'crosshair' },
                        { value: 'grab' },
                        { value: 'grabbing' },
                        { value: 'help' },
                        { value: 'move' },
                        { value: 'text' }
                    ];
                    break;
                case 'overflow':
                case 'overflow-x':
                case 'overflow-y':
                    obj.list = [
                        { value: 'visible' },
                        { value: 'hidden' },
                        { value: 'scroll' },
                        { value: 'auto' }
                    ];
                    break;
                }
                switch (prop) {
                case 'margin':
                    obj.properties = this.build([
                        'margin-top',
                        'margin-right',
                        'margin-bottom',
                        'margin-left'
                    ]);
                    break;
                case 'padding':
                    obj.properties = this.build([
                        'padding-top',
                        'padding-right',
                        'padding-bottom',
                        'padding-left'
                    ]);
                    break;
                case 'text-shadow':
                    obj.properties = this.build([
                        'text-shadow-h',
                        'text-shadow-v',
                        'text-shadow-blur',
                        'text-shadow-color'
                    ]);
                    break;
                case 'border':
                    obj.properties = this.build([
                        'border-width',
                        'border-style',
                        'border-color'
                    ]);
                    break;
                case 'border-radius':
                    obj.properties = this.build([
                        'border-top-left-radius',
                        'border-top-right-radius',
                        'border-bottom-right-radius',
                        'border-bottom-left-radius'
                    ]);
                    break;
                case 'box-shadow':
                    obj.properties = this.build([
                        'box-shadow-h',
                        'box-shadow-v',
                        'box-shadow-blur',
                        'box-shadow-spread',
                        'box-shadow-color',
                        'box-shadow-type'
                    ]);
                    break;
                case 'background':
                    obj.properties = this.build([
                        'background-image',
                        'background-repeat',
                        'background-position',
                        'background-attachment',
                        'background-size'
                    ]);
                    break;
                case 'transition':
                    obj.properties = this.build([
                        'transition-property',
                        'transition-duration',
                        'transition-timing-function'
                    ]);
                    break;
                case 'transform':
                    obj.properties = this.build([
                        'transform-rotate-x',
                        'transform-rotate-y',
                        'transform-rotate-z',
                        'transform-scale-x',
                        'transform-scale-y',
                        'transform-scale-z'
                    ]);
                    break;
                }
                objs.push(obj);
            }
            return objs;
        }
    });
});
define('skylark-grapejs/style_manager/model/Sector',[
    'skylark-backbone',
    'skylark-underscore',
    './Properties',
    './PropertyFactory'
], function (Backbone, a, Properties, PropertyFactory) {
    'use strict';
    return Backbone.Model.undefined({
        defaults: {
            id: '',
            name: '',
            open: true,
            buildProps: '',
            extendBuilded: 1,
            properties: []
        },
        initialize(opts) {
            const o = opts || {};
            const builded = this.buildProperties(o.buildProps);
            const name = this.get('name') || '';
            let props = [];
            !this.get('id') && this.set('id', name.replace(/ /g, '_').toLowerCase());
            if (!builded)
                props = this.get('properties');
            else
                props = this.extendProperties(builded);
            const propsModel = new Properties(props);
            propsModel.sector = this;
            this.set('properties', propsModel);
        },
        extendProperties(props, moProps, ex) {
            var pLen = props.length;
            var mProps = moProps || this.get('properties');
            var ext = this.get('extendBuilded');
            var isolated = [];
            for (var i = 0, len = mProps.length; i < len; i++) {
                var mProp = mProps[i];
                var found = 0;
                for (var j = 0; j < pLen; j++) {
                    var prop = props[j];
                    if (mProp.property == prop.property || mProp.id == prop.property) {
                        var mPProps = mProp.properties;
                        if (mPProps && mPProps.length) {
                            mProp.properties = this.extendProperties(prop.properties || [], mPProps, 1);
                        }
                        props[j] = ext ? a.extend(prop, mProp) : mProp;
                        isolated[j] = props[j];
                        found = 1;
                        continue;
                    }
                }
                if (!found) {
                    props.push(mProp);
                    isolated.push(mProp);
                }
            }
            return ex ? isolated.filter(i => i) : props;
        },
        buildProperties(props) {
            var r;
            var buildP = props || [];
            if (!buildP.length)
                return;
            if (!this.propFactory)
                this.propFactory = new PropertyFactory();
            r = this.propFactory.build(buildP);
            return r;
        }
    });
});
define('skylark-grapejs/style_manager/model/Sectors',[
    'skylark-backbone',
    './Sector'
], function (Backbone, Sector) {
    'use strict';
    return Backbone.Collection.extend({ model: Sector });
});
define('skylark-grapejs/style_manager/view/SectorView',[
    'skylark-backbone',
    'skylark-underscore',
    './PropertiesView'
], function (Backbone, _, PropertiesView) {
    'use strict';
    return Backbone.View.extend({
        template: _.template(`
  <div class="<%= pfx %>title" data-sector-title>
    <i id="<%= pfx %>caret" class="fa"></i>
    <%= label %>
  </div>`),
        events: { 'click [data-sector-title]': 'toggle' },
        initialize(o) {
            this.config = o.config || {};
            this.em = this.config.em;
            this.pfx = this.config.stylePrefix || '';
            this.target = o.target || {};
            this.propTarget = o.propTarget || {};
            this.caretR = 'fa-caret-right';
            this.caretD = 'fa-caret-down';
            const model = this.model;
            this.listenTo(model, 'change:open', this.updateOpen);
            this.listenTo(model, 'updateVisibility', this.updateVisibility);
            this.listenTo(model, 'destroy remove', this.remove);
        },
        updateVisibility() {
            var show;
            this.model.get('properties').each(prop => {
                if (prop.get('visible')) {
                    show = 1;
                }
            });
            this.el.style.display = show ? 'block' : 'none';
        },
        updateOpen() {
            if (this.model.get('open'))
                this.show();
            else
                this.hide();
        },
        show() {
            this.$el.addClass(this.pfx + 'open');
            this.getPropertiesEl().style.display = '';
            this.$caret.removeClass(this.caretR).addClass(this.caretD);
        },
        hide() {
            this.$el.removeClass(this.pfx + 'open');
            this.getPropertiesEl().style.display = 'none';
            this.$caret.removeClass(this.caretD).addClass(this.caretR);
        },
        getPropertiesEl() {
            return this.$el.find(`.${ this.pfx }properties`).get(0);
        },
        toggle(e) {
            var v = this.model.get('open') ? 0 : 1;
            this.model.set('open', v);
        },
        render() {
            const {pfx, model, em, $el} = this;
            const {id, name} = model.attributes;
            const label = em && em.t(`styleManager.sectors.${ id }`) || name;
            $el.html(this.undefined({
                pfx,
                label
            }));
            this.$caret = $el.find(`#${ pfx }caret`);
            this.renderProperties();
            $el.attr('class', `${ pfx }sector ${ pfx }sector__${ id } no-select`);
            this.updateOpen();
            return this;
        },
        renderProperties() {
            var objs = this.model.get('properties');
            if (objs) {
                var view = new PropertiesView({
                    collection: objs,
                    target: this.target,
                    propTarget: this.propTarget,
                    config: this.config
                });
                this.$el.append(view.render().el);
            }
        }
    });
});
define('skylark-grapejs/style_manager/view/SectorsView',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins',
    '../../utils/dom',
    './SectorView'
], function (Backbone, a, b, c, SectorView) {
    'use strict';
    const helperCls = 'hc-state';
    return Backbone.View.undefined({
        initialize(o = {}) {
            const config = o.config || {};
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.target = o.target || {};
            this.config = config;
            const target = {};
            a.extend(target, Backbone.Events);
            const body = document.body;
            const dummy = document.createElement(`el-${ new Date().getTime() }`);
            body.appendChild(dummy);
            target.computedDefault = { ...window.getComputedStyle(dummy) };
            body.removeChild(dummy);
            this.propTarget = target;
            const coll = this.collection;
            const events = 'component:toggled component:update:classes change:state change:device frame:resized';
            this.listenTo(coll, 'add', this.addTo);
            this.listenTo(coll, 'reset', this.render);
            this.listenTo(this.target, events, this.targetUpdated);
        },
        addTo(model, coll, opts = {}) {
            this.addToCollection(model, null, opts);
        },
        toggleStateCls(targets = [], enable) {
            targets.forEach(trg => {
                const el = trg.getEl();
                el && el.classList[enable ? 'add' : 'remove'](helperCls);
            });
        },
        targetUpdated(trg) {
            const em = this.target;
            const pt = this.propTarget;
            const targets = em.getSelectedAll();
            let model = em.getSelected();
            const mdToClear = trg && !!trg.toHTML ? trg : model;
            mdToClear && this.toggleStateCls([mdToClear]);
            if (!model)
                return;
            const config = em.get('Config');
            const state = !config.devicePreviewMode ? em.get('state') : '';
            const {componentFirst} = em.get('SelectorManager').getConfig();
            const el = model.getEl();
            pt.helper = null;
            pt.targets = null;
            if (el && b.isTaggableNode(el)) {
                const stateStr = state ? `:${ state }` : null;
                pt.computed = window.getComputedStyle(el, stateStr);
            }
            const appendStateRule = (style = {}) => {
                const cc = em.get('CssComposer');
                const rules = cc.getAll();
                let helperRule = cc.getClassRule(helperCls);
                if (!helperRule) {
                    helperRule = cc.setClassRule(helperCls);
                } else {
                    rules.remove(helperRule);
                    rules.add(helperRule);
                }
                helperRule.set('important', 1);
                helperRule.setStyle(style);
                pt.helper = helperRule;
            };
            model = em.get('StyleManager').getModelToStyle(model);
            if (state) {
                appendStateRule(model.getStyle());
                this.toggleStateCls(targets, 1);
            }
            pt.model = model;
            if (componentFirst)
                pt.targets = targets;
            pt.trigger('update');
        },
        setTarget(target, opts = {}) {
            const em = this.target;
            const trgs = a.isArray(target) ? target : [target];
            const {targetIsClass, stylable} = opts;
            const models = [];
            trgs.forEach(target => {
                let model = target;
                if (a.isString(target)) {
                    let rule;
                    const rules = em.get('CssComposer').getAll();
                    if (targetIsClass) {
                        rule = rules.filter(rule => rule.get('selectors').getFullString() === target)[0];
                    }
                    if (!rule) {
                        rule = rules.filter(rule => rule.get('selectorsAdd') === target)[0];
                    }
                    if (!rule) {
                        rule = rules.add({
                            selectors: [],
                            selectorsAdd: target
                        });
                    }
                    stylable && rule.set({ stylable });
                    model = rule;
                }
                models.push(model);
            });
            const pt = this.propTarget;
            pt.targets = models;
            pt.trigger('update');
            return models;
        },
        addToCollection(model, fragmentEl, opts = {}) {
            const {pfx, target, propTarget, config, el} = this;
            const appendTo = fragmentEl || el;
            const rendered = new SectorView({
                model,
                id: `${ pfx }${ model.get('id') }`,
                name: model.get('name'),
                properties: model.get('properties'),
                target,
                propTarget,
                config
            }).render().el;
            c.appendAtIndex(appendTo, rendered, opts.at);
            return rendered;
        },
        render() {
            const frag = document.createDocumentFragment();
            const $el = this.$el;
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            $el.empty();
            this.collection.each(model => this.addToCollection(model, frag));
            $el.append(frag);
            $el.addClass(`${ pfx }sectors ${ ppfx }one-bg ${ ppfx }two-color`);
            return this;
        }
    });
});
define('skylark-grapejs/style_manager/index',[
    "skylark-langx/langx",
    'skylark-underscore',
    './config/config',
    './model/Sectors',
    './model/Properties',
    './view/SectorsView'
], function (langx,_, defaults, Sectors, Properties, SectorsView) {
    'use strict';
    return () => {
        var c = {};
        let properties;
        var sectors, SectView;
        return {
            name: 'StyleManager',
            getConfig() {
                return c;
            },
            init(config) {
                c = langx.mxinin({},defaults,conf);
                const ppfx = c.pStylePrefix;
                this.em = c.em;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                properties = new Properties();
                sectors = new Sectors([], c);
                SectView = new SectorsView({
                    collection: sectors,
                    target: c.em,
                    config: c
                });
                return this;
            },
            onLoad() {
                sectors.add(c.sectors);
            },
            postRender() {
                const elTo = this.getConfig().appendTo;
                if (elTo) {
                    const el = _.isElement(elTo) ? elTo : document.querySelector(elTo);
                    el.appendChild(this.render());
                }
            },
            addSector(id, sector, opts = {}) {
                let result = this.getSector(id);
                if (!result) {
                    sector.id = id;
                    result = sectors.add(sector, opts);
                }
                return result;
            },
            getSector(id, opts = {}) {
                const res = sectors.where({ id })[0];
                !res && opts.warn && this._logNoSector(id);
                return res;
            },
            removeSector(id) {
                return this.getSectors().remove(this.getSector(id, { warn: 1 }));
            },
            getSectors() {
                return sectors;
            },
            addProperty(sectorId, property, opts = {}) {
                const sector = this.getSector(sectorId, { warn: 1 });
                let prop = null;
                if (sector)
                    prop = sector.get('properties').add(property, opts);
                return prop;
            },
            getProperty(sectorId, name) {
                const sector = this.getSector(sectorId, { warn: 1 });
                let prop = null;
                if (sector) {
                    prop = sector.get('properties').where({ property: name });
                    prop = prop.length == 1 ? prop[0] : prop;
                }
                return prop;
            },
            removeProperty(sectorId, name) {
                const props = this.getProperties(sectorId);
                return props && props.remove(this.getProperty(sectorId, name));
            },
            getProperties(sectorId) {
                let props = null;
                const sector = this.getSector(sectorId, { warn: 1 });
                if (sector)
                    props = sector.get('properties');
                return props;
            },
            getModelToStyle(model, options = {}) {
                const em = c.em;
                const {skipAdd} = options;
                const classes = model.get('classes');
                const id = model.getId();
                if (em) {
                    const config = em.getConfig();
                    const um = em.get('UndoManager');
                    const cssC = em.get('CssComposer');
                    const sm = em.get('SelectorManager');
                    const smConf = sm ? sm.getConfig() : {};
                    const state = !config.devicePreviewMode ? em.get('state') : '';
                    const valid = classes.getStyleable();
                    const hasClasses = valid.length;
                    const useClasses = !smConf.componentFirst || options.useClasses;
                    const opts = { state };
                    let rule;
                    um.stop();
                    if (hasClasses && useClasses) {
                        const deviceW = em.getCurrentMedia();
                        rule = cssC.get(valid, state, deviceW);
                        if (!rule && !skipAdd) {
                            rule = cssC.add(valid, state, deviceW);
                        }
                    } else if (config.avoidInlineStyle) {
                        rule = cssC.getIdRule(id, opts);
                        !rule && !skipAdd && (rule = cssC.setIdRule(id, {}, opts));
                        if (model.is('wrapper'))
                            rule.set('wrapper', 1);
                    }
                    rule && (model = rule);
                    um.start();
                }
                return model;
            },
            addType(id, definition) {
                properties.addType(id, definition);
            },
            getType(id) {
                return properties.getType(id);
            },
            getTypes() {
                return properties.getTypes();
            },
            createType(id, {model = {}, view = {}} = {}) {
                const type = this.getType(id);
                if (type) {
                    return new type.view(
                        langx.mixin({
                            model: new type.model(model),
                            config: c,
                        },view)
                    );
                }
            },
            setTarget(target, opts) {
                return SectView.setTarget(target, opts);
            },
            getEmitter() {
                return SectView.propTarget;
            },
            render() {
                return SectView.render().el;
            },
            _logNoSector(sectorId) {
                const {em} = this;
                em && em.logWarning(`'${ sectorId }' sector not found`);
            }
        };
    };
});
define('skylark-grapejs/modal_dialog/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'mdl-',
        title: '',
        content: '',
        backdrop: true
    };
});
define('skylark-grapejs/modal_dialog/model/Modal',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            title: '',
            content: '',
            open: false
        }
    });
});
define('skylark-grapejs/modal_dialog/view/ModalView',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.View.extend({
        template({pfx, ppfx, content, title}) {
            return `<div class="${ pfx }dialog ${ ppfx }one-bg ${ ppfx }two-color">
      <div class="${ pfx }header">
        <div class="${ pfx }title">${ title }</div>
        <div class="${ pfx }btn-close" data-close-modal>&Cross;</div>
      </div>
      <div class="${ pfx }content">
        <div id="${ pfx }c">${ content }</div>
        <div style="clear:both"></div>
      </div>
    </div>
    <div class="${ pfx }collector" style="display: none"></div>`;
        },
        events: {
            click: 'onClick',
            'click [data-close-modal]': 'hide'
        },
        initialize(o) {
            const model = this.model;
            const config = o.config || {};
            const pfx = config.stylePrefix || '';
            this.config = config;
            this.pfx = pfx;
            this.ppfx = config.pStylePrefix || '';
            this.listenTo(model, 'change:open', this.updateOpen);
            this.listenTo(model, 'change:title', this.updateTitle);
            this.listenTo(model, 'change:content', this.updateContent);
        },
        onClick(e) {
            const bkd = this.config.backdrop;
            bkd && e.target === this.el && this.hide();
        },
        getCollector() {
            if (!this.$collector)
                this.$collector = this.$el.find('.' + this.pfx + 'collector');
            return this.$collector;
        },
        getContent() {
            const pfx = this.pfx;
            if (!this.$content) {
                this.$content = this.$el.find(`.${ pfx }content #${ pfx }c`);
            }
            return this.$content;
        },
        getTitle() {
            if (!this.$title)
                this.$title = this.$el.find('.' + this.pfx + 'title');
            return this.$title.get(0);
        },
        updateContent() {
            var content = this.getContent();
            const children = content.children();
            const coll = this.getCollector();
            const body = this.model.get('content');
            children.length && coll.append(children);
            content.empty().append(body);
        },
        updateTitle() {
            var title = this.getTitle();
            if (title)
                title.innerHTML = this.model.get('title');
        },
        updateOpen() {
            this.el.style.display = this.model.get('open') ? '' : 'none';
        },
        hide() {
            this.model.set('open', 0);
        },
        show() {
            this.model.set('open', 1);
        },
        render() {
            const el = this.$el;
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            const obj = this.model.toJSON();
            obj.pfx = this.pfx;
            obj.ppfx = this.ppfx;
            el.html(this.template(obj));
            el.attr('class', `${ pfx }container`);
            this.updateOpen();
            return this;
        }
    });
});
define('skylark-grapejs/modal_dialog/index',[
    './config/config',
    './model/Modal',
    './view/ModalView'
], function (defaults, ModalM, ModalView) {
    'use strict';
    return () => {
        var c = {};
        var model, modal;
        const triggerEvent = (enable, em) => {
            em && em.trigger(`modal:${ enable ? 'open' : 'close' }`);
        };
        return {
            name: 'Modal',
            getConfig() {
                return c;
            },
            init(config = {}) {
                c = {
                    ...defaults,
                    ...config
                };
                const em = c.em;
                this.em = em;
                var ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                model = new ModalM(c);
                model.on('change:open', (m, enb) => triggerEvent(enb, em));
                modal = new ModalView({
                    model,
                    config: c
                });
                return this;
            },
            postRender(view) {
                const el = view.model.getConfig().el || view.el;
                this.render().appendTo(el);
            },
            open(opts = {}) {
                opts.title && this.setTitle(opts.title);
                opts.content && this.setContent(opts.content);
                modal.show();
                return this;
            },
            close() {
                modal.hide();
                return this;
            },
            onceClose(clb) {
                this.em.once('modal:close', clb);
                return this;
            },
            onceOpen(clb) {
                this.em.once('modal:open', clb);
                return this;
            },
            isOpen() {
                return !!model.get('open');
            },
            setTitle(title) {
                model.set('title', title);
                return this;
            },
            getTitle() {
                return model.get('title');
            },
            setContent(content) {
                model.set('content', ' ');
                model.set('content', content);
                return this;
            },
            getContent() {
                return model.get('content');
            },
            getContentEl() {
                return modal.getContent().get(0);
            },
            getModel() {
                return model;
            },
            render() {
                return modal.render().$el;
            }
        };
    };
});
define('skylark-grapejs/code_manager/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'cm-',
        inlineCss: false
    };
});
define('skylark-grapejs/code_manager/model/HtmlGenerator',[
    'skylark-backbone'
], function (Backbone) {
    'use strict';
    return Backbone.Model.extend({
        build(model, opts = {}) {
            const models = model.get('components');
            if (opts.exportWrapper) {
                return model.toHTML({ ...opts.wrapperIsBody && { tag: 'body' } });
            }
            return this.buildModels(models);
        },
        buildModels(models) {
            let code = '';
            models.each(model => {
                code += model.toHTML();
            });
            return code;
        }
    });
});
define('skylark-grapejs/code_manager/model/JsonGenerator',[
    'skylark-underscore',
    'skylark-backbone'
], function (a, Backbone) {
    'use strict';
    return Backbone.Model.extend({
        build(model) {
            var json = model.toJSON();
            this.beforeEach(json);
            a.each(json, function (v, attr) {
                var obj = json[attr];
                if (obj instanceof Backbone.Model) {
                    json[attr] = this.build(obj);
                } else if (obj instanceof Backbone.Collection) {
                    var coll = obj;
                    json[attr] = [];
                    if (coll.length) {
                        coll.undefined(function (el, index) {
                            json[attr][index] = this.build(el);
                        }, this);
                    }
                }
            }, this);
            return json;
        },
        beforeEach(obj) {
            delete obj.status;
        }
    });
});
define('skylark-grapejs/code_manager/model/JsGenerator',[
    'skylark-underscore',
    'skylark-backbone'
], function (a, Backbone) {
    'use strict';
    return Backbone.Model.undefined({
        mapModel(model) {
            var code = '';
            var script = model.get('script-export') || model.get('script');
            var type = model.get('type');
            var comps = model.get('components');
            var id = model.getId();
            if (script) {
                var attr = model.get('attributes');
                attr = a.extend({}, attr, { id });
                model.set('attributes', attr, { silent: 1 });
                var scrStr = model.getScriptString(script);
                if (model.get('scriptUpdated')) {
                    this.mapJs[type + '-' + id] = {
                        ids: [id],
                        code: scrStr
                    };
                } else {
                    var mapType = this.mapJs[type];
                    if (mapType) {
                        mapType.ids.push(id);
                    } else {
                        this.mapJs[type] = {
                            ids: [id],
                            code: scrStr
                        };
                    }
                }
            }
            comps.each(function (model) {
                code += this.mapModel(model);
            }, this);
            return code;
        },
        build(model) {
            this.mapJs = {};
            this.mapModel(model);
            var code = '';
            for (var type in this.mapJs) {
                var mapType = this.mapJs[type];
                var ids = '#' + mapType.ids.join(', #');
                code += `
        var items = document.querySelectorAll('${ ids }');
        for (var i = 0, len = items.length; i < len; i++) {
          (function(){${ mapType.code }}.bind(items[i]))();
        }`;
            }
            return code;
        }
    });
});
define('skylark-codemirror/cm',[
	"skylark-langx/skylark"
],function(skylark){

	return skylark.attach("intg.cm", {});
});
define('skylark-codemirror/primitives/util/browser',[],function () {
    'use strict';
    let userAgent = navigator.userAgent;
    let platform = navigator.platform;
    let gecko = /gecko\/\d/i.test(userAgent);
    let ie_upto10 = /MSIE \d/.test(userAgent);
    let ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
    let edge = /Edge\/(\d+)/.exec(userAgent);
    let ie = ie_upto10 || ie_11up || edge;
    let ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    let webkit = !edge && /WebKit\//.test(userAgent);
    let qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
    let chrome = !edge && /Chrome\//.test(userAgent);
    let presto = /Opera\//.test(userAgent);
    let safari = /Apple Computer/.test(navigator.vendor);
    let mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
    let phantom = /PhantomJS/.test(userAgent);
    let ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
    let android = /Android/.test(userAgent);
    let mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
    let mac = ios || /Mac/.test(platform);
    let chromeOS = /\bCrOS\b/.test(userAgent);
    let windows = /win/i.test(platform);
    let presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version)
        presto_version = Number(presto_version[1]);
    if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
    }
    let flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    let captureRightClick = gecko || ie && ie_version >= 9;
    return {
        gecko: gecko,
        ie: ie,
        ie_version: ie_version,
        webkit: webkit,
        chrome: chrome,
        presto: presto,
        safari: safari,
        mac_geMountainLion: mac_geMountainLion,
        phantom: phantom,
        ios: ios,
        android: android,
        mobile: mobile,
        mac: mac,
        chromeOS: chromeOS,
        windows: windows,
        flipCtrlCmd: flipCtrlCmd,
        captureRightClick: captureRightClick
    };
});
define('skylark-codemirror/primitives/util/dom',['./browser'], function (a) {
    'use strict';
    function classTest(cls) {
        return new RegExp('(^|\\s)' + cls + '(?:$|\\s)\\s*');
    }
    let rmClass = function (node, cls) {
        let current = node.className;
        let match = classTest(cls).exec(current);
        if (match) {
            let after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : '');
        }
    };
    function removeChildren(e) {
        for (let count = e.childNodes.length; count > 0; --count)
            e.removeChild(e.firstChild);
        return e;
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
        let e = document.createElement(tag);
        if (className)
            e.className = className;
        if (style)
            e.style.cssText = style;
        if (typeof content == 'string')
            e.appendChild(document.createTextNode(content));
        else if (content)
            for (let i = 0; i < content.length; ++i)
                e.appendChild(content[i]);
        return e;
    }
    function eltP(tag, content, className, style) {
        let e = elt(tag, content, className, style);
        e.setAttribute('role', 'presentation');
        return e;
    }
    let range;
    if (document.createRange)
        range = function (node, start, end, endNode) {
            let r = document.createRange();
            r.setEnd(endNode || node, end);
            r.setStart(node, start);
            return r;
        };
    else
        range = function (node, start, end) {
            let r = document.body.createTextRange();
            try {
                r.moveToElementText(node.parentNode);
            } catch (e) {
                return r;
            }
            r.collapse(true);
            r.moveEnd('character', end);
            r.moveStart('character', start);
            return r;
        };
    function contains(parent, child) {
        if (child.nodeType == 3)
            child = child.parentNode;
        if (parent.contains)
            return parent.contains(child);
        do {
            if (child.nodeType == 11)
                child = child.host;
            if (child == parent)
                return true;
        } while (child = child.parentNode);
    }
    function activeElt() {
        let activeElement;
        try {
            activeElement = document.activeElement;
        } catch (e) {
            activeElement = document.body || null;
        }
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
            activeElement = activeElement.shadowRoot.activeElement;
        return activeElement;
    }
    function addClass(node, cls) {
        let current = node.className;
        if (!classTest(cls).test(current))
            node.className += (current ? ' ' : '') + cls;
    }
    function joinClasses(a, b) {
        let as = a.split(' ');
        for (let i = 0; i < as.length; i++)
            if (as[i] && !classTest(as[i]).test(b))
                b += ' ' + as[i];
        return b;
    }
    let selectInput = function (node) {
        node.select();
    };
    if (a.ios)
        selectInput = function (node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
        };
    else if (a.ie)
        selectInput = function (node) {
            try {
                node.select();
            } catch (_e) {
            }
        };
    return {
        classTest: classTest,
        rmClass: rmClass,
        removeChildren: removeChildren,
        removeChildrenAndAdd: removeChildrenAndAdd,
        elt: elt,
        eltP: eltP,
        range: range,
        contains: contains,
        activeElt: activeElt,
        addClass: addClass,
        joinClasses: joinClasses,
        selectInput: selectInput
    };
});
define('skylark-codemirror/primitives/util/misc',[],function () {
    'use strict';
    function bind(f) {
        let args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return f.apply(null, args);
        };
    }
    function copyObj(obj, target, overwrite) {
        if (!target)
            target = {};
        for (let prop in obj)
            if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
                target[prop] = obj[prop];
        return target;
    }
    function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
            end = string.search(/[^\s\u00a0]/);
            if (end == -1)
                end = string.length;
        }
        for (let i = startIndex || 0, n = startValue || 0;;) {
            let nextTab = string.indexOf('\t', i);
            if (nextTab < 0 || nextTab >= end)
                return n + (end - i);
            n += nextTab - i;
            n += tabSize - n % tabSize;
            i = nextTab + 1;
        }
    }
    class Delayed {
        constructor() {
            this.id = null;
        }
        set(ms, f) {
            clearTimeout(this.id);
            this.id = setTimeout(f, ms);
        }
    }
    function indexOf(array, elt) {
        for (let i = 0; i < array.length; ++i)
            if (array[i] == elt)
                return i;
        return -1;
    }
    let scrollerGap = 30;
    let Pass = {
        toString: function () {
            return 'CodeMirror.Pass';
        }
    };
    let sel_dontScroll = { scroll: false }, sel_mouse = { origin: '*mouse' }, sel_move = { origin: '+move' };
    function findColumn(string, goal, tabSize) {
        for (let pos = 0, col = 0;;) {
            let nextTab = string.indexOf('\t', pos);
            if (nextTab == -1)
                nextTab = string.length;
            let skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal)
                return pos + Math.min(skipped, goal - col);
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal)
                return pos;
        }
    }
    let spaceStrs = [''];
    function spaceStr(n) {
        while (spaceStrs.length <= n)
            spaceStrs.push(lst(spaceStrs) + ' ');
        return spaceStrs[n];
    }
    function lst(arr) {
        return arr[arr.length - 1];
    }
    function map(array, f) {
        let out = [];
        for (let i = 0; i < array.length; i++)
            out[i] = f(array[i], i);
        return out;
    }
    function insertSorted(array, value, score) {
        let pos = 0, priority = score(value);
        while (pos < array.length && score(array[pos]) <= priority)
            pos++;
        array.splice(pos, 0, value);
    }
    function nothing() {
    }
    function createObj(base, props) {
        let inst;
        if (Object.create) {
            inst = Object.create(base);
        } else {
            nothing.prototype = base;
            inst = new nothing();
        }
        if (props)
            copyObj(props, inst);
        return inst;
    }
    let nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
        if (!helper)
            return isWordCharBasic(ch);
        if (helper.source.indexOf('\\w') > -1 && isWordCharBasic(ch))
            return true;
        return helper.test(ch);
    }
    function isEmpty(obj) {
        for (let n in obj)
            if (obj.hasOwnProperty(n) && obj[n])
                return false;
        return true;
    }
    let extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function skipExtendingChars(str, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos)))
            pos += dir;
        return pos;
    }
    function findFirst(pred, from, to) {
        let dir = from > to ? -1 : 1;
        for (;;) {
            if (from == to)
                return from;
            let midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from)
                return pred(mid) ? from : to;
            if (pred(mid))
                to = mid;
            else
                from = mid + dir;
        }
    }
    return {
        bind: bind,
        copyObj: copyObj,
        countColumn: countColumn,
        Delayed: Delayed,
        indexOf: indexOf,
        scrollerGap: scrollerGap,
        Pass: Pass,
        sel_dontScroll: sel_dontScroll,
        sel_mouse: sel_mouse,
        sel_move: sel_move,
        findColumn: findColumn,
        spaceStr: spaceStr,
        lst: lst,
        map: map,
        insertSorted: insertSorted,
        createObj: createObj,
        isWordCharBasic: isWordCharBasic,
        isWordChar: isWordChar,
        isEmpty: isEmpty,
        isExtendingChar: isExtendingChar,
        skipExtendingChars: skipExtendingChars,
        findFirst: findFirst
    };
});
define('skylark-codemirror/primitives/display/Display',[
    '../util/browser',
    '../util/dom',
    '../util/misc'
], function (browser, dom, misc) {
    'use strict';
    function Display(place, doc, input) {
        let d = this;
        this.input = input;
        d.scrollbarFiller = dom.elt('div', null, 'CodeMirror-scrollbar-filler');
        d.scrollbarFiller.setAttribute('cm-not-content', 'true');
        d.gutterFiller = dom.elt('div', null, 'CodeMirror-gutter-filler');
        d.gutterFiller.setAttribute('cm-not-content', 'true');
        d.lineDiv = dom.eltP('div', null, 'CodeMirror-code');
        d.selectionDiv = dom.elt('div', null, null, 'position: relative; z-index: 1');
        d.cursorDiv = dom.elt('div', null, 'CodeMirror-cursors');
        d.measure = dom.elt('div', null, 'CodeMirror-measure');
        d.lineMeasure = dom.elt('div', null, 'CodeMirror-measure');
        d.lineSpace = dom.eltP('div', [
            d.measure,
            d.lineMeasure,
            d.selectionDiv,
            d.cursorDiv,
            d.lineDiv
        ], null, 'position: relative; outline: none');
        let lines = dom.eltP('div', [d.lineSpace], 'CodeMirror-lines');
        d.mover = dom.elt('div', [lines], null, 'position: relative');
        d.sizer = dom.elt('div', [d.mover], 'CodeMirror-sizer');
        d.sizerWidth = null;
        d.heightForcer = dom.elt('div', null, null, 'position: absolute; height: ' + misc.scrollerGap + 'px; width: 1px;');
        d.gutters = dom.elt('div', null, 'CodeMirror-gutters');
        d.lineGutter = null;
        d.scroller = dom.elt('div', [
            d.sizer,
            d.heightForcer,
            d.gutters
        ], 'CodeMirror-scroll');
        d.scroller.setAttribute('tabIndex', '-1');
        d.wrapper = dom.elt('div', [
            d.scrollbarFiller,
            d.gutterFiller,
            d.scroller
        ], 'CodeMirror');
        if (browser.ie && browser.ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
        }
        if (!browser.webkit && !(browser.gecko && browser.mobile))
            d.scroller.draggable = true;
        if (place) {
            if (place.appendChild)
                place.appendChild(d.wrapper);
            else
                place(d.wrapper);
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        input.init(d);
    }
    return { Display: Display };
});
define('skylark-codemirror/primitives/line/utils_line',['../util/misc'], function (a) {
    'use strict';
    function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size)
            throw new Error('There is no line ' + (n + doc.first) + ' in the document.');
        let chunk = doc;
        while (!chunk.lines) {
            for (let i = 0;; ++i) {
                let child = chunk.children[i], sz = child.chunkSize();
                if (n < sz) {
                    chunk = child;
                    break;
                }
                n -= sz;
            }
        }
        return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
        let out = [], n = start.line;
        doc.iter(start.line, end.line + 1, line => {
            let text = line.text;
            if (n == end.line)
                text = text.slice(0, end.ch);
            if (n == start.line)
                text = text.slice(start.ch);
            out.push(text);
            ++n;
        });
        return out;
    }
    function getLines(doc, from, to) {
        let out = [];
        doc.iter(from, to, line => {
            out.push(line.text);
        });
        return out;
    }
    function updateLineHeight(line, height) {
        let diff = height - line.height;
        if (diff)
            for (let n = line; n; n = n.parent)
                n.height += diff;
    }
    function lineNo(line) {
        if (line.parent == null)
            return null;
        let cur = line.parent, no = a.indexOf(cur.lines, line);
        for (let chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (let i = 0;; ++i) {
                if (chunk.children[i] == cur)
                    break;
                no += chunk.children[i].chunkSize();
            }
        }
        return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
        let n = chunk.first;
        outer:
            do {
                for (let i = 0; i < chunk.children.length; ++i) {
                    let child = chunk.children[i], ch = child.height;
                    if (h < ch) {
                        chunk = child;
                        continue outer;
                    }
                    h -= ch;
                    n += child.chunkSize();
                }
                return n;
            } while (!chunk.lines);
        let i = 0;
        for (; i < chunk.lines.length; ++i) {
            let line = chunk.lines[i], lh = line.height;
            if (h < lh)
                break;
            h -= lh;
        }
        return n + i;
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }
    return {
        getLine: getLine,
        getBetween: getBetween,
        getLines: getLines,
        updateLineHeight: updateLineHeight,
        lineNo: lineNo,
        lineAtHeight: lineAtHeight,
        isLine: isLine,
        lineNumberFor: lineNumberFor
    };
});
define('skylark-codemirror/primitives/line/pos',['./utils_line'], function (utils_line) {
    'use strict';
    function Pos(line, ch, sticky = null) {
        if (!(this instanceof Pos))
            return new Pos(line, ch, sticky);
        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
    }
    function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
    }
    function equalCursorPos(a, b) {
        return a.sticky == b.sticky && cmp(a, b) == 0;
    }
    function copyPos(x) {
        return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first)
            return Pos(doc.first, 0);
        let last = doc.first + doc.size - 1;
        if (pos.line > last)
            return Pos(last, utils_line.getLine(doc, last).text.length);
        return clipToLen(pos, utils_line.getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
        let ch = pos.ch;
        if (ch == null || ch > linelen)
            return Pos(pos.line, linelen);
        else if (ch < 0)
            return Pos(pos.line, 0);
        else
            return pos;
    }
    function clipPosArray(doc, array) {
        let out = [];
        for (let i = 0; i < array.length; i++)
            out[i] = clipPos(doc, array[i]);
        return out;
    }
    return {
        Pos: Pos,
        cmp: cmp,
        equalCursorPos: equalCursorPos,
        copyPos: copyPos,
        maxPos: maxPos,
        minPos: minPos,
        clipLine: clipLine,
        clipPos: clipPos,
        clipPosArray: clipPosArray
    };
});
define('skylark-codemirror/primitives/line/saw_special_spans',[],function () {
    'use strict';
    let sawReadOnlySpans = false, sawCollapsedSpans = false;
    function seeReadOnlySpans() {
        sawReadOnlySpans = true;
    }
    function seeCollapsedSpans() {
        sawCollapsedSpans = true;
    }
    return {
        sawReadOnlySpans: sawReadOnlySpans,
        sawCollapsedSpans: sawCollapsedSpans,
        seeReadOnlySpans: seeReadOnlySpans,
        seeCollapsedSpans: seeCollapsedSpans
    };
});
define('skylark-codemirror/primitives/line/spans',[
    '../util/misc',
    './pos',
    './saw_special_spans',
    './utils_line'
], function (misc, pos, saw_special_spans, utils_line) {
    'use strict';
    function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans)
            for (let i = 0; i < spans.length; ++i) {
                let span = spans[i];
                if (span.marker == marker)
                    return span;
            }
    }
    function removeMarkedSpan(spans, span) {
        let r;
        for (let i = 0; i < spans.length; ++i)
            if (spans[i] != span)
                (r || (r = [])).push(spans[i]);
        return r;
    }
    function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
        let nw;
        if (old)
            for (let i = 0; i < old.length; ++i) {
                let span = old[i], marker = span.marker;
                let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {
                    let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                }
            }
        return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
        let nw;
        if (old)
            for (let i = 0; i < old.length; ++i) {
                let span = old[i], marker = span.marker;
                let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {
                    let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
                }
            }
        return nw;
    }
    function stretchSpansOverChange(doc, change) {
        if (change.full)
            return null;
        let oldFirst = utils_line.isLine(doc, change.from.line) && utils_line.getLine(doc, change.from.line).markedSpans;
        let oldLast = utils_line.isLine(doc, change.to.line) && utils_line.getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
            return null;
        let startCh = change.from.ch, endCh = change.to.ch, isInsert = pos.cmp(change.from, change.to) == 0;
        let first = markedSpansBefore(oldFirst, startCh, isInsert);
        let last = markedSpansAfter(oldLast, endCh, isInsert);
        let sameLine = change.text.length == 1, offset = misc.lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
            for (let i = 0; i < first.length; ++i) {
                let span = first[i];
                if (span.to == null) {
                    let found = getMarkedSpanFor(last, span.marker);
                    if (!found)
                        span.to = startCh;
                    else if (sameLine)
                        span.to = found.to == null ? null : found.to + offset;
                }
            }
        }
        if (last) {
            for (let i = 0; i < last.length; ++i) {
                let span = last[i];
                if (span.to != null)
                    span.to += offset;
                if (span.from == null) {
                    let found = getMarkedSpanFor(first, span.marker);
                    if (!found) {
                        span.from = offset;
                        if (sameLine)
                            (first || (first = [])).push(span);
                    }
                } else {
                    span.from += offset;
                    if (sameLine)
                        (first || (first = [])).push(span);
                }
            }
        }
        if (first)
            first = clearEmptySpans(first);
        if (last && last != first)
            last = clearEmptySpans(last);
        let newMarkers = [first];
        if (!sameLine) {
            let gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first)
                for (let i = 0; i < first.length; ++i)
                    if (first[i].to == null)
                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
            for (let i = 0; i < gap; ++i)
                newMarkers.push(gapMarkers);
            newMarkers.push(last);
        }
        return newMarkers;
    }
    function clearEmptySpans(spans) {
        for (let i = 0; i < spans.length; ++i) {
            let span = spans[i];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
                spans.splice(i--, 1);
        }
        if (!spans.length)
            return null;
        return spans;
    }
    function removeReadOnlyRanges(doc, from, to) {
        let markers = null;
        doc.iter(from.line, to.line + 1, line => {
            if (line.markedSpans)
                for (let i = 0; i < line.markedSpans.length; ++i) {
                    let mark = line.markedSpans[i].marker;
                    if (mark.readOnly && (!markers || misc.indexOf(markers, mark) == -1))
                        (markers || (markers = [])).push(mark);
                }
        });
        if (!markers)
            return null;
        let parts = [{
                from: from,
                to: to
            }];
        for (let i = 0; i < markers.length; ++i) {
            let mk = markers[i], m = mk.find(0);
            for (let j = 0; j < parts.length; ++j) {
                let p = parts[j];
                if (pos.cmp(p.to, m.from) < 0 || pos.cmp(p.from, m.to) > 0)
                    continue;
                let newParts = [
                        j,
                        1
                    ], dfrom = pos.cmp(p.from, m.from), dto = pos.cmp(p.to, m.to);
                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
                    newParts.push({
                        from: p.from,
                        to: m.from
                    });
                if (dto > 0 || !mk.inclusiveRight && !dto)
                    newParts.push({
                        from: m.to,
                        to: p.to
                    });
                parts.splice.apply(parts, newParts);
                j += newParts.length - 3;
            }
        }
        return parts;
    }
    function detachMarkedSpans(line) {
        let spans = line.markedSpans;
        if (!spans)
            return;
        for (let i = 0; i < spans.length; ++i)
            spans[i].marker.detachLine(line);
        line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
        if (!spans)
            return;
        for (let i = 0; i < spans.length; ++i)
            spans[i].marker.attachLine(line);
        line.markedSpans = spans;
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
        let lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0)
            return lenDiff;
        let aPos = a.find(), bPos = b.find();
        let fromCmp = pos.cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
            return -fromCmp;
        let toCmp = pos.cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp)
            return toCmp;
        return b.id - a.id;
    }
    function collapsedSpanAtSide(line, start) {
        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans, found;
        if (sps)
            for (let sp, i = 0; i < sps.length; ++i) {
                sp = sps[i];
                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
                    found = sp.marker;
            }
        return found;
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
    }
    function collapsedSpanAround(line, ch) {
        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans, found;
        if (sps)
            for (let i = 0; i < sps.length; ++i) {
                let sp = sps[i];
                if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
                    found = sp.marker;
            }
        return found;
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        let line = utils_line.getLine(doc, utils_line.lineNo);
        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (let i = 0; i < sps.length; ++i) {
                let sp = sps[i];
                if (!sp.marker.collapsed)
                    continue;
                let found = sp.marker.find(0);
                let fromCmp = pos.cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
                let toCmp = pos.cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
                    continue;
                if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? pos.cmp(found.to, from) >= 0 : pos.cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? pos.cmp(found.from, to) <= 0 : pos.cmp(found.from, to) < 0))
                    return true;
            }
    }
    function visualLine(line) {
        let merged;
        while (merged = collapsedSpanAtStart(line))
            line = merged.find(-1, true).line;
        return line;
    }
    function visualLineEnd(line) {
        let merged;
        while (merged = collapsedSpanAtEnd(line))
            line = merged.find(1, true).line;
        return line;
    }
    function visualLineContinued(line) {
        let merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
        }
        return lines;
    }
    function visualLineNo(doc, lineN) {
        let line = utils_line.getLine(doc, lineN), vis = visualLine(line);
        if (line == vis)
            return lineN;
        return utils_line.lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
            return lineN;
        let line = utils_line.getLine(doc, lineN), merged;
        if (!lineIsHidden(doc, line))
            return lineN;
        while (merged = collapsedSpanAtEnd(line))
            line = merged.find(1, true).line;
        return utils_line.lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (let sp, i = 0; i < sps.length; ++i) {
                sp = sps[i];
                if (!sp.marker.collapsed)
                    continue;
                if (sp.from == null)
                    return true;
                if (sp.marker.widgetNode)
                    continue;
                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                    return true;
            }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
            let end = span.marker.find(1, true);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
            return true;
        for (let sp, i = 0; i < line.markedSpans.length; ++i) {
            sp = line.markedSpans[i];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                return true;
        }
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        let h = 0, chunk = lineObj.parent;
        for (let i = 0; i < chunk.lines.length; ++i) {
            let line = chunk.lines[i];
            if (line == lineObj)
                break;
            else
                h += line.height;
        }
        for (let p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (let i = 0; i < p.children.length; ++i) {
                let cur = p.children[i];
                if (cur == chunk)
                    break;
                else
                    h += cur.height;
            }
        }
        return h;
    }
    function lineLength(line) {
        if (line.height == 0)
            return 0;
        let len = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
            let found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
            let found = merged.find(0, true);
            len -= cur.text.length - found.from.ch;
            cur = found.to.line;
            len += cur.text.length - found.to.ch;
        }
        return len;
    }
    function findMaxLine(cm) {
        let d = cm.display, doc = cm.doc;
        d.maxLine = utils_line.getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(line => {
            let len = lineLength(line);
            if (len > d.maxLineLength) {
                d.maxLineLength = len;
                d.maxLine = line;
            }
        });
    }
    return {
        MarkedSpan: MarkedSpan,
        getMarkedSpanFor: getMarkedSpanFor,
        removeMarkedSpan: removeMarkedSpan,
        addMarkedSpan: addMarkedSpan,
        stretchSpansOverChange: stretchSpansOverChange,
        removeReadOnlyRanges: removeReadOnlyRanges,
        detachMarkedSpans: detachMarkedSpans,
        attachMarkedSpans: attachMarkedSpans,
        compareCollapsedMarkers: compareCollapsedMarkers,
        collapsedSpanAtStart: collapsedSpanAtStart,
        collapsedSpanAtEnd: collapsedSpanAtEnd,
        collapsedSpanAround: collapsedSpanAround,
        conflictingCollapsedRange: conflictingCollapsedRange,
        visualLine: visualLine,
        visualLineEnd: visualLineEnd,
        visualLineContinued: visualLineContinued,
        visualLineNo: visualLineNo,
        visualLineEndNo: visualLineEndNo,
        lineIsHidden: lineIsHidden,
        heightAtLine: heightAtLine,
        lineLength: lineLength,
        findMaxLine: findMaxLine
    };
});
define('skylark-codemirror/primitives/util/bidi',['./misc'], function (a) {
    'use strict';
    function iterateBidiSections(order, from, to, f) {
        if (!order)
            return f(from, to, 'ltr', 0);
        let found = false;
        for (let i = 0; i < order.length; ++i) {
            let part = order[i];
            if (part.from < to && part.to > from || from == to && part.to == from) {
                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr', i);
                found = true;
            }
        }
        if (!found)
            f(from, to, 'ltr');
    }
    let bidiOther = null;
    function getBidiPartAt(order, ch, sticky) {
        let found;
        bidiOther = null;
        for (let i = 0; i < order.length; ++i) {
            let cur = order[i];
            if (cur.from < ch && cur.to > ch)
                return i;
            if (cur.to == ch) {
                if (cur.from != cur.to && sticky == 'before')
                    found = i;
                else
                    bidiOther = i;
            }
            if (cur.from == ch) {
                if (cur.from != cur.to && sticky != 'before')
                    found = i;
                else
                    bidiOther = i;
            }
        }
        return found != null ? found : bidiOther;
    }
    let bidiOrdering = function () {
        let lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN';
        let arabicTypes = 'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111';
        function charType(code) {
            if (code <= 247)
                return lowTypes.charAt(code);
            else if (1424 <= code && code <= 1524)
                return 'R';
            else if (1536 <= code && code <= 1785)
                return arabicTypes.charAt(code - 1536);
            else if (1774 <= code && code <= 2220)
                return 'r';
            else if (8192 <= code && code <= 8203)
                return 'w';
            else if (code == 8204)
                return 'b';
            else
                return 'L';
        }
        let bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        let isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
        }
        return function (str, direction) {
            let outerType = direction == 'ltr' ? 'L' : 'R';
            if (str.length == 0 || direction == 'ltr' && !bidiRE.test(str))
                return false;
            let len = str.length, types = [];
            for (let i = 0; i < len; ++i)
                types.push(charType(str.charCodeAt(i)));
            for (let i = 0, prev = outerType; i < len; ++i) {
                let type = types[i];
                if (type == 'm')
                    types[i] = prev;
                else
                    prev = type;
            }
            for (let i = 0, cur = outerType; i < len; ++i) {
                let type = types[i];
                if (type == '1' && cur == 'r')
                    types[i] = 'n';
                else if (isStrong.test(type)) {
                    cur = type;
                    if (type == 'r')
                        types[i] = 'R';
                }
            }
            for (let i = 1, prev = types[0]; i < len - 1; ++i) {
                let type = types[i];
                if (type == '+' && prev == '1' && types[i + 1] == '1')
                    types[i] = '1';
                else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
                    types[i] = prev;
                prev = type;
            }
            for (let i = 0; i < len; ++i) {
                let type = types[i];
                if (type == ',')
                    types[i] = 'N';
                else if (type == '%') {
                    let end;
                    for (end = i + 1; end < len && types[end] == '%'; ++end) {
                    }
                    let replace = i && types[i - 1] == '!' || end < len && types[end] == '1' ? '1' : 'N';
                    for (let j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1;
                }
            }
            for (let i = 0, cur = outerType; i < len; ++i) {
                let type = types[i];
                if (cur == 'L' && type == '1')
                    types[i] = 'L';
                else if (isStrong.test(type))
                    cur = type;
            }
            for (let i = 0; i < len; ++i) {
                if (isNeutral.test(types[i])) {
                    let end;
                    for (end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
                    }
                    let before = (i ? types[i - 1] : outerType) == 'L';
                    let after = (end < len ? types[end] : outerType) == 'L';
                    let replace = before == after ? before ? 'L' : 'R' : outerType;
                    for (let j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1;
                }
            }
            let order = [], m;
            for (let i = 0; i < len;) {
                if (countsAsLeft.test(types[i])) {
                    let start = i;
                    for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
                    }
                    order.push(new BidiSpan(0, start, i));
                } else {
                    let pos = i, at = order.length;
                    for (++i; i < len && types[i] != 'L'; ++i) {
                    }
                    for (let j = pos; j < i;) {
                        if (countsAsNum.test(types[j])) {
                            if (pos < j)
                                order.splice(at, 0, new BidiSpan(1, pos, j));
                            let nstart = j;
                            for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                            }
                            order.splice(at, 0, new BidiSpan(2, nstart, j));
                            pos = j;
                        } else
                            ++j;
                    }
                    if (pos < i)
                        order.splice(at, 0, new BidiSpan(1, pos, i));
                }
            }
            if (direction == 'ltr') {
                if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                    order[0].from = m[0].length;
                    order.unshift(new BidiSpan(0, 0, m[0].length));
                }
                if (a.lst(order).level == 1 && (m = str.match(/\s+$/))) {
                    a.lst(order).to -= m[0].length;
                    order.push(new BidiSpan(0, len - m[0].length, len));
                }
            }
            return direction == 'rtl' ? order.reverse() : order;
        };
    }();
    function getOrder(line, direction) {
        let order = line.order;
        if (order == null)
            order = line.order = bidiOrdering(line.text, direction);
        return order;
    }
    return {
        iterateBidiSections: iterateBidiSections,
        bidiOther: bidiOther,
        getBidiPartAt: getBidiPartAt,
        getOrder: getOrder
    };
});
define('skylark-codemirror/primitives/util/event',[
    './browser',
    './misc'
], function (a, b) {
    'use strict';
    const noHandlers = [];
    let on = function (emitter, type, f) {
        if (emitter.addEventListener) {
            emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
            emitter.attachEvent('on' + type, f);
        } else {
            let map = emitter._handlers || (emitter._handlers = {});
            map[type] = (map[type] || noHandlers).concat(f);
        }
    };
    function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
    }
    function off(emitter, type, f) {
        if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
            emitter.detachEvent('on' + type, f);
        } else {
            let map = emitter._handlers, arr = map && map[type];
            if (arr) {
                let index = b.indexOf(arr, f);
                if (index > -1)
                    map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
            }
        }
    }
    function signal(emitter, type) {
        let handlers = getHandlers(emitter, type);
        if (!handlers.length)
            return;
        let args = Array.prototype.slice.call(arguments, 2);
        for (let i = 0; i < handlers.length; ++i)
            handlers[i].apply(null, args);
    }
    function signalDOMEvent(cm, e, override) {
        if (typeof e == 'string')
            e = {
                type: e,
                preventDefault: function () {
                    this.defaultPrevented = true;
                }
            };
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
        let arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr)
            return;
        let set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (let i = 0; i < arr.length; ++i)
            if (b.indexOf(set, arr[i]) == -1)
                set.push(arr[i]);
    }
    function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
            on(this, type, f);
        };
        ctor.prototype.off = function (type, f) {
            off(this, type, f);
        };
    }
    function e_preventDefault(e) {
        if (e.preventDefault)
            e.preventDefault();
        else
            e.returnValue = false;
    }
    function e_stopPropagation(e) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.cancelBubble = true;
    }
    function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
    }
    function e_target(e) {
        return e.target || e.srcElement;
    }
    function e_button(e) {
        let b = e.which;
        if (b == null) {
            if (e.button & 1)
                b = 1;
            else if (e.button & 2)
                b = 3;
            else if (e.button & 4)
                b = 2;
        }
        if (a.mac && e.ctrlKey && b == 1)
            b = 3;
        return b;
    }
    return {
        on: on,
        getHandlers: getHandlers,
        off: off,
        signal: signal,
        signalDOMEvent: signalDOMEvent,
        signalCursorActivity: signalCursorActivity,
        hasHandler: hasHandler,
        eventMixin: eventMixin,
        e_preventDefault: e_preventDefault,
        e_stopPropagation: e_stopPropagation,
        e_defaultPrevented: e_defaultPrevented,
        e_stop: e_stop,
        e_target: e_target,
        e_button: e_button
    };
});
define('skylark-codemirror/primitives/util/feature_detection',[
    './dom',
    './browser'
], function (a, b) {
    'use strict';
    let dragAndDrop = function () {
        if (b.ie && b.ie_version < 9)
            return false;
        let div = a.elt('div');
        return 'draggable' in div || 'dragDrop' in div;
    }();
    let zwspSupported;
    function zeroWidthElement(measure) {
        if (zwspSupported == null) {
            let test = a.elt('span', '\u200B');
            a.removeChildrenAndAdd(measure, a.elt('span', [
                test,
                document.createTextNode('x')
            ]));
            if (measure.firstChild.offsetHeight != 0)
                zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(b.ie && b.ie_version < 8);
        }
        let node = zwspSupported ? a.elt('span', '\u200B') : a.elt('span', '\xA0', null, 'display: inline-block; width: 1px; margin-right: -1px');
        node.setAttribute('cm-text', '');
        return node;
    }
    let badBidiRects;
    function hasBadBidiRects(measure) {
        if (badBidiRects != null)
            return badBidiRects;
        let txt = a.removeChildrenAndAdd(measure, document.createTextNode('AA'));
        let r0 = a.range(txt, 0, 1).getBoundingClientRect();
        let r1 = a.range(txt, 1, 2).getBoundingClientRect();
        a.removeChildren(measure);
        if (!r0 || r0.left == r0.right)
            return false;
        return badBidiRects = r1.right - r0.right < 3;
    }
    let splitLinesAuto = '\n\nb'.split(/\n/).length != 3 ? string => {
        let pos = 0, result = [], l = string.length;
        while (pos <= l) {
            let nl = string.indexOf('\n', pos);
            if (nl == -1)
                nl = string.length;
            let line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
            let rt = line.indexOf('\r');
            if (rt != -1) {
                result.push(line.slice(0, rt));
                pos += rt + 1;
            } else {
                result.push(line);
                pos = nl + 1;
            }
        }
        return result;
    } : string => string.split(/\r\n?|\n/);
    let hasSelection = window.getSelection ? te => {
        try {
            return te.selectionStart != te.selectionEnd;
        } catch (e) {
            return false;
        }
    } : te => {
        let range;
        try {
            range = te.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range || range.parentElement() != te)
            return false;
        return range.compareEndPoints('StartToEnd', range) != 0;
    };
    let hasCopyEvent = (() => {
        let e = a.elt('div');
        if ('oncopy' in e)
            return true;
        e.setAttribute('oncopy', 'return;');
        return typeof e.oncopy == 'function';
    })();
    let badZoomedRects = null;
    function hasBadZoomedRects(measure) {
        if (badZoomedRects != null)
            return badZoomedRects;
        let node = a.removeChildrenAndAdd(measure, a.elt('span', 'x'));
        let normal = node.getBoundingClientRect();
        let fromRange = a.range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    return {
        dragAndDrop: dragAndDrop,
        zeroWidthElement: zeroWidthElement,
        hasBadBidiRects: hasBadBidiRects,
        splitLinesAuto: splitLinesAuto,
        hasSelection: hasSelection,
        hasCopyEvent: hasCopyEvent,
        hasBadZoomedRects: hasBadZoomedRects
    };
});
define('skylark-codemirror/primitives/modes',['./util/misc'], function (misc) {
    'use strict';
    let modes = {}, mimeModes = {};
    function defineMode(name, mode) {
        if (arguments.length > 2)
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
        modes[name] = mode;
    }
    function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
        if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
        } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
            let found = mimeModes[spec.name];
            if (typeof found == 'string')
                found = { name: found };
            spec = misc.createObj(found, spec);
            spec.name = found.name;
        } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode('application/xml');
        } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode('application/json');
        }
        if (typeof spec == 'string')
            return { name: spec };
        else
            return spec || { name: 'null' };
    }
    function getMode(options, spec) {
        spec = resolveMode(spec);
        let mfactory = modes[spec.name];
        if (!mfactory)
            return getMode(options, 'text/plain');
        let modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            let exts = modeExtensions[spec.name];
            for (let prop in exts) {
                if (!exts.hasOwnProperty(prop))
                    continue;
                if (modeObj.hasOwnProperty(prop))
                    modeObj['_' + prop] = modeObj[prop];
                modeObj[prop] = exts[prop];
            }
        }
        modeObj.name = spec.name;
        if (spec.helperType)
            modeObj.helperType = spec.helperType;
        if (spec.modeProps)
            for (let prop in spec.modeProps)
                modeObj[prop] = spec.modeProps[prop];
        return modeObj;
    }
    let modeExtensions = {};
    function extendMode(mode, properties) {
        let exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        misc.copyObj(properties, exts);
    }
    function copyState(mode, state) {
        if (state === true)
            return state;
        if (mode.copyState)
            return mode.copyState(state);
        let nstate = {};
        for (let n in state) {
            let val = state[n];
            if (val instanceof Array)
                val = val.concat([]);
            nstate[n] = val;
        }
        return nstate;
    }
    function innerMode(mode, state) {
        let info;
        while (mode.innerMode) {
            info = mode.innerMode(state);
            if (!info || info.mode == mode)
                break;
            state = info.state;
            mode = info.mode;
        }
        return info || {
            mode: mode,
            state: state
        };
    }
    function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
    }
    return {
        modes: modes,
        mimeModes: mimeModes,
        defineMode: defineMode,
        defineMIME: defineMIME,
        resolveMode: resolveMode,
        getMode: getMode,
        modeExtensions: modeExtensions,
        extendMode: extendMode,
        copyState: copyState,
        innerMode: innerMode,
        startState: startState
    };
});
define('skylark-codemirror/primitives/util/StringStream',['./misc'], function (a) {
    'use strict';
    class StringStream {
        constructor(string, tabSize, lineOracle) {
            this.pos = this.start = 0;
            this.string = string;
            this.tabSize = tabSize || 8;
            this.lastColumnPos = this.lastColumnValue = 0;
            this.lineStart = 0;
            this.lineOracle = lineOracle;
        }
        eol() {
            return this.pos >= this.string.length;
        }
        sol() {
            return this.pos == this.lineStart;
        }
        peek() {
            return this.string.charAt(this.pos) || undefined;
        }
        next() {
            if (this.pos < this.string.length)
                return this.string.charAt(this.pos++);
        }
        eat(match) {
            let ch = this.string.charAt(this.pos);
            let ok;
            if (typeof match == 'string')
                ok = ch == match;
            else
                ok = ch && (match.test ? match.test(ch) : match(ch));
            if (ok) {
                ++this.pos;
                return ch;
            }
        }
        eatWhile(match) {
            let start = this.pos;
            while (this.eat(match)) {
            }
            return this.pos > start;
        }
        eatSpace() {
            let start = this.pos;
            while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
                ++this.pos;
            return this.pos > start;
        }
        skipToEnd() {
            this.pos = this.string.length;
        }
        skipTo(ch) {
            let found = this.string.indexOf(ch, this.pos);
            if (found > -1) {
                this.pos = found;
                return true;
            }
        }
        backUp(n) {
            this.pos -= n;
        }
        column() {
            if (this.lastColumnPos < this.start) {
                this.lastColumnValue = a.countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                this.lastColumnPos = this.start;
            }
            return this.lastColumnValue - (this.lineStart ? a.countColumn(this.string, this.lineStart, this.tabSize) : 0);
        }
        indentation() {
            return a.countColumn(this.string, null, this.tabSize) - (this.lineStart ? a.countColumn(this.string, this.lineStart, this.tabSize) : 0);
        }
        match(pattern, consume, caseInsensitive) {
            if (typeof pattern == 'string') {
                let cased = str => caseInsensitive ? str.toLowerCase() : str;
                let substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) {
                    if (consume !== false)
                        this.pos += pattern.length;
                    return true;
                }
            } else {
                let match = this.string.slice(this.pos).match(pattern);
                if (match && match.index > 0)
                    return null;
                if (match && consume !== false)
                    this.pos += match[0].length;
                return match;
            }
        }
        current() {
            return this.string.slice(this.start, this.pos);
        }
        hideFirstChars(n, inner) {
            this.lineStart += n;
            try {
                return inner();
            } finally {
                this.lineStart -= n;
            }
        }
        lookAhead(n) {
            let oracle = this.lineOracle;
            return oracle && oracle.lookAhead(n);
        }
        baseToken() {
            let oracle = this.lineOracle;
            return oracle && oracle.baseToken(this.pos);
        }
    }
    return StringStream;
});
define('skylark-codemirror/primitives/line/highlight',[
    '../util/misc',
    '../modes',
    '../util/StringStream',
    './utils_line',
    './pos'
], function (misc, modes, StringStream, utils_line, line_pos) {
    'use strict';
    class SavedContext {
        constructor(state, lookAhead) {
            this.state = state;
            this.lookAhead = lookAhead;
        }
    }
    class Context {
        constructor(doc, state, line, lookAhead) {
            this.state = state;
            this.doc = doc;
            this.line = line;
            this.maxLookAhead = lookAhead || 0;
            this.baseTokens = null;
            this.baseTokenPos = 1;
        }
        lookAhead(n) {
            let line = this.doc.getLine(this.line + n);
            if (line != null && n > this.maxLookAhead)
                this.maxLookAhead = n;
            return line;
        }
        baseToken(n) {
            if (!this.baseTokens)
                return null;
            while (this.baseTokens[this.baseTokenPos] <= n)
                this.baseTokenPos += 2;
            let type = this.baseTokens[this.baseTokenPos + 1];
            return {
                type: type && type.replace(/( |^)overlay .*/, ''),
                size: this.baseTokens[this.baseTokenPos] - n
            };
        }
        nextLine() {
            this.line++;
            if (this.maxLookAhead > 0)
                this.maxLookAhead--;
        }
        static fromSaved(doc, saved, line) {
            if (saved instanceof SavedContext)
                return new Context(doc, modes.copyState(doc.mode, saved.state), line, saved.lookAhead);
            else
                return new Context(doc, modes.copyState(doc.mode, saved), line);
        }
        save(copy) {
            let state = copy !== false ? modes.copyState(this.doc.mode, this.state) : this.state;
            return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
        }
    }
    function highlightLine(cm, line, context, forceToEnd) {
        let st = [cm.state.modeGen], lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, context, (end, style) => st.push(end, style), lineClasses, forceToEnd);
        let state = context.state;
        for (let o = 0; o < cm.state.overlays.length; ++o) {
            context.baseTokens = st;
            let overlay = cm.state.overlays[o], i = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, (end, style) => {
                let start = i;
                while (at < end) {
                    let i_end = st[i];
                    if (i_end > end)
                        st.splice(i, 1, end, st[i + 1], i_end);
                    i += 2;
                    at = Math.min(end, i_end);
                }
                if (!style)
                    return;
                if (overlay.opaque) {
                    st.splice(start, i - start, end, 'overlay ' + style);
                    i = start + 2;
                } else {
                    for (; start < i; start += 2) {
                        let cur = st[start + 1];
                        st[start + 1] = (cur ? cur + ' ' : '') + 'overlay ' + style;
                    }
                }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
        }
        return {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
    }
    function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            let context = getContextBefore(cm, utils_line.lineNo(line));
            let resetState = line.text.length > cm.options.maxHighlightLength && modes.copyState(cm.doc.mode, context.state);
            let result = highlightLine(cm, line, context);
            if (resetState)
                context.state = resetState;
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes)
                line.styleClasses = result.classes;
            else if (line.styleClasses)
                line.styleClasses = null;
            if (updateFrontier === cm.doc.highlightFrontier)
                cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
        }
        return line.styles;
    }
    function getContextBefore(cm, n, precise) {
        let doc = cm.doc, display = cm.display;
        if (!doc.mode.startState)
            return new Context(doc, true, n);
        let start = findStartLine(cm, n, precise);
        let saved = start > doc.first && utils_line.getLine(doc, start - 1).stateAfter;
        let context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, modes.startState(doc.mode), start);
        doc.iter(start, n, line => {
            processLine(cm, line.text, context);
            let pos = context.line;
            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
        });
        if (precise)
            doc.modeFrontier = context.line;
        return context;
    }
    function processLine(cm, text, context, startAt) {
        let mode = cm.doc.mode;
        let stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;
        if (text == '')
            callBlankLine(mode, context.state);
        while (!stream.eol()) {
            readToken(mode, stream, context.state);
            stream.start = stream.pos;
        }
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine)
            return mode.blankLine(state);
        if (!mode.innerMode)
            return;
        let inner = modes.innerMode(mode, state);
        if (inner.mode.blankLine)
            return inner.mode.blankLine(inner.state);
    }
    function readToken(mode, stream, state, inner) {
        for (let i = 0; i < 10; i++) {
            if (inner)
                inner[0] = modes.innerMode(mode, state).mode;
            let style = mode.token(stream, state);
            if (stream.pos > stream.start)
                return style;
        }
        throw new Error('Mode ' + mode.name + ' failed to advance stream.');
    }
    class Token {
        constructor(stream, type, state) {
            this.start = stream.start;
            this.end = stream.pos;
            this.string = stream.current();
            this.type = type || null;
            this.state = state;
        }
    }
    function takeToken(cm, pos, precise, asArray) {
        let doc = cm.doc, mode = doc.mode, style;
        pos = line_pos.clipPos(doc, pos);
        let line = utils_line.getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
        let stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
        if (asArray)
            tokens = [];
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken(mode, stream, context.state);
            if (asArray)
                tokens.push(new Token(stream, style, modes.copyState(doc.mode, context.state)));
        }
        return asArray ? tokens : new Token(stream, style, context.state);
    }
    function extractLineClasses(type, output) {
        if (type)
            for (;;) {
                let lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                let prop = lineClass[1] ? 'bgClass' : 'textClass';
                if (output[prop] == null)
                    output[prop] = lineClass[2];
                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(output[prop]))
                    output[prop] += ' ' + lineClass[2];
            }
        return type;
    }
    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        let flattenSpans = mode.flattenSpans;
        if (flattenSpans == null)
            flattenSpans = cm.options.flattenSpans;
        let curStart = 0, curStyle = null;
        let stream = new StringStream(text, cm.options.tabSize, context), style;
        let inner = cm.options.addModeClass && [null];
        if (text == '')
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
                flattenSpans = false;
                if (forceToEnd)
                    processLine(cm, text, context, stream.pos);
                stream.pos = text.length;
                style = null;
            } else {
                style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
            }
            if (inner) {
                let mName = inner[0].name;
                if (mName)
                    style = 'm-' + (style ? mName + ' ' + style : mName);
            }
            if (!flattenSpans || curStyle != style) {
                while (curStart < stream.start) {
                    curStart = Math.min(stream.start, curStart + 5000);
                    f(curStart, curStyle);
                }
                curStyle = style;
            }
            stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
            let pos = Math.min(stream.pos, curStart + 5000);
            f(pos, curStyle);
            curStart = pos;
        }
    }
    function findStartLine(cm, n, precise) {
        let minindent, minline, doc = cm.doc;
        let lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (let search = n; search > lim; --search) {
            if (search <= doc.first)
                return doc.first;
            let line = utils_line.getLine(doc, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
                return search;
            let indented = misc.countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
                minline = search - 1;
                minindent = indented;
            }
        }
        return minline;
    }
    function retreatFrontier(doc, n) {
        doc.modeFrontier = Math.min(doc.modeFrontier, n);
        if (doc.highlightFrontier < n - 10)
            return;
        let start = doc.first;
        for (let line = n - 1; line > start; line--) {
            let saved = utils_line.getLine(doc, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
                start = line + 1;
                break;
            }
        }
        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
    }
    return {
        highlightLine: highlightLine,
        getLineStyles: getLineStyles,
        getContextBefore: getContextBefore,
        processLine: processLine,
        takeToken: takeToken,
        retreatFrontier: retreatFrontier
    };
});
define('skylark-codemirror/primitives/line/line_data',[
    '../util/bidi',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/feature_detection',
    '../util/misc',
    './highlight',
    './spans',
    './utils_line'
], function (bidi, browser, dom, events, feature_detection, misc, highlight, spans, m_utils_line) {
    'use strict';
    class Line {
        constructor(text, markedSpans, estimateHeight) {
            this.text = text;
            spans.attachMarkedSpans(this, markedSpans);
            this.height = estimateHeight ? estimateHeight(this) : 1;
        }
        lineNo() {
            return m_utils_line.lineNo(this);
        }
    }
    events.eventMixin(Line);
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter)
            line.stateAfter = null;
        if (line.styles)
            line.styles = null;
        if (line.order != null)
            line.order = null;
        spans.detachMarkedSpans(line);
        spans.attachMarkedSpans(line, markedSpans);
        let estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height)
            m_utils_line.updateLineHeight(line, estHeight);
    }
    function cleanUpLine(line) {
        line.parent = null;
        spans.detachMarkedSpans(line);
    }
    let styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
            return null;
        let cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, 'cm-$&'));
    }
    function buildLineContent(cm, lineView) {
        let content = dom.eltP('span', null, null, browser.webkit ? 'padding-right: .1px' : null);
        let builder = {
            pre: dom.eltP('pre', [content], 'CodeMirror-line'),
            content: content,
            col: 0,
            pos: 0,
            cm: cm,
            trailingSpace: false,
            splitSpaces: cm.getOption('lineWrapping')
        };
        lineView.measure = {};
        for (let i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            let line = i ? lineView.rest[i - 1] : lineView.line, order;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (feature_detection.hasBadBidiRects(cm.display.measure) && (order = bidi.getOrder(line, cm.doc.direction)))
                builder.addToken = buildTokenBadBidi(builder.addToken, order);
            builder.map = [];
            let allowFrontierUpdate = lineView != cm.display.externalMeasured && m_utils_line.lineNo(line);
            insertLineContent(line, builder, highlight.getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
                if (line.styleClasses.bgClass)
                    builder.bgClass = dom.joinClasses(line.styleClasses.bgClass, builder.bgClass || '');
                if (line.styleClasses.textClass)
                    builder.textClass = dom.joinClasses(line.styleClasses.textClass, builder.textClass || '');
            }
            if (builder.map.length == 0)
                builder.map.push(0, 0, builder.content.appendChild(feature_detection.zeroWidthElement(cm.display.measure)));
            if (i == 0) {
                lineView.measure.map = builder.map;
                lineView.measure.cache = {};
            } else {
                ;
                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
                (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
        }
        if (browser.webkit) {
            let last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector('.cm-tab'))
                builder.content.className = 'cm-tab-wrap-hack';
        }
        events.signal(cm, 'renderLine', cm, lineView.line, builder.pre);
        if (builder.pre.className)
            builder.textClass = dom.joinClasses(builder.pre.className, builder.textClass || '');
        return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
        let token = dom.elt('span', '\u2022', 'cm-invalidchar');
        token.title = '\\u' + ch.charCodeAt(0).toString(16);
        token.setAttribute('aria-label', token.title);
        return token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text)
            return;
        let displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        let special = builder.cm.state.specialChars, mustWrap = false;
        let content;
        if (!special.test(text)) {
            builder.col += text.length;
            content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (browser.ie && browser.ie_version < 9)
                mustWrap = true;
            builder.pos += text.length;
        } else {
            content = document.createDocumentFragment();
            let pos = 0;
            while (true) {
                special.lastIndex = pos;
                let m = special.exec(text);
                let skipped = m ? m.index - pos : text.length - pos;
                if (skipped) {
                    let txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                    if (browser.ie && browser.ie_version < 9)
                        content.appendChild(dom.elt('span', [txt]));
                    else
                        content.appendChild(txt);
                    builder.map.push(builder.pos, builder.pos + skipped, txt);
                    builder.col += skipped;
                    builder.pos += skipped;
                }
                if (!m)
                    break;
                pos += skipped + 1;
                let txt;
                if (m[0] == '\t') {
                    let tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                    txt = content.appendChild(dom.elt('span', misc.spaceStr(tabWidth), 'cm-tab'));
                    txt.setAttribute('role', 'presentation');
                    txt.setAttribute('cm-text', '\t');
                    builder.col += tabWidth;
                } else if (m[0] == '\r' || m[0] == '\n') {
                    txt = content.appendChild(dom.elt('span', m[0] == '\r' ? '\u240D' : '\u2424', 'cm-invalidchar'));
                    txt.setAttribute('cm-text', m[0]);
                    builder.col += 1;
                } else {
                    txt = builder.cm.options.specialCharPlaceholder(m[0]);
                    txt.setAttribute('cm-text', m[0]);
                    if (browser.ie && browser.ie_version < 9)
                        content.appendChild(dom.elt('span', [txt]));
                    else
                        content.appendChild(txt);
                    builder.col += 1;
                }
                builder.map.push(builder.pos, builder.pos + 1, txt);
                builder.pos++;
            }
        }
        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css) {
            let fullStyle = style || '';
            if (startStyle)
                fullStyle += startStyle;
            if (endStyle)
                fullStyle += endStyle;
            let token = dom.elt('span', [content], fullStyle, css);
            if (attributes) {
                for (let attr in attributes)
                    if (attributes.hasOwnProperty(attr) && attr != 'style' && attr != 'class')
                        token.setAttribute(attr, attributes[attr]);
            }
            return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
    }
    function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text))
            return text;
        let spaceBefore = trailingBefore, result = '';
        for (let i = 0; i < text.length; i++) {
            let ch = text.charAt(i);
            if (ch == ' ' && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
                ch = '\xA0';
            result += ch;
            spaceBefore = ch == ' ';
        }
        return result;
    }
    function buildTokenBadBidi(inner, order) {
        return (builder, text, style, startStyle, endStyle, css, attributes) => {
            style = style ? style + ' cm-force-border' : 'cm-force-border';
            let start = builder.pos, end = start + text.length;
            for (;;) {
                let part;
                for (let i = 0; i < order.length; i++) {
                    part = order[i];
                    if (part.to > start && part.from <= start)
                        break;
                }
                if (part.to >= end)
                    return inner(builder, text, style, startStyle, endStyle, css, attributes);
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
                startStyle = null;
                text = text.slice(part.to - start);
                start = part.to;
            }
        };
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        let widget = !ignoreWidget && marker.widgetNode;
        if (widget)
            builder.map.push(builder.pos, builder.pos + size, widget);
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget)
                widget = builder.content.appendChild(document.createElement('span'));
            widget.setAttribute('cm-marker', marker.id);
        }
        if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
    }
    function insertLineContent(line, builder, styles) {
        let spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
            for (let i = 1; i < styles.length; i += 2)
                builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));
            return;
        }
        let len = allText.length, pos = 0, i = 1, text = '', style, css;
        let nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
        for (;;) {
            if (nextChange == pos) {
                spanStyle = spanEndStyle = spanStartStyle = css = '';
                attributes = null;
                collapsed = null;
                nextChange = Infinity;
                let foundBookmarks = [], endStyles;
                for (let j = 0; j < spans.length; ++j) {
                    let sp = spans[j], m = sp.marker;
                    if (m.type == 'bookmark' && sp.from == pos && m.widgetNode) {
                        foundBookmarks.push(m);
                    } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                        if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                            nextChange = sp.to;
                            spanEndStyle = '';
                        }
                        if (m.className)
                            spanStyle += ' ' + m.className;
                        if (m.css)
                            css = (css ? css + ';' : '') + m.css;
                        if (m.startStyle && sp.from == pos)
                            spanStartStyle += ' ' + m.startStyle;
                        if (m.endStyle && sp.to == nextChange)
                            (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                        if (m.title)
                            (attributes || (attributes = {})).title = m.title;
                        if (m.attributes) {
                            for (let attr in m.attributes)
                                (attributes || (attributes = {}))[attr] = m.attributes[attr];
                        }
                        if (m.collapsed && (!collapsed || spans.compareCollapsedMarkers(collapsed.marker, m) < 0))
                            collapsed = sp;
                    } else if (sp.from > pos && nextChange > sp.from) {
                        nextChange = sp.from;
                    }
                }
                if (endStyles)
                    for (let j = 0; j < endStyles.length; j += 2)
                        if (endStyles[j + 1] == nextChange)
                            spanEndStyle += ' ' + endStyles[j];
                if (!collapsed || collapsed.from == pos)
                    for (let j = 0; j < foundBookmarks.length; ++j)
                        buildCollapsedSpan(builder, 0, foundBookmarks[j]);
                if (collapsed && (collapsed.from || 0) == pos) {
                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                    if (collapsed.to == null)
                        return;
                    if (collapsed.to == pos)
                        collapsed = false;
                }
            }
            if (pos >= len)
                break;
            let upto = Math.min(len, nextChange);
            while (true) {
                if (text) {
                    let end = pos + text.length;
                    if (!collapsed) {
                        let tokenText = end > upto ? text.slice(0, upto - pos) : text;
                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', css, attributes);
                    }
                    if (end >= upto) {
                        text = text.slice(upto - pos);
                        pos = upto;
                        break;
                    }
                    pos = end;
                    spanStartStyle = '';
                }
                text = allText.slice(at, at = styles[i++]);
                style = interpretTokenStyle(styles[i++], builder.cm.options);
            }
        }
    }
    function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = spans.visualLineContinued(line);
        this.size = this.rest ? m_utils_line.lineNo(misc.lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = spans.lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
        let array = [], nextPos;
        for (let pos = from; pos < to; pos = nextPos) {
            let view = new LineView(cm.doc, m_utils_line.getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
        }
        return array;
    }
    return {
        Line: Line,
        updateLine: updateLine,
        cleanUpLine: cleanUpLine,
        buildLineContent: buildLineContent,
        defaultSpecialCharPlaceholder: defaultSpecialCharPlaceholder,
        LineView: LineView,
        buildViewArray: buildViewArray
    };
});
define('skylark-codemirror/primitives/util/operation_group',['./event'], function (a) {
    'use strict';
    let operationGroup = null;
    function pushOperation(op) {
        if (operationGroup) {
            operationGroup.ops.push(op);
        } else {
            op.ownsGroup = operationGroup = {
                ops: [op],
                delayedCallbacks: []
            };
        }
    }
    function fireCallbacksForOps(group) {
        let callbacks = group.delayedCallbacks, i = 0;
        do {
            for (; i < callbacks.length; i++)
                callbacks[i].call(null);
            for (let j = 0; j < group.ops.length; j++) {
                let op = group.ops[j];
                if (op.cursorActivityHandlers)
                    while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                        op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
        } while (i < callbacks.length);
    }
    function finishOperation(op, endCb) {
        let group = op.ownsGroup;
        if (!group)
            return;
        try {
            fireCallbacksForOps(group);
        } finally {
            operationGroup = null;
            endCb(group);
        }
    }
    let orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
        let arr = a.getHandlers(emitter, type);
        if (!arr.length)
            return;
        let args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
            list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
        } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
        }
        for (let i = 0; i < arr.length; ++i)
            list.push(() => arr[i].apply(null, args));
    }
    function fireOrphanDelayed() {
        let delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (let i = 0; i < delayed.length; ++i)
            delayed[i]();
    }
    return {
        pushOperation: pushOperation,
        finishOperation: finishOperation,
        signalLater: signalLater
    };
});
define('skylark-codemirror/primitives/display/update_line',[
    '../line/line_data',
    '../line/utils_line',
    '../util/browser',
    '../util/dom',
    '../util/operation_group'
], function (a, b, c, d, e) {
    'use strict';
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (let j = 0; j < lineView.changes.length; j++) {
            let type = lineView.changes[j];
            if (type == 'text')
                updateLineText(cm, lineView);
            else if (type == 'gutter')
                updateLineGutter(cm, lineView, lineN, dims);
            else if (type == 'class')
                updateLineClasses(cm, lineView);
            else if (type == 'widget')
                updateLineWidgets(cm, lineView, dims);
        }
        lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
            lineView.node = d.elt('div', null, null, 'position: relative');
            if (lineView.text.parentNode)
                lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            lineView.node.appendChild(lineView.text);
            if (c.ie && c.ie_version < 8)
                lineView.node.style.zIndex = 2;
        }
        return lineView.node;
    }
    function updateLineBackground(cm, lineView) {
        let cls = lineView.bgClass ? lineView.bgClass + ' ' + (lineView.line.bgClass || '') : lineView.line.bgClass;
        if (cls)
            cls += ' CodeMirror-linebackground';
        if (lineView.background) {
            if (cls)
                lineView.background.className = cls;
            else {
                lineView.background.parentNode.removeChild(lineView.background);
                lineView.background = null;
            }
        } else if (cls) {
            let wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(d.elt('div', null, cls), wrap.firstChild);
            cm.display.input.setUneditable(lineView.background);
        }
    }
    function getLineContent(cm, lineView) {
        let ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
        }
        return a.buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
        let cls = lineView.text.className;
        let built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node)
            lineView.node = built.pre;
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
        } else if (cls) {
            lineView.text.className = cls;
        }
    }
    function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);
        if (lineView.line.wrapClass)
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        else if (lineView.node != lineView.text)
            lineView.node.className = '';
        let textClass = lineView.textClass ? lineView.textClass + ' ' + (lineView.line.textClass || '') : lineView.line.textClass;
        lineView.text.className = textClass || '';
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
            let wrap = ensureLineWrapped(lineView);
            lineView.gutterBackground = d.elt('div', null, 'CodeMirror-gutter-background ' + lineView.line.gutterClass, `left: ${ cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth }px; width: ${ dims.gutterTotalWidth }px`);
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        let markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            let wrap = ensureLineWrapped(lineView);
            let gutterWrap = lineView.gutter = d.elt('div', null, 'CodeMirror-gutter-wrapper', `left: ${ cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth }px`);
            cm.display.input.setUneditable(gutterWrap);
            wrap.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass)
                gutterWrap.className += ' ' + lineView.line.gutterClass;
            if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
                lineView.lineNumber = gutterWrap.appendChild(d.elt('div', b.lineNumberFor(cm.options, lineN), 'CodeMirror-linenumber CodeMirror-gutter-elt', `left: ${ dims.gutterLeft['CodeMirror-linenumbers'] }px; width: ${ cm.display.lineNumInnerWidth }px`));
            if (markers)
                for (let k = 0; k < cm.options.gutters.length; ++k) {
                    let id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                    if (found)
                        gutterWrap.appendChild(d.elt('div', [found], 'CodeMirror-gutter-elt', `left: ${ dims.gutterLeft[id] }px; width: ${ dims.gutterWidth[id] }px`));
                }
        }
    }
    function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable)
            lineView.alignable = null;
        for (let node = lineView.node.firstChild, next; node; node = next) {
            next = node.nextSibling;
            if (node.className == 'CodeMirror-linewidget')
                lineView.node.removeChild(node);
        }
        insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        let built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass)
            lineView.bgClass = built.bgClass;
        if (built.textClass)
            lineView.textClass = built.textClass;
        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest)
            for (let i = 0; i < lineView.rest.length; i++)
                insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets)
            return;
        let wrap = ensureLineWrapped(lineView);
        for (let i = 0, ws = line.widgets; i < ws.length; ++i) {
            let widget = ws[i], node = d.elt('div', [widget.node], 'CodeMirror-linewidget');
            if (!widget.handleMouseEvents)
                node.setAttribute('cm-ignore-events', 'true');
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above)
                wrap.insertBefore(node, lineView.gutter || lineView.text);
            else
                wrap.appendChild(node);
            e.signalLater(widget, 'redraw');
        }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            ;
            (lineView.alignable || (lineView.alignable = [])).push(node);
            let width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + 'px';
            if (!widget.coverGutter) {
                width -= dims.gutterTotalWidth;
                node.style.paddingLeft = dims.gutterTotalWidth + 'px';
            }
            node.style.width = width + 'px';
        }
        if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = 'relative';
            if (!widget.noHScroll)
                node.style.marginLeft = -dims.gutterTotalWidth + 'px';
        }
    }
    return {
        updateLineForChanges: updateLineForChanges,
        buildLineElement: buildLineElement
    };
});
define('skylark-codemirror/primitives/measurement/widgets',[
    '../util/dom',
    '../util/event'
], function (dom, events) {
    'use strict';
    function widgetHeight(widget) {
        if (widget.height != null)
            return widget.height;
        let cm = widget.doc.cm;
        if (!cm)
            return 0;
        if (!dom.contains(document.body, widget.node)) {
            let parentStyle = 'position: relative;';
            if (widget.coverGutter)
                parentStyle += 'margin-left: -' + cm.display.gutters.offsetWidth + 'px;';
            if (widget.noHScroll)
                parentStyle += 'width: ' + cm.display.wrapper.clientWidth + 'px;';
            dom.removeChildrenAndAdd(cm.display.measure, dom.elt('div', [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e) {
        for (let n = events.e_target(e); n != display.wrapper; n = n.parentNode) {
            if (!n || n.nodeType == 1 && n.getAttribute('cm-ignore-events') == 'true' || n.parentNode == display.sizer && n != display.mover)
                return true;
        }
    }
    return {
        widgetHeight: widgetHeight,
        eventInWidget: eventInWidget
    };
});
define('skylark-codemirror/primitives/measurement/position_measurement',[
    '../line/line_data',
    '../line/pos',
    '../line/spans',
    '../line/utils_line',
    '../util/bidi',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/feature_detection',
    '../util/misc',
    '../display/update_line',
    './widgets'
], function (line_data, line_pos, spans, utils_line, bidi, browser, dom, events, feature_detection, misc, update_line, widgets) {
    'use strict';
    function paddingTop(display) {
        return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
        if (display.cachedPaddingH)
            return display.cachedPaddingH;
        let e = dom.removeChildrenAndAdd(display.measure, dom.elt('pre', 'x'));
        let style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        let data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right))
            display.cachedPaddingH = data;
        return data;
    }
    function scrollGap(cm) {
        return misc.scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect) {
        let wrapping = cm.options.lineWrapping;
        let curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            let heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                let rects = lineView.text.firstChild.getClientRects();
                for (let i = 0; i < rects.length - 1; i++) {
                    let cur = rects[i], next = rects[i + 1];
                    if (Math.abs(cur.bottom - next.bottom) > 2)
                        heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
            }
            heights.push(rect.bottom - rect.top);
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
            return {
                map: lineView.measure.map,
                cache: lineView.measure.cache
            };
        for (let i = 0; i < lineView.rest.length; i++)
            if (lineView.rest[i] == line)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
        for (let i = 0; i < lineView.rest.length; i++)
            if (utils_line.lineNo(lineView.rest[i]) > lineN)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i],
                    before: true
                };
    }
    function updateExternalMeasurement(cm, line) {
        line = spans.visualLine(line);
        let lineN = utils_line.lineNo(line);
        let view = cm.display.externalMeasured = new line_data.LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        let built = view.built = line_data.buildLineContent(cm, view);
        view.text = built.pre;
        dom.removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
            return cm.display.view[findViewIndex(cm, lineN)];
        let ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
            return ext;
    }
    function prepareMeasureForLine(cm, line) {
        let lineN = utils_line.lineNo(line);
        let view = findViewForLine(cm, lineN);
        if (view && !view.text) {
            view = null;
        } else if (view && view.changes) {
            update_line.updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
        }
        if (!view)
            view = updateExternalMeasurement(cm, line);
        let info = mapFromLineView(view, line, lineN);
        return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
        };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before)
            ch = -1;
        let key = ch + (bias || ''), found;
        if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
        } else {
            if (!prepared.rect)
                prepared.rect = prepared.view.text.getBoundingClientRect();
            if (!prepared.hasHeights) {
                ensureLineHeights(cm, prepared.view, prepared.rect);
                prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus)
                prepared.cache[key] = found;
        }
        return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        };
    }
    let nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    function nodeAndOffsetInLineMap(map, ch, bias) {
        let node, start, end, collapse, mStart, mEnd;
        for (let i = 0; i < map.length; i += 3) {
            mStart = map[i];
            mEnd = map[i + 1];
            if (ch < mStart) {
                start = 0;
                end = 1;
                collapse = 'left';
            } else if (ch < mEnd) {
                start = ch - mStart;
                end = start + 1;
            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
                end = mEnd - mStart;
                start = end - 1;
                if (ch >= mEnd)
                    collapse = 'right';
            }
            if (start != null) {
                node = map[i + 2];
                if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right'))
                    collapse = bias;
                if (bias == 'left' && start == 0)
                    while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                        node = map[(i -= 3) + 2];
                        collapse = 'left';
                    }
                if (bias == 'right' && start == mEnd - mStart)
                    while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                        node = map[(i += 3) + 2];
                        collapse = 'right';
                    }
                break;
            }
        }
        return {
            node: node,
            start: start,
            end: end,
            collapse: collapse,
            coverStart: mStart,
            coverEnd: mEnd
        };
    }
    function getUsefulRect(rects, bias) {
        let rect = nullRect;
        if (bias == 'left')
            for (let i = 0; i < rects.length; i++) {
                if ((rect = rects[i]).left != rect.right)
                    break;
            }
        else
            for (let i = rects.length - 1; i >= 0; i--) {
                if ((rect = rects[i]).left != rect.right)
                    break;
            }
        return rect;
    }
    function measureCharInner(cm, prepared, ch, bias) {
        let place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        let node = place.node, start = place.start, end = place.end, collapse = place.collapse;
        let rect;
        if (node.nodeType == 3) {
            for (let i = 0; i < 4; i++) {
                while (start && misc.isExtendingChar(prepared.line.text.charAt(place.coverStart + start)))
                    --start;
                while (place.coverStart + end < place.coverEnd && misc.isExtendingChar(prepared.line.text.charAt(place.coverStart + end)))
                    ++end;
                if (browser.ie && browser.ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
                    rect = node.parentNode.getBoundingClientRect();
                else
                    rect = getUsefulRect(dom.range(node, start, end).getClientRects(), bias);
                if (rect.left || rect.right || start == 0)
                    break;
                end = start;
                start = start - 1;
                collapse = 'right';
            }
            if (browser.ie && browser.ie_version < 11)
                rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        } else {
            if (start > 0)
                collapse = bias = 'right';
            let rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
                rect = rects[bias == 'right' ? rects.length - 1 : 0];
            else
                rect = node.getBoundingClientRect();
        }
        if (browser.ie && browser.ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            let rSpan = node.parentNode.getClientRects()[0];
            if (rSpan)
                rect = {
                    left: rSpan.left,
                    right: rSpan.left + charWidth(cm.display),
                    top: rSpan.top,
                    bottom: rSpan.bottom
                };
            else
                rect = nullRect;
        }
        let rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        let mid = (rtop + rbot) / 2;
        let heights = prepared.view.measure.heights;
        let i = 0;
        for (; i < heights.length - 1; i++)
            if (mid < heights[i])
                break;
        let top = i ? heights[i - 1] : 0, bot = heights[i];
        let result = {
            left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,
            top: top,
            bottom: bot
        };
        if (!rect.left && !rect.right)
            result.bogus = true;
        if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
        }
        return result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !feature_detection.hasBadZoomedRects(measure))
            return rect;
        let scaleX = screen.logicalXDPI / screen.deviceXDPI;
        let scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
        };
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest)
                for (let i = 0; i < lineView.rest.length; i++)
                    lineView.measure.caches[i] = {};
        }
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        dom.removeChildren(cm.display.lineMeasure);
        for (let i = 0; i < cm.display.view.length; i++)
            clearLineMeasurementCacheFor(cm.display.view[i]);
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping)
            cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
    }
    function pageScrollX() {
        if (browser.chrome && browser.android)
            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
        if (browser.chrome && browser.android)
            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
        let height = 0;
        if (lineObj.widgets)
            for (let i = 0; i < lineObj.widgets.length; ++i)
                if (lineObj.widgets[i].above)
                    height += widgets.widgetHeight(lineObj.widgets[i]);
        return height;
    }
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
            let height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
        }
        if (context == 'line')
            return rect;
        if (!context)
            context = 'local';
        let yOff = spans.heightAtLine(lineObj);
        if (context == 'local')
            yOff += paddingTop(cm.display);
        else
            yOff -= cm.display.viewOffset;
        if (context == 'page' || context == 'window') {
            let lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
            let xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
    }
    function fromCoordSystem(cm, coords, context) {
        if (context == 'div')
            return coords;
        let left = coords.left, top = coords.top;
        if (context == 'page') {
            left -= pageScrollX();
            top -= pageScrollY();
        } else if (context == 'local' || !context) {
            let localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top += localBox.top;
        }
        let lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
            left: left - lineSpaceBox.left,
            top: top - lineSpaceBox.top
        };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj)
            lineObj = utils_line.getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || utils_line.getLine(cm.doc, pos.line);
        if (!preparedMeasure)
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function get(ch, right) {
            let m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left', varHeight);
            if (right)
                m.left = m.right;
            else
                m.right = m.left;
            return intoCoordSystem(cm, lineObj, m, context);
        }
        let order = bidi.getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
        if (ch >= lineObj.text.length) {
            ch = lineObj.text.length;
            sticky = 'before';
        } else if (ch <= 0) {
            ch = 0;
            sticky = 'after';
        }
        if (!order)
            return get(sticky == 'before' ? ch - 1 : ch, sticky == 'before');
        function getBidi(ch, partPos, invert) {
            let part = order[partPos], right = part.level == 1;
            return get(invert ? ch - 1 : ch, right != invert);
        }
        let partPos = bidi.getBidiPartAt(order, ch, sticky);
        let other = bidi.bidiOther;
        let val = getBidi(ch, partPos, sticky == 'before');
        if (other != null)
            val.other = getBidi(ch, other, sticky != 'before');
        return val;
    }
    function estimateCoords(cm, pos) {
        let left = 0;
        pos = line_pos.clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping)
            left = charWidth(cm.display) * pos.ch;
        let lineObj = utils_line.getLine(cm.doc, pos.line);
        let top = spans.heightAtLine(lineObj) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
        };
    }
    function PosWithInfo(line, ch, sticky, outside, xRel) {
        let pos = line_pos.Pos(line, ch, sticky);
        pos.xRel = xRel;
        if (outside)
            pos.outside = true;
        return pos;
    }
    function coordsChar(cm, x, y) {
        let doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0)
            return PosWithInfo(doc.first, 0, null, true, -1);
        let lineN = utils_line.lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last)
            return PosWithInfo(doc.first + doc.size - 1, utils_line.getLine(doc, last).text.length, null, true, 1);
        if (x < 0)
            x = 0;
        let lineObj = utils_line.getLine(doc, lineN);
        for (;;) {
            let found = coordsCharInner(cm, lineObj, lineN, x, y);
            let collapsed = spans.collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));
            if (!collapsed)
                return found;
            let rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN)
                return rangeEnd;
            lineObj = utils_line.getLine(doc, lineN = rangeEnd.line);
        }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        let end = lineObj.text.length;
        let begin = misc.findFirst(ch => measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y, end, 0);
        end = misc.findFirst(ch => measureCharPrepared(cm, preparedMeasure, ch).top > y, begin, end);
        return {
            begin,
            end
        };
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure)
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
        let targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), 'line').top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter(box, x, y, left) {
        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        y -= spans.heightAtLine(lineObj);
        let preparedMeasure = prepareMeasureForLine(cm, lineObj);
        let widgetHeight = widgetTopHeight(lineObj);
        let begin = 0, end = lineObj.text.length, ltr = true;
        let order = bidi.getOrder(lineObj, cm.doc.direction);
        if (order) {
            let part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end = ltr ? part.to : part.from - 1;
        }
        let chAround = null, boxAround = null;
        let ch = misc.findFirst(ch => {
            let box = measureCharPrepared(cm, preparedMeasure, ch);
            box.top += widgetHeight;
            box.bottom += widgetHeight;
            if (!boxIsAfter(box, x, y, false))
                return false;
            if (box.top <= y && box.left <= x) {
                chAround = ch;
                boxAround = box;
            }
            return true;
        }, begin, end);
        let baseX, sticky, outside = false;
        if (boxAround) {
            let atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
            ch = chAround + (atStart ? 0 : 1);
            sticky = atStart ? 'after' : 'before';
            baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
            if (!ltr && (ch == end || ch == begin))
                ch++;
            sticky = ch == 0 ? 'after' : ch == lineObj.text.length ? 'before' : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgets.widgetHeight <= y == ltr ? 'after' : 'before';
            let coords = cursorCoords(cm, line_pos.Pos(lineNo, ch, sticky), 'line', lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y < coords.top || y >= coords.bottom;
        }
        ch = misc.skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
    }
    function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
        let index = misc.findFirst(i => {
            let part = order[i], ltr = part.level != 1;
            return boxIsAfter(cursorCoords(cm, line_pos.Pos(lineNo, ltr ? part.to : part.from, ltr ? 'before' : 'after'), 'line', lineObj, preparedMeasure), x, y, true);
        }, 0, order.length - 1);
        let part = order[index];
        if (index > 0) {
            let ltr = part.level != 1;
            let start = cursorCoords(cm, line_pos.Pos(lineNo, ltr ? part.from : part.to, ltr ? 'after' : 'before'), 'line', lineObj, preparedMeasure);
            if (boxIsAfter(start, x, y, true) && start.top > y)
                part = order[index - 1];
        }
        return part;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        let {begin, end} = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        if (/\s/.test(lineObj.text.charAt(end - 1)))
            end--;
        let part = null, closestDist = null;
        for (let i = 0; i < order.length; i++) {
            let p = order[i];
            if (p.from >= end || p.to <= begin)
                continue;
            let ltr = p.level != 1;
            let endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
            let dist = endX < x ? x - endX + 1000000000 : endX - x;
            if (!part || closestDist > dist) {
                part = p;
                closestDist = dist;
            }
        }
        if (!part)
            part = order[order.length - 1];
        if (part.from < begin)
            part = {
                from: begin,
                to: part.to,
                level: part.level
            };
        if (part.to > end)
            part = {
                from: part.from,
                to: end,
                level: part.level
            };
        return part;
    }
    let measureText;
    function textHeight(display) {
        if (display.cachedTextHeight != null)
            return display.cachedTextHeight;
        if (measureText == null) {
            measureText = dom.elt('pre');
            for (let i = 0; i < 49; ++i) {
                measureText.appendChild(document.createTextNode('x'));
                measureText.appendChild(dom.elt('br'));
            }
            measureText.appendChild(document.createTextNode('x'));
        }
        dom.removeChildrenAndAdd(display.measure, measureText);
        let height = measureText.offsetHeight / 50;
        if (height > 3)
            display.cachedTextHeight = height;
        dom.removeChildren(display.measure);
        return height || 1;
    }
    function charWidth(display) {
        if (display.cachedCharWidth != null)
            return display.cachedCharWidth;
        let anchor = dom.elt('span', 'xxxxxxxxxx');
        let pre = dom.elt('pre', [anchor]);
        dom.removeChildrenAndAdd(display.measure, pre);
        let rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2)
            display.cachedCharWidth = width;
        return width || 10;
    }
    function getDimensions(cm) {
        let utils_line = cm.display, left = {}, width = {};
        let gutterLeft = utils_line.gutters.clientLeft;
        for (let n = utils_line.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
            width[cm.options.gutters[i]] = n.clientWidth;
        }
        return {
            fixedPos: compensateForHScroll(utils_line),
            gutterTotalWidth: utils_line.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: utils_line.wrapper.clientWidth
        };
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
        let th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        let perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return line => {
            if (spans.lineIsHidden(cm.doc, line))
                return 0;
            let widgetsHeight = 0;
            if (line.widgets)
                for (let i = 0; i < line.widgets.length; i++) {
                    if (line.widgets[i].height)
                        widgetsHeight += line.widgets[i].height;
                }
            if (wrapping)
                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            else
                return widgetsHeight + th;
        };
    }
    function estimateLineHeights(cm) {
        let doc = cm.doc, est = estimateHeight(cm);
        doc.iter(line => {
            let estHeight = est(line);
            if (estHeight != line.height)
                utils_line.updateLineHeight(line, estHeight);
        });
    }
    function posFromMouse(cm, e, liberal, forRect) {
        let display = cm.display;
        if (!liberal && events.e_target(e).getAttribute('cm-not-content') == 'true')
            return null;
        let x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left;
            y = e.clientY - space.top;
        } catch (e) {
            return null;
        }
        let coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel == 1 && (line = utils_line.getLine(cm.doc, coords.line).text).length == coords.ch) {
            let colDiff = misc.countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = line_pos.Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
            return null;
        n -= cm.display.viewFrom;
        if (n < 0)
            return null;
        let view = cm.display.view;
        for (let i = 0; i < view.length; i++) {
            n -= view[i].size;
            if (n < 0)
                return i;
        }
    }
    return {
        paddingTop: paddingTop,
        paddingVert: paddingVert,
        paddingH: paddingH,
        scrollGap: scrollGap,
        displayWidth: displayWidth,
        displayHeight: displayHeight,
        mapFromLineView: mapFromLineView,
        measureChar: measureChar,
        findViewForLine: findViewForLine,
        prepareMeasureForLine: prepareMeasureForLine,
        measureCharPrepared: measureCharPrepared,
        nodeAndOffsetInLineMap: nodeAndOffsetInLineMap,
        clearLineMeasurementCacheFor: clearLineMeasurementCacheFor,
        clearLineMeasurementCache: clearLineMeasurementCache,
        clearCaches: clearCaches,
        intoCoordSystem: intoCoordSystem,
        fromCoordSystem: fromCoordSystem,
        charCoords: charCoords,
        cursorCoords: cursorCoords,
        estimateCoords: estimateCoords,
        coordsChar: coordsChar,
        wrappedLineExtentChar: wrappedLineExtentChar,
        textHeight: textHeight,
        charWidth: charWidth,
        getDimensions: getDimensions,
        compensateForHScroll: compensateForHScroll,
        estimateHeight: estimateHeight,
        estimateLineHeights: estimateLineHeights,
        posFromMouse: posFromMouse,
        findViewIndex: findViewIndex
    };
});
define('skylark-codemirror/primitives/display/selection',[
    '../line/pos',
    '../line/spans',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../util/bidi',
    '../util/dom'
], function (a, b, c, d, e, f) {
    'use strict';
    function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary = true) {
        let doc = cm.doc, result = {};
        let curFragment = result.cursors = document.createDocumentFragment();
        let selFragment = result.selection = document.createDocumentFragment();
        for (let i = 0; i < doc.sel.ranges.length; i++) {
            if (!primary && i == doc.sel.primIndex)
                continue;
            let range = doc.sel.ranges[i];
            if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom)
                continue;
            let collapsed = range.empty();
            if (collapsed || cm.options.showCursorWhenSelecting)
                drawSelectionCursor(cm, range.head, curFragment);
            if (!collapsed)
                drawSelectionRange(cm, range, selFragment);
        }
        return result;
    }
    function drawSelectionCursor(cm, head, output) {
        let pos = d.cursorCoords(cm, head, 'div', null, null, !cm.options.singleCursorHeightPerLine);
        let cursor = output.appendChild(f.elt('div', '\xA0', 'CodeMirror-cursor'));
        cursor.style.left = pos.left + 'px';
        cursor.style.top = pos.top + 'px';
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
        if (pos.other) {
            let otherCursor = output.appendChild(f.elt('div', '\xA0', 'CodeMirror-cursor CodeMirror-secondarycursor'));
            otherCursor.style.display = '';
            otherCursor.style.left = pos.other.left + 'px';
            otherCursor.style.top = pos.other.top + 'px';
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
        }
    }
    function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
    }
    function drawSelectionRange(cm, range, output) {
        let display = cm.display, doc = cm.doc;
        let fragment = document.createDocumentFragment();
        let padding = d.paddingH(cm.display), leftSide = padding.left;
        let rightSide = Math.max(display.sizerWidth, d.displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        let docLTR = doc.direction == 'ltr';
        function add(left, top, width, bottom) {
            if (top < 0)
                top = 0;
            top = Math.round(top);
            bottom = Math.round(bottom);
            fragment.appendChild(f.elt('div', null, 'CodeMirror-selected', `position: absolute; left: ${ left }px;
                             top: ${ top }px; width: ${ width == null ? rightSide - left : width }px;
                             height: ${ bottom - top }px`));
        }
        function drawForLine(line, fromArg, toArg) {
            let lineObj = c.getLine(doc, line);
            let lineLen = lineObj.text.length;
            let start, end;
            function coords(ch, bias) {
                return d.charCoords(cm, a.Pos(line, ch), 'div', lineObj, bias);
            }
            function wrapX(pos, dir, side) {
                let extent = d.wrappedLineExtentChar(cm, lineObj, null, pos);
                let prop = dir == 'ltr' == (side == 'after') ? 'left' : 'right';
                let ch = side == 'after' ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
                return coords(ch, prop)[prop];
            }
            let order = e.getOrder(lineObj, doc.direction);
            e.iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, (from, to, dir, i) => {
                let ltr = dir == 'ltr';
                let fromPos = coords(from, ltr ? 'left' : 'right');
                let toPos = coords(to - 1, ltr ? 'right' : 'left');
                let openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
                let first = i == 0, last = !order || i == order.length - 1;
                if (toPos.top - fromPos.top <= 3) {
                    let openLeft = (docLTR ? openStart : openEnd) && first;
                    let openRight = (docLTR ? openEnd : openStart) && last;
                    let left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                    let right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                    add(left, fromPos.top, right - left, fromPos.bottom);
                } else {
                    let topLeft, topRight, botLeft, botRight;
                    if (ltr) {
                        topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                        topRight = docLTR ? rightSide : wrapX(from, dir, 'before');
                        botLeft = docLTR ? leftSide : wrapX(to, dir, 'after');
                        botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                    } else {
                        topLeft = !docLTR ? leftSide : wrapX(from, dir, 'before');
                        topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                        botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                        botRight = !docLTR ? rightSide : wrapX(to, dir, 'after');
                    }
                    add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                    if (fromPos.bottom < toPos.top)
                        add(leftSide, fromPos.bottom, null, toPos.top);
                    add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
                }
                if (!start || cmpCoords(fromPos, start) < 0)
                    start = fromPos;
                if (cmpCoords(toPos, start) < 0)
                    start = toPos;
                if (!end || cmpCoords(fromPos, end) < 0)
                    end = fromPos;
                if (cmpCoords(toPos, end) < 0)
                    end = toPos;
            });
            return {
                start: start,
                end: end
            };
        }
        let sFrom = range.from(), sTo = range.to();
        if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
            let fromLine = c.getLine(doc, sFrom.line), toLine = c.getLine(doc, sTo.line);
            let singleVLine = b.visualLine(fromLine) == b.visualLine(toLine);
            let leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            let rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
                if (leftEnd.top < rightStart.top - 2) {
                    add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
                } else {
                    add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                }
            }
            if (leftEnd.bottom < rightStart.top)
                add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
        output.appendChild(fragment);
    }
    function restartBlink(cm) {
        if (!cm.state.focused)
            return;
        let display = cm.display;
        clearInterval(display.blinker);
        let on = true;
        display.cursorDiv.style.visibility = '';
        if (cm.options.cursorBlinkRate > 0)
            display.blinker = setInterval(() => display.cursorDiv.style.visibility = (on = !on) ? '' : 'hidden', cm.options.cursorBlinkRate);
        else if (cm.options.cursorBlinkRate < 0)
            display.cursorDiv.style.visibility = 'hidden';
    }
    return {
        updateSelection: updateSelection,
        prepareSelection: prepareSelection,
        drawSelectionCursor: drawSelectionCursor,
        restartBlink: restartBlink
    };
});
define('skylark-codemirror/primitives/display/focus',[
    './selection',
    '../util/browser',
    '../util/dom',
    '../util/event'
], function (selection, browser, dom, event) {
    'use strict';
    function ensureFocus(cm) {
        if (!cm.state.focused) {
            cm.display.input.focus();
            onFocus(cm);
        }
    }
    function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(() => {
            if (cm.state.delayingBlurEvent) {
                cm.state.delayingBlurEvent = false;
                onBlur(cm);
            }
        }, 100);
    }
    function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent)
            cm.state.delayingBlurEvent = false;
        if (cm.options.readOnly == 'nocursor')
            return;
        if (!cm.state.focused) {
            event.signal(cm, 'focus', cm, e);
            cm.state.focused = true;
            dom.addClass(cm.display.wrapper, 'CodeMirror-focused');
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
                cm.display.input.reset();
                if (browser.webkit)
                    setTimeout(() => cm.display.input.reset(true), 20);
            }
            cm.display.input.receivedFocus();
        }
        selection.restartBlink(cm);
    }
    function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent)
            return;
        if (cm.state.focused) {
            event.signal(cm, 'blur', cm, e);
            cm.state.focused = false;
            dom.rmClass(cm.display.wrapper, 'CodeMirror-focused');
        }
        clearInterval(cm.display.blinker);
        setTimeout(() => {
            if (!cm.state.focused)
                cm.display.shift = false;
        }, 150);
    }
    return {
        ensureFocus: ensureFocus,
        delayBlurEvent: delayBlurEvent,
        onFocus: onFocus,
        onBlur: onBlur
    };
});
define('skylark-codemirror/primitives/display/update_lines',[
    '../line/spans',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../util/browser'
], function (a, b, c, d) {
    'use strict';
    function updateHeightsInViewport(cm) {
        let display = cm.display;
        let prevBottom = display.lineDiv.offsetTop;
        for (let i = 0; i < display.view.length; i++) {
            let cur = display.view[i], wrapping = cm.options.lineWrapping;
            let height, width = 0;
            if (cur.hidden)
                continue;
            if (d.ie && d.ie_version < 8) {
                let bot = cur.node.offsetTop + cur.node.offsetHeight;
                height = bot - prevBottom;
                prevBottom = bot;
            } else {
                let box = cur.node.getBoundingClientRect();
                height = box.bottom - box.top;
                if (!wrapping && cur.text.firstChild)
                    width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
            }
            let diff = cur.line.height - height;
            if (diff > 0.005 || diff < -0.005) {
                b.updateLineHeight(cur.line, height);
                updateWidgetHeight(cur.line);
                if (cur.rest)
                    for (let j = 0; j < cur.rest.length; j++)
                        updateWidgetHeight(cur.rest[j]);
            }
            if (width > cm.display.sizerWidth) {
                let chWidth = Math.ceil(width / c.charWidth(cm.display));
                if (chWidth > cm.display.maxLineLength) {
                    cm.display.maxLineLength = chWidth;
                    cm.display.maxLine = cur.line;
                    cm.display.maxLineChanged = true;
                }
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets)
            for (let i = 0; i < line.widgets.length; ++i) {
                let w = line.widgets[i], parent = w.node.parentNode;
                if (parent)
                    w.height = parent.offsetHeight;
            }
    }
    function visibleLines(display, doc, viewport) {
        let top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - c.paddingTop(display));
        let bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        let from = b.lineAtHeight(doc, top), to = b.lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            let ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from) {
                from = ensureFrom;
                to = b.lineAtHeight(doc, a.heightAtLine(b.getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
                from = b.lineAtHeight(doc, a.heightAtLine(b.getLine(doc, ensureTo)) - display.wrapper.clientHeight);
                to = ensureTo;
            }
        }
        return {
            from: from,
            to: Math.max(to, from + 1)
        };
    }
    return {
        updateHeightsInViewport: updateHeightsInViewport,
        visibleLines: visibleLines
    };
});
define('skylark-codemirror/primitives/display/view_tracking',[
    '../line/line_data',
    '../line/saw_special_spans',
    '../line/spans',
    '../measurement/position_measurement',
    '../util/misc'
], function (a, b, c, d, e) {
    'use strict';
    function regChange(cm, from, to, lendiff) {
        if (from == null)
            from = cm.doc.first;
        if (to == null)
            to = cm.doc.first + cm.doc.size;
        if (!lendiff)
            lendiff = 0;
        let display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
            display.updateLineNumbers = from;
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
            if (b.sawCollapsedSpans && c.visualLineNo(cm.doc, from) < display.viewTo)
                resetView(cm);
        } else if (to <= display.viewFrom) {
            if (b.sawCollapsedSpans && c.visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
                resetView(cm);
            } else {
                display.viewFrom += lendiff;
                display.viewTo += lendiff;
            }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
        } else if (from <= display.viewFrom) {
            let cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
                display.view = display.view.slice(cut.index);
                display.viewFrom = cut.lineN;
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        } else if (to >= display.viewTo) {
            let cut = viewCuttingPoint(cm, from, from, -1);
            if (cut) {
                display.view = display.view.slice(0, cut.index);
                display.viewTo = cut.lineN;
            } else {
                resetView(cm);
            }
        } else {
            let cutTop = viewCuttingPoint(cm, from, from, -1);
            let cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
                display.view = display.view.slice(0, cutTop.index).concat(a.buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        }
        let ext = display.externalMeasured;
        if (ext) {
            if (to < ext.lineN)
                ext.lineN += lendiff;
            else if (from < ext.lineN + ext.size)
                display.externalMeasured = null;
        }
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        let display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
            display.externalMeasured = null;
        if (line < display.viewFrom || line >= display.viewTo)
            return;
        let lineView = display.view[d.findViewIndex(cm, line)];
        if (lineView.node == null)
            return;
        let arr = lineView.changes || (lineView.changes = []);
        if (e.indexOf(arr, type) == -1)
            arr.push(type);
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        let index = d.findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!b.sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
            return {
                index: index,
                lineN: newN
            };
        let n = cm.display.viewFrom;
        for (let i = 0; i < index; i++)
            n += view[i].size;
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1)
                    return null;
                diff = n + view[index].size - oldN;
                index++;
            } else {
                diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
        }
        while (c.visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1))
                return null;
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
        }
        return {
            index: index,
            lineN: newN
        };
    }
    function adjustView(cm, from, to) {
        let display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = a.buildViewArray(cm, from, to);
            display.viewFrom = from;
        } else {
            if (display.viewFrom > from)
                display.view = a.buildViewArray(cm, from, display.viewFrom).concat(display.view);
            else if (display.viewFrom < from)
                display.view = display.view.slice(d.findViewIndex(cm, from));
            display.viewFrom = from;
            if (display.viewTo < to)
                display.view = display.view.concat(a.buildViewArray(cm, display.viewTo, to));
            else if (display.viewTo > to)
                display.view = display.view.slice(0, d.findViewIndex(cm, to));
        }
        display.viewTo = to;
    }
    function countDirtyView(cm) {
        let view = cm.display.view, dirty = 0;
        for (let i = 0; i < view.length; i++) {
            let lineView = view[i];
            if (!lineView.hidden && (!lineView.node || lineView.changes))
                ++dirty;
        }
        return dirty;
    }
    return {
        regChange: regChange,
        regLineChange: regLineChange,
        resetView: resetView,
        adjustView: adjustView,
        countDirtyView: countDirtyView
    };
});
define('skylark-codemirror/primitives/display/update_display',[
    '../line/saw_special_spans',
    '../line/spans',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/misc',
    './update_line',
//    './highlight_worker', // dependence cycle 
//    './line_numbers',
//    './scrollbars',
    './selection',
    './update_lines',
    './view_tracking'
], function (
    a, 
    b, 
    c, 
    d, 
    e, 
    f, 
    g, 
    h, 
    m_update_line, 
//    j, 
//    k, 
//    l, 
    m, 
    n, 
    o
) {
    'use strict';
    class DisplayUpdate {
        constructor(cm, viewport, force) {
            let display = cm.display;
            this.viewport = viewport;
            this.visible = n.visibleLines(display, cm.doc, viewport);
            this.editorIsHidden = !display.wrapper.offsetWidth;
            this.wrapperHeight = display.wrapper.clientHeight;
            this.wrapperWidth = display.wrapper.clientWidth;
            this.oldDisplayWidth = d.displayWidth(cm);
            this.force = force;
            this.dims = d.getDimensions(cm);
            this.events = [];
        }
        signal(emitter, type) {
            if (g.hasHandler(emitter, type))
                this.events.push(arguments);
        }
        finish() {
            for (let i = 0; i < this.events.length; i++)
                g.signal.apply(null, this.events[i]);
        }
    }
    function maybeClipScrollbars(cm) {
        let display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = d.scrollGap(cm) + 'px';
            display.sizer.style.marginBottom = -display.nativeBarWidth + 'px';
            display.sizer.style.borderRightWidth = d.scrollGap(cm) + 'px';
            display.scrollbarsClipped = true;
        }
    }
    function selectionSnapshot(cm) {
        if (cm.hasFocus())
            return null;
        let active = f.activeElt();
        if (!active || !f.contains(cm.display.lineDiv, active))
            return null;
        let result = { activeElt: active };
        if (window.getSelection) {
            let sel = window.getSelection();
            if (sel.anchorNode && sel.extend && f.contains(cm.display.lineDiv, sel.anchorNode)) {
                result.anchorNode = sel.anchorNode;
                result.anchorOffset = sel.anchorOffset;
                result.focusNode = sel.focusNode;
                result.focusOffset = sel.focusOffset;
            }
        }
        return result;
    }
    function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == f.activeElt())
            return;
        snapshot.activeElt.focus();
        if (snapshot.anchorNode && f.contains(document.body, snapshot.anchorNode) && f.contains(document.body, snapshot.focusNode)) {
            let sel = window.getSelection(), range = document.createRange();
            range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
    }
    function updateDisplayIfNeeded(cm, update) {
        let display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) {
            o.resetView(cm);
            return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && o.countDirtyView(cm) == 0)
            return false;
        if (cm.maybeUpdateLineNumberWidth()) { //if (k.maybeUpdateLineNumberWidth(cm)) {
            o.resetView(cm);
            update.dims = d.getDimensions(cm);
        }
        let end = doc.first + doc.size;
        let from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        let to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20)
            from = Math.max(doc.first, display.viewFrom);
        if (display.viewTo > to && display.viewTo - to < 20)
            to = Math.min(end, display.viewTo);
        if (a.sawCollapsedSpans) {
            from = b.visualLineNo(cm.doc, from);
            to = b.visualLineEndNo(cm.doc, to);
        }
        let different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        o.adjustView(cm, from, to);
        display.viewOffset = b.heightAtLine(c.getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + 'px';
        let toUpdate = o.countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
            return false;
        let selSnapshot = selectionSnapshot(cm);
        if (toUpdate > 4)
            display.lineDiv.style.display = 'none';
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4)
            display.lineDiv.style.display = '';
        display.renderedView = display.view;
        restoreSelection(selSnapshot);
        f.removeChildren(display.cursorDiv);
        f.removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            cm.startWorker(400); // j.startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
    }
    function postUpdateDisplay(cm, update) {
        let viewport = update.viewport;
        for (let first = true;; first = false) {
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == d.displayWidth(cm)) {
                if (viewport && viewport.top != null)
                    viewport = { top: Math.min(cm.doc.height + d.paddingVert(cm.display) - d.displayHeight(cm), viewport.top) };
                update.visible = n.visibleLines(cm.display, cm.doc, viewport);
                if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
                    break;
            }
            if (!updateDisplayIfNeeded(cm, update))
                break;
            n.updateHeightsInViewport(cm);
            let barMeasure = cm.measureForScrollbars(); //l.measureForScrollbars(cm);
            m.updateSelection(cm);
            cm.updateScrollbars(barMeasure); //l.updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
        }
        update.signal(cm, 'update', cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, 'viewportChange', cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
        }
    }
    function updateDisplaySimple(cm, viewport) {
        let update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            n.updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            let barMeasure = cm.measureForScrollbars(); //l.measureForScrollbars(cm);
            m.updateSelection(cm);
            cm.updateScrollbars(barMeasure); // l.updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
        }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        let display = cm.display, lineNumbers = cm.options.lineNumbers;
        let container = display.lineDiv, cur = container.firstChild;
        function rm(node) {
            let next = node.nextSibling;
            if (e.webkit && e.mac && cm.display.currentWheelTarget == node)
                node.style.display = 'none';
            else
                node.parentNode.removeChild(node);
            return next;
        }
        let view = display.view, lineN = display.viewFrom;
        for (let i = 0; i < view.length; i++) {
            let lineView = view[i];
            if (lineView.hidden) {
            } else if (!lineView.node || lineView.node.parentNode != container) {
                let node = m_update_line.buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur);
            } else {
                while (cur != lineView.node)
                    cur = rm(cur);
                let updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
                if (lineView.changes) {
                    if (h.indexOf(lineView.changes, 'gutter') > -1)
                        updateNumber = false;
                    m_update_line.updateLineForChanges(cm, lineView, lineN, dims);
                }
                if (updateNumber) {
                    f.removeChildren(lineView.lineNumber);
                    lineView.lineNumber.appendChild(document.createTextNode(c.lineNumberFor(cm.options, lineN)));
                }
                cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
        }
        while (cur)
            cur = rm(cur);
    }
    function updateGutterSpace(cm) {
        let width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + 'px';
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + 'px';
        cm.display.heightForcer.style.top = measure.docHeight + 'px';
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + d.scrollGap(cm) + 'px';
    }
    return {
        DisplayUpdate: DisplayUpdate,
        maybeClipScrollbars: maybeClipScrollbars,
        updateDisplayIfNeeded: updateDisplayIfNeeded,
        postUpdateDisplay: postUpdateDisplay,
        updateDisplaySimple: updateDisplaySimple,
        updateGutterSpace: updateGutterSpace,
        setDocumentHeight: setDocumentHeight
    };
});
define('skylark-codemirror/primitives/display/gutters',[
    '../util/dom',
    '../util/misc',
    './update_display'
], function (dom, misc, update_display) {
    'use strict';
    function updateGutters(cm) {
        let gutters = cm.display.gutters, specs = cm.options.gutters;
        dom.removeChildren(gutters);
        let i = 0;
        for (; i < specs.length; ++i) {
            let gutterClass = specs[i];
            let gElt = gutters.appendChild(dom.elt('div', null, 'CodeMirror-gutter ' + gutterClass));
            if (gutterClass == 'CodeMirror-linenumbers') {
                cm.display.lineGutter = gElt;
                gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
            }
        }
        gutters.style.display = i ? '' : 'none';
        update_display.updateGutterSpace(cm);
    }
    function setGuttersForLineNumbers(options) {
        let found = misc.indexOf(options.gutters, 'CodeMirror-linenumbers');
        if (found == -1 && options.lineNumbers) {
            options.gutters = options.gutters.concat(['CodeMirror-linenumbers']);
        } else if (found > -1 && !options.lineNumbers) {
            options.gutters = options.gutters.slice(0);
            options.gutters.splice(found, 1);
        }
    }
    return {
        updateGutters: updateGutters,
        setGuttersForLineNumbers: setGuttersForLineNumbers
    };
});
define('skylark-codemirror/primitives/display/line_numbers',[
    '../line/utils_line',
    '../measurement/position_measurement',
    '../util/dom',
    './update_display'
], function (utils_line, position_measurement, dom, update_display) {
    'use strict';
    function alignHorizontally(cm) {
        let display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
            return;
        let comp = position_measurement.compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        let gutterW = display.gutters.offsetWidth, left = comp + 'px';
        for (let i = 0; i < view.length; i++)
            if (!view[i].hidden) {
                if (cm.options.fixedGutter) {
                    if (view[i].gutter)
                        view[i].gutter.style.left = left;
                    if (view[i].gutterBackground)
                        view[i].gutterBackground.style.left = left;
                }
                let align = view[i].alignable;
                if (align)
                    for (let j = 0; j < align.length; j++)
                        align[j].style.left = left;
            }
        if (cm.options.fixedGutter)
            display.gutters.style.left = comp + gutterW + 'px';
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
            return false;
        let doc = cm.doc, last = utils_line.lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
            let test = display.measure.appendChild(dom.elt('div', [dom.elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
            let innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = '';
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + 'px';
            update_display.updateGutterSpace(cm);
            return true;
        }
        return false;
    }
    return {
        alignHorizontally: alignHorizontally,
        maybeUpdateLineNumberWidth: maybeUpdateLineNumberWidth
    };
});
define('skylark-codemirror/primitives/display/scrolling',[
    '../line/pos',
    '../measurement/position_measurement',
    '../util/browser',
    '../util/dom',
    '../util/event',
    //'./highlight_worker',// dependence cycle 
    './line_numbers',
    './update_display'
], function (
    a, 
    b, 
    c, 
    d, 
    e, 
//    highlight_worker, 
    g, 
    h
) {
    'use strict';
    function maybeScrollWindow(cm, rect) {
        if (e.signalDOMEvent(cm, 'scrollCursorIntoView'))
            return;
        let display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        if (rect.top + box.top < 0)
            doScroll = true;
        else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
            doScroll = false;
        if (doScroll != null && !c.phantom) {
            let scrollNode = d.elt('div', '\u200B', null, `position: absolute;
                         top: ${ rect.top - display.viewOffset - b.paddingTop(cm.display) }px;
                         height: ${ rect.bottom - rect.top + b.scrollGap(cm) + display.barHeight }px;
                         left: ${ rect.left }px; width: ${ Math.max(2, rect.right - rect.left) }px;`);
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null)
            margin = 0;
        let rect;
        if (!cm.options.lineWrapping && pos == end) {
            pos = pos.ch ? a.Pos(pos.line, pos.sticky == 'before' ? pos.ch - 1 : pos.ch, 'after') : pos;
            end = pos.sticky == 'before' ? a.Pos(pos.line, pos.ch + 1, 'before') : pos;
        }
        for (let limit = 0; limit < 5; limit++) {
            let changed = false;
            let coords = b.cursorCoords(cm, pos);
            let endCoords = !end || end == pos ? coords : b.cursorCoords(cm, end);
            rect = {
                left: Math.min(coords.left, endCoords.left),
                top: Math.min(coords.top, endCoords.top) - margin,
                right: Math.max(coords.left, endCoords.left),
                bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            let scrollPos = calculateScrollPos(cm, rect);
            let startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
                updateScrollTop(cm, scrollPos.scrollTop);
                if (Math.abs(cm.doc.scrollTop - startTop) > 1)
                    changed = true;
            }
            if (scrollPos.scrollLeft != null) {
                setScrollLeft(cm, scrollPos.scrollLeft);
                if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
                    changed = true;
            }
            if (!changed)
                break;
        }
        return rect;
    }
    function scrollIntoView(cm, rect) {
        let scrollPos = calculateScrollPos(cm, rect);
        if (scrollPos.scrollTop != null)
            updateScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null)
            setScrollLeft(cm, scrollPos.scrollLeft);
    }
    function calculateScrollPos(cm, rect) {
        let display = cm.display, snapMargin = b.textHeight(cm.display);
        if (rect.top < 0)
            rect.top = 0;
        let screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        let screen = b.displayHeight(cm), result = {};
        if (rect.bottom - rect.top > screen)
            rect.bottom = rect.top + screen;
        let docBottom = cm.doc.height + b.paddingVert(display);
        let atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
        if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen) {
            let newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
            if (newTop != screentop)
                result.scrollTop = newTop;
        }
        let screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        let screenw = b.displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        let tooWide = rect.right - rect.left > screenw;
        if (tooWide)
            rect.right = rect.left + screenw;
        if (rect.left < 10)
            result.scrollLeft = 0;
        else if (rect.left < screenleft)
            result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
        else if (rect.right > screenw + screenleft - 3)
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        return result;
    }
    function addToScrollTop(cm, top) {
        if (top == null)
            return;
        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        let cur = cm.getCursor();
        cm.curOp.scrollToPos = {
            from: cur,
            to: cur,
            margin: cm.options.cursorScrollMargin
        };
    }
    function scrollToCoords(cm, x, y) {
        if (x != null || y != null)
            resolveScrollToPos(cm);
        if (x != null)
            cm.curOp.scrollLeft = x;
        if (y != null)
            cm.curOp.scrollTop = y;
    }
    function scrollToRange(cm, range) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range;
    }
    function resolveScrollToPos(cm) {
        let range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            let from = b.estimateCoords(cm, range.from), to = b.estimateCoords(cm, range.to);
            scrollToCoordsRange(cm, from, to, range.margin);
        }
    }
    function scrollToCoordsRange(cm, from, to, margin) {
        let sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2)
            return;
        if (!c.gecko)
            h.updateDisplaySimple(cm, { top: val });
        setScrollTop(cm, val, true);
        if (c.gecko)
            h.updateDisplaySimple(cm);
        cm.startWorker(cm, 100); // highlight_worker.startWorker(cm, 100);
    }
    function setScrollTop(cm, val, forceScroll) {
        val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
        if (cm.display.scroller.scrollTop == val && !forceScroll)
            return;
        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (cm.display.scroller.scrollTop != val)
            cm.display.scroller.scrollTop = val;
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll)
            return;
        cm.doc.scrollLeft = val;
        g.alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val)
            cm.display.scroller.scrollLeft = val;
        cm.display.scrollbars.setScrollLeft(val);
    }
    return {
        maybeScrollWindow: maybeScrollWindow,
        scrollPosIntoView: scrollPosIntoView,
        scrollIntoView: scrollIntoView,
        addToScrollTop: addToScrollTop,
        ensureCursorVisible: ensureCursorVisible,
        scrollToCoords: scrollToCoords,
        scrollToRange: scrollToRange,
        scrollToCoordsRange: scrollToCoordsRange,
        updateScrollTop: updateScrollTop,
        setScrollTop: setScrollTop,
        setScrollLeft: setScrollLeft
    };
});
define('skylark-codemirror/primitives/display/scrollbars',[
    '../util/dom',
    '../util/event',
    '../measurement/position_measurement',
    '../util/browser',
    './update_lines',
    '../util/misc',
    './scrolling'
], function (dom, event, position_measurement, browser, update_lines, misc, scrolling) {
    'use strict';
    function measureForScrollbars(cm) {
        let d = cm.display, gutterW = d.gutters.offsetWidth;
        let docH = Math.round(cm.doc.height + position_measurement.paddingVert(cm.display));
        return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + position_measurement.scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
        };
    }
    class NativeScrollbars {
        constructor(place, scroll, cm) {
            this.cm = cm;
            let vert = this.vert = dom.elt('div', [dom.elt('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar');
            let horiz = this.horiz = dom.elt('div', [dom.elt('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar');
            vert.tabIndex = horiz.tabIndex = -1;
            place(vert);
            place(horiz);
            event.on(vert, 'scroll', () => {
                if (vert.clientHeight)
                    scroll(vert.scrollTop, 'vertical');
            });
            event.on(horiz, 'scroll', () => {
                if (horiz.clientWidth)
                    scroll(horiz.scrollLeft, 'horizontal');
            });
            this.checkedZeroWidth = false;
            if (browser.ie && browser.ie_version < 8)
                this.horiz.style.minHeight = this.vert.style.minWidth = '18px';
        }
        update(measure) {
            let needsH = measure.scrollWidth > measure.clientWidth + 1;
            let needsV = measure.scrollHeight > measure.clientHeight + 1;
            let sWidth = measure.nativeBarWidth;
            if (needsV) {
                this.vert.style.display = 'block';
                this.vert.style.bottom = needsH ? sWidth + 'px' : '0';
                let totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + 'px';
            } else {
                this.vert.style.display = '';
                this.vert.firstChild.style.height = '0';
            }
            if (needsH) {
                this.horiz.style.display = 'block';
                this.horiz.style.right = needsV ? sWidth + 'px' : '0';
                this.horiz.style.left = measure.barLeft + 'px';
                let totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + 'px';
            } else {
                this.horiz.style.display = '';
                this.horiz.firstChild.style.width = '0';
            }
            if (!this.checkedZeroWidth && measure.clientHeight > 0) {
                if (sWidth == 0)
                    this.zeroWidthHack();
                this.checkedZeroWidth = true;
            }
            return {
                right: needsV ? sWidth : 0,
                bottom: needsH ? sWidth : 0
            };
        }
        setScrollLeft(pos) {
            if (this.horiz.scrollLeft != pos)
                this.horiz.scrollLeft = pos;
            if (this.disableHoriz)
                this.enableZeroWidthBar(this.horiz, this.disableHoriz, 'horiz');
        }
        setScrollTop(pos) {
            if (this.vert.scrollTop != pos)
                this.vert.scrollTop = pos;
            if (this.disableVert)
                this.enableZeroWidthBar(this.vert, this.disableVert, 'vert');
        }
        zeroWidthHack() {
            let w = browser.mac && !browser.mac_geMountainLion ? '12px' : '18px';
            this.horiz.style.height = this.vert.style.width = w;
            this.horiz.style.pointerEvents = this.vert.style.pointerEvents = 'none';
            this.disableHoriz = new misc.Delayed();
            this.disableVert = new misc.Delayed();
        }
        enableZeroWidthBar(bar, delay, type) {
            bar.style.pointerEvents = 'auto';
            function maybeDisable() {
                let box = bar.getBoundingClientRect();
                let elt = type == 'vert' ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
                if (elt != bar)
                    bar.style.pointerEvents = 'none';
                else
                    delay.set(1000, maybeDisable);
            }
            delay.set(1000, maybeDisable);
        }
        clear() {
            let parent = this.horiz.parentNode;
            parent.removeChild(this.horiz);
            parent.removeChild(this.vert);
        }
    }
    class NullScrollbars {
        update() {
            return {
                bottom: 0,
                right: 0
            };
        }
        setScrollLeft() {
        }
        setScrollTop() {
        }
        clear() {
        }
    }
    function updateScrollbars(cm, measure) {
        if (!measure)
            measure = measureForScrollbars(cm);
        let startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (let i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
                update_lines.updateHeightsInViewport(cm);
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
        }
    }
    function updateScrollbarsInner(cm, measure) {
        let d = cm.display;
        let sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + 'px';
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + 'px';
        d.heightForcer.style.borderBottom = sizes.bottom + 'px solid transparent';
        if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = 'block';
            d.scrollbarFiller.style.height = sizes.bottom + 'px';
            d.scrollbarFiller.style.width = sizes.right + 'px';
        } else
            d.scrollbarFiller.style.display = '';
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = 'block';
            d.gutterFiller.style.height = sizes.bottom + 'px';
            d.gutterFiller.style.width = measure.gutterWidth + 'px';
        } else
            d.gutterFiller.style.display = '';
    }
    let scrollbarModel = {
        'native': NativeScrollbars,
        'null': NullScrollbars
    };
    function initScrollbars(cm) {
        if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.undefined)
                dom.rmClass(cm.display.wrapper, cm.display.scrollbars.undefined);
        }
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](node => {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            event.on(node, 'mousedown', () => {
                if (cm.state.focused)
                    setTimeout(() => cm.display.input.focus(), 0);
            });
            node.setAttribute('cm-not-content', 'true');
        }, (pos, axis) => {
            if (axis == 'horizontal')
                scrolling.setScrollLeft(cm, pos);
            else
                scrolling.updateScrollTop(cm, pos);
        }, cm);
        if (cm.display.scrollbars.undefined)
            dom.addClass(cm.display.wrapper, cm.display.scrollbars.undefined);
    }
    return {
        measureForScrollbars: measureForScrollbars,
        updateScrollbars: updateScrollbars,
        scrollbarModel: scrollbarModel,
        initScrollbars: initScrollbars
    };
});
define('skylark-codemirror/primitives/display/operations',[
    '../line/pos',
    '../line/spans',
    '../measurement/position_measurement',
    '../util/event',
    '../util/dom',
    '../util/operation_group',
    './focus',
    './scrollbars',
    './selection',
    './scrolling',
    './update_display',
    './update_lines'
], function (a, b, c, d, e, f, g, h, i, j, k, l) {
    'use strict';
    let nextOpId = 0;
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: 0,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId
        };
        f.pushOperation(cm.curOp);
    }
    function endOperation(cm) {
        let op = cm.curOp;
        if (op)
            f.finishOperation(op, group => {
                for (let i = 0; i < group.ops.length; i++)
                    group.ops[i].cm.curOp = null;
                endOperations(group);
            });
    }
    function endOperations(group) {
        let ops = group.ops;
        for (let i = 0; i < ops.length; i++)
            endOperation_R1(ops[i]);
        for (let i = 0; i < ops.length; i++)
            endOperation_W1(ops[i]);
        for (let i = 0; i < ops.length; i++)
            endOperation_R2(ops[i]);
        for (let i = 0; i < ops.length; i++)
            endOperation_W2(ops[i]);
        for (let i = 0; i < ops.length; i++)
            endOperation_finish(ops[i]);
    }
    function endOperation_R1(op) {
        let cm = op.cm, display = cm.display;
        k.maybeClipScrollbars(cm);
        if (op.updateMaxLine)
            b.findMaxLine(cm);
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new k.DisplayUpdate(cm, op.mustUpdate && {
            top: op.scrollTop,
            ensure: op.scrollToPos
        }, op.forceUpdate);
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && k.updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
        let cm = op.cm, display = cm.display;
        if (op.updatedDisplay)
            l.updateHeightsInViewport(cm);
        op.barMeasure = h.measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = c.measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + c.scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - c.displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged)
            op.preparedSelection = display.input.prepareSelection();
    }
    function endOperation_W2(op) {
        let cm = op.cm;
        if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + 'px';
            if (op.maxScrollLeft < cm.doc.scrollLeft)
                j.setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            cm.display.maxLineChanged = false;
        }
        let takeFocus = op.focus && op.focus == e.activeElt();
        if (op.preparedSelection)
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
        if (op.updatedDisplay || op.startHeight != cm.doc.height)
            h.updateScrollbars(cm, op.barMeasure);
        if (op.updatedDisplay)
            k.setDocumentHeight(cm, op.barMeasure);
        if (op.selectionChanged)
            i.restartBlink(cm);
        if (cm.state.focused && op.updateInput)
            cm.display.input.reset(op.typing);
        if (takeFocus)
            g.ensureFocus(op.cm);
    }
    function endOperation_finish(op) {
        let cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.updatedDisplay)
            k.postUpdateDisplay(cm, op.update);
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
            display.wheelStartX = display.wheelStartY = null;
        if (op.scrollTop != null)
            j.setScrollTop(cm, op.scrollTop, op.forceScroll);
        if (op.scrollLeft != null)
            j.setScrollLeft(cm, op.scrollLeft, true, true);
        if (op.scrollToPos) {
            let rect = j.scrollPosIntoView(cm, a.clipPos(doc, op.scrollToPos.from), a.clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            j.maybeScrollWindow(cm, rect);
        }
        let hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
            for (let i = 0; i < hidden.length; ++i)
                if (!hidden[i].lines.length)
                    d.signal(hidden[i], 'hide');
        if (unhidden)
            for (let i = 0; i < unhidden.length; ++i)
                if (unhidden[i].lines.length)
                    d.signal(unhidden[i], 'unhide');
        if (display.wrapper.offsetHeight)
            doc.scrollTop = cm.display.scroller.scrollTop;
        if (op.changeObjs)
            d.signal(cm, 'changes', cm, op.changeObjs);
        if (op.update)
            op.update.finish();
    }
    function runInOp(cm, f) {
        if (cm.curOp)
            return f();
        startOperation(cm);
        try {
            return f();
        } finally {
            endOperation(cm);
        }
    }
    function operation(cm, f) {
        return function () {
            if (cm.curOp)
                return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function methodOp(f) {
        return function () {
            if (this.curOp)
                return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(this);
            }
        };
    }
    function docMethodOp(f) {
        return function () {
            let cm = this.cm;
            if (!cm || cm.curOp)
                return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    return {
        startOperation: startOperation,
        endOperation: endOperation,
        runInOp: runInOp,
        operation: operation,
        methodOp: methodOp,
        docMethodOp: docMethodOp
    };
});
define('skylark-codemirror/primitives/display/scroll_events',[
    '../util/browser',
    '../util/event',
    './update_display',
    './scrolling'
], function (a, b, c, d) {
    'use strict';
    let wheelSamples = 0, wheelPixelsPerUnit = null;
    if (a.ie)
        wheelPixelsPerUnit = -0.53;
    else if (a.gecko)
        wheelPixelsPerUnit = 15;
    else if (a.chrome)
        wheelPixelsPerUnit = -0.7;
    else if (a.safari)
        wheelPixelsPerUnit = -1 / 3;
    function wheelEventDelta(e) {
        let dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
            dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
            dy = e.detail;
        else if (dy == null)
            dy = e.wheelDelta;
        return {
            x: dx,
            y: dy
        };
    }
    function wheelEventPixels(e) {
        let delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
    }
    function onScrollWheel(cm, e) {
        let delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
        let display = cm.display, scroll = display.scroller;
        let canScrollX = scroll.scrollWidth > scroll.clientWidth;
        let canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY))
            return;
        if (dy && a.mac && a.webkit) {
            outer:
                for (let cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                    for (let i = 0; i < view.length; i++) {
                        if (view[i].node == cur) {
                            cm.display.currentWheelTarget = cur;
                            break outer;
                        }
                    }
                }
        }
        if (dx && !a.gecko && !a.presto && wheelPixelsPerUnit != null) {
            if (dy && canScrollY)
                d.updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
            d.setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
            if (!dy || dy && canScrollY)
                b.e_preventDefault(e);
            display.wheelStartX = null;
            return;
        }
        if (dy && wheelPixelsPerUnit != null) {
            let pixels = dy * wheelPixelsPerUnit;
            let top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
            if (pixels < 0)
                top = Math.max(0, top + pixels - 50);
            else
                bot = Math.min(cm.doc.height, bot + pixels + 50);
            c.updateDisplaySimple(cm, {
                top: top,
                bottom: bot
            });
        }
        if (wheelSamples < 20) {
            if (display.wheelStartX == null) {
                display.wheelStartX = scroll.scrollLeft;
                display.wheelStartY = scroll.scrollTop;
                display.wheelDX = dx;
                display.wheelDY = dy;
                setTimeout(() => {
                    if (display.wheelStartX == null)
                        return;
                    let movedX = scroll.scrollLeft - display.wheelStartX;
                    let movedY = scroll.scrollTop - display.wheelStartY;
                    let sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null;
                    if (!sample)
                        return;
                    wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                    ++wheelSamples;
                }, 200);
            } else {
                display.wheelDX += dx;
                display.wheelDY += dy;
            }
        }
    }
    return {
        wheelEventPixels: wheelEventPixels,
        onScrollWheel: onScrollWheel
    };
});
define('skylark-codemirror/primitives/display/highlight_worker',[
    '../line/highlight',
    '../modes',
    '../util/misc',
    './operations',
    './view_tracking'
], function (highlight, models, misc, operations, view_tracking) {
    'use strict';
    function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo)
            cm.state.highlight.set(time, misc.bind(highlightWorker, cm));
    }
    function highlightWorker(cm) {
        let doc = cm.doc;
        if (doc.highlightFrontier >= cm.display.viewTo)
            return;
        let end = +new Date() + cm.options.workTime;
        let context = highlight.getContextBefore(cm, doc.highlightFrontier);
        let changedLines = [];
        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), line => {
            if (context.line >= cm.display.viewFrom) {
                let oldStyles = line.styles;
                let resetState = line.text.length > cm.options.maxHighlightLength ? models.copyState(doc.mode, context.state) : null;
                let highlighted = highlight.highlightLine(cm, line, context, true);
                if (resetState)
                    context.state = resetState;
                line.styles = highlighted.styles;
                let oldCls = line.styleClasses, newCls = highlighted.classes;
                if (newCls)
                    line.styleClasses = newCls;
                else if (oldCls)
                    line.styleClasses = null;
                let ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
                for (let i = 0; !ischange && i < oldStyles.length; ++i)
                    ischange = oldStyles[i] != line.styles[i];
                if (ischange)
                    changedLines.push(context.line);
                line.stateAfter = context.save();
                context.nextLine();
            } else {
                if (line.text.length <= cm.options.maxHighlightLength)
                    highlight.processLine(cm, line.text, context);
                line.stateAfter = context.line % 5 == 0 ? context.save() : null;
                context.nextLine();
            }
            if (+new Date() > end) {
                startWorker(cm, cm.options.workDelay);
                return true;
            }
        });
        doc.highlightFrontier = context.line;
        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
        if (changedLines.length)
            operations.runInOp(cm, () => {
                for (let i = 0; i < changedLines.length; i++)
                    view_tracking.regLineChange(cm, changedLines[i], 'text');
            });
    }
    return { startWorker: startWorker };
});
define('skylark-codemirror/primitives/model/selection',[
    '../line/pos',
    '../util/misc'
], function (m_pos, m_misc) {
    'use strict';
    class Selection {
        constructor(ranges, primIndex) {
            this.ranges = ranges;
            this.primIndex = primIndex;
        }
        primary() {
            return this.ranges[this.primIndex];
        }
        equals(other) {
            if (other == this)
                return true;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
                return false;
            for (let i = 0; i < this.ranges.length; i++) {
                let here = this.ranges[i], there = other.ranges[i];
                if (!m_pos.equalCursorPos(here.anchor, there.anchor) || !m_pos.equalCursorPos(here.head, there.head))
                    return false;
            }
            return true;
        }
        deepCopy() {
            let out = [];
            for (let i = 0; i < this.ranges.length; i++)
                out[i] = new Range(m_pos.copyPos(this.ranges[i].anchor), m_pos.copyPos(this.ranges[i].head));
            return new Selection(out, this.primIndex);
        }
        somethingSelected() {
            for (let i = 0; i < this.ranges.length; i++)
                if (!this.ranges[i].empty())
                    return true;
            return false;
        }
        contains(pos, end) {
            if (!end)
                end = pos;
            for (let i = 0; i < this.ranges.length; i++) {
                let range = this.ranges[i];
                if (m_pos.cmp(end, range.from()) >= 0 && m_pos.cmp(pos, range.to()) <= 0)
                    return i;
            }
            return -1;
        }
    }
    class Range {
        constructor(anchor, head) {
            this.anchor = anchor;
            this.head = head;
        }
        from() {
            return m_pos.minPos(this.anchor, this.head);
        }
        to() {
            return m_pos.maxPos(this.anchor, this.head);
        }
        empty() {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
    }
    function normalizeSelection(cm, ranges, primIndex) {
        let mayTouch = cm && cm.options.selectionsMayTouch;
        let prim = ranges[primIndex];
        ranges.sort((a, b) => m_pos.cmp(a.from(), b.from()));
        primIndex = m_misc.indexOf(ranges, prim);
        for (let i = 1; i < ranges.length; i++) {
            let cur = ranges[i], prev = ranges[i - 1];
            let diff = m_pos.cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
                let from = m_pos.minPos(prev.from(), cur.from()), to = m_pos.maxPos(prev.to(), cur.to());
                let inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                if (i <= primIndex)
                    --primIndex;
                ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
            }
        }
        return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
    }
    return {
        Selection: Selection,
        Range: Range,
        normalizeSelection: normalizeSelection,
        simpleSelection: simpleSelection
    };
});
define('skylark-codemirror/primitives/model/change_measurement',[
    '../line/pos',
    '../util/misc',
    './selection'
], function (line_pos, misc, selection) {
    'use strict';
    function changeEnd(change) {
        if (!change.text)
            return change.to;
        return line_pos.Pos(change.from.line + change.text.length - 1, misc.lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange(pos, change) {
        if (line_pos.cmp(pos, change.from) < 0)
            return pos;
        if (line_pos.cmp(pos, change.to) <= 0)
            return changeEnd(change);
        let line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line)
            ch += changeEnd(change).ch - change.to.ch;
        return line_pos.Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
        let out = [];
        for (let i = 0; i < doc.sel.ranges.length; i++) {
            let range = doc.sel.ranges[i];
            out.push(new selection.Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return selection.normalizeSelection(doc.cm, out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
        if (pos.line == old.line)
            return line_pos.Pos(nw.line, pos.ch - old.ch + nw.ch);
        else
            return line_pos.Pos(nw.line + (pos.line - old.line), pos.ch);
    }
    function computeReplacedSel(doc, changes, hint) {
        let out = [];
        let oldPrev = line_pos.Pos(doc.first, 0), newPrev = oldPrev;
        for (let i = 0; i < changes.length; i++) {
            let change = changes[i];
            let from = offsetPos(change.from, oldPrev, newPrev);
            let to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == 'around') {
                let range = doc.sel.ranges[i], inv = line_pos.cmp(range.head, range.anchor) < 0;
                out[i] = new selection.Range(inv ? to : from, inv ? from : to);
            } else {
                out[i] = new selection.Range(from, from);
            }
        }
        return new selection.Selection(out, doc.sel.primIndex);
    }
    return {
        changeEnd: changeEnd,
        computeSelAfterChange: computeSelAfterChange,
        computeReplacedSel: computeReplacedSel
    };
});
define('skylark-codemirror/primitives/display/mode_state',[
    '../modes',
    //'./highlight_worker',// dependence cycle 
    './view_tracking'
], function (
    models, 
    //highlight_worker, 
    view_tracking
) {
    'use strict';
    function loadMode(cm) {
        cm.doc.mode = models.getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
    }
    function resetModeState(cm) {
        cm.doc.iter(line => {
            if (line.stateAfter)
                line.stateAfter = null;
            if (line.styles)
                line.styles = null;
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        cm.startWorker(cm, 100); // highlight_worker.startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp)
            view_tracking.regChange(cm);
    }
    return {
        loadMode: loadMode,
        resetModeState: resetModeState
    };
});
define('skylark-codemirror/primitives/model/document_data',[
    '../display/mode_state',
    '../display/operations',
    '../display/view_tracking',
    '../line/line_data',
    '../line/spans',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../util/dom',
    '../util/misc',
    '../util/operation_group'
], function (a, b, c, d, e, f, g, h, i, j) {
    'use strict';
    function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && i.lst(change.text) == '' && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
            d.updateLine(line, text, spans, estimateHeight);
            j.signalLater(line, 'change', line, change);
        }
        function linesFor(start, end) {
            let result = [];
            for (let i = start; i < end; ++i)
                result.push(new d.Line(text[i], spansFor(i), estimateHeight));
            return result;
        }
        let from = change.from, to = change.to, text = change.text;
        let firstLine = f.getLine(doc, from.line), lastLine = f.getLine(doc, to.line);
        let lastText = i.lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (change.full) {
            doc.insert(0, linesFor(0, text.length));
            doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
            let added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines)
                doc.remove(from.line, nlines);
            if (added.length)
                doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
            if (text.length == 1) {
                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
                let added = linesFor(1, text.length - 1);
                added.push(new d.Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                doc.insert(from.line + 1, added);
            }
        } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc.remove(from.line + 1, nlines);
        } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            let added = linesFor(1, text.length - 1);
            if (nlines > 1)
                doc.remove(from.line + 1, nlines - 1);
            doc.insert(from.line + 1, added);
        }
        j.signalLater(doc, 'change', doc, change);
    }
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked)
                for (let i = 0; i < doc.linked.length; ++i) {
                    let rel = doc.linked[i];
                    if (rel.doc == skip)
                        continue;
                    let shared = sharedHist && rel.sharedHist;
                    if (sharedHistOnly && !shared)
                        continue;
                    f(rel.doc, shared);
                    propagate(rel.doc, doc, shared);
                }
        }
        propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
        if (doc.cm)
            throw new Error('This document is already in use.');
        cm.doc = doc;
        doc.cm = cm;
        g.estimateLineHeights(cm);
        a.loadMode(cm);
        setDirectionClass(cm);
        if (!cm.options.lineWrapping)
            e.findMaxLine(cm);
        cm.options.mode = doc.modeOption;
        c.regChange(cm);
    }
    function setDirectionClass(cm) {
        ;
        (cm.doc.direction == 'rtl' ? h.addClass : h.rmClass)(cm.display.lineDiv, 'CodeMirror-rtl');
    }
    function directionChanged(cm) {
        b.runInOp(cm, () => {
            setDirectionClass(cm);
            c.regChange(cm);
        });
    }
    return {
        isWholeLineUpdate: isWholeLineUpdate,
        updateDoc: updateDoc,
        linkedDocs: linkedDocs,
        attachDoc: attachDoc,
        directionChanged: directionChanged
    };
});
define('skylark-codemirror/primitives/model/history',[
    '../line/pos',
    '../line/spans',
    '../line/utils_line',
    '../util/event',
    '../util/misc',
    './change_measurement',
    './document_data',
    './selection'
], function (a, b, c, d, e, f, g, h) {
    'use strict';
    function History(startGen) {
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = startGen || 1;
    }
    function historyChangeFromChange(doc, change) {
        let histChange = {
            from: a.copyPos(change.from),
            to: f.changeEnd(change),
            text: c.getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        g.linkedDocs(doc, doc => attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), true);
        return histChange;
    }
    function clearSelectionEvents(array) {
        while (array.length) {
            let last = e.lst(array);
            if (last.ranges)
                array.pop();
            else
                break;
        }
    }
    function lastChangeEvent(hist, force) {
        if (force) {
            clearSelectionEvents(hist.done);
            return e.lst(hist.done);
        } else if (hist.done.length && !e.lst(hist.done).ranges) {
            return e.lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return e.lst(hist.done);
        }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        let hist = doc.history;
        hist.undone.length = 0;
        let time = +new Date(), cur;
        let last;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = e.lst(cur.changes);
            if (a.cmp(change.from, change.to) == 0 && a.cmp(change.from, last.to) == 0) {
                last.to = f.changeEnd(change);
            } else {
                cur.changes.push(historyChangeFromChange(doc, change));
            }
        } else {
            let before = e.lst(hist.done);
            if (!before || !before.ranges)
                pushSelectionToHistory(doc.sel, hist.done);
            cur = {
                changes: [historyChangeFromChange(doc, change)],
                generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
                hist.done.shift();
                if (!hist.done[0].ranges)
                    hist.done.shift();
            }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last)
            d.signal(doc, 'historyAdded');
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        let ch = origin.charAt(0);
        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        let hist = doc.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, e.lst(hist.done), sel)))
            hist.done[hist.done.length - 1] = sel;
        else
            pushSelectionToHistory(sel, hist.done);
        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false)
            clearSelectionEvents(hist.undone);
    }
    function pushSelectionToHistory(sel, dest) {
        let top = e.lst(dest);
        if (!(top && top.ranges && top.equals(sel)))
            dest.push(sel);
    }
    function attachLocalSpans(doc, change, from, to) {
        let existing = change['spans_' + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), line => {
            if (line.markedSpans)
                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
            ++n;
        });
    }
    function removeClearedSpans(spans) {
        if (!spans)
            return null;
        let out;
        for (let i = 0; i < spans.length; ++i) {
            if (spans[i].marker.explicitlyCleared) {
                if (!out)
                    out = spans.slice(0, i);
            } else if (out)
                out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
        let found = change['spans_' + doc.id];
        if (!found)
            return null;
        let nw = [];
        for (let i = 0; i < change.text.length; ++i)
            nw.push(removeClearedSpans(found[i]));
        return nw;
    }
    function mergeOldSpans(doc, change) {
        let old = getOldSpans(doc, change);
        let stretched = b.stretchSpansOverChange(doc, change);
        if (!old)
            return stretched;
        if (!stretched)
            return old;
        for (let i = 0; i < old.length; ++i) {
            let oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur) {
                spans:
                    for (let j = 0; j < stretchCur.length; ++j) {
                        let span = stretchCur[j];
                        for (let k = 0; k < oldCur.length; ++k)
                            if (oldCur[k].marker == span.marker)
                                continue spans;
                        oldCur.push(span);
                    }
            } else if (stretchCur) {
                old[i] = stretchCur;
            }
        }
        return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        let copy = [];
        for (let i = 0; i < events.length; ++i) {
            let event = events[i];
            if (event.ranges) {
                copy.push(instantiateSel ? h.Selection.prototype.deepCopy.call(event) : event);
                continue;
            }
            let changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (let j = 0; j < changes.length; ++j) {
                let change = changes[j], m;
                newChanges.push({
                    from: change.from,
                    to: change.to,
                    text: change.text
                });
                if (newGroup)
                    for (var prop in change)
                        if (m = prop.match(/^spans_(\d+)$/)) {
                            if (e.indexOf(newGroup, Number(m[1])) > -1) {
                                e.lst(newChanges)[prop] = change[prop];
                                delete change[prop];
                            }
                        }
            }
        }
        return copy;
    }
    return {
        History: History,
        historyChangeFromChange: historyChangeFromChange,
        addChangeToHistory: addChangeToHistory,
        addSelectionToHistory: addSelectionToHistory,
        pushSelectionToHistory: pushSelectionToHistory,
        mergeOldSpans: mergeOldSpans,
        copyHistoryArray: copyHistoryArray
    };
});
define('skylark-codemirror/primitives/model/selection_updates',[
    '../util/operation_group',
    '../display/scrolling',
    '../line/pos',
    '../line/utils_line',
    '../util/event',
    '../util/misc',
    './history',
    './selection'
], function (a, b, c, d, e, f, g, h) {
    'use strict';
    function extendRange(range, head, other, extend) {
        if (extend) {
            let anchor = range.anchor;
            if (other) {
                let posBefore = c.cmp(head, anchor) < 0;
                if (posBefore != c.cmp(other, anchor) < 0) {
                    anchor = head;
                    head = other;
                } else if (posBefore != c.cmp(head, other) < 0) {
                    head = other;
                }
            }
            return new h.Range(anchor, head);
        } else {
            return new h.Range(other || head, head);
        }
    }
    function extendSelection(doc, head, other, options, extend) {
        if (extend == null)
            extend = doc.cm && (doc.cm.display.shift || doc.extend);
        setSelection(doc, new h.Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
    }
    function extendSelections(doc, heads, options) {
        let out = [];
        let extend = doc.cm && (doc.cm.display.shift || doc.extend);
        for (let i = 0; i < doc.sel.ranges.length; i++)
            out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
        let newSel = h.normalizeSelection(doc.cm, out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
    }
    function replaceOneSelection(doc, i, range, options) {
        let ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, h.normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, h.simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel, options) {
        let obj = {
            ranges: sel.ranges,
            update: function (ranges) {
                this.ranges = [];
                for (let i = 0; i < ranges.length; i++)
                    this.ranges[i] = new h.Range(c.clipPos(doc, ranges[i].anchor), c.clipPos(doc, ranges[i].head));
            },
            origin: options && options.origin
        };
        e.signal(doc, 'beforeSelectionChange', doc, obj);
        if (doc.cm)
            e.signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
        if (obj.ranges != sel.ranges)
            return h.normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
        else
            return sel;
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        let done = doc.history.done, last = f.lst(done);
        if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc, sel, options);
        } else {
            setSelection(doc, sel, options);
        }
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        g.addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
        if (e.hasHandler(doc, 'beforeSelectionChange') || doc.cm && e.hasHandler(doc.cm, 'beforeSelectionChange'))
            sel = filterSelectionChange(doc, sel, options);
        let bias = options && options.bias || (c.cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm)
            b.ensureCursorVisible(doc.cm);
    }
    function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel))
            return;
        doc.sel = sel;
        if (doc.cm) {
            doc.cm.curOp.updateInput = 1;
            doc.cm.curOp.selectionChanged = true;
            e.signalCursorActivity(doc.cm);
        }
        a.signalLater(doc, 'cursorActivity', doc);
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        let out;
        for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i];
            let old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
            let newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
            let newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
            if (out || newAnchor != range.anchor || newHead != range.head) {
                if (!out)
                    out = sel.ranges.slice(0, i);
                out[i] = new h.Range(newAnchor, newHead);
            }
        }
        return out ? h.normalizeSelection(doc.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        let line = d.getLine(doc, pos.line);
        if (line.markedSpans)
            for (let i = 0; i < line.markedSpans.length; ++i) {
                let sp = line.markedSpans[i], m = sp.marker;
                if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                    if (mayClear) {
                        e.signal(m, 'beforeCursorEnter');
                        if (m.explicitlyCleared) {
                            if (!line.markedSpans)
                                break;
                            else {
                                --i;
                                continue;
                            }
                        }
                    }
                    if (!m.atomic)
                        continue;
                    if (oldPos) {
                        let near = m.find(dir < 0 ? 1 : -1), diff;
                        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
                            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                        if (near && near.line == pos.line && (diff = c.cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
                            return skipAtomicInner(doc, near, pos, dir, mayClear);
                    }
                    let far = m.find(dir < 0 ? -1 : 1);
                    if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
                        far = movePos(doc, far, dir, far.line == pos.line ? line : null);
                    return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
                }
            }
        return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        let dir = bias || 1;
        let found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
        if (!found) {
            doc.cantEdit = true;
            return c.Pos(doc.first, 0);
        }
        return found;
    }
    function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc.first)
                return c.clipPos(doc, c.Pos(pos.line - 1));
            else
                return null;
        } else if (dir > 0 && pos.ch == (line || d.getLine(doc, pos.line)).text.length) {
            if (pos.line < doc.first + doc.size - 1)
                return c.Pos(pos.line + 1, 0);
            else
                return null;
        } else {
            return new c.Pos(pos.line, pos.ch + dir);
        }
    }
    function selectAll(cm) {
        cm.setSelection(c.Pos(cm.firstLine(), 0), c.Pos(cm.lastLine()), f.sel_dontScroll);
    }
    return {
        extendRange: extendRange,
        extendSelection: extendSelection,
        extendSelections: extendSelections,
        replaceOneSelection: replaceOneSelection,
        setSimpleSelection: setSimpleSelection,
        setSelectionReplaceHistory: setSelectionReplaceHistory,
        setSelection: setSelection,
        setSelectionNoUndo: setSelectionNoUndo,
        reCheckSelection: reCheckSelection,
        skipAtomic: skipAtomic,
        selectAll: selectAll
    };
});
define('skylark-codemirror/primitives/model/changes',[
    '../line/highlight',
    '../display/highlight_worker',
    '../display/operations',
    '../display/view_tracking',
    '../line/pos',
    '../line/saw_special_spans',
    '../line/spans',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../util/event',
    '../util/misc',
    '../util/operation_group',
    './change_measurement',
    './document_data',
    './history',
    './selection',
    './selection_updates'
], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
    'use strict';
    function filterChange(doc, change, update) {
        let obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: () => obj.canceled = true
        };
        if (update)
            obj.update = (from, to, text, origin) => {
                if (from)
                    obj.from = e.clipPos(doc, from);
                if (to)
                    obj.to = e.clipPos(doc, to);
                if (text)
                    obj.text = text;
                if (origin !== undefined)
                    obj.origin = origin;
            };
        j.signal(doc, 'beforeChange', doc, obj);
        if (doc.cm)
            j.signal(doc.cm, 'beforeChange', doc.cm, obj);
        if (obj.canceled) {
            if (doc.cm)
                doc.cm.curOp.updateInput = 2;
            return null;
        }
        return {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        };
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp)
                return c.operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits)
                return;
        }
        if (j.hasHandler(doc, 'beforeChange') || doc.cm && j.hasHandler(doc.cm, 'beforeChange')) {
            change = filterChange(doc, change, true);
            if (!change)
                return;
        }
        let split = f.sawReadOnlySpans && !ignoreReadOnly && g.removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
            for (let i = split.length - 1; i >= 0; --i)
                makeChangeInner(doc, {
                    from: split[i].from,
                    to: split[i].to,
                    text: i ? [''] : change.text,
                    origin: change.origin
                });
        } else {
            makeChangeInner(doc, change);
        }
    }
    function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == '' && e.cmp(change.from, change.to) == 0)
            return;
        let selAfter = m.computeSelAfterChange(doc, change);
        o.addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, g.stretchSpansOverChange(doc, change));
        let rebased = [];
        n.linkedDocs(doc, (doc, sharedHist) => {
            if (!sharedHist && k.indexOf(rebased, doc.history) == -1) {
                rebaseHist(doc.history, change);
                rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, g.stretchSpansOverChange(doc, change));
        });
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        let suppress = doc.cm && doc.cm.state.suppressEdits;
        if (suppress && !allowSelectionOnly)
            return;
        let hist = doc.history, event, selAfter = doc.sel;
        let source = type == 'undo' ? hist.done : hist.undone, dest = type == 'undo' ? hist.undone : hist.done;
        let i = 0;
        for (; i < source.length; i++) {
            event = source[i];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
                break;
        }
        if (i == source.length)
            return;
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (;;) {
            event = source.pop();
            if (event.ranges) {
                o.pushSelectionToHistory(event, dest);
                if (allowSelectionOnly && !event.equals(doc.sel)) {
                    q.setSelection(doc, event, { clearRedo: false });
                    return;
                }
                selAfter = event;
            } else if (suppress) {
                source.push(event);
                return;
            } else
                break;
        }
        let antiChanges = [];
        o.pushSelectionToHistory(selAfter, dest);
        dest.push({
            changes: antiChanges,
            generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        let filter = j.hasHandler(doc, 'beforeChange') || doc.cm && j.hasHandler(doc.cm, 'beforeChange');
        for (let i = event.changes.length - 1; i >= 0; --i) {
            let change = event.changes[i];
            change.origin = type;
            if (filter && !filterChange(doc, change, false)) {
                source.length = 0;
                return;
            }
            antiChanges.push(o.historyChangeFromChange(doc, change));
            let after = i ? m.computeSelAfterChange(doc, change) : k.lst(source);
            makeChangeSingleDoc(doc, change, after, o.mergeOldSpans(doc, change));
            if (!i && doc.cm)
                doc.cm.scrollIntoView({
                    from: change.from,
                    to: m.changeEnd(change)
                });
            let rebased = [];
            n.linkedDocs(doc, (doc, sharedHist) => {
                if (!sharedHist && k.indexOf(rebased, doc.history) == -1) {
                    rebaseHist(doc.history, change);
                    rebased.push(doc.history);
                }
                makeChangeSingleDoc(doc, change, null, o.mergeOldSpans(doc, change));
            });
        }
    }
    function shiftDoc(doc, distance) {
        if (distance == 0)
            return;
        doc.first += distance;
        doc.sel = new p.Selection(k.map(doc.sel.ranges, range => new p.Range(e.Pos(range.anchor.line + distance, range.anchor.ch), e.Pos(range.head.line + distance, range.head.ch))), doc.sel.primIndex);
        if (doc.cm) {
            d.regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (let d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
                d.regLineChange(doc.cm, l, 'gutter');
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
            return c.operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first) {
            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            return;
        }
        if (change.from.line > doc.lastLine())
            return;
        if (change.from.line < doc.first) {
            let shift = change.text.length - 1 - (doc.first - change.from.line);
            shiftDoc(doc, shift);
            change = {
                from: e.Pos(doc.first, 0),
                to: e.Pos(change.to.line + shift, change.to.ch),
                text: [k.lst(change.text)],
                origin: change.origin
            };
        }
        let last = doc.lastLine();
        if (change.to.line > last) {
            change = {
                from: change.from,
                to: e.Pos(last, h.getLine(doc, last).text.length),
                text: [change.text[0]],
                origin: change.origin
            };
        }
        change.removed = h.getBetween(doc, change.from, change.to);
        if (!selAfter)
            selAfter = m.computeSelAfterChange(doc, change);
        if (doc.cm)
            makeChangeSingleDocInEditor(doc.cm, change, spans);
        else
            n.updateDoc(doc, change, spans);
        q.setSelectionNoUndo(doc, selAfter, k.sel_dontScroll);
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        let doc = cm.doc, display = cm.display, from = change.from, to = change.to;
        let recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
            checkWidthStart = h.lineNo(g.visualLine(h.getLine(doc, from.line)));
            doc.iter(checkWidthStart, to.line + 1, line => {
                if (line == display.maxLine) {
                    recomputeMaxLength = true;
                    return true;
                }
            });
        }
        if (doc.sel.contains(change.from, change.to) > -1)
            j.signalCursorActivity(cm);
        n.updateDoc(doc, change, spans, i.estimateHeight(cm));
        if (!cm.options.lineWrapping) {
            doc.iter(checkWidthStart, from.line + change.text.length, line => {
                let len = g.lineLength(line);
                if (len > display.maxLineLength) {
                    display.maxLine = line;
                    display.maxLineLength = len;
                    display.maxLineChanged = true;
                    recomputeMaxLength = false;
                }
            });
            if (recomputeMaxLength)
                cm.curOp.updateMaxLine = true;
        }
        a.retreatFrontier(doc, from.line);
        b.startWorker(cm, 400);
        let lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full)
            d.regChange(cm);
        else if (from.line == to.line && change.text.length == 1 && !n.isWholeLineUpdate(cm.doc, change))
            d.regLineChange(cm, from.line, 'text');
        else
            d.regChange(cm, from.line, to.line + 1, lendiff);
        let changesHandler = j.hasHandler(cm, 'changes'), changeHandler = j.hasHandler(cm, 'change');
        if (changeHandler || changesHandler) {
            let obj = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            };
            if (changeHandler)
                l.signalLater(cm, 'change', cm, obj);
            if (changesHandler)
                (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
        cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
        if (!to)
            to = from;
        if (e.cmp(to, from) < 0)
            [from, to] = [
                to,
                from
            ];
        if (typeof code == 'string')
            code = doc.splitLines(code);
        makeChange(doc, {
            from,
            to,
            text: code,
            origin
        });
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
            pos.line += diff;
        } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
        }
    }
    function rebaseHistArray(array, from, to, diff) {
        for (let i = 0; i < array.length; ++i) {
            let sub = array[i], ok = true;
            if (sub.ranges) {
                if (!sub.copied) {
                    sub = array[i] = sub.deepCopy();
                    sub.copied = true;
                }
                for (let j = 0; j < sub.ranges.length; j++) {
                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                }
                continue;
            }
            for (let j = 0; j < sub.changes.length; ++j) {
                let cur = sub.changes[j];
                if (to < cur.from.line) {
                    cur.from = e.Pos(cur.from.line + diff, cur.from.ch);
                    cur.to = e.Pos(cur.to.line + diff, cur.to.ch);
                } else if (from <= cur.to.line) {
                    ok = false;
                    break;
                }
            }
            if (!ok) {
                array.splice(0, i + 1);
                i = 0;
            }
        }
    }
    function rebaseHist(hist, change) {
        let from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
    }
    function changeLine(doc, handle, changeType, op) {
        let no = handle, line = handle;
        if (typeof handle == 'number')
            line = h.getLine(doc, e.clipLine(doc, handle));
        else
            no = h.lineNo(handle);
        if (no == null)
            return null;
        if (op(line, no) && doc.cm)
            d.regLineChange(doc.cm, no, changeType);
        return line;
    }
    return {
        makeChange: makeChange,
        makeChangeFromHistory: makeChangeFromHistory,
        replaceRange: replaceRange,
        changeLine: changeLine
    };
});
define('skylark-codemirror/primitives/model/chunk',[
    '../line/line_data',
    '../util/misc',
    '../util/operation_group'
], function (a, b, c) {
    'use strict';
    function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        let height = 0;
        for (let i = 0; i < lines.length; ++i) {
            lines[i].parent = this;
            height += lines[i].height;
        }
        this.height = height;
    }
    LeafChunk.prototype = {
        chunkSize() {
            return this.lines.length;
        },
        removeInner(at, n) {
            for (let i = at, e = at + n; i < e; ++i) {
                let line = this.lines[i];
                this.height -= line.height;
                a.cleanUpLine(line);
                c.signalLater(line, 'delete');
            }
            this.lines.splice(at, n);
        },
        collapse(lines) {
            lines.push.apply(lines, this.lines);
        },
        insertInner(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (let i = 0; i < lines.length; ++i)
                lines[i].parent = this;
        },
        iterN(at, n, op) {
            for (let e = at + n; at < e; ++at)
                if (op(this.lines[at]))
                    return true;
        }
    };
    function BranchChunk(children) {
        this.children = children;
        let size = 0, height = 0;
        for (let i = 0; i < children.length; ++i) {
            let ch = children[i];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
    }
    BranchChunk.prototype = {
        chunkSize() {
            return this.size;
        },
        removeInner(at, n) {
            this.size -= n;
            for (let i = 0; i < this.children.length; ++i) {
                let child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    let rm = Math.min(n, sz - at), oldHeight = child.height;
                    child.removeInner(at, rm);
                    this.height -= oldHeight - child.height;
                    if (sz == rm) {
                        this.children.splice(i--, 1);
                        child.parent = null;
                    }
                    if ((n -= rm) == 0)
                        break;
                    at = 0;
                } else
                    at -= sz;
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                let lines = [];
                this.collapse(lines);
                this.children = [new LeafChunk(lines)];
                this.children[0].parent = this;
            }
        },
        collapse(lines) {
            for (let i = 0; i < this.children.length; ++i)
                this.children[i].collapse(lines);
        },
        insertInner(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (let i = 0; i < this.children.length; ++i) {
                let child = this.children[i], sz = child.chunkSize();
                if (at <= sz) {
                    child.insertInner(at, lines, height);
                    if (child.lines && child.lines.length > 50) {
                        let remaining = child.lines.length % 25 + 25;
                        for (let pos = remaining; pos < child.lines.length;) {
                            let leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                            child.height -= leaf.height;
                            this.children.splice(++i, 0, leaf);
                            leaf.parent = this;
                        }
                        child.lines = child.lines.slice(0, remaining);
                        this.maybeSpill();
                    }
                    break;
                }
                at -= sz;
            }
        },
        maybeSpill() {
            if (this.children.length <= 10)
                return;
            let me = this;
            do {
                let spilled = me.children.splice(me.children.length - 5, 5);
                let sibling = new BranchChunk(spilled);
                if (!me.parent) {
                    let copy = new BranchChunk(me.children);
                    copy.parent = me;
                    me.children = [
                        copy,
                        sibling
                    ];
                    me = copy;
                } else {
                    me.size -= sibling.size;
                    me.height -= sibling.height;
                    let myIndex = b.indexOf(me.parent.children, me);
                    me.parent.children.splice(myIndex + 1, 0, sibling);
                }
                sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
        },
        iterN(at, n, op) {
            for (let i = 0; i < this.children.length; ++i) {
                let child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    let used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op))
                        return true;
                    if ((n -= used) == 0)
                        break;
                    at = 0;
                } else
                    at -= sz;
            }
        }
    };
    return {
        LeafChunk: LeafChunk,
        BranchChunk: BranchChunk
    };
});
define('skylark-codemirror/primitives/model/line_widget',[
    '../display/operations',
    '../display/scrolling',
    '../display/view_tracking',
    '../line/spans',
    '../line/utils_line',
    '../measurement/widgets',
    './changes',
    '../util/event',
    '../util/operation_group'
], function (a, b, c, d, e, f, g, h, i) {
    'use strict';
    class LineWidget {
        constructor(doc, node, options) {
            if (options)
                for (let opt in options)
                    if (options.hasOwnProperty(opt))
                        this[opt] = options[opt];
            this.doc = doc;
            this.node = node;
        }
        clear() {
            let cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = e.lineNo(line);
            if (no == null || !ws)
                return;
            for (let i = 0; i < ws.length; ++i)
                if (ws[i] == this)
                    ws.splice(i--, 1);
            if (!ws.length)
                line.widgets = null;
            let height = f.widgetHeight(this);
            e.updateLineHeight(line, Math.max(0, line.height - height));
            if (cm) {
                a.runInOp(cm, () => {
                    adjustScrollWhenAboveVisible(cm, line, -height);
                    c.regLineChange(cm, no, 'widget');
                });
                i.signalLater(cm, 'lineWidgetCleared', cm, this, no);
            }
        }
        changed() {
            let oldH = this.height, cm = this.doc.cm, line = this.line;
            this.height = null;
            let diff = f.widgetHeight(this) - oldH;
            if (!diff)
                return;
            if (!d.lineIsHidden(this.doc, line))
                e.updateLineHeight(line, line.height + diff);
            if (cm) {
                a.runInOp(cm, () => {
                    cm.curOp.forceUpdate = true;
                    adjustScrollWhenAboveVisible(cm, line, diff);
                    i.signalLater(cm, 'lineWidgetChanged', cm, this, e.lineNo(line));
                });
            }
        }
    }
    h.eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (d.heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop))
            b.addToScrollTop(cm, diff);
    }
    function addLineWidget(doc, handle, node, options) {
        let widget = new LineWidget(doc, node, options);
        let cm = doc.cm;
        if (cm && widget.noHScroll)
            cm.display.alignWidgets = true;
        g.changeLine(doc, handle, 'widget', line => {
            let widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null)
                widgets.push(widget);
            else
                widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
            widget.line = line;
            if (cm && !d.lineIsHidden(doc, line)) {
                let aboveVisible = d.heightAtLine(line) < doc.scrollTop;
                e.updateLineHeight(line, line.height + f.widgetHeight(widget));
                if (aboveVisible)
                    b.addToScrollTop(cm, widget.height);
                cm.curOp.forceUpdate = true;
            }
            return true;
        });
        if (cm)
            i.signalLater(cm, 'lineWidgetAdded', cm, widget, typeof handle == 'number' ? handle : e.lineNo(handle));
        return widget;
    }
    return {
        LineWidget: LineWidget,
        addLineWidget: addLineWidget
    };
});
define('skylark-codemirror/primitives/model/mark_text',[
    '../util/dom',
    '../util/event',
    '../display/operations',
    '../line/pos',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../line/saw_special_spans',
    '../line/spans',
    '../util/misc',
    '../util/operation_group',
    '../measurement/widgets',
    '../display/view_tracking',
    './document_data',
    './history',
    './selection_updates'
], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
    'use strict';
    let nextMarkerId = 0;
    class TextMarker {
        constructor(doc, type) {
            this.lines = [];
            this.type = type;
            this.doc = doc;
            this.id = ++nextMarkerId;
        }
        clear() {
            if (this.explicitlyCleared)
                return;
            let cm = this.doc.cm, withOp = cm && !cm.curOp;
            if (withOp)
                c.startOperation(cm);
            if (b.hasHandler(this, 'clear')) {
                let found = this.find();
                if (found)
                    j.signalLater(this, 'clear', found.from, found.to);
            }
            let min = null, max = null;
            for (let i = 0; i < this.lines.length; ++i) {
                let line = this.lines[i];
                let span = h.getMarkedSpanFor(line.markedSpans, this);
                if (cm && !this.collapsed)
                    l.regLineChange(cm, e.lineNo(line), 'text');
                else if (cm) {
                    if (span.to != null)
                        max = e.lineNo(line);
                    if (span.from != null)
                        min = e.lineNo(line);
                }
                line.markedSpans = h.removeMarkedSpan(line.markedSpans, span);
                if (span.from == null && this.collapsed && !h.lineIsHidden(this.doc, line) && cm)
                    e.updateLineHeight(line, f.textHeight(cm.display));
            }
            if (cm && this.collapsed && !cm.options.lineWrapping)
                for (let i = 0; i < this.lines.length; ++i) {
                    let visual = h.visualLine(this.lines[i]), len = h.lineLength(visual);
                    if (len > cm.display.maxLineLength) {
                        cm.display.maxLine = visual;
                        cm.display.maxLineLength = len;
                        cm.display.maxLineChanged = true;
                    }
                }
            if (min != null && cm && this.collapsed)
                l.regChange(cm, min, max + 1);
            this.lines.length = 0;
            this.explicitlyCleared = true;
            if (this.atomic && this.doc.cantEdit) {
                this.doc.cantEdit = false;
                if (cm)
                    o.reCheckSelection(cm.doc);
            }
            if (cm)
                j.signalLater(cm, 'markerCleared', cm, this, min, max);
            if (withOp)
                c.endOperation(cm);
            if (this.parent)
                this.parent.clear();
        }
        find(side, lineObj) {
            if (side == null && this.type == 'bookmark')
                side = 1;
            let from, to;
            for (let i = 0; i < this.lines.length; ++i) {
                let line = this.lines[i];
                let span = h.getMarkedSpanFor(line.markedSpans, this);
                if (span.from != null) {
                    from = d.Pos(lineObj ? line : e.lineNo(line), span.from);
                    if (side == -1)
                        return from;
                }
                if (span.to != null) {
                    to = d.Pos(lineObj ? line : e.lineNo(line), span.to);
                    if (side == 1)
                        return to;
                }
            }
            return from && {
                from: from,
                to: to
            };
        }
        changed() {
            let pos = this.find(-1, true), widget = this, cm = this.doc.cm;
            if (!pos || !cm)
                return;
            c.runInOp(cm, () => {
                let line = pos.line, lineN = e.lineNo(pos.line);
                let view = f.findViewForLine(cm, lineN);
                if (view) {
                    f.clearLineMeasurementCacheFor(view);
                    cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
                }
                cm.curOp.updateMaxLine = true;
                if (!h.lineIsHidden(widget.doc, line) && widget.height != null) {
                    let oldHeight = widget.height;
                    widget.height = null;
                    let dHeight = k.widgetHeight(widget) - oldHeight;
                    if (dHeight)
                        e.updateLineHeight(line, line.height + dHeight);
                }
                j.signalLater(cm, 'markerChanged', cm, this);
            });
        }
        attachLine(line) {
            if (!this.lines.length && this.doc.cm) {
                let op = this.doc.cm.curOp;
                if (!op.maybeHiddenMarkers || i.indexOf(op.maybeHiddenMarkers, this) == -1)
                    (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
            this.lines.push(line);
        }
        detachLine(line) {
            this.lines.splice(i.indexOf(this.lines, line), 1);
            if (!this.lines.length && this.doc.cm) {
                let op = this.doc.cm.curOp;
                (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
            }
        }
    }
    b.eventMixin(TextMarker);
    function markText(doc, from, to, options, type) {
        if (options && options.shared)
            return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
            return c.operation(doc.cm, markText)(doc, from, to, options, type);
        let marker = new TextMarker(doc, type), diff = d.cmp(from, to);
        if (options)
            i.copyObj(options, marker, false);
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
            return marker;
        if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = a.eltP('span', [marker.replacedWith], 'CodeMirror-widget');
            if (!options.handleMouseEvents)
                marker.widgetNode.setAttribute('cm-ignore-events', 'true');
            if (options.insertLeft)
                marker.widgetNode.insertLeft = true;
        }
        if (marker.collapsed) {
            if (h.conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && h.conflictingCollapsedRange(doc, to.line, from, to, marker))
                throw new Error('Inserting collapsed marker partially overlapping an existing one');
            g.seeCollapsedSpans();
        }
        if (marker.addToHistory)
            n.addChangeToHistory(doc, {
                from: from,
                to: to,
                origin: 'markText'
            }, doc.sel, NaN);
        let curLine = from.line, cm = doc.cm, updateMaxLine;
        doc.iter(curLine, to.line + 1, line => {
            if (cm && marker.collapsed && !cm.options.lineWrapping && h.visualLine(line) == cm.display.maxLine)
                updateMaxLine = true;
            if (marker.collapsed && curLine != from.line)
                e.updateLineHeight(line, 0);
            h.addMarkedSpan(line, new h.MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
            ++curLine;
        });
        if (marker.collapsed)
            doc.iter(from.line, to.line + 1, line => {
                if (h.lineIsHidden(doc, line))
                    e.updateLineHeight(line, 0);
            });
        if (marker.clearOnEnter)
            b.on(marker, 'beforeCursorEnter', () => marker.clear());
        if (marker.readOnly) {
            g.seeReadOnlySpans();
            if (doc.history.done.length || doc.history.undone.length)
                doc.clearHistory();
        }
        if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
        }
        if (cm) {
            if (updateMaxLine)
                cm.curOp.updateMaxLine = true;
            if (marker.collapsed)
                l.regChange(cm, from.line, to.line + 1);
            else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title)
                for (let i = from.line; i <= to.line; i++)
                    l.regLineChange(cm, i, 'text');
            if (marker.atomic)
                o.reCheckSelection(cm.doc);
            j.signalLater(cm, 'markerAdded', cm, marker);
        }
        return marker;
    }
    class SharedTextMarker {
        constructor(markers, primary) {
            this.markers = markers;
            this.primary = primary;
            for (let i = 0; i < markers.length; ++i)
                markers[i].parent = this;
        }
        clear() {
            if (this.explicitlyCleared)
                return;
            this.explicitlyCleared = true;
            for (let i = 0; i < this.markers.length; ++i)
                this.markers[i].clear();
            j.signalLater(this, 'clear');
        }
        find(side, lineObj) {
            return this.primary.find(side, lineObj);
        }
    }
    b.eventMixin(SharedTextMarker);
    function markTextShared(doc, from, to, options, type) {
        options = i.copyObj(options);
        options.shared = false;
        let markers = [markText(doc, from, to, options, type)], primary = markers[0];
        let widget = options.widgetNode;
        m.linkedDocs(doc, doc => {
            if (widget)
                options.widgetNode = widget.cloneNode(true);
            markers.push(markText(doc, d.clipPos(doc, from), d.clipPos(doc, to), options, type));
            for (let i = 0; i < doc.linked.length; ++i)
                if (doc.linked[i].isParent)
                    return;
            primary = i.lst(markers);
        });
        return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(d.Pos(doc.first, 0), doc.clipPos(d.Pos(doc.lastLine())), m => m.parent);
    }
    function copySharedMarkers(doc, markers) {
        for (let i = 0; i < markers.length; i++) {
            let marker = markers[i], pos = marker.find();
            let mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (d.cmp(mFrom, mTo)) {
                let subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark);
                subMark.parent = marker;
            }
        }
    }
    function detachSharedMarkers(markers) {
        for (let i = 0; i < markers.length; i++) {
            let marker = markers[i], linked = [marker.primary.doc];
            m.linkedDocs(marker.primary.doc, d => linked.push(d));
            for (let j = 0; j < marker.markers.length; j++) {
                let subMarker = marker.markers[j];
                if (i.indexOf(linked, subMarker.doc) == -1) {
                    subMarker.parent = null;
                    marker.markers.splice(j--, 1);
                }
            }
        }
    }
    return {
        TextMarker: TextMarker,
        markText: markText,
        SharedTextMarker: SharedTextMarker,
        findSharedMarkers: findSharedMarkers,
        copySharedMarkers: copySharedMarkers,
        detachSharedMarkers: detachSharedMarkers
    };
});
define('skylark-codemirror/primitives/model/Doc',[
    '../display/operations',
    '../line/line_data',
    '../line/pos',
    '../line/spans',
    '../line/utils_line',
    '../util/dom',
    '../util/feature_detection',
    '../util/misc',
    '../display/scrolling',
    './changes',
    './change_measurement',
    './chunk',
    './document_data',
    './history',
    './line_widget',
    './mark_text',
    './selection',
    './selection_updates'
], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
    'use strict';
    let nextDocId = 0;
    let Doc = function (text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc))
            return new Doc(text, mode, firstLine, lineSep, direction);
        if (firstLine == null)
            firstLine = 0;
        l.BranchChunk.call(this, [new l.LeafChunk([new b.Line('', null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        let start = c.Pos(firstLine, 0);
        this.sel = q.simpleSelection(start);
        this.history = new n.History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == 'rtl' ? 'rtl' : 'ltr';
        this.extend = false;
        if (typeof text == 'string')
            text = this.splitLines(text);
        m.updateDoc(this, {
            from: start,
            to: start,
            text: text
        });
        r.setSelection(this, q.simpleSelection(start), h.sel_dontScroll);
    };
    Doc.prototype = h.createObj(l.BranchChunk.prototype, {
        constructor: Doc,
        iter: function (from, to, op) {
            if (op)
                this.iterN(from - this.first, to - from, op);
            else
                this.iterN(this.first, this.first + this.size, from);
        },
        insert: function (at, lines) {
            let height = 0;
            for (let i = 0; i < lines.length; ++i)
                height += lines[i].height;
            this.insertInner(at - this.first, lines, height);
        },
        remove: function (at, n) {
            this.removeInner(at - this.first, n);
        },
        getValue: function (lineSep) {
            let lines = e.getLines(this, this.first, this.first + this.size);
            if (lineSep === false)
                return lines;
            return lines.join(lineSep || this.lineSeparator());
        },
        setValue: a.docMethodOp(function (code) {
            let top = c.Pos(this.first, 0), last = this.first + this.size - 1;
            j.makeChange(this, {
                from: top,
                to: c.Pos(last, e.getLine(this, last).text.length),
                text: this.splitLines(code),
                origin: 'setValue',
                full: true
            }, true);
            if (this.cm)
                i.scrollToCoords(this.cm, 0, 0);
            r.setSelection(this, q.simpleSelection(top), h.sel_dontScroll);
        }),
        replaceRange: function (code, from, to, origin) {
            from = c.clipPos(this, from);
            to = to ? c.clipPos(this, to) : from;
            j.replaceRange(this, code, from, to, origin);
        },
        getRange: function (from, to, lineSep) {
            let lines = e.getBetween(this, c.clipPos(this, from), c.clipPos(this, to));
            if (lineSep === false)
                return lines;
            return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function (line) {
            let l = this.getLineHandle(line);
            return l && l.text;
        },
        getLineHandle: function (line) {
            if (e.isLine(this, line))
                return e.getLine(this, line);
        },
        getLineNumber: function (line) {
            return e.lineNo(line);
        },
        getLineHandleVisualStart: function (line) {
            if (typeof line == 'number')
                line = e.getLine(this, line);
            return d.visualLine(line);
        },
        lineCount: function () {
            return this.size;
        },
        firstLine: function () {
            return this.first;
        },
        lastLine: function () {
            return this.first + this.size - 1;
        },
        clipPos: function (pos) {
            return c.clipPos(this, pos);
        },
        getCursor: function (start) {
            let range = this.sel.primary(), pos;
            if (start == null || start == 'head')
                pos = range.head;
            else if (start == 'anchor')
                pos = range.anchor;
            else if (start == 'end' || start == 'to' || start === false)
                pos = range.to();
            else
                pos = range.from();
            return pos;
        },
        listSelections: function () {
            return this.sel.ranges;
        },
        somethingSelected: function () {
            return this.sel.somethingSelected();
        },
        setCursor: a.docMethodOp(function (line, ch, options) {
            r.setSimpleSelection(this, c.clipPos(this, typeof line == 'number' ? c.Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: a.docMethodOp(function (anchor, head, options) {
            r.setSimpleSelection(this, c.clipPos(this, anchor), c.clipPos(this, head || anchor), options);
        }),
        extendSelection: a.docMethodOp(function (head, other, options) {
            r.extendSelection(this, c.clipPos(this, head), other && c.clipPos(this, other), options);
        }),
        extendSelections: a.docMethodOp(function (heads, options) {
            r.extendSelections(this, c.clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: a.docMethodOp(function (f, options) {
            let heads = h.map(this.sel.ranges, f);
            r.extendSelections(this, c.clipPosArray(this, heads), options);
        }),
        setSelections: a.docMethodOp(function (ranges, primary, options) {
            if (!ranges.length)
                return;
            let out = [];
            for (let i = 0; i < ranges.length; i++)
                out[i] = new q.Range(c.clipPos(this, ranges[i].anchor), c.clipPos(this, ranges[i].head));
            if (primary == null)
                primary = Math.min(ranges.length - 1, this.sel.primIndex);
            r.setSelection(this, q.normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: a.docMethodOp(function (anchor, head, options) {
            let ranges = this.sel.ranges.slice(0);
            ranges.push(new q.Range(c.clipPos(this, anchor), c.clipPos(this, head || anchor)));
            r.setSelection(this, q.normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function (lineSep) {
            let ranges = this.sel.ranges, lines;
            for (let i = 0; i < ranges.length; i++) {
                let sel = e.getBetween(this, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false)
                return lines;
            else
                return lines.join(lineSep || this.lineSeparator());
        },
        getSelections: function (lineSep) {
            let parts = [], ranges = this.sel.ranges;
            for (let i = 0; i < ranges.length; i++) {
                let sel = e.getBetween(this, ranges[i].from(), ranges[i].to());
                if (lineSep !== false)
                    sel = sel.join(lineSep || this.lineSeparator());
                parts[i] = sel;
            }
            return parts;
        },
        replaceSelection: function (code, collapse, origin) {
            let dup = [];
            for (let i = 0; i < this.sel.ranges.length; i++)
                dup[i] = code;
            this.replaceSelections(dup, collapse, origin || '+input');
        },
        replaceSelections: a.docMethodOp(function (code, collapse, origin) {
            let changes = [], sel = this.sel;
            for (let i = 0; i < sel.ranges.length; i++) {
                let range = sel.ranges[i];
                changes[i] = {
                    from: range.from(),
                    to: range.to(),
                    text: this.splitLines(code[i]),
                    origin: origin
                };
            }
            let newSel = collapse && collapse != 'end' && k.computeReplacedSel(this, changes, collapse);
            for (let i = changes.length - 1; i >= 0; i--)
                j.makeChange(this, changes[i]);
            if (newSel)
                r.setSelectionReplaceHistory(this, newSel);
            else if (this.cm)
                i.ensureCursorVisible(this.cm);
        }),
        undo: a.docMethodOp(function () {
            j.makeChangeFromHistory(this, 'undo');
        }),
        redo: a.docMethodOp(function () {
            j.makeChangeFromHistory(this, 'redo');
        }),
        undoSelection: a.docMethodOp(function () {
            j.makeChangeFromHistory(this, 'undo', true);
        }),
        redoSelection: a.docMethodOp(function () {
            j.makeChangeFromHistory(this, 'redo', true);
        }),
        setExtending: function (val) {
            this.extend = val;
        },
        getExtending: function () {
            return this.extend;
        },
        historySize: function () {
            let hist = this.history, done = 0, undone = 0;
            for (let i = 0; i < hist.done.length; i++)
                if (!hist.done[i].ranges)
                    ++done;
            for (let i = 0; i < hist.undone.length; i++)
                if (!hist.undone[i].ranges)
                    ++undone;
            return {
                undo: done,
                redo: undone
            };
        },
        clearHistory: function () {
            this.history = new n.History(this.history.maxGeneration);
        },
        markClean: function () {
            this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function (forceSplit) {
            if (forceSplit)
                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            return this.history.generation;
        },
        isClean: function (gen) {
            return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function () {
            return {
                done: n.copyHistoryArray(this.history.done),
                undone: n.copyHistoryArray(this.history.undone)
            };
        },
        setHistory: function (histData) {
            let hist = this.history = new n.History(this.history.maxGeneration);
            hist.done = n.copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = n.copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: a.docMethodOp(function (line, gutterID, value) {
            return j.changeLine(this, line, 'gutter', line => {
                let markers = line.gutterMarkers || (line.gutterMarkers = {});
                markers[gutterID] = value;
                if (!value && h.isEmpty(markers))
                    line.gutterMarkers = null;
                return true;
            });
        }),
        clearGutter: a.docMethodOp(function (gutterID) {
            this.iter(line => {
                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                    j.changeLine(this, line, 'gutter', () => {
                        line.gutterMarkers[gutterID] = null;
                        if (h.isEmpty(line.gutterMarkers))
                            line.gutterMarkers = null;
                        return true;
                    });
                }
            });
        }),
        lineInfo: function (line) {
            let n;
            if (typeof line == 'number') {
                if (!e.isLine(this, line))
                    return null;
                n = line;
                line = e.getLine(this, line);
                if (!line)
                    return null;
            } else {
                n = e.lineNo(line);
                if (n == null)
                    return null;
            }
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            };
        },
        addLineClass: a.docMethodOp(function (handle, where, cls) {
            return j.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {
                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';
                if (!line[prop])
                    line[prop] = cls;
                else if (f.classTest(cls).test(line[prop]))
                    return false;
                else
                    line[prop] += ' ' + cls;
                return true;
            });
        }),
        removeLineClass: a.docMethodOp(function (handle, where, cls) {
            return j.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {
                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';
                let cur = line[prop];
                if (!cur)
                    return false;
                else if (cls == null)
                    line[prop] = null;
                else {
                    let found = cur.match(f.classTest(cls));
                    if (!found)
                        return false;
                    let end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
                }
                return true;
            });
        }),
        addLineWidget: a.docMethodOp(function (handle, node, options) {
            return o.addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function (widget) {
            widget.clear();
        },
        markText: function (from, to, options) {
            return p.markText(this, c.clipPos(this, from), c.clipPos(this, to), options, options && options.type || 'range');
        },
        setBookmark: function (pos, options) {
            let realOpts = {
                replacedWith: options && (options.nodeType == null ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: false,
                shared: options && options.shared,
                handleMouseEvents: options && options.handleMouseEvents
            };
            pos = c.clipPos(this, pos);
            return p.markText(this, pos, pos, realOpts, 'bookmark');
        },
        findMarksAt: function (pos) {
            pos = c.clipPos(this, pos);
            let markers = [], spans = e.getLine(this, pos.line).markedSpans;
            if (spans)
                for (let i = 0; i < spans.length; ++i) {
                    let span = spans[i];
                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                        markers.push(span.marker.parent || span.marker);
                }
            return markers;
        },
        findMarks: function (from, to, filter) {
            from = c.clipPos(this, from);
            to = c.clipPos(this, to);
            let found = [], lineNo = from.line;
            this.iter(from.line, to.line + 1, line => {
                let spans = line.markedSpans;
                if (spans)
                    for (let i = 0; i < spans.length; i++) {
                        let span = spans[i];
                        if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))
                            found.push(span.marker.parent || span.marker);
                    }
                ++lineNo;
            });
            return found;
        },
        getAllMarks: function () {
            let markers = [];
            this.iter(line => {
                let sps = line.markedSpans;
                if (sps)
                    for (let i = 0; i < sps.length; ++i)
                        if (sps[i].from != null)
                            markers.push(sps[i].marker);
            });
            return markers;
        },
        posFromIndex: function (off) {
            let ch, lineNo = this.first, sepSize = this.lineSeparator().length;
            this.iter(line => {
                let sz = line.text.length + sepSize;
                if (sz > off) {
                    ch = off;
                    return true;
                }
                off -= sz;
                ++lineNo;
            });
            return c.clipPos(this, c.Pos(lineNo, ch));
        },
        indexFromPos: function (coords) {
            coords = c.clipPos(this, coords);
            let index = coords.ch;
            if (coords.line < this.first || coords.ch < 0)
                return 0;
            let sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, line => {
                index += line.text.length + sepSize;
            });
            return index;
        },
        copy: function (copyHistory) {
            let doc = new Doc(e.getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            doc.scrollTop = this.scrollTop;
            doc.scrollLeft = this.scrollLeft;
            doc.sel = this.sel;
            doc.extend = false;
            if (copyHistory) {
                doc.history.undoDepth = this.history.undoDepth;
                doc.setHistory(this.getHistory());
            }
            return doc;
        },
        linkedDoc: function (options) {
            if (!options)
                options = {};
            let from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from)
                from = options.from;
            if (options.to != null && options.to < to)
                to = options.to;
            let copy = new Doc(e.getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options.sharedHist)
                copy.history = this.history;
            (this.linked || (this.linked = [])).push({
                doc: copy,
                sharedHist: options.sharedHist
            });
            copy.linked = [{
                    doc: this,
                    isParent: true,
                    sharedHist: options.sharedHist
                }];
            p.copySharedMarkers(copy, p.findSharedMarkers(this));
            return copy;
        },
        unlinkDoc: function (other) {
            //if (other instanceof CodeMirror) // modified by lwf
            if (other.doc)
                other = other.doc;
            if (this.linked)
                for (let i = 0; i < this.linked.length; ++i) {
                    let link = this.linked[i];
                    if (link.doc != other)
                        continue;
                    this.linked.splice(i, 1);
                    other.unlinkDoc(this);
                    p.detachSharedMarkers(p.findSharedMarkers(this));
                    break;
                }
            if (other.history == this.history) {
                let splitIds = [other.id];
                m.linkedDocs(other, doc => splitIds.push(doc.id), true);
                other.history = new n.History(null);
                other.history.done = n.copyHistoryArray(this.history.done, splitIds);
                other.history.undone = n.copyHistoryArray(this.history.undone, splitIds);
            }
        },
        iterLinkedDocs: function (f) {
            m.linkedDocs(this, f);
        },
        getMode: function () {
            return this.mode;
        },
        getEditor: function () {
            return this.cm;
        },
        splitLines: function (str) {
            if (this.lineSep)
                return str.split(this.lineSep);
            return g.splitLinesAuto(str);
        },
        lineSeparator: function () {
            return this.lineSep || '\n';
        },
        setDirection: a.docMethodOp(function (dir) {
            if (dir != 'rtl')
                dir = 'ltr';
            if (dir == this.direction)
                return;
            this.direction = dir;
            this.iter(line => line.order = null);
            if (this.cm)
                m.directionChanged(this.cm);
        })
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    return Doc;
});
define('skylark-codemirror/primitives/edit/drop_events',[
    '../display/selection',
    '../display/operations',
    '../line/pos',
    '../measurement/position_measurement',
    '../measurement/widgets',
    '../model/changes',
    '../model/change_measurement',
    '../model/selection',
    '../model/selection_updates',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/misc'
], function (a, b, c, d, e, f, g, h, i, j, k, l, m) {
    'use strict';
    let lastDrop = 0;
    function onDrop(e) {
        let cm = this;
        clearDragCursor(cm);
        if (l.signalDOMEvent(cm, e) || e.eventInWidget(cm.display, e))
            return;
        l.e_preventDefault(e);
        if (j.ie)
            lastDrop = +new Date();
        let pos = d.posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly())
            return;
        if (files && files.length && window.FileReader && window.File) {
            let n = files.length, text = Array(n), read = 0;
            let loadFile = (file, i) => {
                if (cm.options.allowDropFileTypes && m.indexOf(cm.options.allowDropFileTypes, file.type) == -1)
                    return;
                let reader = new FileReader();
                reader.onload = b.operation(cm, () => {
                    let content = reader.result;
                    if (/[\x00-\x08\x0e-\x1f]{2}/.test(content))
                        content = '';
                    text[i] = content;
                    if (++read == n) {
                        pos = c.clipPos(cm.doc, pos);
                        let change = {
                            from: pos,
                            to: pos,
                            text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                            origin: 'paste'
                        };
                        f.makeChange(cm.doc, change);
                        i.setSelectionReplaceHistory(cm.doc, h.simpleSelection(pos, g.changeEnd(change)));
                    }
                });
                reader.readAsText(file);
            };
            for (let i = 0; i < n; ++i)
                loadFile(files[i], i);
        } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
                cm.state.draggingText(e);
                setTimeout(() => cm.display.input.focus(), 20);
                return;
            }
            try {
                let text = e.dataTransfer.getData('Text');
                if (text) {
                    let selected;
                    if (cm.state.draggingText && !cm.state.draggingText.copy)
                        selected = cm.listSelections();
                    i.setSelectionNoUndo(cm.doc, h.simpleSelection(pos, pos));
                    if (selected)
                        for (let i = 0; i < selected.length; ++i)
                            f.replaceRange(cm.doc, '', selected[i].anchor, selected[i].head, 'drag');
                    cm.replaceSelection(text, 'around', 'paste');
                    cm.display.input.focus();
                }
            } catch (e) {
            }
        }
    }
    function onDragStart(cm, e) {
        if (j.ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            l.e_stop(e);
            return;
        }
        if (l.signalDOMEvent(cm, e) || e.eventInWidget(cm.display, e))
            return;
        e.dataTransfer.setData('Text', cm.getSelection());
        e.dataTransfer.effectAllowed = 'copyMove';
        if (e.dataTransfer.setDragImage && !j.safari) {
            let img = k.elt('img', null, null, 'position: fixed; left: 0; top: 0;');
            img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
            if (j.presto) {
                img.width = img.height = 1;
                cm.display.wrapper.appendChild(img);
                img._top = img.offsetTop;
            }
            e.dataTransfer.setDragImage(img, 0, 0);
            if (j.presto)
                img.parentNode.removeChild(img);
        }
    }
    function onDragOver(cm, e) {
        let pos = d.posFromMouse(cm, e);
        if (!pos)
            return;
        let frag = document.createDocumentFragment();
        a.drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
            cm.display.dragCursor = k.elt('div', null, 'CodeMirror-cursors CodeMirror-dragcursors');
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        k.removeChildrenAndAdd(cm.display.dragCursor, frag);
    }
    function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
        }
    }
    return {
        onDrop: onDrop,
        onDragStart: onDragStart,
        onDragOver: onDragOver,
        clearDragCursor: clearDragCursor
    };
});
define('skylark-codemirror/primitives/edit/global_events',[
    '../display/focus',
    '../util/event'
], function (focuses, events) {
    'use strict';
    function forEachCodeMirror(f) {
        if (!document.getElementsByClassName)
            return;
        let byClass = document.getElementsByClassName('CodeMirror'), editors = [];
        for (let i = 0; i < byClass.length; i++) {
            let cm = byClass[i].CodeMirror;
            if (cm)
                editors.push(cm);
        }
        if (editors.length)
            editors[0].operation(() => {
                for (let i = 0; i < editors.length; i++)
                    f(editors[i]);
            });
    }
    let globalsRegistered = false;
    function ensureGlobalHandlers() {
        if (globalsRegistered)
            return;
        registerGlobalHandlers();
        globalsRegistered = true;
    }
    function registerGlobalHandlers() {
        let resizeTimer;
        events.on(window, 'resize', () => {
            if (resizeTimer == null)
                resizeTimer = setTimeout(() => {
                    resizeTimer = null;
                    forEachCodeMirror(onResize);
                }, 100);
        });
        events.on(window, 'blur', () => forEachCodeMirror(focuses.onBlur));
    }
    function onResize(cm) {
        let d = cm.display;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
    }
    return { ensureGlobalHandlers: ensureGlobalHandlers };
});
define('skylark-codemirror/primitives/input/keynames',[],function () {
    'use strict';
    let keyNames = {
        3: 'Pause',
        8: 'Backspace',
        9: 'Tab',
        13: 'Enter',
        16: 'Shift',
        17: 'Ctrl',
        18: 'Alt',
        19: 'Pause',
        20: 'CapsLock',
        27: 'Esc',
        32: 'Space',
        33: 'PageUp',
        34: 'PageDown',
        35: 'End',
        36: 'Home',
        37: 'Left',
        38: 'Up',
        39: 'Right',
        40: 'Down',
        44: 'PrintScrn',
        45: 'Insert',
        46: 'Delete',
        59: ';',
        61: '=',
        91: 'Mod',
        92: 'Mod',
        93: 'Mod',
        106: '*',
        107: '=',
        109: '-',
        110: '.',
        111: '/',
        127: 'Delete',
        145: 'ScrollLock',
        173: '-',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: "'",
        63232: 'Up',
        63233: 'Down',
        63234: 'Left',
        63235: 'Right',
        63272: 'Delete',
        63273: 'Home',
        63275: 'End',
        63276: 'PageUp',
        63277: 'PageDown',
        63302: 'Insert'
    };
    for (let i = 0; i < 10; i++)
        keyNames[i + 48] = keyNames[i + 96] = String(i);
    for (let i = 65; i <= 90; i++)
        keyNames[i] = String.fromCharCode(i);
    for (let i = 1; i <= 12; i++)
        keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
    return { keyNames: keyNames };
});
define('skylark-codemirror/primitives/input/keymap',[
    '../util/browser',
    '../util/misc',
    './keynames'
], function (browser, misc, keynames) {
    'use strict';
    let keyMap = {};
    keyMap.basic = {
        'Left': 'goCharLeft',
        'Right': 'goCharRight',
        'Up': 'goLineUp',
        'Down': 'goLineDown',
        'End': 'goLineEnd',
        'Home': 'goLineStartSmart',
        'PageUp': 'goPageUp',
        'PageDown': 'goPageDown',
        'Delete': 'delCharAfter',
        'Backspace': 'delCharBefore',
        'Shift-Backspace': 'delCharBefore',
        'Tab': 'defaultTab',
        'Shift-Tab': 'indentAuto',
        'Enter': 'newlineAndIndent',
        'Insert': 'toggleOverwrite',
        'Esc': 'singleSelection'
    };
    keyMap.pcDefault = {
        'Ctrl-A': 'selectAll',
        'Ctrl-D': 'deleteLine',
        'Ctrl-Z': 'undo',
        'Shift-Ctrl-Z': 'redo',
        'Ctrl-Y': 'redo',
        'Ctrl-Home': 'goDocStart',
        'Ctrl-End': 'goDocEnd',
        'Ctrl-Up': 'goLineUp',
        'Ctrl-Down': 'goLineDown',
        'Ctrl-Left': 'goGroupLeft',
        'Ctrl-Right': 'goGroupRight',
        'Alt-Left': 'goLineStart',
        'Alt-Right': 'goLineEnd',
        'Ctrl-Backspace': 'delGroupBefore',
        'Ctrl-Delete': 'delGroupAfter',
        'Ctrl-S': 'save',
        'Ctrl-F': 'find',
        'Ctrl-G': 'findNext',
        'Shift-Ctrl-G': 'findPrev',
        'Shift-Ctrl-F': 'replace',
        'Shift-Ctrl-R': 'replaceAll',
        'Ctrl-[': 'indentLess',
        'Ctrl-]': 'indentMore',
        'Ctrl-U': 'undoSelection',
        'Shift-Ctrl-U': 'redoSelection',
        'Alt-U': 'redoSelection',
        'fallthrough': 'basic'
    };
    keyMap.emacsy = {
        'Ctrl-F': 'goCharRight',
        'Ctrl-B': 'goCharLeft',
        'Ctrl-P': 'goLineUp',
        'Ctrl-N': 'goLineDown',
        'Alt-F': 'goWordRight',
        'Alt-B': 'goWordLeft',
        'Ctrl-A': 'goLineStart',
        'Ctrl-E': 'goLineEnd',
        'Ctrl-V': 'goPageDown',
        'Shift-Ctrl-V': 'goPageUp',
        'Ctrl-D': 'delCharAfter',
        'Ctrl-H': 'delCharBefore',
        'Alt-D': 'delWordAfter',
        'Alt-Backspace': 'delWordBefore',
        'Ctrl-K': 'killLine',
        'Ctrl-T': 'transposeChars',
        'Ctrl-O': 'openLine'
    };
    keyMap.macDefault = {
        'Cmd-A': 'selectAll',
        'Cmd-D': 'deleteLine',
        'Cmd-Z': 'undo',
        'Shift-Cmd-Z': 'redo',
        'Cmd-Y': 'redo',
        'Cmd-Home': 'goDocStart',
        'Cmd-Up': 'goDocStart',
        'Cmd-End': 'goDocEnd',
        'Cmd-Down': 'goDocEnd',
        'Alt-Left': 'goGroupLeft',
        'Alt-Right': 'goGroupRight',
        'Cmd-Left': 'goLineLeft',
        'Cmd-Right': 'goLineRight',
        'Alt-Backspace': 'delGroupBefore',
        'Ctrl-Alt-Backspace': 'delGroupAfter',
        'Alt-Delete': 'delGroupAfter',
        'Cmd-S': 'save',
        'Cmd-F': 'find',
        'Cmd-G': 'findNext',
        'Shift-Cmd-G': 'findPrev',
        'Cmd-Alt-F': 'replace',
        'Shift-Cmd-Alt-F': 'replaceAll',
        'Cmd-[': 'indentLess',
        'Cmd-]': 'indentMore',
        'Cmd-Backspace': 'delWrappedLineLeft',
        'Cmd-Delete': 'delWrappedLineRight',
        'Cmd-U': 'undoSelection',
        'Shift-Cmd-U': 'redoSelection',
        'Ctrl-Up': 'goDocStart',
        'Ctrl-Down': 'goDocEnd',
        'fallthrough': [
            'basic',
            'emacsy'
        ]
    };
    keyMap['default'] = browser.mac ? keyMap.macDefault : keyMap.pcDefault;
    function normalizeKeyName(name) {
        let parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        let alt, ctrl, shift, cmd;
        for (let i = 0; i < parts.length - 1; i++) {
            let mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod))
                cmd = true;
            else if (/^a(lt)?$/i.test(mod))
                alt = true;
            else if (/^(c|ctrl|control)$/i.test(mod))
                ctrl = true;
            else if (/^s(hift)?$/i.test(mod))
                shift = true;
            else
                throw new Error('Unrecognized modifier name: ' + mod);
        }
        if (alt)
            name = 'Alt-' + name;
        if (ctrl)
            name = 'Ctrl-' + name;
        if (cmd)
            name = 'Cmd-' + name;
        if (shift)
            name = 'Shift-' + name;
        return name;
    }
    function normalizeKeyMap(keymap) {
        let copy = {};
        for (let keyname in keymap)
            if (keymap.hasOwnProperty(keyname)) {
                let value = keymap[keyname];
                if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
                    continue;
                if (value == '...') {
                    delete keymap[keyname];
                    continue;
                }
                let keys = misc.map(keyname.split(' '), normalizeKeyName);
                for (let i = 0; i < keys.length; i++) {
                    let val, name;
                    if (i == keys.length - 1) {
                        name = keys.join(' ');
                        val = value;
                    } else {
                        name = keys.slice(0, i + 1).join(' ');
                        val = '...';
                    }
                    let prev = copy[name];
                    if (!prev)
                        copy[name] = val;
                    else if (prev != val)
                        throw new Error('Inconsistent bindings for ' + name);
                }
                delete keymap[keyname];
            }
        for (let prop in copy)
            keymap[prop] = copy[prop];
        return keymap;
    }
    function lookupKey(key, map, handle, context) {
        map = getKeyMap(map);
        let found = map.call ? map.call(key, context) : map[key];
        if (found === false)
            return 'nothing';
        if (found === '...')
            return 'multi';
        if (found != null && handle(found))
            return 'handled';
        if (map.fallthrough) {
            if (Object.prototype.toString.call(map.fallthrough) != '[object Array]')
                return lookupKey(key, map.fallthrough, handle, context);
            for (let i = 0; i < map.fallthrough.length; i++) {
                let result = lookupKey(key, map.fallthrough[i], handle, context);
                if (result)
                    return result;
            }
        }
    }
    function isModifierKey(value) {
        let name = typeof value == 'string' ? value : keynames.keyNames[value.keyCode];
        return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
    }
    function addModifierNames(name, event, noShift) {
        let base = name;
        if (event.altKey && base != 'Alt')
            name = 'Alt-' + name;
        if ((browser.flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != 'Ctrl')
            name = 'Ctrl-' + name;
        if ((browser.flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != 'Cmd')
            name = 'Cmd-' + name;
        if (!noShift && event.shiftKey && base != 'Shift')
            name = 'Shift-' + name;
        return name;
    }
    function keyName(event, noShift) {
        if (browser.presto && event.keyCode == 34 && event['char'])
            return false;
        let name = keynames.keyNames[event.keyCode];
        if (name == null || event.altGraphKey)
            return false;
        if (event.keyCode == 3 && event.code)
            name = event.code;
        return addModifierNames(name, event, noShift);
    }
    function getKeyMap(val) {
        return typeof val == 'string' ? keyMap[val] : val;
    }
    return {
        keyMap: keyMap,
        normalizeKeyMap: normalizeKeyMap,
        lookupKey: lookupKey,
        isModifierKey: isModifierKey,
        addModifierNames: addModifierNames,
        keyName: keyName,
        getKeyMap: getKeyMap
    };
});
define('skylark-codemirror/primitives/edit/deleteNearSelection',[
    '../display/operations',
    '../display/scrolling',
    '../line/pos',
    '../model/changes',
    '../util/misc'
], function (operations, scrolling, line_pos, changes, misc) {
    'use strict';
    function deleteNearSelection(cm, compute) {
        let ranges = cm.doc.sel.ranges, kill = [];
        for (let i = 0; i < ranges.length; i++) {
            let toKill = compute(ranges[i]);
            while (kill.length && line_pos.cmp(toKill.from, misc.lst(kill).to) <= 0) {
                let replaced = kill.pop();
                if (line_pos.cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break;
                }
            }
            kill.push(toKill);
        }
        operations.runInOp(cm, () => {
            for (let i = kill.length - 1; i >= 0; i--)
                changes.replaceRange(cm.doc, '', kill[i].from, kill[i].to, '+delete');
            scrolling.ensureCursorVisible(cm);
        });
    }
    return { deleteNearSelection: deleteNearSelection };
});
define('skylark-codemirror/primitives/input/movement',[
    '../line/pos',
    '../measurement/position_measurement',
    '../util/bidi',
    '../util/misc'
], function (line_pos, position_measurement, bidi, misc) {
    'use strict';
    function moveCharLogically(line, ch, dir) {
        let target = misc.skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
    }
    function moveLogically(line, start, dir) {
        let ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new line_pos.Pos(start.line, ch, dir < 0 ? 'after' : 'before');
    }
    function endOfLine(visually, cm, lineObj, lineNo, dir) {
        if (visually) {
            let order = bidi.getOrder(lineObj, cm.doc.direction);
            if (order) {
                let part = dir < 0 ? misc.lst(order) : order[0];
                let moveInStorageOrder = dir < 0 == (part.level == 1);
                let sticky = moveInStorageOrder ? 'after' : 'before';
                let ch;
                if (part.level > 0 || cm.doc.direction == 'rtl') {
                    let prep = position_measurement.prepareMeasureForLine(cm, lineObj);
                    ch = dir < 0 ? lineObj.text.length - 1 : 0;
                    let targetTop = position_measurement.measureCharPrepared(cm, prep, ch).top;
                    ch = misc.findFirst(ch => position_measurement.measureCharPrepared(cm, prep, ch).top == targetTop, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
                    if (sticky == 'before')
                        ch = moveCharLogically(lineObj, ch, 1);
                } else
                    ch = dir < 0 ? part.to : part.from;
                return new line_pos.Pos(lineNo, ch, sticky);
            }
        }
        return new line_pos.Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? 'before' : 'after');
    }
    function moveVisually(cm, line, start, dir) {
        let bidi = bidi.getOrder(line, cm.doc.direction);
        if (!bidi)
            return moveLogically(line, start, dir);
        if (start.ch >= line.text.length) {
            start.ch = line.text.length;
            start.sticky = 'before';
        } else if (start.ch <= 0) {
            start.ch = 0;
            start.sticky = 'after';
        }
        let partPos = bidi.getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
        if (cm.doc.direction == 'ltr' && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
            return moveLogically(line, start, dir);
        }
        let mv = (pos, dir) => moveCharLogically(line, pos instanceof line_pos.Pos ? pos.ch : pos, dir);
        let prep;
        let getWrappedLineExtent = ch => {
            if (!cm.options.lineWrapping)
                return {
                    begin: 0,
                    end: line.text.length
                };
            prep = prep || position_measurement.prepareMeasureForLine(cm, line);
            return position_measurement.wrappedLineExtentChar(cm, line, prep, ch);
        };
        let wrappedLineExtent = getWrappedLineExtent(start.sticky == 'before' ? mv(start, -1) : start.ch);
        if (cm.doc.direction == 'rtl' || part.level == 1) {
            let moveInStorageOrder = part.level == 1 == dir < 0;
            let ch = mv(start, moveInStorageOrder ? 1 : -1);
            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
                let sticky = moveInStorageOrder ? 'before' : 'after';
                return new line_pos.Pos(start.line, ch, sticky);
            }
        }
        let searchInVisualLine = (partPos, dir, wrappedLineExtent) => {
            let getRes = (ch, moveInStorageOrder) => moveInStorageOrder ? new line_pos.Pos(start.line, mv(ch, 1), 'before') : new line_pos.Pos(start.line, ch, 'after');
            for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
                let part = bidi[partPos];
                let moveInStorageOrder = dir > 0 == (part.level != 1);
                let ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                if (part.from <= ch && ch < part.to)
                    return getRes(ch, moveInStorageOrder);
                ch = moveInStorageOrder ? part.from : mv(part.to, -1);
                if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end)
                    return getRes(ch, moveInStorageOrder);
            }
        };
        let res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
        if (res)
            return res;
        let nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
            if (res)
                return res;
        }
        return null;
    }
    return {
        moveLogically: moveLogically,
        endOfLine: endOfLine,
        moveVisually: moveVisually
    };
});
define('skylark-codemirror/primitives/edit/commands',[
    './deleteNearSelection',
    '../display/operations',
    '../display/scrolling',
    '../input/movement',
    '../line/pos',
    '../line/spans',
    '../line/utils_line',
    '../model/selection',
    '../model/selection_updates',
    '../util/misc',
    '../util/bidi'
], function (a, b, c, d, e, f, g, h, i, j, k) {
    'use strict';
    let commands = {
        selectAll: i.selectAll,
        singleSelection: cm => cm.setSelection(cm.getCursor('anchor'), cm.getCursor('head'), j.sel_dontScroll),
        killLine: cm => a.deleteNearSelection(cm, range => {
            if (range.empty()) {
                let len = g.getLine(cm.doc, range.head.line).text.length;
                if (range.head.ch == len && range.head.line < cm.lastLine())
                    return {
                        from: range.head,
                        to: e.Pos(range.head.line + 1, 0)
                    };
                else
                    return {
                        from: range.head,
                        to: e.Pos(range.head.line, len)
                    };
            } else {
                return {
                    from: range.from(),
                    to: range.to()
                };
            }
        }),
        deleteLine: cm => a.deleteNearSelection(cm, range => ({
            from: e.Pos(range.from().line, 0),
            to: e.clipPos(cm.doc, e.Pos(range.to().line + 1, 0))
        })),
        delLineLeft: cm => a.deleteNearSelection(cm, range => ({
            from: e.Pos(range.from().line, 0),
            to: range.from()
        })),
        delWrappedLineLeft: cm => a.deleteNearSelection(cm, range => {
            let top = cm.charCoords(range.head, 'div').top + 5;
            let leftPos = cm.coordsChar({
                left: 0,
                top: top
            }, 'div');
            return {
                from: leftPos,
                to: range.from()
            };
        }),
        delWrappedLineRight: cm => a.deleteNearSelection(cm, range => {
            let top = cm.charCoords(range.head, 'div').top + 5;
            let rightPos = cm.coordsChar({
                left: cm.display.lineDiv.offsetWidth + 100,
                top: top
            }, 'div');
            return {
                from: range.from(),
                to: rightPos
            };
        }),
        undo: cm => cm.undo(),
        redo: cm => cm.redo(),
        undoSelection: cm => cm.undoSelection(),
        redoSelection: cm => cm.redoSelection(),
        goDocStart: cm => cm.extendSelection(e.Pos(cm.firstLine(), 0)),
        goDocEnd: cm => cm.extendSelection(e.Pos(cm.lastLine())),
        goLineStart: cm => cm.extendSelectionsBy(range => lineStart(cm, range.head.line), {
            origin: '+move',
            bias: 1
        }),
        goLineStartSmart: cm => cm.extendSelectionsBy(range => lineStartSmart(cm, range.head), {
            origin: '+move',
            bias: 1
        }),
        goLineEnd: cm => cm.extendSelectionsBy(range => lineEnd(cm, range.head.line), {
            origin: '+move',
            bias: -1
        }),
        goLineRight: cm => cm.extendSelectionsBy(range => {
            let top = cm.cursorCoords(range.head, 'div').top + 5;
            return cm.coordsChar({
                left: cm.display.lineDiv.offsetWidth + 100,
                top: top
            }, 'div');
        }, j.sel_move),
        goLineLeft: cm => cm.extendSelectionsBy(range => {
            let top = cm.cursorCoords(range.head, 'div').top + 5;
            return cm.coordsChar({
                left: 0,
                top: top
            }, 'div');
        }, j.sel_move),
        goLineLeftSmart: cm => cm.extendSelectionsBy(range => {
            let top = cm.cursorCoords(range.head, 'div').top + 5;
            let pos = cm.coordsChar({
                left: 0,
                top: top
            }, 'div');
            if (pos.ch < cm.getLine(pos.line).search(/\S/))
                return lineStartSmart(cm, range.head);
            return pos;
        }, j.sel_move),
        goLineUp: cm => cm.moveV(-1, 'line'),
        goLineDown: cm => cm.moveV(1, 'line'),
        goPageUp: cm => cm.moveV(-1, 'page'),
        goPageDown: cm => cm.moveV(1, 'page'),
        goCharLeft: cm => cm.moveH(-1, 'char'),
        goCharRight: cm => cm.moveH(1, 'char'),
        goColumnLeft: cm => cm.moveH(-1, 'column'),
        goColumnRight: cm => cm.moveH(1, 'column'),
        goWordLeft: cm => cm.moveH(-1, 'word'),
        goGroupRight: cm => cm.moveH(1, 'group'),
        goGroupLeft: cm => cm.moveH(-1, 'group'),
        goWordRight: cm => cm.moveH(1, 'word'),
        delCharBefore: cm => cm.deleteH(-1, 'char'),
        delCharAfter: cm => cm.deleteH(1, 'char'),
        delWordBefore: cm => cm.deleteH(-1, 'word'),
        delWordAfter: cm => cm.deleteH(1, 'word'),
        delGroupBefore: cm => cm.deleteH(-1, 'group'),
        delGroupAfter: cm => cm.deleteH(1, 'group'),
        indentAuto: cm => cm.indentSelection('smart'),
        indentMore: cm => cm.indentSelection('add'),
        indentLess: cm => cm.indentSelection('subtract'),
        insertTab: cm => cm.replaceSelection('\t'),
        insertSoftTab: cm => {
            let spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (let i = 0; i < ranges.length; i++) {
                let pos = ranges[i].from();
                let col = j.countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(j.spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
        },
        defaultTab: cm => {
            if (cm.somethingSelected())
                cm.indentSelection('add');
            else
                cm.execCommand('insertTab');
        },
        transposeChars: cm => b.runInOp(cm, () => {
            let ranges = cm.listSelections(), newSel = [];
            for (let i = 0; i < ranges.length; i++) {
                if (!ranges[i].empty())
                    continue;
                let cur = ranges[i].head, line = g.getLine(cm.doc, cur.line).text;
                if (line) {
                    if (cur.ch == line.length)
                        cur = new e.Pos(cur.line, cur.ch - 1);
                    if (cur.ch > 0) {
                        cur = new e.Pos(cur.line, cur.ch + 1);
                        cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), e.Pos(cur.line, cur.ch - 2), cur, '+transpose');
                    } else if (cur.line > cm.doc.first) {
                        let prev = g.getLine(cm.doc, cur.line - 1).text;
                        if (prev) {
                            cur = new e.Pos(cur.line, 1);
                            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), e.Pos(cur.line - 1, prev.length - 1), cur, '+transpose');
                        }
                    }
                }
                newSel.push(new h.Range(cur, cur));
            }
            cm.setSelections(newSel);
        }),
        newlineAndIndent: cm => b.runInOp(cm, () => {
            let sels = cm.listSelections();
            for (let i = sels.length - 1; i >= 0; i--)
                cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, '+input');
            sels = cm.listSelections();
            for (let i = 0; i < sels.length; i++)
                cm.indentLine(sels[i].from().line, null, true);
            c.ensureCursorVisible(cm);
        }),
        openLine: cm => cm.replaceSelection('\n', 'start'),
        toggleOverwrite: cm => cm.toggleOverwrite()
    };
    function lineStart(cm, lineN) {
        let line = g.getLine(cm.doc, lineN);
        let visual = f.visualLine(line);
        if (visual != line)
            lineN = g.lineNo(visual);
        return d.endOfLine(true, cm, visual, lineN, 1);
    }
    function lineEnd(cm, lineN) {
        let line = g.getLine(cm.doc, lineN);
        let visual = f.visualLineEnd(line);
        if (visual != line)
            lineN = g.lineNo(visual);
        return d.endOfLine(true, cm, line, lineN, -1);
    }
    function lineStartSmart(cm, pos) {
        let start = lineStart(cm, pos.line);
        let line = g.getLine(cm.doc, start.line);
        let order = k.getOrder(line, cm.doc.direction);
        if (!order || order[0].level == 0) {
            let firstNonWS = Math.max(0, line.text.search(/\S/));
            let inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return e.Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
        }
        return start;
    }
    return { commands: commands };
});
define('skylark-codemirror/primitives/edit/key_events',[
    '../util/operation_group',
    '../display/selection',
    '../input/keymap',
    '../measurement/widgets',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/feature_detection',
    '../util/misc',
    './commands'
], function (operation_group, selection, keymap, widgets, browser, dom, events, feature_detection, misc, m_commands) {
    'use strict';
    function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == 'string') {
            bound = m_commands.commands[bound];
            if (!bound)
                return false;
        }
        cm.display.input.ensurePolled();
        let prevShift = cm.display.shift, done = false;
        try {
            if (cm.isReadOnly())
                cm.state.suppressEdits = true;
            if (dropShift)
                cm.display.shift = false;
            done = bound(cm) != misc.Pass;
        } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
        }
        return done;
    }
    function lookupKeyForEditor(cm, name, handle) {
        for (let i = 0; i < cm.state.keyMaps.length; i++) {
            let result = keymap.lookupKey(name, cm.state.keyMaps[i], handle, cm);
            if (result)
                return result;
        }
        return cm.options.extraKeys && keymap.lookupKey(name, cm.options.extraKeys, handle, cm) || keymap.lookupKey(name, cm.options.keyMap, handle, cm);
    }
    let stopSeq = new misc.Delayed();
    function dispatchKey(cm, name, e, handle) {
        let seq = cm.state.keySeq;
        if (seq) {
            if (keymap.isModifierKey(name))
                return 'handled';
            if (/\'$/.test(name))
                cm.state.keySeq = null;
            else
                stopSeq.set(50, () => {
                    if (cm.state.keySeq == seq) {
                        cm.state.keySeq = null;
                        cm.display.input.reset();
                    }
                });
            if (dispatchKeyInner(cm, seq + ' ' + name, e, handle))
                return true;
        }
        return dispatchKeyInner(cm, name, e, handle);
    }
    function dispatchKeyInner(cm, name, e, handle) {
        let result = lookupKeyForEditor(cm, name, handle);
        if (result == 'multi')
            cm.state.keySeq = name;
        if (result == 'handled')
            operation_group.signalLater(cm, 'keyHandled', cm, name, e);
        if (result == 'handled' || result == 'multi') {
            events.e_preventDefault(e);
            selection.restartBlink(cm);
        }
        return !!result;
    }
    function handleKeyBinding(cm, e) {
        let name = keymap.keyName(e, true);
        if (!name)
            return false;
        if (e.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, 'Shift-' + name, e, b => doHandleBinding(cm, b, true)) || dispatchKey(cm, name, e, b => {
                if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
            });
        } else {
            return dispatchKey(cm, name, e, b => doHandleBinding(cm, b));
        }
    }
    function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, b => doHandleBinding(cm, b, true));
    }
    let lastStoppedKey = null;
    function onKeyDown(e) {
        let cm = this;
        cm.curOp.focus = dom.activeElt();
        if (events.signalDOMEvent(cm, e))
            return;
        if (browser.ie && browser.ie_version < 11 && e.keyCode == 27)
            e.returnValue = false;
        let code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        let handled = handleKeyBinding(cm, e);
        if (browser.presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !feature_detection.hasCopyEvent && (browser.mac ? e.metaKey : e.ctrlKey))
                cm.replaceSelection('', null, 'cut');
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
            showCrossHair(cm);
    }
    function showCrossHair(cm) {
        let lineDiv = cm.display.lineDiv;
        dom.addClass(lineDiv, 'CodeMirror-crosshair');
        function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
                dom.rmClass(lineDiv, 'CodeMirror-crosshair');
                events.off(document, 'keyup', up);
                events.off(document, 'mouseover', up);
            }
        }
        events.on(document, 'keyup', up);
        events.on(document, 'mouseover', up);
    }
    function onKeyUp(e) {
        if (e.keyCode == 16)
            this.doc.sel.shift = false;
        events.signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
        let cm = this;
        if (widgets.eventInWidget(cm.display, e) || events.signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || browser.mac && e.metaKey)
            return;
        let keyCode = e.keyCode, charCode = e.charCode;
        if (browser.presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            events.e_preventDefault(e);
            return;
        }
        if (browser.presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e))
            return;
        let ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (ch == '\b')
            return;
        if (handleCharBinding(cm, e, ch))
            return;
        cm.display.input.onKeyPress(e);
    }
    return {
        dispatchKey: dispatchKey,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        onKeyPress: onKeyPress
    };
});
define('skylark-codemirror/primitives/edit/mouse_events',[
    '../display/focus',
    '../display/operations',
    '../display/update_lines',
    '../line/pos',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../measurement/widgets',
    '../model/selection',
    '../model/selection_updates',
    '../util/browser',
    '../util/bidi',
    '../util/dom',
    '../util/event',
    '../util/feature_detection',
    '../util/misc',
    '../input/keymap',
    './key_events',
    './commands'
], function (focus, operations, update_lines, line_pos, utils_line, position_measurement, widgets, selection, selection_updates, browser, bidi, dom, events, n, o, p, q, r) {
    'use strict';
    const DOUBLECLICK_DELAY = 400;
    class PastClick {
        constructor(time, pos, button) {
            this.time = time;
            this.pos = pos;
            this.button = button;
        }
        compare(time, pos, button) {
            return this.time + DOUBLECLICK_DELAY > time && line_pos.cmp(pos, this.pos) == 0 && button == this.button;
        }
    }
    let lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
        let now = +new Date();
        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
            lastClick = lastDoubleClick = null;
            return 'triple';
        } else if (lastClick && lastClick.compare(now, pos, button)) {
            lastDoubleClick = new PastClick(now, pos, button);
            lastClick = null;
            return 'double';
        } else {
            lastClick = new PastClick(now, pos, button);
            lastDoubleClick = null;
            return 'single';
        }
    }
    function onMouseDown(e) {
        let cm = this, display = cm.display;
        if (events.signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())
            return;
        display.input.ensurePolled();
        display.shift = e.shiftKey;
        if (widgets.eventInWidget(display, e)) {
            if (!browser.webkit) {
                display.scroller.draggable = false;
                setTimeout(() => display.scroller.draggable = true, 100);
            }
            return;
        }
        if (clickInGutter(cm, e))
            return;
        let pos = position_measurement.posFromMouse(cm, e), button = events.e_button(e), repeat = pos ? clickRepeat(pos, button) : 'single';
        window.focus();
        if (button == 1 && cm.state.selectingText)
            cm.state.selectingText(e);
        if (pos && handleMappedButton(cm, button, pos, repeat, e))
            return;
        if (button == 1) {
            if (pos)
                leftButtonDown(cm, pos, repeat, e);
            else if (events.e_target(e) == display.scroller)
                events.e_preventDefault(e);
        } else if (button == 2) {
            if (pos)
                selection_updates.extendSelection(cm.doc, pos);
            setTimeout(() => display.input.focus(), 20);
        } else if (button == 3) {
            if (browser.captureRightClick)
                cm.display.input.onContextMenu(e);
            else
                focus.delayBlurEvent(cm);
        }
    }
    function handleMappedButton(cm, button, pos, repeat, event) {
        let name = 'Click';
        if (repeat == 'double')
            name = 'Double' + name;
        else if (repeat == 'triple')
            name = 'Triple' + name;
        name = (button == 1 ? 'Left' : button == 2 ? 'Middle' : 'Right') + name;
        return q.dispatchKey(cm, p.addModifierNames(name, event), event, bound => {
            if (typeof bound == 'string')
                bound = r.commands[bound];
            if (!bound)
                return false;
            let done = false;
            try {
                if (cm.isReadOnly())
                    cm.state.suppressEdits = true;
                done = bound(cm, pos) != o.Pass;
            } finally {
                cm.state.suppressEdits = false;
            }
            return done;
        });
    }
    function configureMouse(cm, repeat, event) {
        let option = cm.getOption('configureMouse');
        let value = option ? option(cm, repeat, event) : {};
        if (value.unit == null) {
            let rect = browser.chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? 'rectangle' : repeat == 'single' ? 'char' : repeat == 'double' ? 'word' : 'line';
        }
        if (value.extend == null || cm.doc.extend)
            value.extend = cm.doc.extend || event.shiftKey;
        if (value.addNew == null)
            value.addNew = browser.mac ? event.metaKey : event.ctrlKey;
        if (value.moveOnDrag == null)
            value.moveOnDrag = !(browser.mac ? event.altKey : event.ctrlKey);
        return value;
    }
    function leftButtonDown(cm, pos, repeat, event) {
        if (browser.ie)
            setTimeout(o.bind(focus.ensureFocus, cm), 0);
        else
            cm.curOp.focus = dom.activeElt();
        let behavior = configureMouse(cm, repeat, event);
        let sel = cm.doc.sel, contained;
        if (cm.options.dragDrop && n.dragAndDrop && !cm.isReadOnly() && repeat == 'single' && (contained = sel.contains(pos)) > -1 && (line_pos.cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (line_pos.cmp(contained.to(), pos) > 0 || pos.xRel < 0))
            leftButtonStartDrag(cm, event, pos, behavior);
        else
            leftButtonSelect(cm, event, pos, behavior);
    }
    function leftButtonStartDrag(cm, event, pos, behavior) {
        let display = cm.display, moved = false;
        let dragEnd = operations.operation(cm, e => {
            if (browser.webkit)
                display.scroller.draggable = false;
            cm.state.draggingText = false;
            events.off(display.wrapper.ownerDocument, 'mouseup', dragEnd);
            events.off(display.wrapper.ownerDocument, 'mousemove', mouseMove);
            events.off(display.scroller, 'dragstart', dragStart);
            events.off(display.scroller, 'drop', dragEnd);
            if (!moved) {
                events.e_preventDefault(e);
                if (!behavior.addNew)
                    selection_updates.extendSelection(cm.doc, pos, null, null, behavior.extend);
                if (browser.webkit || browser.ie && browser.ie_version == 9)
                    setTimeout(() => {
                        display.wrapper.ownerDocument.body.focus();
                        display.input.focus();
                    }, 20);
                else
                    display.input.focus();
            }
        });
        let mouseMove = function (e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };
        let dragStart = () => moved = true;
        if (browser.webkit)
            display.scroller.draggable = true;
        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        if (display.scroller.dragDrop)
            display.scroller.dragDrop();
        events.on(display.wrapper.ownerDocument, 'mouseup', dragEnd);
        events.on(display.wrapper.ownerDocument, 'mousemove', mouseMove);
        events.on(display.scroller, 'dragstart', dragStart);
        events.on(display.scroller, 'drop', dragEnd);
        focus.delayBlurEvent(cm);
        setTimeout(() => display.input.focus(), 20);
    }
    function rangeForUnit(cm, pos, unit) {
        if (unit == 'char')
            return new selection.Range(pos, pos);
        if (unit == 'word')
            return cm.findWordAt(pos);
        if (unit == 'line')
            return new selection.Range(line_pos.Pos(pos.line, 0), line_pos.clipPos(cm.doc, line_pos.Pos(pos.line + 1, 0)));
        let result = unit(cm, pos);
        return new selection.Range(result.from, result.to);
    }
    function leftButtonSelect(cm, event, start, behavior) {
        let display = cm.display, doc = cm.doc;
        events.e_preventDefault(event);
        let ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (behavior.addNew && !behavior.extend) {
            ourIndex = doc.sel.contains(start);
            if (ourIndex > -1)
                ourRange = ranges[ourIndex];
            else
                ourRange = new selection.Range(start, start);
        } else {
            ourRange = doc.sel.primary();
            ourIndex = doc.sel.primIndex;
        }
        if (behavior.unit == 'rectangle') {
            if (!behavior.addNew)
                ourRange = new selection.Range(start, start);
            start = position_measurement.posFromMouse(cm, event, true, true);
            ourIndex = -1;
        } else {
            let range = rangeForUnit(cm, start, behavior.unit);
            if (behavior.extend)
                ourRange = selection_updates.extendRange(ourRange, range.anchor, range.head, behavior.extend);
            else
                ourRange = range;
        }
        if (!behavior.addNew) {
            ourIndex = 0;
            selection_updates.setSelection(doc, new selection.Selection([ourRange], 0), o.sel_mouse);
            startSel = doc.sel;
        } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            selection_updates.setSelection(doc, selection.normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {
                scroll: false,
                origin: '*mouse'
            });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == 'char' && !behavior.extend) {
            selection_updates.setSelection(doc, selection.normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                scroll: false,
                origin: '*mouse'
            });
            startSel = doc.sel;
        } else {
            selection_updates.replaceOneSelection(doc, ourIndex, ourRange, o.sel_mouse);
        }
        let lastPos = start;
        function extendTo(pos) {
            if (line_pos.cmp(lastPos, pos) == 0)
                return;
            lastPos = pos;
            if (behavior.unit == 'rectangle') {
                let ranges = [], tabSize = cm.options.tabSize;
                let startCol = o.countColumn(utils_line.getLine(doc, start.line).text, start.ch, tabSize);
                let posCol = o.countColumn(utils_line.getLine(doc, pos.line).text, pos.ch, tabSize);
                let left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
                for (let line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                    let text = utils_line.getLine(doc, line).text, leftPos = o.findColumn(text, left, tabSize);
                    if (left == right)
                        ranges.push(new selection.Range(line_pos.Pos(line, leftPos), line_pos.Pos(line, leftPos)));
                    else if (text.length > leftPos)
                        ranges.push(new selection.Range(line_pos.Pos(line, leftPos), line_pos.Pos(line, o.findColumn(text, right, tabSize))));
                }
                if (!ranges.length)
                    ranges.push(new selection.Range(start, start));
                selection_updates.setSelection(doc, selection.normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                    origin: '*mouse',
                    scroll: false
                });
                cm.scrollIntoView(pos);
            } else {
                let oldRange = ourRange;
                let range = rangeForUnit(cm, pos, behavior.unit);
                let anchor = oldRange.anchor, head;
                if (line_pos.cmp(range.anchor, anchor) > 0) {
                    head = range.head;
                    anchor = line_pos.minPos(oldRange.from(), range.anchor);
                } else {
                    head = range.anchor;
                    anchor = line_pos.maxPos(oldRange.to(), range.head);
                }
                let ranges = startSel.ranges.slice(0);
                ranges[ourIndex] = bidiSimplify(cm, new selection.Range(line_pos.clipPos(doc, anchor), head));
                selection_updates.setSelection(doc, selection.normalizeSelection(cm, ranges, ourIndex), o.sel_mouse);
            }
        }
        let editorSize = display.wrapper.getBoundingClientRect();
        let counter = 0;
        function extend(e) {
            let curCount = ++counter;
            let cur = position_measurement.posFromMouse(cm, e, true, behavior.unit == 'rectangle');
            if (!cur)
                return;
            if (line_pos.cmp(cur, lastPos) != 0) {
                cm.curOp.focus = dom.activeElt();
                extendTo(cur);
                let visible = update_lines.visibleLines(display, doc);
                if (cur.line >= visible.to || cur.line < visible.from)
                    setTimeout(operations.operation(cm, () => {
                        if (counter == curCount)
                            extend(e);
                    }), 150);
            } else {
                let outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                if (outside)
                    setTimeout(operations.operation(cm, () => {
                        if (counter != curCount)
                            return;
                        display.scroller.scrollTop += outside;
                        extend(e);
                    }), 50);
            }
        }
        function done(e) {
            cm.state.selectingText = false;
            counter = Infinity;
            events.e_preventDefault(e);
            display.input.focus();
            events.off(display.wrapper.ownerDocument, 'mousemove', move);
            events.off(display.wrapper.ownerDocument, 'mouseup', up);
            doc.history.lastSelOrigin = null;
        }
        let move = operations.operation(cm, e => {
            if (e.buttons === 0 || !events.e_button(e))
                done(e);
            else
                extend(e);
        });
        let up = operations.operation(cm, done);
        cm.state.selectingText = up;
        events.on(display.wrapper.ownerDocument, 'mousemove', move);
        events.on(display.wrapper.ownerDocument, 'mouseup', up);
    }
    function bidiSimplify(cm, range) {
        let {anchor, head} = range, anchorLine = utils_line.getLine(cm.doc, anchor.line);
        if (line_pos.cmp(anchor, head) == 0 && anchor.sticky == head.sticky)
            return range;
        let order = bidi.getOrder(anchorLine);
        if (!order)
            return range;
        let index = bidi.getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
        if (part.from != anchor.ch && part.to != anchor.ch)
            return range;
        let boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
        if (boundary == 0 || boundary == order.length)
            return range;
        let leftSide;
        if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == 'ltr' ? 1 : -1) > 0;
        } else {
            let headIndex = bidi.getBidiPartAt(order, head.ch, head.sticky);
            let dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary)
                leftSide = dir < 0;
            else
                leftSide = dir > 0;
        }
        let usePart = order[boundary + (leftSide ? -1 : 0)];
        let from = leftSide == (usePart.level == 1);
        let ch = from ? usePart.from : usePart.to, sticky = from ? 'after' : 'before';
        return anchor.ch == ch && anchor.sticky == sticky ? range : new selection.Range(new line_pos.Pos(anchor.line, ch, sticky), head);
    }
    function gutterEvent(cm, e, type, prevent) {
        let mX, mY;
        if (e.touches) {
            mX = e.touches[0].clientX;
            mY = e.touches[0].clientY;
        } else {
            try {
                mX = e.clientX;
                mY = e.clientY;
            } catch (e) {
                return false;
            }
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
            return false;
        if (prevent)
            events.e_preventDefault(e);
        let display = cm.display;
        let lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !events.hasHandler(cm, type))
            return events.e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (let i = 0; i < cm.options.gutters.length; ++i) {
            let g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                let line = utils_line.lineAtHeight(cm.doc, mY);
                let gutter = cm.options.gutters[i];
                events.signal(cm, type, cm, line, gutter, e);
                return events.e_defaultPrevented(e);
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, 'gutterClick', true);
    }
    function onContextMenu(cm, e) {
        if (widgets.eventInWidget(cm.display, e) || contextMenuInGutter(cm, e))
            return;
        if (events.signalDOMEvent(cm, e, 'contextmenu'))
            return;
        if (!browser.captureRightClick)
            cm.display.input.onContextMenu(e);
    }
    function contextMenuInGutter(cm, e) {
        if (!events.hasHandler(cm, 'gutterContextMenu'))
            return false;
        return gutterEvent(cm, e, 'gutterContextMenu', false);
    }
    return {
        onMouseDown: onMouseDown,
        clickInGutter: clickInGutter,
        onContextMenu: onContextMenu
    };
});
define('skylark-codemirror/primitives/edit/utils',['../measurement/position_measurement'], function (a) {
    'use strict';
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
        a.clearCaches(cm);
    }
    return { themeChanged: themeChanged };
});
define('skylark-codemirror/primitives/edit/options',[
    '../display/focus',
    '../display/gutters',
    '../display/line_numbers',
    '../display/mode_state',
    '../display/scrollbars',
    '../display/selection',
    '../display/view_tracking',
    '../input/keymap',
    '../line/line_data',
    '../line/pos',
    '../line/spans',
    '../measurement/position_measurement',
    '../model/changes',
    '../util/browser',
    '../util/dom',
    '../util/event',
    './utils'
], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
    'use strict';
    let Init = {
        toString: function () {
            return 'CodeMirror.Init';
        }
    };
    let defaults = {};
    let optionHandlers = {};
    function defineOptions(CodeMirror) {
        let optionHandlers = CodeMirror.optionHandlers;
        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt;
            if (handle)
                optionHandlers[name] = notOnInit ? (cm, val, old) => {
                    if (old != Init)
                        handle(cm, val, old);
                } : handle;
        }
        CodeMirror.defineOption = option;
        CodeMirror.Init = Init;
        option('value', '', (cm, val) => cm.setValue(val), true);
        option('mode', null, (cm, val) => {
            cm.doc.modeOption = val;
            d.loadMode(cm);
        }, true);
        option('indentUnit', 2, d.loadMode, true);
        option('indentWithTabs', false);
        option('smartIndent', true);
        option('tabSize', 4, cm => {
            d.resetModeState(cm);
            l.clearCaches(cm);
            g.regChange(cm);
        }, true);
        option('lineSeparator', null, (cm, val) => {
            cm.doc.lineSep = val;
            if (!val)
                return;
            let newBreaks = [], lineNo = cm.doc.first;
            cm.doc.iter(line => {
                for (let pos = 0;;) {
                    let found = line.text.indexOf(val, pos);
                    if (found == -1)
                        break;
                    pos = found + val.length;
                    newBreaks.push(j.Pos(lineNo, found));
                }
                lineNo++;
            });
            for (let i = newBreaks.length - 1; i >= 0; i--)
                m.replaceRange(cm.doc, val, newBreaks[i], j.Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
        });
        option('specialChars', /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, (cm, val, old) => {
            cm.state.specialChars = new RegExp(val.source + (val.test('\t') ? '' : '|\t'), 'g');
            if (old != Init)
                cm.refresh();
        });
        option('specialCharPlaceholder', i.defaultSpecialCharPlaceholder, cm => cm.refresh(), true);
        option('electricChars', true);
        option('inputStyle', n.mobile ? 'contenteditable' : 'textarea', () => {
            throw new Error('inputStyle can not (yet) be changed in a running editor');
        }, true);
        option('spellcheck', false, (cm, val) => cm.getInputField().spellcheck = val, true);
        option('autocorrect', false, (cm, val) => cm.getInputField().autocorrect = val, true);
        option('autocapitalize', false, (cm, val) => cm.getInputField().autocapitalize = val, true);
        option('rtlMoveVisually', !n.windows);
        option('wholeLineUpdateBefore', true);
        option('theme', 'default', cm => {
            q.themeChanged(cm);
            guttersChanged(cm);
        }, true);
        option('keyMap', 'default', (cm, val, old) => {
            let next = h.getKeyMap(val);
            let prev = old != Init && h.getKeyMap(old);
            if (prev && prev.detach)
                prev.detach(cm, next);
            if (next.attach)
                next.attach(cm, prev || null);
        });
        option('extraKeys', null);
        option('configureMouse', null);
        option('lineWrapping', false, wrappingChanged, true);
        option('gutters', [], cm => {
            b.setGuttersForLineNumbers(cm.options);
            guttersChanged(cm);
        }, true);
        option('fixedGutter', true, (cm, val) => {
            cm.display.gutters.style.left = val ? l.compensateForHScroll(cm.display) + 'px' : '0';
            cm.refresh();
        }, true);
        option('coverGutterNextToScrollbar', false, cm => e.updateScrollbars(cm), true);
        option('scrollbarStyle', 'native', cm => {
            e.initScrollbars(cm);
            e.updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option('lineNumbers', false, cm => {
            b.setGuttersForLineNumbers(cm.options);
            guttersChanged(cm);
        }, true);
        option('firstLineNumber', 1, guttersChanged, true);
        option('lineNumberFormatter', integer => integer, guttersChanged, true);
        option('showCursorWhenSelecting', false, f.updateSelection, true);
        option('resetSelectionOnContextMenu', true);
        option('lineWiseCopyCut', true);
        option('pasteLinesPerSelection', true);
        option('selectionsMayTouch', false);
        option('readOnly', false, (cm, val) => {
            if (val == 'nocursor') {
                a.onBlur(cm);
                cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
        });
        option('disableInput', false, (cm, val) => {
            if (!val)
                cm.display.input.reset();
        }, true);
        option('dragDrop', true, dragDropChanged);
        option('allowDropFileTypes', null);
        option('cursorBlinkRate', 530);
        option('cursorScrollMargin', 0);
        option('cursorHeight', 1, f.updateSelection, true);
        option('singleCursorHeightPerLine', true, f.updateSelection, true);
        option('workTime', 100);
        option('workDelay', 100);
        option('flattenSpans', true, d.resetModeState, true);
        option('addModeClass', false, d.resetModeState, true);
        option('pollInterval', 100);
        option('undoDepth', 200, (cm, val) => cm.doc.history.undoDepth = val);
        option('historyEventDelay', 1250);
        option('viewportMargin', 10, cm => cm.refresh(), true);
        option('maxHighlightLength', 10000, d.resetModeState, true);
        option('moveInputWithCursor', true, (cm, val) => {
            if (!val)
                cm.display.input.resetPosition();
        });
        option('tabindex', null, (cm, val) => cm.display.input.getField().tabIndex = val || '');
        option('autofocus', null);
        option('direction', 'ltr', (cm, val) => cm.doc.setDirection(val), true);
        option('phrases', null);
    }
    function guttersChanged(cm) {
        b.updateGutters(cm);
        g.regChange(cm);
        c.alignHorizontally(cm);
    }
    function dragDropChanged(cm, value, old) {
        let wasOn = old && old != Init;
        if (!value != !wasOn) {
            let funcs = cm.display.dragFunctions;
            let toggle = value ? p.on : p.off;
            toggle(cm.display.scroller, 'dragstart', funcs.start);
            toggle(cm.display.scroller, 'dragenter', funcs.enter);
            toggle(cm.display.scroller, 'dragover', funcs.over);
            toggle(cm.display.scroller, 'dragleave', funcs.leave);
            toggle(cm.display.scroller, 'drop', funcs.drop);
        }
    }
    function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
            o.addClass(cm.display.wrapper, 'CodeMirror-wrap');
            cm.display.sizer.style.minWidth = '';
            cm.display.sizerWidth = null;
        } else {
            o.rmClass(cm.display.wrapper, 'CodeMirror-wrap');
            k.findMaxLine(cm);
        }
        l.estimateLineHeights(cm);
        g.regChange(cm);
        l.clearCaches(cm);
        setTimeout(() => e.updateScrollbars(cm), 100);
    }
    return {
        Init: Init,
        defaults: defaults,
        optionHandlers: optionHandlers,
        defineOptions: defineOptions
    };
});
define('skylark-codemirror/primitives/edit/CodeMirror',[
    '../display/Display',
    '../display/focus',
    '../display/gutters',
    '../display/line_numbers',
    '../display/operations',
    '../display/scrollbars',
    '../display/scroll_events',
    '../display/scrolling',
    '../line/pos',
    '../measurement/position_measurement',
    '../measurement/widgets',
    '../model/Doc',
    '../model/document_data',
    '../model/selection',
    '../model/selection_updates',
    '../util/browser',
    '../util/event',
    '../util/misc',
    './drop_events',
    './global_events',
    './key_events',
    './mouse_events',
    './utils',
    './options'
], function (m_display, focuses, gutters, line_numbers, operations, scrollbars, scroll_events, scrolling, line_pos, position_measurement, widgets, Doc, document_data, selection, selection_updates, browser, events, misc, drop_events, global_events, key_events, mouse_events, utils, m_options) {
    'use strict';
    function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
            return new CodeMirror(place, options);
        this.options = options = options ? misc.copyObj(options) : {};
        misc.copyObj(m_options.defaults, options, false);
        gutters.setGuttersForLineNumbers(options);
        let doc = options.value;
        if (typeof doc == 'string')
            doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
        else if (options.mode)
            doc.modeOption = options.mode;
        this.doc = doc;
        let input = new CodeMirror.inputStyles[options.inputStyle](this);
        let display = this.display = new m_display.Display(place, doc, input);
        display.wrapper.CodeMirror = this;
        gutters.updateGutters(this);
        utils.themeChanged(this);
        if (options.lineWrapping)
            this.display.wrapper.className += ' CodeMirror-wrap';
        scrollbars.initScrollbars(this);
        this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: false,
            draggingText: false,
            highlight: new misc.Delayed(),
            keySeq: null,
            specialChars: null
        };
        if (options.autofocus && !browser.mobile)
            display.input.focus();
        if (browser.ie && browser.ie_version < 11)
            setTimeout(() => this.display.input.reset(true), 20);
        registerEventHandlers(this);
        global_events.ensureGlobalHandlers();
        operations.startOperation(this);
        this.curOp.forceUpdate = true;
        document_data.attachDoc(this, doc);
        if (options.autofocus && !browser.mobile || this.hasFocus())
            setTimeout(misc.bind(focuses.onFocus, this), 20);
        else
            focuses.onBlur(this);
        for (let opt in m_options.optionHandlers)
            if (m_options.optionHandlers.hasOwnProperty(opt))
                m_options.optionHandlers[opt](this, options[opt], m_options.Init);
        line_numbers.maybeUpdateLineNumberWidth(this);
        if (options.finishInit)
            options.finishInit(this);
        for (let i = 0; i < initHooks.length; ++i)
            initHooks[i](this);
        operations.endOperation(this);
        if (browser.webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == 'optimizelegibility')
            display.lineDiv.style.textRendering = 'auto';
    }
    
    CodeMirror.defaults = m_options.defaults;
    CodeMirror.optionHandlers = m_options.optionHandlers;

    function registerEventHandlers(cm) {
        let d = cm.display;
        events.on(d.scroller, 'mousedown', operations.operation(cm, mouse_events.onMouseDown));
        if (browser.ie && browser.ie_version < 11)
            events.on(d.scroller, 'dblclick', operations.operation(cm, e => {
                if (events.signalDOMEvent(cm, e))
                    return;
                let pos = position_measurement.posFromMouse(cm, e);
                if (!pos || mouse_events.clickInGutter(cm, e) || widgets.eventInWidget(cm.display, e))
                    return;
                events.e_preventDefault(e);
                let word = cm.findWordAt(pos);
                selection_updates.extendSelection(cm.doc, word.anchor, word.head);
            }));
        else
            events.on(d.scroller, 'dblclick', e => events.signalDOMEvent(cm, e) || events.e_preventDefault(e));
        events.on(d.scroller, 'contextmenu', e => mouse_events.onContextMenu(cm, e));
        let touchFinished, prevTouch = { end: 0 };
        function finishTouch() {
            if (d.activeTouch) {
                touchFinished = setTimeout(() => d.activeTouch = null, 1000);
                prevTouch = d.activeTouch;
                prevTouch.end = +new Date();
            }
        }
        function isMouseLikeTouchEvent(e) {
            if (e.touches.length != 1)
                return false;
            let touch = e.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
            if (other.left == null)
                return true;
            let dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
        }
        events.on(d.scroller, 'touchstart', e => {
            if (!events.signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !mouse_events.clickInGutter(cm, e)) {
                d.input.ensurePolled();
                clearTimeout(touchFinished);
                let now = +new Date();
                d.activeTouch = {
                    start: now,
                    moved: false,
                    prev: now - prevTouch.end <= 300 ? prevTouch : null
                };
                if (e.touches.length == 1) {
                    d.activeTouch.left = e.touches[0].pageX;
                    d.activeTouch.top = e.touches[0].pageY;
                }
            }
        });
        events.on(d.scroller, 'touchmove', () => {
            if (d.activeTouch)
                d.activeTouch.moved = true;
        });
        events.on(d.scroller, 'touchend', e => {
            let touch = d.activeTouch;
            if (touch && !widgets.eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
                let pos = cm.coordsChar(d.activeTouch, 'page'), range;
                if (!touch.prev || farAway(touch, touch.prev))
                    range = new selection.Range(pos, pos);
                else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
                    range = cm.findWordAt(pos);
                else
                    range = new selection.Range(line_pos.Pos(pos.line, 0), line_pos.clipPos(cm.doc, line_pos.Pos(pos.line + 1, 0)));
                cm.setSelection(range.anchor, range.head);
                cm.focus();
                events.e_preventDefault(e);
            }
            finishTouch();
        });
        events.on(d.scroller, 'touchcancel', finishTouch);
        events.on(d.scroller, 'scroll', () => {
            if (d.scroller.clientHeight) {
                scrolling.updateScrollTop(cm, d.scroller.scrollTop);
                scrolling.setScrollLeft(cm, d.scroller.scrollLeft, true);
                events.signal(cm, 'scroll', cm);
            }
        });
        events.on(d.scroller, 'mousewheel', e => scroll_events.onScrollWheel(cm, e));
        events.on(d.scroller, 'DOMMouseScroll', e => scroll_events.onScrollWheel(cm, e));
        events.on(d.wrapper, 'scroll', () => d.wrapper.scrollTop = d.wrapper.scrollLeft = 0);
        d.dragFunctions = {
            enter: e => {
                if (!events.signalDOMEvent(cm, e))
                    events.e_stop(e);
            },
            over: e => {
                if (!events.signalDOMEvent(cm, e)) {
                    drop_events.onDragOver(cm, e);
                    events.e_stop(e);
                }
            },
            start: e => drop_events.onDragStart(cm, e),
            drop: operations.operation(cm, drop_events.onDrop),
            leave: e => {
                if (!events.signalDOMEvent(cm, e)) {
                    drop_events.clearDragCursor(cm);
                }
            }
        };
        let inp = d.input.getField();
        events.on(inp, 'keyup', e => key_events.onKeyUp.call(cm, e));
        events.on(inp, 'keydown', operations.operation(cm, key_events.onKeyDown));
        events.on(inp, 'keypress', operations.operation(cm, key_events.onKeyPress));
        events.on(inp, 'focus', e => focuses.onFocus(cm, e));
        events.on(inp, 'blur', e => focuses.onBlur(cm, e));
    }
    let initHooks = [];
    CodeMirror.defineInitHook = f => initHooks.push(f);

    return CodeMirror;
});
define('skylark-codemirror/primitives/input/indent',[
    '../line/highlight',
    '../line/pos',
    '../line/utils_line',
    '../model/changes',
    '../model/selection',
    '../model/selection_updates',
    '../util/misc'
], function (a, b, c, d, e, f, g) {
    'use strict';
    function indentLine(cm, n, how, aggressive) {
        let doc = cm.doc, state;
        if (how == null)
            how = 'add';
        if (how == 'smart') {
            if (!doc.mode.indent)
                how = 'prev';
            else
                state = a.getContextBefore(cm, n).state;
        }
        let tabSize = cm.options.tabSize;
        let line = c.getLine(doc, n), curSpace = g.countColumn(line.text, null, tabSize);
        if (line.stateAfter)
            line.stateAfter = null;
        let curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = 'not';
        } else if (how == 'smart') {
            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == g.Pass || indentation > 150) {
                if (!aggressive)
                    return;
                how = 'prev';
            }
        }
        if (how == 'prev') {
            if (n > doc.first)
                indentation = g.countColumn(c.getLine(doc, n - 1).text, null, tabSize);
            else
                indentation = 0;
        } else if (how == 'add') {
            indentation = curSpace + cm.options.indentUnit;
        } else if (how == 'subtract') {
            indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == 'number') {
            indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        let indentString = '', pos = 0;
        if (cm.options.indentWithTabs)
            for (let i = Math.floor(indentation / tabSize); i; --i) {
                pos += tabSize;
                indentString += '\t';
            }
        if (pos < indentation)
            indentString += g.spaceStr(indentation - pos);
        if (indentString != curSpaceString) {
            d.replaceRange(doc, indentString, b.Pos(n, 0), b.Pos(n, curSpaceString.length), '+input');
            line.stateAfter = null;
            return true;
        } else {
            for (let i = 0; i < doc.sel.ranges.length; i++) {
                let range = doc.sel.ranges[i];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    let pos = b.Pos(n, curSpaceString.length);
                    f.replaceOneSelection(doc, i, new e.Range(pos, pos));
                    break;
                }
            }
        }
    }
    return { indentLine: indentLine };
});
define('skylark-codemirror/primitives/input/input',[
    '../display/operations',
    '../display/scrolling',
    '../line/pos',
    '../line/utils_line',
    '../model/changes',
    '../util/browser',
    '../util/dom',
    '../util/misc',
    '../util/operation_group',
    '../util/feature_detection',
    './indent'
], function (operations, scrolling, line_pos, utils_line, changes, browser, dom, misc, operation_group, feature_detection, indent) {
    'use strict';
    let lastCopied = null;
    function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
        let doc = cm.doc;
        cm.display.shift = false;
        if (!sel)
            sel = doc.sel;
        let recent = +new Date() - 200;
        let paste = origin == 'paste' || cm.state.pasteIncoming > recent;
        let textLines = feature_detection.splitLinesAuto(inserted), multiPaste = null;
        if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join('\n') == inserted) {
                if (sel.ranges.length % lastCopied.text.length == 0) {
                    multiPaste = [];
                    for (let i = 0; i < lastCopied.text.length; i++)
                        multiPaste.push(doc.splitLines(lastCopied.text[i]));
                }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
                multiPaste = misc.map(textLines, l => [l]);
            }
        }
        let updateInput = cm.curOp.updateInput;
        for (let i = sel.ranges.length - 1; i >= 0; i--) {
            let range = sel.ranges[i];
            let from = range.from(), to = range.to();
            if (range.empty()) {
                if (deleted && deleted > 0)
                    from = line_pos.Pos(from.line, from.ch - deleted);
                else if (cm.state.overwrite && !paste)
                    to = line_pos.Pos(to.line, Math.min(utils_line.getLine(doc, to.line).text.length, to.ch + misc.lst(textLines).length));
                else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join('\n') == inserted)
                    from = to = line_pos.Pos(from.line, 0);
            }
            let changeEvent = {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                origin: origin || (paste ? 'paste' : cm.state.cutIncoming > recent ? 'cut' : '+input')
            };
            changes.makeChange(cm.doc, changeEvent);
            operation_group.signalLater(cm, 'inputRead', cm, changeEvent);
        }
        if (inserted && !paste)
            triggerElectric(cm, inserted);
        scrolling.ensureCursorVisible(cm);
        if (cm.curOp.updateInput < 2)
            cm.curOp.updateInput = updateInput;
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste(e, cm) {
        let pasted = e.clipboardData && e.clipboardData.getData('Text');
        if (pasted) {
            e.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput)
                operations.runInOp(cm, () => applyTextInput(cm, pasted, 0, null, 'paste'));
            return true;
        }
    }
    function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent)
            return;
        let sel = cm.doc.sel;
        for (let i = sel.ranges.length - 1; i >= 0; i--) {
            let range = sel.ranges[i];
            if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line)
                continue;
            let mode = cm.getModeAt(range.head);
            let indented = false;
            if (mode.electricChars) {
                for (let j = 0; j < mode.electricChars.length; j++)
                    if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                        indented = indent.indentLine(cm, range.head.line, 'smart');
                        break;
                    }
            } else if (mode.electricInput) {
                if (mode.electricInput.test(utils_line.getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
                    indented = indent.indentLine(cm, range.head.line, 'smart');
            }
            if (indented)
                operation_group.signalLater(cm, 'electricInput', cm, range.head.line);
        }
    }
    function copyableRanges(cm) {
        let text = [], ranges = [];
        for (let i = 0; i < cm.doc.sel.ranges.length; i++) {
            let line = cm.doc.sel.ranges[i].head.line;
            let lineRange = {
                anchor: line_pos.Pos(line, 0),
                head: line_pos.Pos(line + 1, 0)
            };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
            text: text,
            ranges: ranges
        };
    }
    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute('autocorrect', !!autocorrect);
        field.setAttribute('autocapitalize', !!autocapitalize);
        field.setAttribute('spellcheck', !!spellcheck);
    }
    function hiddenTextarea() {
        let te = dom.elt('textarea', null, null, 'position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none');
        let div = dom.elt('div', [te], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
        if (browser.webkit)
            te.style.width = '1000px';
        else
            te.setAttribute('wrap', 'off');
        if (browser.ios)
            te.style.border = '1px solid black';
        disableBrowserMagic(te);
        return div;
    }
    return {
        lastCopied: lastCopied,
        setLastCopied: setLastCopied,
        applyTextInput: applyTextInput,
        handlePaste: handlePaste,
        triggerElectric: triggerElectric,
        copyableRanges: copyableRanges,
        disableBrowserMagic: disableBrowserMagic,
        hiddenTextarea: hiddenTextarea
    };
});
define('skylark-codemirror/primitives/edit/methods',[
    './deleteNearSelection',
    './commands',
    '../model/document_data',
    '../util/dom',
    '../util/event',
    '../line/highlight',
    '../input/indent',
    '../input/input',
    './key_events',
    './mouse_events',
    '../input/keymap',
    '../input/movement',
    '../display/operations',
    '../line/pos',
    '../measurement/position_measurement',
    '../model/selection',
    '../model/selection_updates',
    '../display/scrolling',
    '../line/spans',
    '../display/update_display',
    '../util/misc',
    '../util/operation_group',
    '../line/utils_line',
    '../display/view_tracking',
    '../display/highlight_worker',
    '../display/line_numbers',
    '../display/scrollbars'
], function (
    m_deleteNearSelection, 
    m_commands, 
    m_document_data, 
    dom, 
    events, 
    highlight, 
    indent, 
    m_input, 
    key_events, 
    mouse_events, 
    keymap, 
    movement, 
    operations, 
    line_pos, 
    position_measurement, 
    selection, 
    selection_updates, 
    scrolling, 
    line_spans, 
    update_display, 
    misc, 
    operation_group, 
    utils_line, 
    view_tracking,
    m_highlight_worker,
    m_line_numbers,
    m_scrollbars
) {
    'use strict';

    function findPosH(doc, pos, dir, unit, visually) {
        let oldPos = pos;
        let origDir = dir;
        let lineObj = utils_line.getLine(doc, pos.line);
        function findNextLine() {
            let l = pos.line + dir;
            if (l < doc.first || l >= doc.first + doc.size)
                return false;
            pos = new line_pos.Pos(l, pos.ch, pos.sticky);
            return lineObj = utils_line.getLine(doc, l);
        }
        function moveOnce(boundToLine) {
            let next;
            if (visually) {
                next = movement.moveVisually(doc.cm, lineObj, pos, dir);
            } else {
                next = movement.moveLogically(lineObj, pos, dir);
            }
            if (next == null) {
                if (!boundToLine && findNextLine())
                    pos = movement.endOfLine(visually, doc.cm, lineObj, pos.line, dir);
                else
                    return false;
            } else {
                pos = next;
            }
            return true;
        }
        if (unit == 'char') {
            moveOnce();
        } else if (unit == 'column') {
            moveOnce(true);
        } else if (unit == 'word' || unit == 'group') {
            let sawType = null, group = unit == 'group';
            let helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');
            for (let first = true;; first = false) {
                if (dir < 0 && !moveOnce(!first))
                    break;
                let cur = lineObj.text.charAt(pos.ch) || '\n';
                let type = misc.isWordChar(cur, helper) ? 'w' : group && cur == '\n' ? 'n' : !group || /\s/.test(cur) ? null : 'p';
                if (group && !first && !type)
                    type = 's';
                if (sawType && sawType != type) {
                    if (dir < 0) {
                        dir = 1;
                        moveOnce();
                        pos.sticky = 'after';
                    }
                    break;
                }
                if (type)
                    sawType = type;
                if (dir > 0 && !moveOnce(!first))
                    break;
            }
        }
        let result = selection_updates.skipAtomic(doc, pos, oldPos, origDir, true);
        if (line_pos.equalCursorPos(oldPos, result))
            result.hitSide = true;
        return result;
    }
    function findPosV(cm, pos, dir, unit) {
        let doc = cm.doc, x = pos.left, y;
        if (unit == 'page') {
            let pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            let moveAmount = Math.max(pageSize - 0.5 * position_measurement.textHeight(cm.display), 3);
            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == 'line') {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        let target;
        for (;;) {
            target = position_measurement.coordsChar(cm, x, y);
            if (!target.outside)
                break;
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = true;
                break;
            }
            y += dir * 5;
        }
        return target;
    }
        
    return function (CodeMirror) {
        let optionHandlers = CodeMirror.optionHandlers;
        let helpers = CodeMirror.helpers = {};
        CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function () {
                window.focus();
                this.display.input.focus();
            },
            setOption: function (option, value) {
                let options = this.options, old = options[option];
                if (options[option] == value && option != 'mode')
                    return;
                options[option] = value;
                if (optionHandlers.hasOwnProperty(option))
                    operations.operation(this, optionHandlers[option])(this, value, old);
                events.signal(this, 'optionChange', this, option);
            },
            getOption: function (option) {
                return this.options[option];
            },
            getDoc: function () {
                return this.doc;
            },
            addKeyMap: function (map, bottom) {
                this.state.keyMaps[bottom ? 'push' : 'unshift'](keymap.getKeyMap(map));
            },
            removeKeyMap: function (map) {
                let maps = this.state.keyMaps;
                for (let i = 0; i < maps.length; ++i)
                    if (maps[i] == map || maps[i].name == map) {
                        maps.splice(i, 1);
                        return true;
                    }
            },
            addOverlay: operations.methodOp(function (spec, options) {
                let mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                if (mode.startState)
                    throw new Error('Overlays may not be stateful.');
                misc.insertSorted(this.state.overlays, {
                    mode: mode,
                    modeSpec: spec,
                    opaque: options && options.opaque,
                    priority: options && options.priority || 0
                }, overlay => overlay.priority);
                this.state.modeGen++;
                view_tracking.regChange(this);
            }),
            removeOverlay: operations.methodOp(function (spec) {
                let overlays = this.state.overlays;
                for (let i = 0; i < overlays.length; ++i) {
                    let cur = overlays[i].modeSpec;
                    if (cur == spec || typeof spec == 'string' && cur.name == spec) {
                        overlays.splice(i, 1);
                        this.state.modeGen++;
                        view_tracking.regChange(this);
                        return;
                    }
                }
            }),
            indentLine: operations.methodOp(function (n, dir, aggressive) {
                if (typeof dir != 'string' && typeof dir != 'number') {
                    if (dir == null)
                        dir = this.options.smartIndent ? 'smart' : 'prev';
                    else
                        dir = dir ? 'add' : 'subtract';
                }
                if (utils_line.isLine(this.doc, n))
                    indent.indentLine(this, n, dir, aggressive);
            }),
            indentSelection: operations.methodOp(function (how) {
                let ranges = this.doc.sel.ranges, end = -1;
                for (let i = 0; i < ranges.length; i++) {
                    let range = ranges[i];
                    if (!range.empty()) {
                        let from = range.from(), to = range.to();
                        let start = Math.max(end, from.line);
                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                        for (let j = start; j < end; ++j)
                            indent.indentLine(this, j, how);
                        let newRanges = this.doc.sel.ranges;
                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                            selection_updates.replaceOneSelection(this.doc, i, new selection.Range(from, newRanges[i].to()), misc.sel_dontScroll);
                    } else if (range.head.line > end) {
                        indent.indentLine(this, range.head.line, how, true);
                        end = range.head.line;
                        if (i == this.doc.sel.primIndex)
                            scrolling.ensureCursorVisible(this);
                    }
                }
            }),
            getTokenAt: function (pos, precise) {
                return highlight.takeToken(this, pos, precise);
            },
            getLineTokens: function (line, precise) {
                return highlight.takeToken(this, line_pos.Pos(line), precise, true);
            },
            getTokenTypeAt: function (pos) {
                pos = line_pos.clipPos(this.doc, pos);
                let styles = highlight.getLineStyles(this, utils_line.getLine(this.doc, pos.line));
                let before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                let type;
                if (ch == 0)
                    type = styles[2];
                else
                    for (;;) {
                        let mid = before + after >> 1;
                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                            after = mid;
                        else if (styles[mid * 2 + 1] < ch)
                            before = mid + 1;
                        else {
                            type = styles[mid * 2 + 2];
                            break;
                        }
                    }
                let cut = type ? type.indexOf('overlay ') : -1;
                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function (pos) {
                let mode = this.doc.mode;
                if (!mode.innerMode)
                    return mode;
                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function (pos, type) {
                return this.getHelpers(pos, type)[0];
            },
            getHelpers: function (pos, type) {
                let found = [];
                if (!helpers.hasOwnProperty(type))
                    return found;
                let help = helpers[type], mode = this.getModeAt(pos);
                if (typeof mode[type] == 'string') {
                    if (help[mode[type]])
                        found.push(help[mode[type]]);
                } else if (mode[type]) {
                    for (let i = 0; i < mode[type].length; i++) {
                        let val = help[mode[type][i]];
                        if (val)
                            found.push(val);
                    }
                } else if (mode.helperType && help[mode.helperType]) {
                    found.push(help[mode.helperType]);
                } else if (help[mode.name]) {
                    found.push(help[mode.name]);
                }
                for (let i = 0; i < help._global.length; i++) {
                    let cur = help._global[i];
                    if (cur.pred(mode, this) && misc.indexOf(found, cur.val) == -1)
                        found.push(cur.val);
                }
                return found;
            },
            getStateAfter: function (line, precise) {
                let doc = this.doc;
                line = line_pos.clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
                return highlight.getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function (start, mode) {
                let pos, range = this.doc.sel.primary();
                if (start == null)
                    pos = range.head;
                else if (typeof start == 'object')
                    pos = line_pos.clipPos(this.doc, start);
                else
                    pos = start ? range.from() : range.to();
                return position_measurement.cursorCoords(this, pos, mode || 'page');
            },
            charCoords: function (pos, mode) {
                return position_measurement.charCoords(this, line_pos.clipPos(this.doc, pos), mode || 'page');
            },
            coordsChar: function (coords, mode) {
                coords = position_measurement.fromCoordSystem(this, coords, mode || 'page');
                return position_measurement.coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function (height, mode) {
                height = position_measurement.fromCoordSystem(this, {
                    top: height,
                    left: 0
                }, mode || 'page').top;
                return utils_line.lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function (line, mode, includeWidgets) {
                let end = false, lineObj;
                if (typeof line == 'number') {
                    let last = this.doc.first + this.doc.size - 1;
                    if (line < this.doc.first)
                        line = this.doc.first;
                    else if (line > last) {
                        line = last;
                        end = true;
                    }
                    lineObj = utils_line.getLine(this.doc, line);
                } else {
                    lineObj = line;
                }
                return position_measurement.intoCoordSystem(this, lineObj, {
                    top: 0,
                    left: 0
                }, mode || 'page', includeWidgets || end).top + (end ? this.doc.height - line_spans.heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function () {
                return position_measurement.textHeight(this.display);
            },
            defaultCharWidth: function () {
                return position_measurement.charWidth(this.display);
            },
            getViewport: function () {
                return {
                    from: this.display.viewFrom,
                    to: this.display.viewTo
                };
            },
            addWidget: function (pos, node, scroll, vert, horiz) {
                let display = this.display;
                pos = position_measurement.cursorCoords(this, line_pos.clipPos(this.doc, pos));
                let top = pos.bottom, left = pos.left;
                node.style.position = 'absolute';
                node.setAttribute('cm-ignore-events', 'true');
                this.display.input.setUneditable(node);
                display.sizer.appendChild(node);
                if (vert == 'over') {
                    top = pos.top;
                } else if (vert == 'above' || vert == 'near') {
                    let vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                        top = pos.top - node.offsetHeight;
                    else if (pos.bottom + node.offsetHeight <= vspace)
                        top = pos.bottom;
                    if (left + node.offsetWidth > hspace)
                        left = hspace - node.offsetWidth;
                }
                node.style.top = top + 'px';
                node.style.left = node.style.right = '';
                if (horiz == 'right') {
                    left = display.sizer.clientWidth - node.offsetWidth;
                    node.style.right = '0px';
                } else {
                    if (horiz == 'left')
                        left = 0;
                    else if (horiz == 'middle')
                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                    node.style.left = left + 'px';
                }
                if (scroll)
                    scrolling.scrollIntoView(this, {
                        left,
                        top,
                        right: left + node.offsetWidth,
                        bottom: top + node.offsetHeight
                    });
            },
            triggerOnKeyDown: operations.methodOp(key_events.onKeyDown),
            triggerOnKeyPress: operations.methodOp(key_events.onKeyPress),
            triggerOnKeyUp: key_events.onKeyUp,
            triggerOnMouseDown: operations.methodOp(mouse_events.onMouseDown),
            execCommand: function (cmd) {
                if (m_commands.commands.hasOwnProperty(cmd))
                    return m_commands.commands[cmd].call(null, this);
            },
            triggerElectric: operations.methodOp(function (text) {
                m_input.triggerElectric(this, text);
            }),
            findPosH: function (from, amount, unit, visually) {
                let dir = 1;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                let cur = line_pos.clipPos(this.doc, from);
                for (let i = 0; i < amount; ++i) {
                    cur = findPosH(this.doc, cur, dir, unit, visually);
                    if (cur.hitSide)
                        break;
                }
                return cur;
            },
            moveH: operations.methodOp(function (dir, unit) {
                this.extendSelectionsBy(range => {
                    if (this.display.shift || this.doc.extend || range.empty())
                        return findPosH(this.doc, range.head, dir, unit, this.options.rtlMoveVisually);
                    else
                        return dir < 0 ? range.from() : range.to();
                }, misc.sel_move);
            }),
            deleteH: operations.methodOp(function (dir, unit) {
                let sel = this.doc.sel, doc = this.doc;
                if (sel.somethingSelected())
                    doc.replaceSelection('', null, '+delete');
                else
                    m_deleteNearSelection.deleteNearSelection(this, range => {
                        let other = findPosH(doc, range.head, dir, unit, false);
                        return dir < 0 ? {
                            from: other,
                            to: range.head
                        } : {
                            from: range.head,
                            to: other
                        };
                    });
            }),
            findPosV: function (from, amount, unit, goalColumn) {
                let dir = 1, x = goalColumn;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                let cur = line_pos.clipPos(this.doc, from);
                for (let i = 0; i < amount; ++i) {
                    let coords = position_measurement.cursorCoords(this, cur, 'div');
                    if (x == null)
                        x = coords.left;
                    else
                        coords.left = x;
                    cur = findPosV(this, coords, dir, unit);
                    if (cur.hitSide)
                        break;
                }
                return cur;
            },
            moveV: operations.methodOp(function (dir, unit) {
                let doc = this.doc, goals = [];
                let collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                doc.extendSelectionsBy(range => {
                    if (collapse)
                        return dir < 0 ? range.from() : range.to();
                    let headPos = position_measurement.cursorCoords(this, range.head, 'div');
                    if (range.goalColumn != null)
                        headPos.left = range.goalColumn;
                    goals.push(headPos.left);
                    let pos = findPosV(this, headPos, dir, unit);
                    if (unit == 'page' && range == doc.sel.primary())
                        scrolling.addToScrollTop(this, position_measurement.charCoords(this, pos, 'div').top - headPos.top);
                    return pos;
                }, misc.sel_move);
                if (goals.length)
                    for (let i = 0; i < doc.sel.ranges.length; i++)
                        doc.sel.ranges[i].goalColumn = goals[i];
            }),
            findWordAt: function (pos) {
                let doc = this.doc, line = utils_line.getLine(doc, pos.line).text;
                let start = pos.ch, end = pos.ch;
                if (line) {
                    let helper = this.getHelper(pos, 'wordChars');
                    if ((pos.sticky == 'before' || end == line.length) && start)
                        --start;
                    else
                        ++end;
                    let startChar = line.charAt(start);
                    let check = misc.isWordChar(startChar, helper) ? ch => misc.isWordChar(ch, helper) : /\s/.test(startChar) ? ch => /\s/.test(ch) : ch => !/\s/.test(ch) && !misc.isWordChar(ch);
                    while (start > 0 && check(line.charAt(start - 1)))
                        --start;
                    while (end < line.length && check(line.charAt(end)))
                        ++end;
                }
                return new selection.Range(line_pos.Pos(pos.line, start), line_pos.Pos(pos.line, end));
            },
            toggleOverwrite: function (value) {
                if (value != null && value == this.state.overwrite)
                    return;
                if (this.state.overwrite = !this.state.overwrite)
                    dom.addClass(this.display.cursorDiv, 'CodeMirror-overwrite');
                else
                    dom.rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');
                events.signal(this, 'overwriteToggle', this, this.state.overwrite);
            },
            hasFocus: function () {
                return this.display.input.getField() == dom.activeElt();
            },
            isReadOnly: function () {
                return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: operations.methodOp(function (x, y) {
                scrolling.scrollToCoords(this, x, y);
            }),
            getScrollInfo: function () {
                let scroller = this.display.scroller;
                return {
                    left: scroller.scrollLeft,
                    top: scroller.scrollTop,
                    height: scroller.scrollHeight - position_measurement.scrollGap(this) - this.display.barHeight,
                    width: scroller.scrollWidth - position_measurement.scrollGap(this) - this.display.barWidth,
                    clientHeight: position_measurement.displayHeight(this),
                    clientWidth: position_measurement.displayWidth(this)
                };
            },
            scrollIntoView: operations.methodOp(function (range, margin) {
                if (range == null) {
                    range = {
                        from: this.doc.sel.primary().head,
                        to: null
                    };
                    if (margin == null)
                        margin = this.options.cursorScrollMargin;
                } else if (typeof range == 'number') {
                    range = {
                        from: line_pos.Pos(range, 0),
                        to: null
                    };
                } else if (range.from == null) {
                    range = {
                        from: range,
                        to: null
                    };
                }
                if (!range.to)
                    range.to = range.from;
                range.margin = margin || 0;
                if (range.from.line != null) {
                    scrolling.scrollToRange(this, range);
                } else {
                    scrolling.scrollToCoordsRange(this, range.from, range.to, range.margin);
                }
            }),
            setSize: operations.methodOp(function (width, height) {
                let interpret = val => typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
                if (width != null)
                    this.display.wrapper.style.width = interpret(width);
                if (height != null)
                    this.display.wrapper.style.height = interpret(height);
                if (this.options.lineWrapping)
                    position_measurement.clearLineMeasurementCache(this);
                let lineNo = this.display.viewFrom;
                this.doc.iter(lineNo, this.display.viewTo, line => {
                    if (line.widgets)
                        for (let i = 0; i < line.widgets.length; i++)
                            if (line.widgets[i].noHScroll) {
                                view_tracking.regLineChange(this, lineNo, 'widget');
                                break;
                            }
                    ++lineNo;
                });
                this.curOp.forceUpdate = true;
                events.signal(this, 'refresh', this);
            }),
            operation: function (f) {
                return operations.runInOp(this, f);
            },
            startOperation: function () {
                return operations.startOperation(this);
            },
            endOperation: function () {
                return operations.endOperation(this);
            },
            refresh: operations.methodOp(function () {
                let oldHeight = this.display.cachedTextHeight;
                view_tracking.regChange(this);
                this.curOp.forceUpdate = true;
                position_measurement.clearCaches(this);
                scrolling.scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
                update_display.updateGutterSpace(this);
                if (oldHeight == null || Math.abs(oldHeight - position_measurement.textHeight(this.display)) > 0.5)
                    position_measurement.estimateLineHeights(this);
                events.signal(this, 'refresh', this);
            }),
            swapDoc: operations.methodOp(function (doc) {
                let old = this.doc;
                old.cm = null;
                m_document_data.attachDoc(this, doc);
                position_measurement.clearCaches(this);
                this.display.input.reset();
                scrolling.scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
                this.curOp.forceScroll = true;
                operation_group.signalLater(this, 'swapDoc', this, old);
                return old;
            }),
            phrase: function (phraseText) {
                let phrases = this.options.phrases;
                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function () {
                return this.display.input.getField();
            },
            getWrapperElement: function () {
                return this.display.wrapper;
            },
            getScrollerElement: function () {
                return this.display.scroller;
            },
            getGutterElement: function () {
                return this.display.gutters;
            },

            startWorker : function(time) {
                return m_highlight_worker.startWorker(this,time);
            },

            maybeUpdateLineNumberWidth : function() {
                return m_line_numbers.maybeUpdateLineNumberWidth(this);
            },

            measureForScrollbars : function() {
                return m_scrollbars.measureForScrollbars(this);
            },

            updateScrollbars : function(measure) {
                return m_scrollbars.updateScrollbars(this,measure);
            }
        };
        events.eventMixin(CodeMirror);
        CodeMirror.registerHelper = function (type, name, value) {
            if (!helpers.hasOwnProperty(type))
                helpers[type] = CodeMirror[type] = { _global: [] };
            helpers[type][name] = value;
        };
        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
            CodeMirror.registerHelper(type, name, value);
            helpers[type]._global.push({
                pred: predicate,
                val: value
            });
        };
    };

});
define('skylark-codemirror/primitives/input/ContentEditableInput',[
    '../display/operations',
    '../display/selection',
    '../display/view_tracking',
    './input',
    '../line/pos',
    '../line/utils_line',
    '../measurement/position_measurement',
    '../model/changes',
    '../model/selection',
    '../model/selection_updates',
    '../util/bidi',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/misc'
], function (operations, display_selection, view_tracking, inputs, line_pos, utils_line, position_measurement, changes, selection, selection_updates, bidi, browser, dom, events, misc) {
    'use strict';
    class ContentEditableInput {
        constructor(cm) {
            this.cm = cm;
            this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
            this.polling = new misc.Delayed();
            this.composing = null;
            this.gracePeriod = false;
            this.readDOMTimeout = null;
        }
        init(display) {
            let input = this, cm = input.cm;
            let div = input.div = display.lineDiv;
            inputs.disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
            events.on(div, 'paste', e => {
                if (events.signalDOMEvent(cm, e) || inputs.handlePaste(e, cm))
                    return;
                if (browser.ie_version <= 11)
                    setTimeout(operations.operation(cm, () => this.updateFromDOM()), 20);
            });
            events.on(div, 'compositionstart', e => {
                this.composing = {
                    data: e.data,
                    done: false
                };
            });
            events.on(div, 'compositionupdate', e => {
                if (!this.composing)
                    this.composing = {
                        data: e.data,
                        done: false
                    };
            });
            events.on(div, 'compositionend', e => {
                if (this.composing) {
                    if (e.data != this.composing.data)
                        this.readFromDOMSoon();
                    this.composing.done = true;
                }
            });
            events.on(div, 'touchstart', () => input.forceCompositionEnd());
            events.on(div, 'input', () => {
                if (!this.composing)
                    this.readFromDOMSoon();
            });
            function onCopyCut(e) {
                if (events.signalDOMEvent(cm, e))
                    return;
                if (cm.somethingSelected()) {
                    inputs.setLastCopied({
                        lineWise: false,
                        text: cm.getSelections()
                    });
                    if (e.type == 'cut')
                        cm.replaceSelection('', null, 'cut');
                } else if (!cm.options.lineWiseCopyCut) {
                    return;
                } else {
                    let ranges = inputs.copyableRanges(cm);
                    inputs.setLastCopied({
                        lineWise: true,
                        text: ranges.text
                    });
                    if (e.type == 'cut') {
                        cm.operation(() => {
                            cm.setSelections(ranges.ranges, 0, misc.sel_dontScroll);
                            cm.replaceSelection('', null, 'cut');
                        });
                    }
                }
                if (e.clipboardData) {
                    e.clipboardData.clearData();
                    let content = inputs.lastCopied.text.join('\n');
                    e.clipboardData.setData('Text', content);
                    if (e.clipboardData.getData('Text') == content) {
                        e.preventDefault();
                        return;
                    }
                }
                let kludge = inputs.hiddenTextarea(), te = kludge.firstChild;
                cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
                te.value = inputs.lastCopied.text.join('\n');
                let hadFocus = document.activeElement;
                dom.selectInput(te);
                setTimeout(() => {
                    cm.display.lineSpace.removeChild(kludge);
                    hadFocus.focus();
                    if (hadFocus == div)
                        input.showPrimarySelection();
                }, 50);
            }
            events.on(div, 'copy', onCopyCut);
            events.on(div, 'cut', onCopyCut);
        }
        prepareSelection() {
            let result = display_selection.prepareSelection(this.cm, false);
            result.focus = this.cm.state.focused;
            return result;
        }
        showSelection(info, takeFocus) {
            if (!info || !this.cm.display.view.length)
                return;
            if (info.focus || takeFocus)
                this.showPrimarySelection();
            this.showMultipleSelections(info);
        }
        getSelection() {
            return this.cm.display.wrapper.ownerDocument.getSelection();
        }
        showPrimarySelection() {
            let sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
            let from = prim.from(), to = prim.to();
            if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
                sel.removeAllRanges();
                return;
            }
            let curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
            let curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && line_pos.cmp(line_pos.minPos(curAnchor, curFocus), from) == 0 && line_pos.cmp(line_pos.maxPos(curAnchor, curFocus), to) == 0)
                return;
            let view = cm.display.view;
            let start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
                node: view[0].measure.map[2],
                offset: 0
            };
            let end = to.line < cm.display.viewTo && posToDOM(cm, to);
            if (!end) {
                let measure = view[view.length - 1].measure;
                let map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                end = {
                    node: map[map.length - 1],
                    offset: map[map.length - 2] - map[map.length - 3]
                };
            }
            if (!start || !end) {
                sel.removeAllRanges();
                return;
            }
            let old = sel.rangeCount && sel.getRangeAt(0), rng;
            try {
                rng = dom.range(start.node, start.offset, end.offset, end.node);
            } catch (e) {
            }
            if (rng) {
                if (!browser.gecko && cm.state.focused) {
                    sel.collapse(start.node, start.offset);
                    if (!rng.collapsed) {
                        sel.removeAllRanges();
                        sel.addRange(rng);
                    }
                } else {
                    sel.removeAllRanges();
                    sel.addRange(rng);
                }
                if (old && sel.anchorNode == null)
                    sel.addRange(old);
                else if (browser.gecko)
                    this.startGracePeriod();
            }
            this.rememberSelection();
        }
        startGracePeriod() {
            clearTimeout(this.gracePeriod);
            this.gracePeriod = setTimeout(() => {
                this.gracePeriod = false;
                if (this.selectionChanged())
                    this.cm.operation(() => this.cm.curOp.selectionChanged = true);
            }, 20);
        }
        showMultipleSelections(info) {
            dom.removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
            dom.removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        }
        rememberSelection() {
            let sel = this.getSelection();
            this.lastAnchorNode = sel.anchorNode;
            this.lastAnchorOffset = sel.anchorOffset;
            this.lastFocusNode = sel.focusNode;
            this.lastFocusOffset = sel.focusOffset;
        }
        selectionInEditor() {
            let sel = this.getSelection();
            if (!sel.rangeCount)
                return false;
            let node = sel.getRangeAt(0).commonAncestorContainer;
            return dom.contains(this.div, node);
        }
        focus() {
            if (this.cm.options.readOnly != 'nocursor') {
                if (!this.selectionInEditor())
                    this.showSelection(this.prepareSelection(), true);
                this.div.focus();
            }
        }
        blur() {
            this.div.blur();
        }
        getField() {
            return this.div;
        }
        supportsTouch() {
            return true;
        }
        receivedFocus() {
            let input = this;
            if (this.selectionInEditor())
                this.pollSelection();
            else
                operations.runInOp(this.cm, () => input.cm.curOp.selectionChanged = true);
            function poll() {
                if (input.cm.state.focused) {
                    input.pollSelection();
                    input.polling.set(input.cm.options.pollInterval, poll);
                }
            }
            this.polling.set(this.cm.options.pollInterval, poll);
        }
        selectionChanged() {
            let sel = this.getSelection();
            return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        }
        pollSelection() {
            if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())
                return;
            let sel = this.getSelection(), cm = this.cm;
            if (browser.android && browser.chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
                this.cm.triggerOnKeyDown({
                    type: 'keydown',
                    keyCode: 8,
                    preventDefault: Math.abs
                });
                this.blur();
                this.focus();
                return;
            }
            if (this.composing)
                return;
            this.rememberSelection();
            let anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
            let head = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (anchor && head)
                operations.runInOp(cm, () => {
                    selection_updates.setSelection(cm.doc, selection.simpleSelection(anchor, head), misc.sel_dontScroll);
                    if (anchor.bad || head.bad)
                        cm.curOp.selectionChanged = true;
                });
        }
        pollContent() {
            if (this.readDOMTimeout != null) {
                clearTimeout(this.readDOMTimeout);
                this.readDOMTimeout = null;
            }
            let cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
            let from = sel.from(), to = sel.to();
            if (from.ch == 0 && from.line > cm.firstLine())
                from = line_pos.Pos(from.line - 1, utils_line.getLine(cm.doc, from.line - 1).length);
            if (to.ch == utils_line.getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
                to = line_pos.Pos(to.line + 1, 0);
            if (from.line < display.viewFrom || to.line > display.viewTo - 1)
                return false;
            let fromIndex, fromLine, fromNode;
            if (from.line == display.viewFrom || (fromIndex = position_measurement.findViewIndex(cm, from.line)) == 0) {
                fromLine = utils_line.lineNo(display.view[0].line);
                fromNode = display.view[0].node;
            } else {
                fromLine = utils_line.lineNo(display.view[fromIndex].line);
                fromNode = display.view[fromIndex - 1].node.nextSibling;
            }
            let toIndex = position_measurement.findViewIndex(cm, to.line);
            let toLine, toNode;
            if (toIndex == display.view.length - 1) {
                toLine = display.viewTo - 1;
                toNode = display.lineDiv.lastChild;
            } else {
                toLine = utils_line.lineNo(display.view[toIndex + 1].line) - 1;
                toNode = display.view[toIndex + 1].node.previousSibling;
            }
            if (!fromNode)
                return false;
            let newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
            let oldText = utils_line.getBetween(cm.doc, line_pos.Pos(fromLine, 0), line_pos.Pos(toLine, utils_line.getLine(cm.doc, toLine).text.length));
            while (newText.length > 1 && oldText.length > 1) {
                if (misc.lst(newText) == misc.lst(oldText)) {
                    newText.pop();
                    oldText.pop();
                    toLine--;
                } else if (newText[0] == oldText[0]) {
                    newText.shift();
                    oldText.shift();
                    fromLine++;
                } else
                    break;
            }
            let cutFront = 0, cutEnd = 0;
            let newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
            while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
                ++cutFront;
            let newBot = misc.lst(newText), oldBot = misc.lst(oldText);
            let maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
            while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
                ++cutEnd;
            if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
                while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
                    cutFront--;
                    cutEnd++;
                }
            }
            newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, '');
            newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, '');
            let chFrom = line_pos.Pos(fromLine, cutFront);
            let chTo = line_pos.Pos(toLine, oldText.length ? misc.lst(oldText).length - cutEnd : 0);
            if (newText.length > 1 || newText[0] || line_pos.cmp(chFrom, chTo)) {
                changes.replaceRange(cm.doc, newText, chFrom, chTo, '+input');
                return true;
            }
        }
        ensurePolled() {
            this.forceCompositionEnd();
        }
        reset() {
            this.forceCompositionEnd();
        }
        forceCompositionEnd() {
            if (!this.composing)
                return;
            clearTimeout(this.readDOMTimeout);
            this.composing = null;
            this.updateFromDOM();
            this.div.blur();
            this.div.focus();
        }
        readFromDOMSoon() {
            if (this.readDOMTimeout != null)
                return;
            this.readDOMTimeout = setTimeout(() => {
                this.readDOMTimeout = null;
                if (this.composing) {
                    if (this.composing.done)
                        this.composing = null;
                    else
                        return;
                }
                this.updateFromDOM();
            }, 80);
        }
        updateFromDOM() {
            if (this.cm.isReadOnly() || !this.pollContent())
                operations.runInOp(this.cm, () => view_tracking.regChange(this.cm));
        }
        setUneditable(node) {
            node.contentEditable = 'false';
        }
        onKeyPress(e) {
            if (e.charCode == 0 || this.composing)
                return;
            e.preventDefault();
            if (!this.cm.isReadOnly())
                operations.operation(this.cm, inputs.applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        }
        readOnlyChanged(val) {
            this.div.contentEditable = String(val != 'nocursor');
        }
        onContextMenu() {
        }
        resetPosition() {
        }
    };
    ContentEditableInput.prototype.needsContentAttribute = true;
    function posToDOM(cm, pos) {
        let view = position_measurement.findViewForLine(cm, pos.line);
        if (!view || view.hidden)
            return null;
        let line = utils_line.getLine(cm.doc, pos.line);
        let info = position_measurement.mapFromLineView(view, line, pos.line);
        let order = bidi.getOrder(line, cm.doc.direction), side = 'left';
        if (order) {
            let partPos = bidi.getBidiPartAt(order, pos.ch);
            side = partPos % 2 ? 'right' : 'left';
        }
        let result = position_measurement.nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == 'right' ? result.end : result.start;
        return result;
    }
    function isInGutter(node) {
        for (let scan = node; scan; scan = scan.parentNode)
            if (/CodeMirror-gutter-wrapper/.test(scan.className))
                return true;
        return false;
    }
    function badPos(pos, bad) {
        if (bad)
            pos.bad = true;
        return pos;
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
        let text = '', closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
        function recognizeMarker(id) {
            return marker => marker.id == id;
        }
        function close() {
            if (closing) {
                text += lineSep;
                if (extraLinebreak)
                    text += lineSep;
                closing = extraLinebreak = false;
            }
        }
        function addText(str) {
            if (str) {
                close();
                text += str;
            }
        }
        function walk(node) {
            if (node.nodeType == 1) {
                let cmText = node.getAttribute('cm-text');
                if (cmText) {
                    addText(cmText);
                    return;
                }
                let markerID = node.getAttribute('cm-marker'), range;
                if (markerID) {
                    let found = cm.findMarks(line_pos.Pos(fromLine, 0), line_pos.Pos(toLine + 1, 0), recognizeMarker(+markerID));
                    if (found.length && (range = found[0].find(0)))
                        addText(utils_line.getBetween(cm.doc, range.from, range.to).join(lineSep));
                    return;
                }
                if (node.getAttribute('contenteditable') == 'false')
                    return;
                let isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0)
                    return;
                if (isBlock)
                    close();
                for (let i = 0; i < node.childNodes.length; i++)
                    walk(node.childNodes[i]);
                if (/^(pre|p)$/i.test(node.nodeName))
                    extraLinebreak = true;
                if (isBlock)
                    closing = true;
            } else if (node.nodeType == 3) {
                addText(node.nodeValue.replace(/\u200b/g, '').replace(/\u00a0/g, ' '));
            }
        }
        for (;;) {
            walk(from);
            if (from == to)
                break;
            from = from.nextSibling;
            extraLinebreak = false;
        }
        return text;
    }
    function domToPos(cm, node, offset) {
        let lineNode;
        if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset];
            if (!lineNode)
                return badPos(cm.clipPos(line_pos.Pos(cm.display.viewTo - 1)), true);
            node = null;
            offset = 0;
        } else {
            for (lineNode = node;; lineNode = lineNode.parentNode) {
                if (!lineNode || lineNode == cm.display.lineDiv)
                    return null;
                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)
                    break;
            }
        }
        for (let i = 0; i < cm.display.view.length; i++) {
            let lineView = cm.display.view[i];
            if (lineView.node == lineNode)
                return locateNodeInLineView(lineView, node, offset);
        }
    }
    function locateNodeInLineView(lineView, node, offset) {
        let wrapper = lineView.text.firstChild, bad = false;
        if (!node || !dom.contains(wrapper, node))
            return badPos(line_pos.Pos(utils_line.lineNo(lineView.line), 0), true);
        if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset];
            offset = 0;
            if (!node) {
                let line = lineView.rest ? misc.lst(lineView.rest) : lineView.line;
                return badPos(line_pos.Pos(utils_line.lineNo(line), line.text.length), bad);
            }
        }
        let textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset)
                offset = textNode.nodeValue.length;
        }
        while (topNode.parentNode != wrapper)
            topNode = topNode.parentNode;
        let measure = lineView.measure, maps = measure.maps;
        function find(textNode, topNode, offset) {
            for (let i = -1; i < (maps ? maps.length : 0); i++) {
                let map = i < 0 ? measure.map : maps[i];
                for (let j = 0; j < map.length; j += 3) {
                    let curNode = map[j + 2];
                    if (curNode == textNode || curNode == topNode) {
                        let line = utils_line.lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                        let ch = map[j] + offset;
                        if (offset < 0 || curNode != textNode)
                            ch = map[j + (offset ? 1 : 0)];
                        return line_pos.Pos(line, ch);
                    }
                }
            }
        }
        let found = find(textNode, topNode, offset);
        if (found)
            return badPos(found, bad);
        for (let after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
            found = find(after, after.firstChild, 0);
            if (found)
                return badPos(line_pos.Pos(found.line, found.ch - dist), bad);
            else
                dist += after.textContent.length;
        }
        for (let before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
            found = find(before, before.firstChild, -1);
            if (found)
                return badPos(line_pos.Pos(found.line, found.ch + dist), bad);
            else
                dist += before.textContent.length;
        }
    }

    return ContentEditableInput;
});
define('skylark-codemirror/primitives/input/TextareaInput',[
    '../display/operations',
    '../display/selection',
    './input',
    '../measurement/position_measurement',
    '../measurement/widgets',
    '../model/selection',
    '../model/selection_updates',
    '../util/browser',
    '../util/dom',
    '../util/event',
    '../util/feature_detection',
    '../util/misc'
], function (
    operations, 
    display_selection, 
    inputs, 
    position_measurement, 
    widgets, 
    model_selection, 
    selection_updates, 
    browser, 
    dom, 
    event, 
    feature_detection, 
    misc
) {
    'use strict';
    class TextareaInput {
        constructor(cm) {
            this.cm = cm;
            this.prevInput = '';
            this.pollingFast = false;
            this.polling = new misc.Delayed();
            this.hasSelection = false;
            this.composing = null;
        }
        init(display) {
            let self = this, cm = this.cm;
            this.createField(display);
            const te = this.textarea;
            display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
            if (browser.ios)
                te.style.width = '0px';
            event.on(te, 'input', () => {
                if (browser.ie && browser.ie_version >= 9 && this.hasSelection)
                    this.hasSelection = null;
                self.poll();
            });
            event.on(te, 'paste', e => {
                if (event.signalDOMEvent(cm, e) || inputs.handlePaste(e, cm))
                    return;
                cm.state.pasteIncoming = +new Date();
                self.fastPoll();
            });
            function prepareCopyCut(e) {
                if (event.signalDOMEvent(cm, e))
                    return;
                if (cm.somethingSelected()) {
                    inputs.setLastCopied({
                        lineWise: false,
                        text: cm.getSelections()
                    });
                } else if (!cm.options.lineWiseCopyCut) {
                    return;
                } else {
                    let ranges = inputs.copyableRanges(cm);
                    inputs.setLastCopied({
                        lineWise: true,
                        text: ranges.text
                    });
                    if (e.type == 'cut') {
                        cm.setSelections(ranges.ranges, null, misc.sel_dontScroll);
                    } else {
                        self.prevInput = '';
                        te.value = ranges.text.join('\n');
                        dom.selectInput(te);
                    }
                }
                if (e.type == 'cut')
                    cm.state.cutIncoming = +new Date();
            }
            event.on(te, 'cut', prepareCopyCut);
            event.on(te, 'copy', prepareCopyCut);
            event.on(display.scroller, 'paste', e => {
                if (widgets.eventInWidget(display, e) || event.signalDOMEvent(cm, e))
                    return;
                if (!te.dispatchEvent) {
                    cm.state.pasteIncoming = +new Date();
                    self.focus();
                    return;
                }
                const event = new Event('paste');
                event.clipboardData = e.clipboardData;
                te.dispatchEvent(event);
            });
            event.on(display.lineSpace, 'selectstart', e => {
                if (!widgets.eventInWidget(display, e))
                    event.e_preventDefault(e);
            });
            event.on(te, 'compositionstart', () => {
                let start = cm.getCursor('from');
                if (self.composing)
                    self.composing.range.clear();
                self.composing = {
                    start: start,
                    range: cm.markText(start, cm.getCursor('to'), { className: 'CodeMirror-composing' })
                };
            });
            event.on(te, 'compositionend', () => {
                if (self.composing) {
                    self.poll();
                    self.composing.range.clear();
                    self.composing = null;
                }
            });
        }
        createField(_display) {
            this.wrapper = inputs.hiddenTextarea();
            this.textarea = this.wrapper.firstChild;
        }
        prepareSelection() {
            let cm = this.cm, display = cm.display, doc = cm.doc;
            let result = display_selection.prepareSelection(cm);
            if (cm.options.moveInputWithCursor) {
                let headPos = position_measurement.cursorCoords(cm, doc.sel.primary().head, 'div');
                let wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
                result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
                result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
            }
            return result;
        }
        showSelection(drawn) {
            let cm = this.cm, display = cm.display;
            dom.removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
            dom.removeChildrenAndAdd(display.selectionDiv, drawn.selection);
            if (drawn.teTop != null) {
                this.wrapper.style.top = drawn.teTop + 'px';
                this.wrapper.style.left = drawn.teLeft + 'px';
            }
        }
        reset(typing) {
            if (this.contextMenuPending || this.composing)
                return;
            let cm = this.cm;
            if (cm.somethingSelected()) {
                this.prevInput = '';
                let content = cm.getSelection();
                this.textarea.value = content;
                if (cm.state.focused)
                    dom.selectInput(this.textarea);
                if (browser.ie && browser.ie_version >= 9)
                    this.hasSelection = content;
            } else if (!typing) {
                this.prevInput = this.textarea.value = '';
                if (browser.ie && browser.ie_version >= 9)
                    this.hasSelection = null;
            }
        }
        getField() {
            return this.textarea;
        }
        supportsTouch() {
            return false;
        }
        focus() {
            if (this.cm.options.readOnly != 'nocursor' && (!browser.mobile || dom.activeElt() != this.textarea)) {
                try {
                    this.textarea.focus();
                } catch (e) {
                }
            }
        }
        blur() {
            this.textarea.blur();
        }
        resetPosition() {
            this.wrapper.style.top = this.wrapper.style.left = 0;
        }
        receivedFocus() {
            this.slowPoll();
        }
        slowPoll() {
            if (this.pollingFast)
                return;
            this.polling.set(this.cm.options.pollInterval, () => {
                this.poll();
                if (this.cm.state.focused)
                    this.slowPoll();
            });
        }
        fastPoll() {
            let missed = false, self = this;
            self.pollingFast = true;
            function p() {
                let changed = self.poll();
                if (!changed && !missed) {
                    missed = true;
                    self.polling.set(60, p);
                } else {
                    self.pollingFast = false;
                    self.slowPoll();
                }
            }
            self.polling.set(20, p);
        }
        poll() {
            let cm = this.cm, input = this.textarea, prevInput = this.prevInput;
            if (this.contextMenuPending || !cm.state.focused || feature_detection.hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
                return false;
            let text = input.value;
            if (text == prevInput && !cm.somethingSelected())
                return false;
            if (browser.ie && browser.ie_version >= 9 && this.hasSelection === text || browser.mac && /[\uf700-\uf7ff]/.test(text)) {
                cm.display.input.reset();
                return false;
            }
            if (cm.doc.sel == cm.display.selForContextMenu) {
                let first = text.charCodeAt(0);
                if (first == 8203 && !prevInput)
                    prevInput = '\u200B';
                if (first == 8666) {
                    this.reset();
                    return this.cm.execCommand('undo');
                }
            }
            let same = 0, l = Math.min(prevInput.length, text.length);
            while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
                ++same;
            operations.runInOp(cm, () => {
                inputs.applyTextInput(cm, text.slice(same), prevInput.length - same, null, this.composing ? '*compose' : null);
                if (text.length > 1000 || text.indexOf('\n') > -1)
                    input.value = this.prevInput = '';
                else
                    this.prevInput = text;
                if (this.composing) {
                    this.composing.range.clear();
                    this.composing.range = cm.markText(this.composing.start, cm.getCursor('to'), { className: 'CodeMirror-composing' });
                }
            });
            return true;
        }
        ensurePolled() {
            if (this.pollingFast && this.poll())
                this.pollingFast = false;
        }
        onKeyPress() {
            if (browser.ie && browser.ie_version >= 9)
                this.hasSelection = null;
            this.fastPoll();
        }
        onContextMenu(e) {
            let self = this, cm = self.cm, display = cm.display, te = self.textarea;
            if (self.contextMenuPending)
                self.contextMenuPending();
            let pos = position_measurement.posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
            if (!pos || browser.presto)
                return;
            let reset = cm.options.resetSelectionOnContextMenu;
            if (reset && cm.doc.sel.contains(pos) == -1)
                operations.operation(cm, selection_updates.setSelection)(cm.doc, model_selection.simpleSelection(pos), misc.sel_dontScroll);
            let oldCSS = te.style.cssText, oldWrapperCSS = self.wrapper.style.cssText;
            let wrapperBox = self.wrapper.offsetParent.getBoundingClientRect();
            self.wrapper.style.cssText = 'position: static';
            te.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ${ e.clientY - wrapperBox.top - 5 }px; left: ${ e.clientX - wrapperBox.left - 5 }px;
      z-index: 1000; background: ${ browser.ie ? 'rgba(255, 255, 255, .05)' : 'transparent' };
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
            let oldScrollY;
            if (browser.webkit)
                oldScrollY = window.scrollY;
            display.input.focus();
            if (browser.webkit)
                window.scrollTo(null, oldScrollY);
            display.input.reset();
            if (!cm.somethingSelected())
                te.value = self.prevInput = ' ';
            self.contextMenuPending = rehide;
            display.selForContextMenu = cm.doc.sel;
            clearTimeout(display.detectingSelectAll);
            function prepareSelectAllHack() {
                if (te.selectionStart != null) {
                    let selected = cm.somethingSelected();
                    let extval = '\u200B' + (selected ? te.value : '');
                    te.value = '\u21DA';
                    te.value = extval;
                    self.prevInput = selected ? '' : '\u200B';
                    te.selectionStart = 1;
                    te.selectionEnd = extval.length;
                    display.selForContextMenu = cm.doc.sel;
                }
            }
            function rehide() {
                if (self.contextMenuPending != rehide)
                    return;
                self.contextMenuPending = false;
                self.wrapper.style.cssText = oldWrapperCSS;
                te.style.cssText = oldCSS;
                if (browser.ie && browser.ie_version < 9)
                    display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
                if (te.selectionStart != null) {
                    if (!browser.ie || browser.ie && browser.ie_version < 9)
                        prepareSelectAllHack();
                    let i = 0, poll = () => {
                            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && self.prevInput == '\u200B') {
                                operations.operation(cm, selection_updates.selectAll)(cm);
                            } else if (i++ < 10) {
                                display.detectingSelectAll = setTimeout(poll, 500);
                            } else {
                                display.selForContextMenu = null;
                                display.input.reset();
                            }
                        };
                    display.detectingSelectAll = setTimeout(poll, 200);
                }
            }
            if (browser.ie && browser.ie_version >= 9)
                prepareSelectAllHack();
            if (browser.captureRightClick) {
                event.e_stop(e);
                let mouseup = () => {
                    event.off(window, 'mouseup', mouseup);
                    setTimeout(rehide, 20);
                };
                event.on(window, 'mouseup', mouseup);
            } else {
                setTimeout(rehide, 50);
            }
        }
        readOnlyChanged(val) {
            if (!val)
                this.reset();
            this.textarea.disabled = val == 'nocursor';
        }
        setUneditable() {
        }
    };
    TextareaInput.prototype.needsContentAttribute = false;

    return TextareaInput;

});
define('skylark-codemirror/primitives/edit/fromTextArea',[
    './CodeMirror',
    '../util/dom',
    '../util/event',
    '../util/misc'
], function (CodeMirror, dom, events, misc) {
    'use strict';
    function fromTextArea(textarea, options) {
        options = options ? misc.copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex)
            options.tabindex = textarea.tabIndex;
        if (!options.placeholder && textarea.placeholder)
            options.placeholder = textarea.placeholder;
        if (options.autofocus == null) {
            let hasFocus = dom.activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
        }
        function save() {
            textarea.value = cm.getValue();
        }
        let realSubmit;
        if (textarea.form) {
            events.on(textarea.form, 'submit', save);
            if (!options.leaveSubmitMethodAlone) {
                let form = textarea.form;
                realSubmit = form.submit;
                try {
                    let wrappedSubmit = form.submit = () => {
                        save();
                        form.submit = realSubmit;
                        form.submit();
                        form.submit = wrappedSubmit;
                    };
                } catch (e) {
                }
            }
        }
        options.finishInit = cm => {
            cm.save = save;
            cm.getTextArea = () => textarea;
            cm.toTextArea = () => {
                cm.toTextArea = isNaN;
                save();
                textarea.parentNode.removeChild(cm.getWrapperElement());
                textarea.style.display = '';
                if (textarea.form) {
                    events.off(textarea.form, 'submit', save);
                    if (typeof textarea.form.submit == 'function')
                        textarea.form.submit = realSubmit;
                }
            };
        };
        textarea.style.display = 'none';
        let cm = CodeMirror(node => textarea.parentNode.insertBefore(node, textarea.nextSibling), options);
        return cm;
    }
    return { fromTextArea: fromTextArea };
});
define('skylark-codemirror/primitives/edit/legacy',[
    '../display/scrollbars',
    '../display/scroll_events',
    '../input/keymap',
    '../input/keynames',
    '../line/line_data',
    '../line/pos',
    '../model/change_measurement',
    '../model/Doc',
    '../model/line_widget',
    '../model/mark_text',
    '../modes',
    '../util/dom',
    '../util/event',
    '../util/feature_detection',
    '../util/misc',
    '../util/StringStream',
    './commands'
], function (a, b, c, d, e, f, g, Doc, h, i, j, k, l, m, n, StringStream, o) {
    'use strict';
    function addLegacyProps(CodeMirror) {
        CodeMirror.off = l.off;
        CodeMirror.on = l.on;
        CodeMirror.wheelEventPixels = b.wheelEventPixels;
        CodeMirror.Doc = Doc;
        CodeMirror.splitLines = m.splitLinesAuto;
        CodeMirror.countColumn = n.countColumn;
        CodeMirror.findColumn = n.findColumn;
        CodeMirror.isWordChar = n.isWordCharBasic;
        CodeMirror.Pass = n.Pass;
        CodeMirror.signal = l.signal;
        CodeMirror.Line = e.Line;
        CodeMirror.changeEnd = g.changeEnd;
        CodeMirror.scrollbarModel = a.scrollbarModel;
        CodeMirror.Pos = f.Pos;
        CodeMirror.cmpPos = f.cmp;
        CodeMirror.modes = j.modes;
        CodeMirror.mimeModes = j.mimeModes;
        CodeMirror.resolveMode = j.resolveMode;
        CodeMirror.getMode = j.getMode;
        CodeMirror.modeExtensions = j.modeExtensions;
        CodeMirror.extendMode = j.extendMode;
        CodeMirror.copyState = j.copyState;
        CodeMirror.startState = j.startState;
        CodeMirror.innerMode = j.innerMode;
        CodeMirror.commands = o.commands;
        CodeMirror.keyMap = c.keyMap;
        CodeMirror.keyName = c.keyName;
        CodeMirror.isModifierKey = c.isModifierKey;
        CodeMirror.lookupKey = c.lookupKey;
        CodeMirror.normalizeKeyMap = c.normalizeKeyMap;
        CodeMirror.StringStream = StringStream;
        CodeMirror.SharedTextMarker = i.SharedTextMarker;
        CodeMirror.TextMarker = i.TextMarker;
        CodeMirror.LineWidget = h.LineWidget;
        CodeMirror.e_preventDefault = l.e_preventDefault;
        CodeMirror.e_stopPropagation = l.e_stopPropagation;
        CodeMirror.e_stop = l.e_stop;
        CodeMirror.addClass = k.addClass;
        CodeMirror.contains = k.contains;
        CodeMirror.rmClass = k.rmClass;
        CodeMirror.keyNames = d.keyNames;
    }
    return { addLegacyProps: addLegacyProps };
});
define('skylark-codemirror/primitives/edit/main',[
    './CodeMirror',
    '../util/event',
    '../util/misc',
    './options',
    './methods',
    '../model/Doc',
    '../input/ContentEditableInput',
    '../input/TextareaInput',
    '../modes',
    './fromTextArea',
    './legacy'
], function (CodeMirror, events, misc, options, addEditorMethods, Doc, ContentEditableInput, TextareaInput, modes, m_fromTextArea, legacy) {
    'use strict';
    options.defineOptions(CodeMirror);

    addEditorMethods(CodeMirror);

    let dontDelegate = 'iter insert remove copy getEditor constructor'.split(' ');
    for (let prop in Doc.prototype)
        if (Doc.prototype.hasOwnProperty(prop) && misc.indexOf(dontDelegate, prop) < 0)
            CodeMirror.prototype[prop] = function (method) {
                return function () {
                    return method.apply(this.doc, arguments);
                };
            }(Doc.prototype[prop]);

    events.eventMixin(Doc);

    CodeMirror.inputStyles = {
        'textarea': TextareaInput,
        'contenteditable': ContentEditableInput
    };

    CodeMirror.defineMode = function (name) {
        if (!CodeMirror.defaults.mode && name != 'null')
            CodeMirror.defaults.mode = name;
        modes.defineMode.apply(this, arguments);
    };

    CodeMirror.defineMIME = modes.defineMIME;

    CodeMirror.defineMode('null', () => ({ token: stream => stream.skipToEnd() }));

    CodeMirror.defineMIME('text/plain', 'null');

    CodeMirror.defineExtension = (name, func) => {
        CodeMirror.prototype[name] = func;
    };

    CodeMirror.defineDocExtension = (name, func) => {
        Doc.prototype[name] = func;
    };

    CodeMirror.fromTextArea = m_fromTextArea.fromTextArea;

    legacy.addLegacyProps(CodeMirror);
    CodeMirror.version = '5.45.0';
    return { 
        CodeMirror : CodeMirror 
    };
});
define('skylark-codemirror/CodeMirror',[
	'./cm',
	'./primitives/edit/main'
], function (cm,_main) {
    'use strict';
    return cm.CodeMirror = _main.CodeMirror;
});
define('skylark-codemirror/main',[
	"./cm",
    "./CodeMirror"
],function(cm){

	return cm;
});
define('skylark-codemirror', ['skylark-codemirror/main'], function (main) { return main; });

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

define('skylark-codemirror/mode/xml/xml',["../../CodeMirror"], function(CodeMirror) {


var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    }
  }

  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

define('skylark-codemirror/mode/javascript/javascript',["../../CodeMirror"], function(CodeMirror) {


CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.match(/^(?:x[\da-f]+|o[0-7]+|b[01]+)n?/i)) {
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:n|(?:\.\d*)?(?:[eE][+\-]?\d+)?)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=")
        } else if (/[<>*+\-]/.test(ch)) {
          stream.eat(ch)
          if (ch == ">") stream.eat(ch)
        }
      }
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function inList(name, list) {
    for (var v = list; v; v = v.next) if (v.name == name) return true
    return false;
  }
  function register(varname) {
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (state.lexical.info == "var" && state.context && state.context.block) {
        // FIXME function decls are also not block scoped
        var newContext = registerVarScoped(varname, state.context)
        if (newContext != null) {
          state.context = newContext
          return
        }
      } else if (!inList(varname, state.localVars)) {
        state.localVars = new Var(varname, state.localVars)
        return
      }
    }
    // Fall through means this is global
    if (parserConfig.globalVars && !inList(varname, state.globalVars))
      state.globalVars = new Var(varname, state.globalVars)
  }
  function registerVarScoped(varname, context) {
    if (!context) {
      return null
    } else if (context.block) {
      var inner = registerVarScoped(varname, context.prev)
      if (!inner) return null
      if (inner == context.prev) return context
      return new Context(inner, context.vars, true)
    } else if (inList(varname, context.vars)) {
      return context
    } else {
      return new Context(context.prev, new Var(varname, context.vars), false)
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }
  function Var(name, next) { this.name = name; this.next = next }

  var defaultVars = new Var("this", new Var("arguments", null))
  function pushcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)
    cx.state.localVars = defaultVars
  }
  function pushblockcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)
    cx.state.localVars = null
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars
    cx.state.context = cx.state.context.prev
  }
  popcontext.lex = true
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "class" || (isTS && value == "interface")) {
      cx.marked = "keyword"
      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
    }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword"
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword"
        return cont(pushlex("form"), expression, statement, poplex)
      } else if (isTS && value == "abstract") {
        cx.marked = "keyword"
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                      block, poplex, poplex, popcontext);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function maybeCatchBinding(type) {
    if (type == "(") return cont(funarg, expect(")"))
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), expression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    if (type == "import") return cont(expression);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword"
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      if (sep && sep.indexOf(";") > -1) return pass(what)
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":" || value == "in") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword"
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof" || value == "infer") {
      cx.marked = "keyword"
      return cont(value == "typeof" ? expressionNoComma : typeexpr)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type"
      return cont(afterType)
    }
    if (value == "|" || value == "&") return cont(typeexpr)
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?" || type == "number" || type == "string") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expect("variable"), maybetype, expect("]"), typeprop)
    } else if (type == "(") {
      return pass(functiondecl, typeprop)
    }
  }
  function typearg(type, value) {
    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
    if (type == ":") return cont(typeexpr)
    if (type == "spread") return cont(typearg)
    return pass(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(typeexpr, expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(eltpattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
    return cont(expect(":"), pattern, maybeAssign);
  }
  function eltpattern() {
    return pass(pattern, maybeAssign)
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, forspec2);
    if (type == "variable") return cont(forspec2);
    return pass(forspec2)
  }
  function forspec2(type, value) {
    if (type == ")") return cont()
    if (type == ";") return cont(forspec2)
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
    return pass(expression, forspec2)
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function functiondecl(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
    if (type == "variable") {register(value); return cont(functiondecl);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
  }
  function typename(type, value) {
    if (type == "keyword" || type == "variable") {
      cx.marked = "type"
      return cont(typename)
    } else if (value == "<") {
      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
    }
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    if (isTS && type == "this") return cont(maybetype, maybeAssign)
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(isTS ? classfield : functiondef, classBody);
    }
    if (type == "number" || type == "string") return cont(isTS ? classfield : functiondef, classBody);
    if (type == "[")
      return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (isTS && type == "(") return pass(functiondecl, classBody)
    if (type == ";" || type == ",") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"
    return pass(isInterface ? functiondecl : functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && new Context(null, null, false),
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

define('skylark-codemirror/mode/css/css',["../../CodeMirror"], function(CodeMirror) {


CodeMirror.defineMode("css", function(config, parserConfig) {
  var inline = parserConfig.inline
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]*/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (stream.match(/[\w-.]+(?=\()/)) {
      if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {
        state.tokenize = tokenParenthesized;
      }
      return ret("variable callee", "variable");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
    return type;
  }

  function popContext(state) {
    if (state.context.prev)
      state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (supportsAtComponent && /@component/i.test(type)) {
      return pushContext(state, stream, "atComponentBlock");
    } else if (/^@(-moz-)?document$/i.test(type)) {
      return pushContext(state, stream, "documentTypes");
    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
      return pushContext(state, stream, "atBlock");
    } else if (/^@(font-face|counter-style)/i.test(type)) {
      state.stateArg = type;
      return "restricted_atBlock_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "interpolation") return pushContext(state, stream, "interpolation");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "meta") return "pseudo";

    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.documentTypes = function(type, stream, state) {
    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
      override = "tag";
      return state.context.type;
    } else {
      return states.atBlock(type, stream, state);
    }
  };

  states.atBlock = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "atBlock_parens");
    if (type == "}" || type == ";") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "interpolation") return pushContext(state, stream, "interpolation");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and" || word == "or")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else if (mediaValueKeywords.hasOwnProperty(word))
        override = "keyword";
      else if (propertyKeywords.hasOwnProperty(word))
        override = "property";
      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
        override = "string-2";
      else if (valueKeywords.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords.hasOwnProperty(word))
        override = "keyword";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.atComponentBlock = function(type, stream, state) {
    if (type == "}")
      return popAndPass(type, stream, state);
    if (type == "{")
      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
    if (type == "word")
      override = "error";
    return state.context.type;
  };

  states.atBlock_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.atBlock(type, stream, state);
  };

  states.restricted_atBlock_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "restricted_atBlock");
    if (type == "word" && state.stateArg == "@counter-style") {
      override = "variable";
      return "restricted_atBlock_before";
    }
    return pass(type, stream, state);
  };

  states.restricted_atBlock = function(type, stream, state) {
    if (type == "}") {
      state.stateArg = null;
      return popContext(state);
    }
    if (type == "word") {
      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "restricted_atBlock";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type == "word") override = "variable";
    else if (type != "variable" && type != "(" && type != ")") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      if (type != "comment")
        state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev) {
        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
          // Resume indentation from parent context.
          cx = cx.prev;
          indent = cx.indent;
        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
          // Dedent relative to current context.
          indent = Math.max(0, cx.indent - indentUnit);
        }
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: lineComment,
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = [
    "domain", "regexp", "url", "url-prefix"
  ], documentTypes = keySet(documentTypes_);

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid", "orientation",
    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
    "pointer", "any-pointer", "hover", "any-hover"
  ], mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = [
    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
    "interlace", "progressive"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-blend-mode", "background-clip",
    "background-color", "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "mix-blend-mode", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
    "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
    "shape-outside", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = [
    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
    "speak-as", "suffix", "symbols", "system"
  ], counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
    "compact", "condensed", "contain", "content", "contents",
    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
    "dot-dash", "dot-dot-dash",
    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
    "katakana", "katakana-iroha", "keep-all", "khmer",
    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
    "progress", "push-button", "radial-gradient", "radio", "read-only",
    "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeating-linear-gradient",
    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "simp-chinese-formal", "simp-chinese-informal", "single",
    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "tamil",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "trad-chinese-formal", "trad-chinese-informal", "transform",
    "translate", "translate3d", "translateX", "translateY", "translateZ",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
    .concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*\{/, false))
          return [null, null]
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE


define('skylark-codemirror/mode/htmlmixed/htmlmixed',[
  "../../CodeMirror",
  "../xml/xml",
  "../javascript/javascript",
  "../css/css"
], function(CodeMirror) {

  "use strict";

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr))
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i])
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " "
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
        state.inTag = null
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
        var mode = CodeMirror.getMode(config, modeSpec)
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
      } else if (state.inTag) {
        state.inTag += stream.current()
        if (stream.eol()) state.inTag += " "
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter, line);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});

define('skylark-grapejs/code_manager/model/formating',[
    'skylark-codemirror'
], function (CodeMirror) {

  CodeMirror.extendMode("css", {
    commentStart: "/*",
    commentEnd: "*/",
    newlineAfterToken: function(_type, content) {
      return /^[;{}]$/.test(content);
    }
  });

  CodeMirror.extendMode("javascript", {
    commentStart: "/*",
    commentEnd: "*/",
    // FIXME semicolons inside of for
    newlineAfterToken: function(_type, content, textAfter, state) {
      if (this.jsonMode) {
        return /^[\[,{]$/.test(content) || /^}/.test(textAfter);
      } else {
        if (content == ";" && state.lexical && state.lexical.type == ")") return false;
        return /^[;{}]$/.test(content) && !/^;/.test(textAfter);
      }
    }
  });

  var inlineElements = /^(a|abbr|acronym|area|base|bdo|big|br|button|caption|cite|code|col|colgroup|dd|del|dfn|em|frame|hr|iframe|img|input|ins|kbd|label|legend|link|map|object|optgroup|option|param|q|samp|script|select|small|span|strong|sub|sup|textarea|tt|var)$/;

  CodeMirror.extendMode("xml", {
    commentStart: "<!--",
    commentEnd: "-->",
    newlineAfterToken: function(type, content, textAfter, state) {
      var inline = false;
      if (this.configuration == "html")
        inline = state.context ? inlineElements.test(state.context.tagName) : false;
      return !inline && ((type == "tag" && />$/.test(content) && state.context) ||
                         /^</.test(textAfter));
    }
  });

  // Comment/uncomment the specified range
  CodeMirror.defineExtension("commentRange", function (isComment, from, to) {
    var cm = this, curMode = CodeMirror.innerMode(cm.getMode(), cm.getTokenAt(from).state).mode;
    cm.operation(function() {
      if (isComment) { // Comment range
        cm.replaceRange(curMode.commentEnd, to);
        cm.replaceRange(curMode.commentStart, from);
        if (from.line == to.line && from.ch == to.ch) // An empty comment inserted - put cursor inside
          cm.setCursor(from.line, from.ch + curMode.commentStart.length);
      } else { // Uncomment range
        var selText = cm.getRange(from, to);
        var startIndex = selText.indexOf(curMode.commentStart);
        var endIndex = selText.lastIndexOf(curMode.commentEnd);
        if (startIndex > -1 && endIndex > -1 && endIndex > startIndex) {
          // Take string till comment start
          selText = selText.substr(0, startIndex) +
          // From comment start till comment end
             selText.substring(startIndex + curMode.commentStart.length, endIndex) +
          // From comment end till string end
             selText.substr(endIndex + curMode.commentEnd.length);
        }
        cm.replaceRange(selText, from, to);
      }
    });
  });

  // Applies automatic mode-aware indentation to the specified range
  CodeMirror.defineExtension("autoIndentRange", function (from, to) {
    var cmInstance = this;
    this.operation(function () {
      for (var i = from.line; i <= to.line; i++) {
        cmInstance.indentLine(i, "smart");
      }
    });
  });

  // Applies automatic formatting to the specified range
  CodeMirror.defineExtension("autoFormatRange", function (from, to) {
    var cm = this;
    var outer = cm.getMode(), text = cm.getRange(from, to).split("\n");
    var state = CodeMirror.copyState(outer, cm.getTokenAt(from).state);
    var tabSize = cm.getOption("tabSize");

    var out = "", lines = 0, atSol = from.ch === 0;
    function newline() {
      out += "\n";
      atSol = true;
      ++lines;
    }

    for (var i = 0; i < text.length; ++i) {
      var stream = new CodeMirror.StringStream(text[i], tabSize);
      while (!stream.eol()) {
        var inner = CodeMirror.innerMode(outer, state);
        var style = outer.token(stream, state), cur = stream.current();
        stream.start = stream.pos;
        if (!atSol || /\S/.test(cur)) {
          out += cur;
          atSol = false;
        }
        if (!atSol && inner.mode.newlineAfterToken &&
            inner.mode.newlineAfterToken(style, cur, stream.string.slice(stream.pos) || text[i+1] || "", inner.state))
          newline();
      }
      if (!stream.pos && outer.blankLine) outer.blankLine(state);
      if (!atSol && i < text.length - 1) newline();
    }

    cm.operation(function () {
      cm.replaceRange(out, from, to);
      for (var cur = from.line + 1, end = from.line + lines; cur <= end; ++cur)
        cm.indentLine(cur, "smart");
      cm.setSelection(from, cm.getCursor(false));
    });
  });
});

define('skylark-grapejs/code_manager/model/CodeMirrorEditor',[
    'skylark-underscore',
    'skylark-backbone',
    'skylark-codemirror',
    'skylark-codemirror/mode/htmlmixed/htmlmixed',
    'skylark-codemirror/mode/css/css',
    './formating'
], function (a, Backbone, CodeMirror) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            input: '',
            label: '',
            codeName: '',
            theme: 'hopscotch',
            readOnly: true,
            lineNumbers: true
        },
        init(el) {
            a.bindAll(this, 'onChange');
            this.editor = CodeMirror.fromTextArea(el, {
                dragDrop: false,
                lineWrapping: true,
                mode: this.get('codeName'),
                ...this.attributes
            });
            this.element = el;
            this.editor.on('change', this.onChange);
            return this;
        },
        onChange() {
            this.trigger('update', this);
        },
        getEditor() {
            return this.editor;
        },
        getElement() {
            return this.element;
        },
        setElement(el) {
            this.element = el;
            return this;
        },
        refresh() {
            this.getEditor().refresh();
            return this;
        },
        focus() {
            this.getEditor().focus();
            return this;
        },
        getContent() {
            const ed = this.getEditor();
            return ed && ed.getValue();
        },
        setContent(v, opts = {}) {
            const {editor} = this;
            if (!editor)
                return;
            editor.setValue(v);
            if (editor.autoFormatRange) {
                CodeMirror.commands.selectAll(editor);
                editor.autoFormatRange(editor.getCursor(true), editor.getCursor(false));
                CodeMirror.commands.goDocStart(editor);
            }
            !opts.noRefresh && setTimeout(() => this.refresh());
        }
    });
});
define('skylark-grapejs/code_manager/view/EditorView',[
    'skylark-underscore',
    'skylark-backbone'
], function (_, Backbone) {
    'use strict';
    return Backbone.View.extend({
        template: _.template(`
  <div class="<%= pfx %>editor" id="<%= pfx %><%= codeName %>">
  	<div id="<%= pfx %>title"><%= label %></div>
  	<div id="<%= pfx %>code"></div>
  </div>`),
        initialize(o) {
            this.config = o.config || {};
            this.pfx = this.config.stylePrefix;
        },
        render() {
            var obj = this.model.toJSON();
            obj.pfx = this.pfx;
            this.$el.html(this.undefined(obj));
            this.$el.attr('class', this.pfx + 'editor-c');
            this.$el.find('#' + this.pfx + 'code').append(this.model.get('input'));
            return this;
        }
    });
});
define('skylark-grapejs/code_manager/index',[
    'skylark-underscore',
    './config/config',
    './model/HtmlGenerator',
    './model/CssGenerator',
    './model/JsonGenerator',
    './model/JsGenerator',
    './model/CodeMirrorEditor',
    './view/EditorView'
], function (a, defaults, gHtml, gCss, gJson, gJs, eCM, editorView) {
    'use strict';
    return () => {
        var c = {};
        var generators = {}, defGenerators = {}, viewers = {}, defViewers = {};
        const defaultViewer = 'CodeMirror';
        return {
            getConfig() {
                return c;
            },
            config: c,
            EditorView: editorView,
            name: 'CodeManager',
            init(config) {
                c = config || {};
                for (var name in defaults) {
                    if (!(name in c))
                        c[name] = defaults[name];
                }
                var ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                defGenerators.html = new gHtml();
                defGenerators.css = new gCss();
                defGenerators.json = new gJson();
                defGenerators.js = new gJs();
                defViewers.CodeMirror = new eCM();
                this.loadDefaultGenerators().loadDefaultViewers();
                return this;
            },
            addGenerator(id, generator) {
                generators[id] = generator;
                return this;
            },
            getGenerator(id) {
                return generators[id] || null;
            },
            getGenerators() {
                return generators;
            },
            addViewer(id, viewer) {
                viewers[id] = viewer;
                return this;
            },
            getViewer(id) {
                return viewers[id] || null;
            },
            getViewers() {
                return viewers;
            },
            createViewer(opts = {}) {
                const type = !a.isUndefined(opts.type) ? opts.type : defaultViewer;
                const viewer = this.getViewer(type) && this.getViewer(type).clone();
                const cont = document.createElement('div');
                const txtarea = document.createElement('textarea');
                cont.appendChild(txtarea);
                viewer.set(opts);
                viewer.init(txtarea);
                viewer.setElement(cont);
                return viewer;
            },
            updateViewer(viewer, code) {
                viewer.setContent(code);
            },
            getCode(model, genId, opt = {}) {
                opt.em = c.em;
                var generator = this.getGenerator(genId);
                return generator ? generator.build(model, opt) : '';
            },
            loadDefaultGenerators() {
                for (var id in defGenerators)
                    this.addGenerator(id, defGenerators[id]);
                return this;
            },
            loadDefaultViewers() {
                for (var id in defViewers)
                    this.addViewer(id, defViewers[id]);
                return this;
            }
        };
    };
});
define('skylark-grapejs/panels/config/config',[],function () {
    'use strict';
    const swv = 'sw-visibility';
    const expt = 'export-template';
    const osm = 'open-sm';
    const otm = 'open-tm';
    const ola = 'open-layers';
    const obl = 'open-blocks';
    const ful = 'fullscreen';
    const prv = 'preview';
    return {
        stylePrefix: 'pn-',
        defaults: [
            {
                id: 'commands',
                buttons: [{}]
            },
            {
                id: 'options',
                buttons: [
                    {
                        active: true,
                        id: swv,
                        className: 'fa fa-square-o',
                        command: swv,
                        context: swv,
                        attributes: { title: 'View components' }
                    },
                    {
                        id: prv,
                        className: 'fa fa-eye',
                        command: prv,
                        context: prv,
                        attributes: { title: 'Preview' }
                    },
                    {
                        id: ful,
                        className: 'fa fa-arrows-alt',
                        command: ful,
                        context: ful,
                        attributes: { title: 'Fullscreen' }
                    },
                    {
                        id: expt,
                        className: 'fa fa-code',
                        command: expt,
                        attributes: { title: 'View code' }
                    }
                ]
            },
            {
                id: 'views',
                buttons: [
                    {
                        id: osm,
                        className: 'fa fa-paint-brush',
                        command: osm,
                        active: true,
                        togglable: 0,
                        attributes: { title: 'Open Style Manager' }
                    },
                    {
                        id: otm,
                        className: 'fa fa-cog',
                        command: otm,
                        togglable: 0,
                        attributes: { title: 'Settings' }
                    },
                    {
                        id: ola,
                        className: 'fa fa-bars',
                        command: ola,
                        togglable: 0,
                        attributes: { title: 'Open Layer Manager' }
                    },
                    {
                        id: obl,
                        className: 'fa fa-th-large',
                        command: obl,
                        togglable: 0,
                        attributes: { title: 'Open Blocks' }
                    }
                ]
            }
        ],
        em: null,
        delayBtnsShow: 300
    };
});
define('skylark-grapejs/panels/model/Button',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            id: '',
            label: '',
            tagName: 'span',
            className: '',
            command: '',
            context: '',
            buttons: [],
            attributes: {},
            options: {},
            active: false,
            dragDrop: false,
            togglable: true,
            runDefaultCommand: true,
            stopDefaultCommand: false,
            disable: false
        },
        initialize(options) {
            if (this.get('buttons').length) {
                var Buttons = require('./Buttons').default;
                this.set('buttons', new Buttons(this.get('buttons')));
            }
        }
    });
});
define('skylark-grapejs/panels/model/Buttons',[
    'skylark-backbone',
    './Button'
], function (Backbone, Button) {
    'use strict';
    return Backbone.Collection.extend({
        model: Button,
        deactivateAllExceptOne(except, r) {
            this.forEach((model, index) => {
                if (model !== except) {
                    model.set('active', false);
                    if (r && model.get('buttons').length)
                        model.get('buttons').deactivateAllExceptOne(except, r);
                }
            });
        },
        deactivateAll(ctx, sender) {
            const context = ctx || '';
            this.forEach(model => {
                if (model.get('context') == context && model !== sender) {
                    model.set('active', false, { silent: 1 });
                    model.trigger('updateActive', { fromCollection: 1 });
                }
            });
        },
        disableAllButtons(ctx) {
            var context = ctx || '';
            this.forEach((model, index) => {
                if (model.get('context') == context) {
                    model.set('disable', true);
                }
            });
        },
        disableAllButtonsExceptOne(except, r) {
            this.forEach((model, index) => {
                if (model !== except) {
                    model.set('disable', true);
                    if (r && model.get('buttons').length)
                        model.get('buttons').disableAllButtonsExceptOne(except, r);
                }
            });
        }
    });
});
define('skylark-grapejs/panels/model/Panel',[
    'skylark-backbone',
    './Buttons'
], function (Backbone, Buttons) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            id: '',
            content: '',
            visible: true,
            buttons: [],
            attributes: {}
        },
        initialize(options) {
            this.btn = this.get('buttons') || [];
            this.buttons = new Buttons(this.btn);
            this.set('buttons', this.buttons);
        }
    });
});
define('skylark-grapejs/panels/model/Panels',[
    'skylark-backbone',
    './Panel'
], function (Backbone, Panel) {
    'use strict';
    return Backbone.Collection.extend({ model: Panel });
});
define('skylark-grapejs/panels/view/ButtonView',[
    'skylark-backbone',
    'skylark-underscore'
], function (Backbone, a) {
    'use strict';
    const $ = Backbone.$;
    return Backbone.View.extend({
        tagName() {
            return this.model.get('tagName');
        },
        events: { click: 'clicked' },
        initialize(o) {
            var cls = this.model.get('className');
            this.config = o.config || {};
            this.em = this.config.em || {};
            const pfx = this.config.stylePrefix || '';
            const ppfx = this.config.pStylePrefix || '';
            this.pfx = pfx;
            this.ppfx = this.config.pStylePrefix || '';
            this.id = pfx + this.model.get('id');
            this.activeCls = `${ pfx }active ${ ppfx }four-color`;
            this.disableCls = `${ ppfx }disabled`;
            this.btnsVisCls = `${ pfx }visible`;
            this.className = pfx + 'btn' + (cls ? ' ' + cls : '');
            this.listenTo(this.model, 'change', this.render);
            this.listenTo(this.model, 'change:active updateActive', this.updateActive);
            this.listenTo(this.model, 'checkActive', this.checkActive);
            this.listenTo(this.model, 'change:bntsVis', this.updateBtnsVis);
            this.listenTo(this.model, 'change:attributes', this.updateAttributes);
            this.listenTo(this.model, 'change:className', this.updateClassName);
            this.listenTo(this.model, 'change:disable', this.updateDisable);
            if (this.em && this.em.get)
                this.commands = this.em.get('Commands');
        },
        updateClassName() {
            const {model, pfx} = this;
            const cls = model.get('className');
            const attrCls = model.get('attributes').class;
            const classStr = `${ attrCls ? attrCls : '' } ${ pfx }btn ${ cls ? cls : '' }`;
            this.$el.attr('class', classStr.trim());
        },
        updateAttributes() {
            const {em, model, $el} = this;
            const attr = model.get('attributes') || {};
            const title = em && em.t && em.t(`panels.buttons.titles.${ model.id }`);
            $el.attr(attr);
            title && $el.attr({ title });
            this.updateClassName();
        },
        updateBtnsVis() {
            if (!this.$buttons)
                return;
            if (this.model.get('bntsVis'))
                this.$buttons.addClass(this.btnsVisCls);
            else
                this.$buttons.removeClass(this.btnsVisCls);
        },
        updateActive(opts = {}) {
            const {model, commands, $el, activeCls} = this;
            const {fromCollection} = opts;
            const context = model.get('context');
            const options = model.get('options');
            const commandName = model.get('command');
            let command = {};
            if (commands && a.isString(commandName)) {
                command = commands.get(commandName) || {};
            } else if (a.isFunction(commandName)) {
                command = commands.create({ run: commandName });
            } else if (commandName !== null && a.isObject(commandName)) {
                command = commands.create(commandName);
            }
            if (model.get('active')) {
                !fromCollection && model.collection.deactivateAll(context, model);
                model.set('active', true, { silent: true }).trigger('checkActive');
                commands.runCommand(command, {
                    ...options,
                    sender: model
                });
                command.noStop && model.set('active', false);
            } else {
                $el.removeClass(activeCls);
                commands.stopCommand(command, {
                    ...options,
                    sender: model,
                    force: 1
                });
            }
        },
        updateDisable() {
            const {disableCls, model} = this;
            const disable = model.get('disable');
            this.$el[disable ? 'addClass' : 'removeClass'](disableCls);
        },
        checkActive() {
            const {model, $el, activeCls} = this;
            model.get('active') ? $el.addClass(activeCls) : $el.removeClass(activeCls);
        },
        clicked(e) {
            if (this.model.get('bntsVis'))
                return;
            if (this.model.get('disable'))
                return;
            this.toggleActive();
        },
        toggleActive() {
            const {model} = this;
            const {active, togglable} = model.attributes;
            if (active && !togglable)
                return;
            model.set('active', !active);
            var command = this.em.get('Commands').get('select-comp');
            if (active) {
                if (model.get('runDefaultCommand'))
                    this.em.runDefault();
            } else {
                if (model.get('stopDefaultCommand'))
                    this.em.stopDefault();
            }
        },
        render() {
            const label = this.model.get('label');
            const {$el} = this;
            $el.empty();
            this.updateAttributes();
            label && $el.append(label);
            this.checkActive();
            this.updateDisable();
            return this;
        }
    });
});
define('skylark-grapejs/panels/view/ButtonsView',[
    'skylark-backbone',
    './ButtonView',
    'skylark-underscore'
], function (Backbone, ButtonView, a) {
    'use strict';
    return Backbone.View.extend({
        initialize(o) {
            this.opt = o || {};
            this.config = this.opt.config || {};
            this.pfx = this.config.stylePrefix || '';
            this.parentM = this.opt.parentM || null;
            this.listenTo(this.collection, 'add', this.addTo);
            this.listenTo(this.collection, 'reset remove', this.render);
            this.className = this.pfx + 'buttons';
        },
        addTo(model) {
            this.addToCollection(model);
        },
        addToCollection(model, fragmentEl) {
            var fragment = fragmentEl || null;
            var viewObject = ButtonView;
            var view = new viewObject({
                model,
                config: this.config,
                parentM: this.parentM
            });
            var rendered = view.render().el;
            if (fragment) {
                fragment.appendChild(rendered);
            } else {
                this.$el.append(rendered);
            }
            return rendered;
        },
        render() {
            var fragment = document.createDocumentFragment();
            this.$el.empty();
            this.collection.each(function (model) {
                this.addToCollection(model, fragment);
            }, this);
            this.$el.append(fragment);
            this.$el.attr('class', a.result(this, 'className'));
            return this;
        }
    });
});
define('skylark-grapejs/panels/view/PanelView',[
    'skylark-backbone',
    './ButtonsView'
], function (Backbone, ButtonsView) {
    'use strict';
    return Backbone.View.extend({
        initialize(o) {
            const config = o.config || {};
            const model = this.model;
            this.config = config;
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.buttons = model.get('buttons');
            this.className = this.pfx + 'panel';
            this.id = this.pfx + model.get('id');
            this.listenTo(model, 'change:appendContent', this.appendContent);
            this.listenTo(model, 'change:content', this.updateContent);
            this.listenTo(model, 'change:visible', this.toggleVisible);
            model.view = this;
        },
        appendContent() {
            this.$el.append(this.model.get('appendContent'));
        },
        updateContent() {
            this.$el.html(this.model.get('content'));
        },
        toggleVisible() {
            if (!this.model.get('visible')) {
                this.$el.addClass(`${ this.ppfx }hidden`);
                return;
            }
            this.$el.removeClass(`${ this.ppfx }hidden`);
        },
        attributes() {
            return this.model.get('attributes');
        },
        initResize() {
            const em = this.config.em;
            const editor = em ? em.get('Editor') : '';
            const resizable = this.model.get('resizable');
            if (editor && resizable) {
                var resz = resizable === true ? [
                    1,
                    1,
                    1,
                    1
                ] : resizable;
                var resLen = resz.length;
                var tc, cr, bc, cl = 0;
                if (resLen == 2) {
                    tc = resz[0];
                    bc = resz[0];
                    cr = resz[1];
                    cl = resz[1];
                } else if (resLen == 4) {
                    tc = resz[0];
                    cr = resz[1];
                    bc = resz[2];
                    cl = resz[3];
                }
                var resizer = editor.Utils.Resizer.init({
                    tc,
                    cr,
                    bc,
                    cl,
                    tl: 0,
                    tr: 0,
                    bl: 0,
                    br: 0,
                    appendTo: this.el,
                    silentFrames: 1,
                    avoidContainerUpdate: 1,
                    prefix: editor.getConfig().stylePrefix,
                    onEnd() {
                        em && em.trigger('change:canvasOffset');
                    },
                    posFetcher: (el, {target}) => {
                        const style = el.style;
                        const config = resizer.getConfig();
                        const keyWidth = config.keyWidth;
                        const keyHeight = config.keyHeight;
                        const rect = el.getBoundingClientRect();
                        const forContainer = target == 'container';
                        const styleWidth = style[keyWidth];
                        const styleHeight = style[keyHeight];
                        const width = styleWidth && !forContainer ? parseFloat(styleWidth) : rect.width;
                        const height = styleHeight && !forContainer ? parseFloat(styleHeight) : rect.height;
                        return {
                            left: 0,
                            top: 0,
                            width,
                            height
                        };
                    },
                    ...resizable
                });
                resizer.blur = () => {
                };
                resizer.focus(this.el);
            }
        },
        render() {
            const $el = this.$el;
            const ppfx = this.ppfx;
            const cls = `${ this.className } ${ this.id } ${ ppfx }one-bg ${ ppfx }two-color`;
            $el.addClass(cls);
            if (this.buttons.length) {
                var buttons = new ButtonsView({
                    collection: this.buttons,
                    config: this.config
                });
                $el.append(buttons.render().el);
            }
            $el.append(this.model.get('content'));
            return this;
        }
    });
});
define('skylark-grapejs/panels/view/PanelsView',[
    'skylark-backbone',
    './PanelView'
], function (Backbone, PanelView) {
    'use strict';
    return Backbone.View.extend({
        initialize(o) {
            this.opt = o || {};
            this.config = this.opt.config || {};
            this.pfx = this.config.stylePrefix || '';
            const items = this.collection;
            this.listenTo(items, 'add', this.addTo);
            this.listenTo(items, 'reset', this.render);
            this.listenTo(items, 'remove', this.onRemove);
            this.className = this.pfx + 'panels';
        },
        onRemove(model) {
            const view = model.view;
            view && view.remove();
        },
        addTo(model) {
            this.addToCollection(model);
        },
        addToCollection(model, fragmentEl) {
            const fragment = fragmentEl || null;
            const config = this.config;
            const el = model.get('el');
            const view = new PanelView({
                el,
                model,
                config
            });
            const rendered = view.render().el;
            const appendTo = model.get('appendTo');
            if (el) {
            } else if (appendTo) {
                var appendEl = document.querySelector(appendTo);
                appendEl.appendChild(rendered);
            } else {
                if (fragment) {
                    fragment.appendChild(rendered);
                } else {
                    this.$el.append(rendered);
                }
            }
            view.initResize();
            return rendered;
        },
        render() {
            const $el = this.$el;
            const frag = document.createDocumentFragment();
            $el.empty();
            this.collection.each(model => this.addToCollection(model, frag));
            $el.append(frag);
            $el.attr('class', this.className);
            return this;
        }
    });
});
define('skylark-grapejs/panels/index',[
    './config/config',
    './model/Panel',
    './model/Panels',
    './view/PanelView',
    './view/PanelsView'
], function (defaults, Panel, Panels, PanelView, PanelsView) {
    'use strict';
    return () => {
        var c = {};
        var panels, PanelsViewObj;
        return {
            name: 'Panels',
            init(config) {
                c = config || {};
                for (var name in defaults) {
                    if (!(name in c))
                        c[name] = defaults[name];
                }
                var ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                panels = new Panels(c.defaults);
                PanelsViewObj = new PanelsView({
                    collection: panels,
                    config: c
                });
                return this;
            },
            getPanels() {
                return panels;
            },
            getPanelsEl() {
                return PanelsViewObj.el;
            },
            addPanel(panel) {
                return panels.add(panel);
            },
            removePanel(panel) {
                return panels.remove(panel);
            },
            getPanel(id) {
                var res = panels.where({ id });
                return res.length ? res[0] : null;
            },
            addButton(panelId, button) {
                var pn = this.getPanel(panelId);
                return pn ? pn.get('buttons').add(button) : null;
            },
            removeButton(panelId, button) {
                var pn = this.getPanel(panelId);
                return pn && pn.get('buttons').remove(button);
            },
            getButton(panelId, id) {
                var pn = this.getPanel(panelId);
                if (pn) {
                    var res = pn.get('buttons').where({ id });
                    return res.length ? res[0] : null;
                }
                return null;
            },
            render() {
                return PanelsViewObj.render().el;
            },
            active() {
                this.getPanels().each(p => {
                    p.get('buttons').each(btn => {
                        btn.get('active') && btn.trigger('updateActive');
                    });
                });
            },
            disableButtons() {
                this.getPanels().each(p => {
                    p.get('buttons').each(btn => {
                        if (btn.get('disable'))
                            btn.trigger('change:disable');
                    });
                });
            },
            Panel
        };
    };
});
define('skylark-grapejs/rich_text_editor/model/RichTextEditor',['../../utils/mixins'], function (a) {
    'use strict';
    const RTE_KEY = '_rte';
    const btnState = {
        ACTIVE: 1,
        INACTIVE: 0,
        DISABLED: -1
    };
    const isValidAnchor = rte => {
        const anchor = rte.selection().anchorNode;
        const parentNode = anchor && anchor.parentNode;
        const nextSibling = anchor && anchor.nextSibling;
        return parentNode && parentNode.nodeName == 'A' || nextSibling && nextSibling.nodeName == 'A';
    };
    const defActions = {
        bold: {
            name: 'bold',
            icon: '<b>B</b>',
            attributes: { title: 'Bold' },
            result: rte => rte.exec('bold')
        },
        italic: {
            name: 'italic',
            icon: '<i>I</i>',
            attributes: { title: 'Italic' },
            result: rte => rte.exec('italic')
        },
        underline: {
            name: 'underline',
            icon: '<u>U</u>',
            attributes: { title: 'Underline' },
            result: rte => rte.exec('underline')
        },
        strikethrough: {
            name: 'strikethrough',
            icon: '<strike>S</strike>',
            attributes: { title: 'Strike-through' },
            result: rte => rte.exec('strikeThrough')
        },
        link: {
            icon: `<span style="transform:rotate(45deg)">&supdsub;</span>`,
            name: 'link',
            attributes: {
                style: 'font-size:1.4rem;padding:0 4px 2px;',
                title: 'Link'
            },
            state: (rte, doc) => {
                if (rte && rte.selection()) {
                    return isValidAnchor(rte) ? btnState.ACTIVE : btnState.INACTIVE;
                } else {
                    return btnState.INACTIVE;
                }
            },
            result: rte => {
                if (isValidAnchor(rte)) {
                    rte.exec('unlink');
                } else {
                    rte.insertHTML(`<a class="link" href="">${ rte.selection() }</a>`);
                }
            }
        }
    };
    return class RichTextEditor {
        constructor(settings = {}) {
            const el = settings.el;
            if (el[RTE_KEY]) {
                return el[RTE_KEY];
            }
            el[RTE_KEY] = this;
            this.setEl(el);
            this.updateActiveActions = this.updateActiveActions.bind(this);
            const settAct = settings.actions || [];
            settAct.forEach((action, i) => {
                if (typeof action === 'string') {
                    action = defActions[action];
                } else if (defActions[action.name]) {
                    action = {
                        ...defActions[action.name],
                        ...action
                    };
                }
                settAct[i] = action;
            });
            const actions = settAct.length ? settAct : Object.keys(defActions).map(action => defActions[action]);
            settings.classes = {
                ...{
                    actionbar: 'actionbar',
                    button: 'action',
                    active: 'active',
                    disabled: 'disabled',
                    inactive: 'inactive'
                },
                ...settings.classes
            };
            const classes = settings.classes;
            let actionbar = settings.actionbar;
            this.actionbar = actionbar;
            this.settings = settings;
            this.classes = classes;
            this.actions = actions;
            if (!actionbar) {
                const actionbarCont = settings.actionbarContainer;
                actionbar = document.createElement('div');
                actionbar.className = classes.actionbar;
                actionbarCont.appendChild(actionbar);
                this.actionbar = actionbar;
                actions.forEach(action => this.addAction(action));
            }
            settings.styleWithCSS && this.exec('styleWithCSS');
            this.syncActions();
            return this;
        }
        destroy() {
            this.el = 0;
            this.doc = 0;
            this.actionbar = 0;
            this.settings = {};
            this.classes = {};
            this.actions = [];
        }
        setEl(el) {
            this.el = el;
            this.doc = el.ownerDocument;
        }
        updateActiveActions() {
            this.getActions().forEach(action => {
                const btn = action.btn;
                const update = action.update;
                const {active, inactive, disabled} = { ...this.classes };
                const state = action.state;
                const name = action.name;
                const doc = this.doc;
                btn.className = btn.className.replace(active, '').trim();
                btn.className = btn.className.replace(inactive, '').trim();
                btn.className = btn.className.replace(disabled, '').trim();
                if (state) {
                    switch (state(this, doc)) {
                    case btnState.ACTIVE:
                        btn.className += ` ${ active }`;
                        break;
                    case btnState.INACTIVE:
                        btn.className += ` ${ inactive }`;
                        break;
                    case btnState.DISABLED:
                        btn.className += ` ${ disabled }`;
                        break;
                    }
                } else {
                    if (doc.queryCommandSupported(name) && doc.queryCommandState(name)) {
                        btn.className += ` ${ active }`;
                    }
                }
                update && update(this, action);
            });
        }
        enable() {
            if (this.enabled) {
                return this;
            }
            this.actionbarEl().style.display = '';
            this.el.contentEditable = true;
            a.on(this.el, 'mouseup keyup', this.updateActiveActions);
            this.syncActions();
            this.updateActiveActions();
            this.el.focus();
            this.enabled = 1;
            return this;
        }
        disable() {
            this.actionbarEl().style.display = 'none';
            this.el.contentEditable = false;
            a.off(this.el, 'mouseup keyup', this.updateActiveActions);
            this.enabled = 0;
            return this;
        }
        syncActions() {
            this.getActions().forEach(action => {
                if (this.settings.actionbar) {
                    if (!action.state || action.state && action.state(this, this.doc) >= 0) {
                        const event = action.event || 'click';
                        action.btn[`on${ event }`] = e => {
                            action.result(this, action);
                            this.updateActiveActions();
                        };
                    }
                }
            });
        }
        addAction(action, opts = {}) {
            const sync = opts.sync;
            const btn = document.createElement('span');
            const icon = action.icon;
            const attr = action.attributes || {};
            btn.className = this.classes.button;
            action.btn = btn;
            for (let key in attr) {
                btn.setAttribute(key, attr[key]);
            }
            if (typeof icon == 'string') {
                btn.innerHTML = icon;
            } else {
                btn.appendChild(icon);
            }
            this.actionbarEl().appendChild(btn);
            if (sync) {
                this.actions.push(action);
                this.syncActions();
            }
        }
        getActions() {
            return this.actions;
        }
        selection() {
            return this.doc.getSelection();
        }
        exec(command, value = null) {
            this.doc.execCommand(command, false, value);
        }
        actionbarEl() {
            return this.actionbar;
        }
        insertHTML(value) {
            let lastNode;
            const doc = this.doc;
            const sel = doc.getSelection();
            if (sel && sel.rangeCount) {
                const node = doc.createElement('div');
                const range = sel.getRangeAt(0);
                range.deleteContents();
                node.innerHTML = value;
                Array.prototype.slice.call(node.childNodes).forEach(nd => {
                    range.insertNode(nd);
                    lastNode = nd;
                });
                sel.removeAllRanges();
                sel.addRange(range);
                this.el.focus();
            }
        }
    };
});
define('skylark-grapejs/rich_text_editor/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'rte-',
        adjustToolbar: 1,
        actions: [
            'bold',
            'italic',
            'underline',
            'strikethrough',
            'link'
        ]
    };
});
define('skylark-grapejs/rich_text_editor/index',[
    './model/RichTextEditor',
    '../../utils/mixins',
    './config/config'
], function (RichTextEditor, a, defaults) {
    'use strict';
    return () => {
        let config = {};
        let toolbar, actions, lastEl, lastElPos, globalRte;
        const hideToolbar = () => {
            const style = toolbar.style;
            const size = '-1000px';
            style.top = size;
            style.left = size;
            style.display = 'none';
        };
        return {
            customRte: null,
            name: 'RichTextEditor',
            getConfig() {
                return config;
            },
            init(opts = {}) {
                config = {
                    ...defaults,
                    ...opts
                };
                const ppfx = config.pStylePrefix;
                if (ppfx) {
                    config.stylePrefix = ppfx + config.stylePrefix;
                }
                this.pfx = config.stylePrefix;
                actions = config.actions || [];
                toolbar = document.createElement('div');
                toolbar.className = `${ ppfx }rte-toolbar ${ ppfx }one-bg`;
                globalRte = this.initRte(document.createElement('div'));
                a.on(toolbar, 'mousedown', e => e.stopPropagation());
                return this;
            },
            destroy() {
                const {customRte} = this;
                globalRte && globalRte.destroy();
                customRte && customRte.destroy && customRte.destroy();
                toolbar = 0;
                globalRte = 0;
                this.actionbar = 0;
                this.actions = 0;
            },
            postRender(ev) {
                const canvas = ev.model.get('Canvas');
                toolbar.style.pointerEvents = 'all';
                hideToolbar();
                canvas.getToolsEl().appendChild(toolbar);
            },
            initRte(el) {
                const pfx = this.pfx;
                const actionbarContainer = toolbar;
                const actionbar = this.actionbar;
                const actions = this.actions || [...config.actions];
                const classes = {
                    actionbar: `${ pfx }actionbar`,
                    button: `${ pfx }action`,
                    active: `${ pfx }active`,
                    inactive: `${ pfx }inactive`,
                    disabled: `${ pfx }disabled`
                };
                const rte = new RichTextEditor({
                    el,
                    classes,
                    actions,
                    actionbar,
                    actionbarContainer
                });
                globalRte && globalRte.setEl(el);
                if (rte.actionbar) {
                    this.actionbar = rte.actionbar;
                }
                if (rte.actions) {
                    this.actions = rte.actions;
                }
                return rte;
            },
            add(name, action = {}) {
                action.name = name;
                globalRte.addAction(action, { sync: 1 });
            },
            get(name) {
                let result;
                globalRte.getActions().forEach(action => {
                    if (action.name == name) {
                        result = action;
                    }
                });
                return result;
            },
            getAll() {
                return globalRte.getActions();
            },
            remove(name) {
                const actions = this.getAll();
                const action = this.get(name);
                if (action) {
                    const btn = action.btn;
                    const index = actions.indexOf(action);
                    btn.parentNode.removeChild(btn);
                    actions.splice(index, 1);
                }
                return action;
            },
            getToolbarEl() {
                return toolbar;
            },
            updatePosition() {
                const un = 'px';
                const canvas = config.em.get('Canvas');
                const {style} = toolbar;
                const pos = canvas.getTargetToElementFixed(lastEl, toolbar, { event: 'rteToolbarPosUpdate' });
                style.top = pos.top + un;
                style.left = 0 + un;
            },
            enable(view, rte) {
                lastEl = view.el;
                const canvas = config.em.get('Canvas');
                const em = config.em;
                const el = view.getChildrenContainer();
                const customRte = this.customRte;
                lastElPos = canvas.getElementPos(lastEl);
                toolbar.style.display = '';
                rte = customRte ? customRte.enable(el, rte) : this.initRte(el).enable();
                if (em) {
                    setTimeout(this.updatePosition.bind(this), 0);
                    const event = 'change:canvasOffset canvasScroll frame:scroll component:update';
                    em.undefined(event, this.updatePosition, this);
                    em.undefined(event, this.updatePosition, this);
                    em.trigger('rte:enable', view, rte);
                }
                return rte;
            },
            disable(view, rte) {
                const em = config.em;
                const customRte = this.customRte;
                var el = view.getChildrenContainer();
                if (customRte) {
                    customRte.disable(el, rte);
                } else {
                    rte && rte.disable();
                }
                hideToolbar();
                em && em.trigger('rte:disable', view, rte);
            }
        };
    };
});
define('skylark-grapejs/asset_manager/config/config',[],function () {
    'use strict';
    return {
        assets: [],
        noAssets: '',
        stylePrefix: 'am-',
        upload: 0,
        uploadName: 'files',
        headers: {},
        params: {},
        credentials: 'include',
        multiUpload: true,
        autoAdd: 1,
        customFetch: '',
        uploadFile: '',
        embedAsBase64: 1,
        handleAdd: '',
        dropzone: 0,
        openAssetsOnDrop: 1,
        dropzoneContent: '',
        beforeUpload: null,
        showUrlInput: true
    };
});
define('skylark-grapejs/asset_manager/model/Asset',[
    'skylark-backbone/Model'
], function (Model) {
    'use strict';
    return Model.extend({
        idAttribute: 'src',
        defaults: {
            type: '',
            src: ''
        },
        getFilename() {
            return this.get('src').split('/').pop();
        },
        getExtension() {
            return this.getFilename().split('.').pop();
        }
    });
});
define('skylark-grapejs/asset_manager/model/AssetImage',[
    "skylark-langx/langx",
    './Asset'
], function (langx,Asset) {
    'use strict';
    return Asset.extend({
        defaults: langx.mixin({},Asset.prototype.defaults,{
            type: 'image',
            unitDim: 'px',
            height: 0,
            width: 0
        })
    });
});
define('skylark-grapejs/asset_manager/view/AssetView',[
    'skylark-backbone',
    'skylark-underscore'
], function (Backbone, _) {
    'use strict';
    return Backbone.View.extend({
        initialize(o = {}) {
            this.options = o;
            this.collection = o.collection;
            const config = o.config || {};
            this.config = config;
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.em = config.em;
            this.className = this.pfx + 'asset';
            this.listenTo(this.model, 'destroy remove', this.remove);
            this.model.view = this;
            const init = this.init && this.init.bind(this);
            init && init(o);
        },
        template() {
            const pfx = this.pfx;
            return `
      <div class="${ pfx }preview-cont">
        ${ this.getPreview() }
      </div>
      <div class="${ pfx }meta">
        ${ this.getInfo() }
      </div>
      <div class="${ pfx }close" data-toggle="asset-remove">
        &Cross;
      </div>
    `;
        },
        updateTarget(target) {
            if (target && target.set) {
                target.set('attributes', _.clone(target.get('attributes')));
                target.set('src', this.model.get('src'));
            }
        },
        getPreview() {
            return '';
        },
        getInfo() {
            return '';
        },
        render() {
            const el = this.el;
            el.innerHTML = this.template(this, this.model);
            el.className = this.className;
            return this;
        }
    });
});
define('skylark-grapejs/asset_manager/view/AssetImageView',[
    'skylark-underscore',
    './AssetView'
], function (a, AssetView) {
    'use strict';
    return AssetView.extend({
        events: {
            'click [data-toggle=asset-remove]': 'onRemove',
            click: 'onClick',
            dblclick: 'onDblClick'
        },
        getPreview() {
            const pfx = this.pfx;
            const src = this.model.get('src');
            return `
      <div class="${ pfx }preview" style="background-image: url('${ src }');"></div>
      <div class="${ pfx }preview-bg ${ this.ppfx }checker-bg"></div>
    `;
        },
        getInfo() {
            const pfx = this.pfx;
            const model = this.model;
            let name = model.get('name');
            let width = model.get('width');
            let height = model.get('height');
            let unit = model.get('unitDim');
            let dim = width && height ? `${ width }x${ height }${ unit }` : '';
            name = name || model.getFilename();
            return `
      <div class="${ pfx }name">${ name }</div>
      <div class="${ pfx }dimensions">${ dim }</div>
    `;
        },
        init(o) {
            const pfx = this.pfx;
            this.className += ` ${ pfx }asset-image`;
        },
        onClick() {
            var onClick = this.config.onClick;
            var model = this.model;
            this.collection.trigger('deselectAll');
            this.$el.addClass(this.pfx + 'highlight');
            if (a.isFunction(onClick)) {
                onClick(model);
            } else {
                this.updateTarget(this.collection.target);
            }
        },
        onDblClick() {
            const {em, model} = this;
            const onDblClick = this.config.onDblClick;
            if (a.isFunction(onDblClick)) {
                onDblClick(model);
            } else {
                this.updateTarget(this.collection.target);
                em && em.get('Modal').close();
            }
            var onSelect = this.collection.onSelect;
            a.isFunction(onSelect) && onSelect(model);
        },
        onRemove(e) {
            e.stopImmediatePropagation();
            this.model.collection.remove(this.model);
        }
    });
});
define('skylark-grapejs/asset_manager/model/Assets',[
    'skylark-backbone/Collection',
    './AssetImage',
    './../view/AssetImageView',
    '../../domain_abstract/model/TypeableCollection'
], function (Collection, AssetImage, AssetImageView, TypeableCollection) {
    'use strict';
    return Collection.extend(TypeableCollection).extend({
        types: [{
                id: 'image',
                model: AssetImage,
                view: AssetImageView,
                isType(value) {
                    if (typeof value == 'string') {
                        return {
                            type: 'image',
                            src: value
                        };
                    }
                    return value;
                }
            }]
    });
});
define('skylark-grapejs/asset_manager/view/AssetsView',[
    'skylark-backbone'
], function (Backbone) {
    'use strict';
    return Backbone.View.extend({
        events: { submit: 'handleSubmit' },
        //template({
        //    pfx,
        //    ppfx,
        //    em,
        //    ...view
        //}) {
        template() {
            const {
                pfx,
                ppfx,
                em
            } = this;  // modified by lwf
            let form = '';
            if (this.config.showUrlInput) {
                form = `
          <form class="${ pfx }add-asset">
            <div class="${ ppfx }field ${ pfx }add-field">
              <input placeholder="${ em && em.t('assetManager.inputPlh') }"/>
            </div>
            <button class="${ ppfx }btn-prim">${ em && em.t('assetManager.addButton') }</button>
            <div style="clear:both"></div>
          </form>
      `;
            }
            return `
    <div class="${ pfx }assets-cont">
      <div class="${ pfx }assets-header">
        ${ form }
      </div>
      <div class="${ pfx }assets" data-el="assets"></div>
      <div style="clear:both"></div>
    </div>
    `;
        },
        initialize(o) {
            this.options = o;
            this.config = o.config;
            this.pfx = this.config.stylePrefix || '';
            this.ppfx = this.config.pStylePrefix || '';
            this.em = this.config.em;
            const coll = this.collection;
            this.listenTo(coll, 'reset', this.renderAssets);
            this.listenTo(coll, 'add', this.addToAsset);
            this.listenTo(coll, 'remove', this.removedAsset);
            this.listenTo(coll, 'deselectAll', this.deselectAll);
        },
        handleSubmit(e) {
            e.preventDefault();
            const input = this.getAddInput();
            const url = input && input.value.trim();
            const handleAdd = this.config.handleAdd;
            if (!url) {
                return;
            }
            input.value = '';
            this.getAssetsEl().scrollTop = 0;
            if (handleAdd) {
                handleAdd.bind(this)(url);
            } else {
                this.options.globalCollection.add(url, { at: 0 });
            }
        },
        getAssetsEl() {
            return this.el.querySelector(`.${ this.pfx }assets`);
        },
        getAddInput() {
            if (!this.inputUrl || !this.inputUrl.value)
                this.inputUrl = this.el.querySelector(`.${ this.pfx }add-asset input`);
            return this.inputUrl;
        },
        removedAsset(model) {
            if (!this.collection.length) {
                this.toggleNoAssets();
            }
        },
        addToAsset(model) {
            if (this.collection.length == 1) {
                this.toggleNoAssets(1);
            }
            this.addAsset(model);
        },
        addAsset(model, fragmentEl = null) {
            const fragment = fragmentEl;
            const collection = this.collection;
            const config = this.config;
            const rendered = new model.typeView({
                model,
                collection,
                config
            }).render().el;
            if (fragment) {
                fragment.appendChild(rendered);
            } else {
                const assetsEl = this.getAssetsEl();
                if (assetsEl) {
                    assetsEl.insertBefore(rendered, assetsEl.firstChild);
                }
            }
            return rendered;
        },
        toggleNoAssets(hide) {
            const assetsEl = this.$el.find(`.${ this.pfx }assets`);
            if (hide) {
                assetsEl.empty();
            } else {
                const noAssets = this.config.noAssets;
                noAssets && assetsEl.append(noAssets);
            }
        },
        deselectAll() {
            const pfx = this.pfx;
            this.$el.find(`.${ pfx }highlight`).removeClass(`${ pfx }highlight`);
        },
        renderAssets() {
            const fragment = document.createDocumentFragment();
            const assets = this.$el.find(`.${ this.pfx }assets`);
            assets.empty();
            this.toggleNoAssets(this.collection.length);
            this.collection.each(model => this.addAsset(model, fragment));
            assets.append(fragment);
        },
        render() {
            const fuRendered = this.options.fu.render().el;
            this.$el.empty();
            this.$el.append(fuRendered).append(this.template(this));
            this.el.className = `${ this.ppfx }asset-manager`;
            this.renderAssets();
            this.rendered = 1;
            return this;
        }
    });
});
define('skylark-grapejs/asset_manager/view/FileUploader',[
    'skylark-underscore',
    'skylark-backbone',
    '../../utils/fetch'
], function (_, Backbone, fetch) {
    'use strict';
    return Backbone.View.extend({
        template: _.template(`
  <form>
    <div id="<%= pfx %>title"><%= title %></div>
    <input type="file" id="<%= uploadId %>" name="file" accept="*/*" <%= disabled ? 'disabled' : '' %> <%= multiUpload ? 'multiple' : '' %>/>
    <div style="clear:both;"></div>
  </form>
  `),
        events: {},
        initialize(opts = {}) {
            this.options = opts;
            const c = opts.config || {};
            this.config = c;
            this.em = this.config.em;
            this.pfx = c.stylePrefix || '';
            this.ppfx = c.pStylePrefix || '';
            this.target = this.options.globalCollection || {};
            this.uploadId = this.pfx + 'uploadFile';
            this.disabled = c.disableUpload !== undefined ? c.disableUpload : !c.upload && !c.embedAsBase64;
            this.multiUpload = c.multiUpload !== undefined ? c.multiUpload : true;
            this.events['change #' + this.uploadId] = 'uploadFile';
            let uploadFile = c.uploadFile;
            if (uploadFile) {
                this.uploadFile = uploadFile.bind(this);
            } else if (!c.upload && c.embedAsBase64) {
                this.uploadFile = this.constructor.embedAsBase64;
            }
            this.delegateEvents();
        },
        onUploadStart() {
            const em = this.config.em;
            em && em.trigger('asset:upload:start');
        },
        onUploadEnd(res) {
            const {$el, config} = this;
            const em = config.em;
            em && em.trigger('asset:upload:end', res);
            const input = $el.find('input');
            input && input.val('');
        },
        onUploadError(err) {
            const em = this.config.em;
            console.error(err);
            this.onUploadEnd(err);
            em && em.trigger('asset:upload:error', err);
        },
        onUploadResponse(text, clb) {
            const em = this.config.em;
            const config = this.config;
            const target = this.target;
            let json;
            try {
                json = typeof text === 'string' ? JSON.parse(text) : text;
            } catch (e) {
                json = text;
            }
            em && em.trigger('asset:upload:response', json);
            if (config.autoAdd && target) {
                target.add(json.data, { at: 0 });
            }
            this.onUploadEnd(text);
            clb && clb(json);
        },
        uploadFile(e, clb) {
            const files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
            const {config} = this;
            const {beforeUpload} = config;
            const beforeUploadResponse = beforeUpload && beforeUpload(files);
            if (beforeUploadResponse === false)
                return;
            const body = new FormData();
            const {params, customFetch} = config;
            for (let param in params) {
                body.append(param, params[param]);
            }
            if (this.multiUpload) {
                for (let i = 0; i < files.length; i++) {
                    body.append(`${ config.uploadName }[]`, files[i]);
                }
            } else if (files.length) {
                body.append(config.uploadName, files[0]);
            }
            var target = this.target;
            const url = config.upload;
            const headers = config.headers;
            const reqHead = 'X-Requested-With';
            if (typeof headers[reqHead] == 'undefined') {
                headers[reqHead] = 'XMLHttpRequest';
            }
            if (url) {
                this.onUploadStart();
                const fetchOpts = {
                    method: 'post',
                    credentials: config.credentials || 'include',
                    headers,
                    body
                };
                const fetchResult = customFetch ? customFetch(url, fetchOpts) : fetch(url, fetchOpts).then(res => (res.status / 200 | 0) == 1 ? res.text() : res.text().then(text => Promise.reject(text)));
                return fetchResult.then(text => this.onUploadResponse(text, clb)).catch(err => this.onUploadError(err));
            }
        },
        initDrop() {
            var that = this;
            if (!this.uploadForm) {
                this.uploadForm = this.$el.find('form').get(0);
                if ('draggable' in this.uploadForm) {
                    var uploadFile = this.uploadFile;
                    this.uploadForm.ondragover = function () {
                        this.className = that.pfx + 'hover';
                        return false;
                    };
                    this.uploadForm.ondragleave = function () {
                        this.className = '';
                        return false;
                    };
                    this.uploadForm.ondrop = function (e) {
                        this.className = '';
                        e.preventDefault();
                        that.uploadFile(e);
                        return;
                    };
                }
            }
        },
        initDropzone(ev) {
            let addedCls = 0;
            const c = this.config;
            const em = ev.model;
            const edEl = ev.el;
            const editor = em.get('Editor');
            const container = em.get('Config').el;
            const frameEl = em.get('Canvas').getBody();
            const ppfx = this.ppfx;
            const updatedCls = `${ ppfx }dropzone-active`;
            const dropzoneCls = `${ ppfx }dropzone`;
            const cleanEditorElCls = () => {
                edEl.className = edEl.className.replace(updatedCls, '').trim();
                addedCls = 0;
            };
            const onDragOver = () => {
                if (!addedCls) {
                    edEl.className += ` ${ updatedCls }`;
                    addedCls = 1;
                }
                return false;
            };
            const onDragLeave = () => {
                cleanEditorElCls();
                return false;
            };
            const onDrop = e => {
                cleanEditorElCls();
                e.preventDefault();
                e.stopPropagation();
                this.uploadFile(e);
                if (c.openAssetsOnDrop && editor) {
                    const target = editor.getSelected();
                    editor.runCommand('open-assets', {
                        target,
                        onSelect() {
                            editor.Modal.close();
                            editor.AssetManager.setTarget(null);
                        }
                    });
                }
                return false;
            };
            ev.$el.append(`<div class="${ dropzoneCls }">${ c.dropzoneContent }</div>`);
            cleanEditorElCls();
            if ('draggable' in edEl) {
                [
                    edEl,
                    frameEl
                ].forEach(item => {
                    item.ondragover = onDragOver;
                    item.ondragleave = onDragLeave;
                    item.ondrop = onDrop;
                });
            }
        },
        render() {
            const {$el, pfx, em} = this;
            $el.html(this.undefined({
                title: em && em.t('assetManager.uploadTitle'),
                uploadId: this.uploadId,
                disabled: this.disabled,
                multiUpload: this.multiUpload,
                pfx
            }));
            this.initDrop();
            $el.attr('class', pfx + 'file-uploader');
            return this;
        }
    }, {
        embedAsBase64: function (e, clb) {
            const files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
            const response = { data: [] };
            if (!FileReader) {
                this.onUploadError(new Error('Unsupported platform, FileReader is not defined'));
                return;
            }
            const promises = [];
            const mimeTypeMatcher = /^(.+)\/(.+)$/;
            for (const file of files) {
                const promise = new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.addEventListener('load', event => {
                        let type;
                        const name = file.name;
                        const match = mimeTypeMatcher.exec(file.type);
                        if (match) {
                            type = match[1];
                        } else {
                            type = file.type;
                        }
                        if (type === 'image') {
                            const data = {
                                src: reader.result,
                                name,
                                type,
                                height: 0,
                                width: 0
                            };
                            const image = new Image();
                            image.addEventListener('error', error => {
                                reject(error);
                            });
                            image.addEventListener('load', () => {
                                data.height = image.height;
                                data.width = image.width;
                                resolve(data);
                            });
                            image.src = data.src;
                        } else if (type) {
                            resolve({
                                src: reader.result,
                                name,
                                type
                            });
                        } else {
                            resolve(reader.result);
                        }
                    });
                    reader.addEventListener('error', error => {
                        reject(error);
                    });
                    reader.addEventListener('abort', error => {
                        reject('Aborted');
                    });
                    reader.readAsDataURL(file);
                });
                promises.push(promise);
            }
            Promise.all(promises).then(data => {
                response.data = data;
                this.onUploadResponse(response, clb);
            }, error => {
                this.onUploadError(error);
            });
        }
    });
});
define('skylark-grapejs/asset_manager/index',[
    './config/config',
    './model/Assets',
    './view/AssetsView',
    './view/FileUploader'
], function (defaults, Assets, AssetsView, FileUpload) {
    'use strict';
    return () => {
        let c = {};
        let assets, am, fu;
        return {
            name: 'AssetManager',
            storageKey: 'assets',
            getConfig() {
                return c;
            },
            init(config) {
                c = config || {};
                for (let name in defaults) {
                    if (!(name in c))
                        c[name] = defaults[name];
                }
                const ppfx = c.pStylePrefix;
                const em = c.em;
                if (ppfx) {
                    c.stylePrefix = ppfx + c.stylePrefix;
                }
                assets = new Assets([]);
                const obj = {
                    collection: new Assets([]),
                    globalCollection: assets,
                    config: c
                };
                fu = new FileUpload(obj);
                obj.fu = fu;
                am = new AssetsView(obj);
                assets.listenTo(assets, 'add', model => {
                    this.getAllVisible().add(model);
                    em && em.trigger('asset:add', model);
                });
                assets.listenTo(assets, 'remove', model => {
                    this.getAllVisible().remove(model);
                    em && em.trigger('asset:remove', model);
                });
                return this;
            },
            add(asset, opts = {}) {
                if (typeof opts.at == 'undefined') {
                    opts.at = 0;
                }
                return assets.add(asset, opts);
            },
            get(src) {
                return assets.where({ src })[0];
            },
            getAll() {
                return assets;
            },
            getAllVisible() {
                return am.collection;
            },
            remove(src) {
                var asset = this.get(src);
                this.getAll().remove(asset);
                return this;
            },
            store(noStore) {
                var obj = {};
                var assets = JSON.stringify(this.getAll().toJSON());
                obj[this.storageKey] = assets;
                if (!noStore && c.stm)
                    c.stm.store(obj);
                return obj;
            },
            load(data = {}) {
                const name = this.storageKey;
                let assets = data[name] || [];
                if (typeof assets == 'string') {
                    try {
                        assets = JSON.parse(data[name]);
                    } catch (err) {
                    }
                }
                if (assets && assets.length) {
                    this.getAll().reset(assets);
                }
                return assets;
            },
            getContainer() {
                return am.el;
            },
            getAssetsEl() {
                return am.el.querySelector('[data-el=assets]');
            },
            render(assets) {
                const toRender = assets || this.getAll().models;
                if (!am.rendered) {
                    am.render();
                }
                am.collection.reset(toRender);
                return this.getContainer();
            },
            addType(id, definition) {
                this.getAll().addType(id, definition);
            },
            getType(id) {
                return this.getAll().getType(id);
            },
            getTypes() {
                return this.getAll().getTypes();
            },
            AssetsView() {
                return am;
            },
            FileUploader() {
                return fu;
            },
            onLoad() {
                this.getAll().reset(c.assets);
            },
            postRender(editorView) {
                c.dropzone && fu.initDropzone(editorView);
            },
            setTarget(m) {
                am.collection.target = m;
            },
            onSelect(f) {
                am.collection.onSelect = f;
            },
            onClick(func) {
                c.onClick = func;
            },
            onDblClick(func) {
                c.onDblClick = func;
            }
        };
    };
});
define('skylark-grapejs/css_composer/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'css-',
        staticRules: '',
        rules: []
    };
});
define('skylark-grapejs/domain_abstract/model/Styleable',[
    'skylark-underscore',
    '../../utils/mixins',
    '../../parser/model/ParserHtml'
], function (a, b, ParserHtml) {
    'use strict';
    const parseStyle = ParserHtml().parseStyle;
    return {
        parseStyle,
        extendStyle(prop) {
            return {
                ...this.getStyle(),
                ...prop
            };
        },
        getStyle() {
            const style = this.get('style') || {};
            return { ...style };
        },
        setStyle(prop = {}, opts = {}) {
            if (a.isString(prop)) {
                prop = parseStyle(prop);
            }
            const propOrig = this.getStyle();
            const propNew = { ...prop };
            this.set('style', propNew, opts);
            const diff = b.shallowDiff(propOrig, propNew);
            a.keys(diff).forEach(pr => {
                const em = this.em;
                this.trigger(`change:style:${ pr }`);
                if (em) {
                    em.trigger(`styleable:change`, this, pr);
                    em.trigger(`styleable:change:${ pr }`, this, pr);
                }
            });
            return propNew;
        },
        addStyle(prop, value = '', opts = {}) {
            if (typeof prop == 'string') {
                prop = { prop: value };
            } else {
                opts = value || {};
            }
            prop = this.extendStyle(prop);
            this.setStyle(prop, opts);
        },
        removeStyle(prop) {
            let style = this.getStyle();
            delete style[prop];
            this.setStyle(style);
        },
        styleToString(opts = {}) {
            const result = [];
            const style = this.getStyle();
            for (let prop in style) {
                const imp = opts.important;
                const important = a.isArray(imp) ? imp.indexOf(prop) >= 0 : imp;
                const value = `${ style[prop] }${ important ? ' !important' : '' }`;
                const propPrv = prop.substr(0, 2) == '__';
                value && !propPrv && result.push(`${ prop }:${ value };`);
            }
            return result.join('');
        },
        getSelectors() {
            return this.get('selectors') || this.get('classes');
        },
        getSelectorsString() {
            return this.selectorsToString ? this.selectorsToString() : this.getSelectors().getFullString();
        }
    };
});
define('skylark-grapejs/css_composer/model/CssRule',[
    'skylark-underscore',
    'skylark-backbone',
    '../../domain_abstract/model/Styleable',
    '../../selector_manager/model/Selectors'
], function (a, Backbone, Styleable, Selectors) {
    'use strict';
    const {CSS} = window;
    return Backbone.Model.extend(Styleable).extend({
        defaults: {
            selectors: {},
            selectorsAdd: '',
            style: {},
            mediaText: '',
            state: '',
            stylable: true,
            atRuleType: '',
            singleAtRule: 0,
            important: 0
        },
        initialize(c, opt = {}) {
            this.config = c || {};
            const em = opt.em;
            let selectors = this.config.selectors || [];
            this.em = em;
            if (em) {
                const sm = em.get('SelectorManager');
                const slct = [];
                selectors.undefined(selector => {
                    slct.push(sm.add(selector));
                });
                selectors = slct;
            }
            this.set('selectors', new Selectors(selectors));
        },
        getAtRule() {
            const type = this.get('atRuleType');
            const condition = this.get('mediaText');
            const typeStr = type ? `@${ type }` : condition ? '@media' : '';
            return typeStr + (condition && typeStr ? ` ${ condition }` : '');
        },
        selectorsToString(opts = {}) {
            const result = [];
            const {em} = this;
            const state = this.get('state');
            const wrapper = this.get('wrapper');
            const addSelector = this.get('selectorsAdd');
            const isBody = wrapper && em && em.getConfig('wrapperIsBody');
            const selOpts = { escape: str => CSS && CSS.escape ? CSS.escape(str) : str };
            const selectors = isBody ? 'body' : this.get('selectors').getFullString(0, selOpts);
            const stateStr = state && !opts.skipState ? `:${ state }` : '';
            selectors && result.push(`${ selectors }${ stateStr }`);
            addSelector && !opts.skipAdd && result.push(addSelector);
            return result.join(', ');
        },
        getDeclaration(opts = {}) {
            let result = '';
            const selectors = this.selectorsToString();
            const style = this.styleToString(opts);
            const singleAtRule = this.get('singleAtRule');
            if ((selectors || singleAtRule) && style) {
                result = singleAtRule ? style : `${ selectors }{${ style }}`;
            }
            return result;
        },
        toCSS(opts = {}) {
            let result = '';
            const atRule = this.getAtRule();
            const block = this.getDeclaration(opts);
            block && (result = block);
            if (atRule && result) {
                result = `${ atRule }{${ result }}`;
            }
            return result;
        },
        toJSON(...args) {
            const obj = Backbone.Model.prototype.toJSON.apply(this, args);
            if (this.em.getConfig('avoidDefaults')) {
                const defaults = this.defaults;
                a.forEach(defaults, (value, key) => {
                    if (obj[key] === value) {
                        delete obj[key];
                    }
                });
                if (a.isEmpty(obj.selectors))
                    delete obj.selectors;
                if (a.isEmpty(obj.style))
                    delete obj.style;
            }
            return obj;
        },
        compare(selectors, state, width, ruleProps = {}) {
            var st = state || '';
            var wd = width || '';
            var selectorsAdd = ruleProps.selectorsAdd || '';
            var atRuleType = ruleProps.atRuleType || '';
            var cId = 'cid';
            if (!(selectors instanceof Array) && !selectors.models)
                selectors = [selectors];
            var a1 = a.map(selectors.models || selectors, model => model.get('name'));
            var a2 = a.map(this.get('selectors').models, model => model.get('name'));
            var f = false;
            if (a1.length !== a2.length)
                return f;
            for (var i = 0; i < a1.length; i++) {
                var re = 0;
                for (var j = 0; j < a2.length; j++) {
                    if (a1[i] === a2[j])
                        re = 1;
                }
                if (re === 0)
                    return f;
            }
            if (this.get('state') !== st || this.get('mediaText') !== wd || this.get('selectorsAdd') !== selectorsAdd || this.get('atRuleType') !== atRuleType) {
                return f;
            }
            return true;
        }
    });
});
define('skylark-grapejs/css_composer/model/CssRules',[
    'skylark-backbone',
    './CssRule'
], function (Backbone, CssRule) {
    'use strict';
    return Backbone.Collection.extend({
        initialize(models, opt) {
            if (opt && opt.em)
                this.editor = opt.em;
            this.model = (attrs, options) => {
                var model;
                if (!options.em && opt && opt.em)
                    options.em = opt.em;
                switch (1) {
                default:
                    model = new CssRule(attrs, options);
                }
                return model;
            };
        },
        add(models, opt = {}) {
            if (typeof models === 'string') {
                models = this.editor.get('Parser').parseCss(models);
            }
            opt.em = this.editor;
            return Backbone.Collection.prototype.add.apply(this, [
                models,
                opt
            ]);
        }
    });
});
define('skylark-grapejs/css_composer/view/CssRuleView',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.View.extend({
        tagName: 'style',
        initialize(o = {}) {
            this.config = o.config || {};
            const model = this.model;
            const toTrack = 'change:style change:state change:mediaText';
            this.listenTo(model, toTrack, this.render);
            this.listenTo(model, 'destroy remove', this.remove);
            this.listenTo(model.get('selectors'), 'change', this.render);
        },
        render() {
            const model = this.model;
            const important = model.get('important');
            this.el.innerHTML = this.model.toCSS({ important });
            return this;
        }
    });
});
define('skylark-grapejs/css_composer/view/CssGroupRuleView',['./CssRuleView'], function (CssRuleView) {
    'use strict';
    return CssRuleView.extend({
        _createElement: function (tagName) {
            return document.createTextNode('');
        },
        render() {
            const model = this.model;
            const important = model.get('important');
            this.el.textContent = model.getDeclaration({ important });
            return this;
        }
    });
});
define('skylark-grapejs/css_composer/view/CssRulesView',[
    'skylark-backbone',
    './CssRuleView',
    './CssGroupRuleView'
], function (Backbone, CssRuleView, CssGroupRuleView) {
    'use strict';
    const $ = Backbone.$;
    const getBlockId = (pfx, order) => `${ pfx }${ order ? `-${ parseFloat(order) }` : '' }`;
    return Backbone.View.extend({
        initialize(o) {
            const config = o.config || {};
            this.atRules = {};
            this.config = config;
            this.em = config.em;
            this.pfx = config.stylePrefix || '';
            this.className = this.pfx + 'rules';
            const coll = this.collection;
            this.listenTo(coll, 'add', this.addTo);
            this.listenTo(coll, 'reset', this.render);
        },
        addTo(model) {
            this.addToCollection(model);
        },
        addToCollection(model, fragmentEl) {
            if (!this.renderStarted) {
                return;
            }
            const fragment = fragmentEl || null;
            const {config} = this;
            const opts = {
                model,
                config
            };
            let rendered, view;
            if (model.get('atRuleType') === 'keyframes') {
                const atRule = model.getAtRule();
                let atRuleEl = this.atRules[atRule];
                if (!atRuleEl) {
                    const styleEl = document.createElement('style');
                    atRuleEl = document.createTextNode('');
                    styleEl.appendChild(document.createTextNode(`${ atRule }{`));
                    styleEl.appendChild(atRuleEl);
                    styleEl.appendChild(document.createTextNode(`}`));
                    this.atRules[atRule] = atRuleEl;
                    rendered = styleEl;
                }
                view = new CssGroupRuleView(opts);
                atRuleEl.appendData(view.render().el.textContent);
            } else {
                view = new CssRuleView(opts);
                rendered = view.render().el;
            }
            const clsName = this.className;
            const mediaText = model.get('mediaText');
            const defaultBlockId = getBlockId(clsName);
            let blockId = defaultBlockId;
            if (mediaText) {
                blockId = getBlockId(clsName, this.getMediaWidth(mediaText));
            }
            if (rendered) {
                const container = fragment || this.el;
                let contRules;
                try {
                    contRules = container.querySelector(`#${ blockId }`);
                } catch (e) {
                }
                if (!contRules) {
                    contRules = container.querySelector(`#${ defaultBlockId }`);
                }
                contRules.appendChild(rendered);
            }
            return rendered;
        },
        getMediaWidth(mediaText) {
            return mediaText && mediaText.replace(`(${ this.em.getConfig('mediaCondition') }: `, '').replace(')', '');
        },
        render() {
            this.renderStarted = 1;
            this.atRules = {};
            const {em, $el, className, collection} = this;
            const frag = document.createDocumentFragment();
            $el.empty();
            const prs = em.get('DeviceManager').getAll().pluck('priority');
            prs.every(pr => pr) && prs.unshift(0);
            prs.forEach(pr => $(`<div id="${ getBlockId(className, pr) }"></div>`).appendTo(frag));
            collection.each(model => this.addToCollection(model, frag));
            $el.append(frag);
            $el.attr('class', className);
            return this;
        }
    });
});
define('selector_manager/model/Selector',['skylark-backbone'], function (Backbone) {
    'use strict';
    const TYPE_CLASS = 1;
    const TYPE_ID = 2;
    const Selector = Backbone.Model.extend({
        idAttribute: 'name',
        defaults: {
            name: '',
            label: '',
            type: TYPE_CLASS,
            active: true,
            private: false,
            protected: false
        },
        initialize(props, opts = {}) {
            const {
                config = {}
            } = opts;
            const name = this.get('name');
            const label = this.get('label');
            if (!name) {
                this.set('name', label);
            } else if (!label) {
                this.set('label', name);
            }
            const namePreEsc = this.get('name');
            const {escapeName} = config;
            const nameEsc = escapeName ? escapeName(namePreEsc) : Selector.escapeName(namePreEsc);
            this.set('name', nameEsc);
        },
        getFullName(opts = {}) {
            const {escape} = opts;
            const name = this.get('name');
            let init = '';
            switch (this.get('type')) {
            case TYPE_CLASS:
                init = '.';
                break;
            case TYPE_ID:
                init = '#';
                break;
            }
            return init + (escape ? escape(name) : name);
        }
    }, {
        TYPE_CLASS,
        TYPE_ID,
        escapeName(name) {
            return `${ name }`.trim().replace(/([^a-z0-9\w-\:]+)/gi, '-');
        }
    });
    return Selector;
});
define('selector_manager/model/Selectors',[
    'skylark-underscore',
    'skylark-backbone',
    './Selector'
], function (a, Backbone, Selector) {
    'use strict';
    return Backbone.Collection.extend({
        model: Selector,
        modelId: attr => `${ attr.name }_${ attr.type || Selector.TYPE_CLASS }`,
        getStyleable() {
            return a.filter(this.models, item => item.get('active') && !item.get('private'));
        },
        getValid({noDisabled} = {}) {
            return a.filter(this.models, item => !item.get('private')).undefined(item => noDisabled ? item.get('active') : 1);
        },
        getFullString(collection, opts = {}) {
            const result = [];
            const coll = collection || this;
            coll.forEach(selector => result.push(selector.getFullName(opts)));
            return result.join('').trim();
        }
    });
});
define('skylark-grapejs/css_composer/index',[
    'skylark-underscore',
    './config/config',
    './model/CssRule',
    './model/CssRules',
    './view/CssRulesView',
    '../../selector_manager/model/Selectors',
    '../../selector_manager/model/Selector'
], function (a, defaults, CssRule, CssRules, CssRulesView, Selectors, Selector) {
    'use strict';
    return () => {
        let em;
        var c = {};
        var rules, rulesView;
        return {
            Selectors,
            name: 'CssComposer',
            getConfig() {
                return c;
            },
            storageKey() {
                var keys = [];
                var smc = c.stm && c.stm.getConfig() || {};
                if (smc.storeCss)
                    keys.push('css');
                if (smc.storeStyles)
                    keys.push('styles');
                return keys;
            },
            init(config) {
                c = config || {};
                for (var name in defaults) {
                    if (!(name in c))
                        c[name] = defaults[name];
                }
                var ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                var elStyle = c.em && c.em.config.style || '';
                c.rules = elStyle || c.rules;
                em = c.em;
                rules = new CssRules([], c);
                rulesView = new CssRulesView({
                    collection: rules,
                    config: c
                });
                return this;
            },
            onLoad() {
                rules.add(c.rules);
            },
            postLoad(em) {
                const ev = 'add remove';
                const rules = this.getAll();
                const um = em.get('UndoManager');
                um && um.add(rules);
                em.stopListening(rules, ev, this.handleChange);
                em.listenTo(rules, ev, this.handleChange);
                rules.each(rule => this.handleChange(rule, { avoidStore: 1 }));
            },
            handleChange(model, opts = {}) {
                const ev = 'change:style';
                const um = em.get('UndoManager');
                um && um.add(model);
                const handleUpdates = em.handleUpdates.bind(em);
                em.stopListening(model, ev, handleUpdates);
                em.listenTo(model, ev, handleUpdates);
                !opts.avoidStore && handleUpdates('', '', opts);
            },
            load(data) {
                var d = data || '';
                if (!d && c.stm) {
                    d = c.em.getCacheLoad();
                }
                var obj = d.styles || '';
                if (d.styles) {
                    try {
                        obj = JSON.parse(d.styles);
                    } catch (err) {
                    }
                } else if (d.css) {
                    obj = c.em.get('Parser').parseCss(d.css);
                }
                if (a.isArray(obj)) {
                    obj.length && rules.reset(obj);
                } else if (obj) {
                    rules.reset(obj);
                }
                return obj;
            },
            store(noStore) {
                if (!c.stm)
                    return;
                var obj = {};
                var keys = this.storageKey();
                if (keys.indexOf('css') >= 0)
                    obj.css = c.em.getCss();
                if (keys.indexOf('styles') >= 0)
                    obj.styles = JSON.stringify(rules);
                if (!noStore)
                    c.stm.store(obj);
                return obj;
            },
            add(selectors, state, width, opts = {}) {
                var s = state || '';
                var w = width || '';
                var opt = { ...opts };
                var rule = this.get(selectors, s, w, opt);
                if (rule && rule.config && !rule.config.singleAtRule) {
                    return rule;
                } else {
                    opt.state = s;
                    opt.mediaText = w;
                    opt.selectors = '';
                    rule = new CssRule(opt, c);
                    rule.get('selectors').add(selectors);
                    rules.add(rule);
                    return rule;
                }
            },
            get(selectors, state, width, ruleProps) {
                var rule = null;
                rules.each(m => {
                    if (rule)
                        return;
                    if (m.compare(selectors, state, width, ruleProps))
                        rule = m;
                });
                return rule;
            },
            getAll() {
                return rules;
            },
            clear() {
                this.getAll().reset();
                return this;
            },
            addCollection(data, opts = {}) {
                var result = [];
                var d = data instanceof Array ? data : [data];
                for (var i = 0, l = d.length; i < l; i++) {
                    var rule = d[i] || {};
                    if (!rule.selectors)
                        continue;
                    var sm = c.em && c.em.get('SelectorManager');
                    if (!sm)
                        console.warn('Selector Manager not found');
                    var sl = rule.selectors;
                    var sels = sl instanceof Array ? sl : [sl];
                    var newSels = [];
                    for (var j = 0, le = sels.length; j < le; j++) {
                        var selec = sm.add(sels[j]);
                        newSels.push(selec);
                    }
                    var modelExists = this.get(newSels, rule.state, rule.mediaText, rule);
                    var model = this.add(newSels, rule.state, rule.mediaText, rule);
                    var updateStyle = !modelExists || !opts.avoidUpdateStyle;
                    const style = rule.style || {};
                    if (updateStyle) {
                        let styleUpdate = opts.extend ? {
                            ...model.get('style'),
                            ...style
                        } : style;
                        model.set('style', styleUpdate);
                    }
                    result.push(model);
                }
                return result;
            },
            setRule(selectors, style, opts = {}) {
                const {atRuleType, atRuleParams} = opts;
                const node = em.get('Parser').parserCss.checkNode({
                    selectors,
                    style
                })[0];
                const {state, selectorsAdd} = node;
                const sm = em.get('SelectorManager');
                const selector = sm.add(node.selectors);
                const rule = this.add(selector, state, atRuleParams, {
                    selectorsAdd,
                    atRule: atRuleType
                });
                rule.setStyle(style, opts);
                return rule;
            },
            getRule(selectors, opts = {}) {
                const sm = em.get('SelectorManager');
                const node = em.get('Parser').parserCss.checkNode({ selectors })[0];
                const selector = sm.get(node.selectors);
                const {state, selectorsAdd} = node;
                const {atRuleType, atRuleParams} = opts;
                return selector && this.get(selector, state, atRuleParams, {
                    selectorsAdd,
                    atRule: atRuleType
                });
            },
            setIdRule(name, style = {}, opts = {}) {
                const state = opts.state || '';
                const media = opts.mediaText || em.getCurrentMedia();
                const sm = em.get('SelectorManager');
                const selector = sm.add({
                    name,
                    type: Selector.TYPE_ID
                });
                const rule = this.add(selector, state, media);
                rule.setStyle(style, opts);
                return rule;
            },
            getIdRule(name, opts = {}) {
                const state = opts.state || '';
                const media = opts.mediaText || em.getCurrentMedia();
                const selector = em.get('SelectorManager').get(name, Selector.TYPE_ID);
                return selector && this.get(selector, state, media);
            },
            setClassRule(name, style = {}, opts = {}) {
                const state = opts.state || '';
                const media = opts.mediaText || em.getCurrentMedia();
                const sm = em.get('SelectorManager');
                const selector = sm.add({
                    name,
                    type: Selector.TYPE_CLASS
                });
                const rule = this.add(selector, state, media);
                rule.setStyle(style, opts);
                return rule;
            },
            getClassRule(name, opts = {}) {
                const state = opts.state || '';
                const media = opts.mediaText || em.getCurrentMedia();
                const selector = em.get('SelectorManager').get(name, Selector.TYPE_CLASS);
                return selector && this.get(selector, state, media);
            },
            render() {
                return rulesView.render().el;
            }
        };
    };
});
define('skylark-grapejs/trait_manager/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'trt-',
        appendTo: '',
        optionsTarget: [
            { value: false },
            { value: '_blank' }
        ]
    };
});
define('domain_abstract/view/DomainViews',[
    'skylark-underscore',
    'skylark-backbone'
], function (a, Backbone) {
    'use strict';
    return Backbone.View.extend({
        itemView: '',
        itemsView: '',
        itemType: 'type',
        autoAdd: 0,
        initialize(opts = {}, config) {
            this.config = config || opts.config || {};
            this.autoAdd && this.listenTo(this.collection, 'add', this.addTo);
            this.init();
        },
        init() {
        },
        addTo(model) {
            this.add(model);
        },
        itemViewNotFound(type) {
            const {config, ns} = this;
            const {em} = config;
            const warn = `${ ns ? `[${ ns }]: ` : '' }'${ type }' type not found`;
            em && em.logWarning(warn);
        },
        add(model, fragment) {
            const {config, reuseView, itemsView = {}} = this;
            const inputTypes = [
                'button',
                'checkbox',
                'color',
                'date',
                'datetime-local',
                'email',
                'file',
                'hidden',
                'image',
                'month',
                'number',
                'password',
                'radio',
                'range',
                'reset',
                'search',
                'submit',
                'tel',
                'text',
                'time',
                'url',
                'week'
            ];
            var frag = fragment || null;
            var itemView = this.itemView;
            var typeField = model.get(this.itemType);
            let view;
            if (itemsView[typeField]) {
                itemView = itemsView[typeField];
            } else if (typeField && !itemsView[typeField] && !a.includes(inputTypes, typeField)) {
                this.itemViewNotFound(typeField);
            }
            if (model.view && reuseView) {
                view = model.view;
            } else {
                view = new itemView({
                    model,
                    config
                }, config);
            }
            var rendered = view.render().el;
            if (frag)
                frag.appendChild(rendered);
            else
                this.$el.append(rendered);
        },
        render() {
            var frag = document.createDocumentFragment();
            this.$el.empty();
            if (this.collection.length)
                this.collection.each(function (model) {
                    this.add(model, frag);
                }, this);
            this.$el.append(frag);
            this.onRender();
            return this;
        },
        onRender() {
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitView',[
    'skylark-backbone',
    'skylark-underscore',
    'utils/mixins'
], function (Backbone, a, b) {
    'use strict';
    const $ = Backbone.$;
    return Backbone.View.extend({
        events: {},
        eventCapture: ['change'],
        appendInput: 1,
        attributes() {
            return this.model.get('attributes');
        },
        templateLabel() {
            const {ppfx} = this;
            const label = this.getLabel();
            return `<div class="${ ppfx }label" title="${ label }">${ label }</div>`;
        },
        templateInput() {
            const {clsField} = this;
            return `<div class="${ clsField }" data-input></div>`;
        },
        initialize(o = {}) {
            const {
                config = {}
            } = o;
            const {model, eventCapture} = this;
            const {target} = model;
            const {type} = model.attributes;
            this.config = config;
            this.em = config.em;
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.target = target;
            const {ppfx} = this;
            this.clsField = `${ ppfx }field ${ ppfx }field-${ type }`;
            [
                [
                    'change:value',
                    this.onValueChange
                ],
                [
                    'remove',
                    this.removeView
                ]
            ].forEach(([event, clb]) => {
                model.off(event, clb);
                this.listenTo(model, event, clb);
            });
            model.view = this;
            this.listenTo(model, 'change:label', this.render);
            this.listenTo(model, 'change:placeholder', this.rerender);
            eventCapture.forEach(event => this.events[event] = 'onChange');
            this.delegateEvents();
            this.init();
        },
        getClbOpts() {
            return {
                component: this.target,
                trait: this.model,
                elInput: this.getInputElem()
            };
        },
        removeView() {
            this.remove();
            this.removed();
        },
        init() {
        },
        removed() {
        },
        onRender() {
        },
        onUpdate() {
        },
        onEvent() {
        },
        onChange(event) {
            const el = this.getInputElem();
            if (el && !a.isUndefined(el.value)) {
                this.model.set('value', el.value);
            }
            this.onEvent({
                ...this.getClbOpts(),
                event
            });
        },
        getValueForTarget() {
            return this.model.get('value');
        },
        setInputValue(value) {
            const el = this.getInputElem();
            el && (el.value = value);
        },
        onValueChange(model, value, opts = {}) {
            if (opts.fromTarget) {
                this.setInputValue(model.get('value'));
                this.postUpdate();
            } else {
                const val = this.getValueForTarget();
                model.setTargetValue(val, opts);
            }
        },
        renderLabel() {
            const {$el, target} = this;
            const label = this.getLabel();
            let tpl = this.templateLabel(target);
            if (this.createLabel) {
                tpl = this.createLabel({
                    label,
                    component: target,
                    trait: this
                }) || '';
            }
            $el.find('[data-label]').append(tpl);
        },
        getLabel() {
            const {em} = this;
            const {label, name} = this.model.attributes;
            return em.t(`traitManager.traits.labels.${ name }`) || b.capitalize(label || name).replace(/-/g, ' ');
        },
        getComponent() {
            return this.target;
        },
        getInputEl() {
            if (!this.$input) {
                const {em, model} = this;
                const md = model;
                const {name} = model.attributes;
                const plh = md.get('placeholder') || md.get('default') || '';
                const type = md.get('type') || 'text';
                const min = md.get('min');
                const max = md.get('max');
                const value = this.getModelValue();
                const input = $(`<input type="${ type }" placeholder="${ plh }">`);
                const i18nAttr = em.t(`traitManager.traits.attributes.${ name }`) || {};
                input.attr(i18nAttr);
                if (!a.isUndefined(value)) {
                    md.set({ value }, { silent: true });
                    input.prop('value', value);
                }
                if (min) {
                    input.prop('min', min);
                }
                if (max) {
                    input.prop('max', max);
                }
                this.$input = input;
            }
            return this.$input.get(0);
        },
        getInputElem() {
            const {input, $input} = this;
            return input || $input && $input.get && $input.get(0) || this.getElInput();
        },
        getModelValue() {
            let value;
            const model = this.model;
            const target = this.target;
            const name = model.get('name');
            if (model.get('changeProp')) {
                value = target.get(name);
            } else {
                const attrs = target.get('attributes');
                value = model.get('value') || attrs[name];
            }
            return !a.isUndefined(value) ? value : '';
        },
        getElInput() {
            return this.elInput;
        },
        renderField() {
            const {$el, appendInput, model} = this;
            const inputs = $el.find('[data-input]');
            const el = inputs[inputs.length - 1];
            let tpl = model.el;
            if (!tpl) {
                tpl = this.createInput ? this.createInput(this.getClbOpts()) : this.getInputEl();
            }
            if (a.isString(tpl)) {
                el.innerHTML = tpl;
                this.elInput = el.firstChild;
            } else {
                appendInput ? el.appendChild(tpl) : el.insertBefore(tpl, el.firstChild);
                this.elInput = tpl;
            }
            model.el = this.elInput;
        },
        hasLabel() {
            const {label} = this.model.attributes;
            return !this.noLabel && label !== false;
        },
        rerender() {
            this.model.el = null;
            this.render();
        },
        postUpdate() {
            this.onUpdate(this.getClbOpts());
        },
        render() {
            const {$el, pfx, ppfx, model} = this;
            const {type} = model.attributes;
            const hasLabel = this.hasLabel && this.hasLabel();
            const cls = `${ pfx }trait`;
            this.$input = null;
            let tmpl = `<div class="${ cls }">
      ${ hasLabel ? `<div class="${ ppfx }label-wrp" data-label></div>` : '' }
      <div class="${ ppfx }field-wrp ${ ppfx }field-wrp--${ type }" data-input>
        ${ this.templateInput ? a.isFunction(this.templateInput) ? this.templateInput(this.getClbOpts()) : this.templateInput : '' }
      </div>
    </div>`;
            $el.empty().append(tmpl);
            hasLabel && this.renderLabel();
            this.renderField();
            this.el.className = `${ cls }__wrp`;
            this.postUpdate();
            this.onRender(this.getClbOpts());
            return this;
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitSelectView',[
    'skylark-backbone',
    'skylark-underscore',
    './TraitView'
], function (Backbone, a, TraitView) {
    'use strict';
    const $ = Backbone.$;
    return TraitView.extend({
        init() {
            this.listenTo(this.model, 'change:options', this.rerender);
        },
        templateInput() {
            const {ppfx, clsField} = this;
            return `<div class="${ clsField }">
      <div data-input></div>
      <div class="${ ppfx }sel-arrow">
        <div class="${ ppfx }d-s-arrow"></div>
      </div>
    </div>`;
        },
        getInputEl() {
            if (!this.$input) {
                const {model, em} = this;
                const propName = model.get('name');
                const opts = model.get('options') || [];
                let input = '<select>';
                opts.forEach(el => {
                    let attrs = '';
                    let name, value, style;
                    if (a.isString(el)) {
                        name = el;
                        value = el;
                    } else {
                        name = el.name || el.label || el.value;
                        value = `${ a.isUndefined(el.value) ? el.id : el.value }`.replace(/"/g, '&quot;');
                        style = el.style ? el.style.replace(/"/g, '&quot;') : '';
                        attrs += style ? ` style="${ style }"` : '';
                    }
                    const resultName = em.t(`traitManager.traits.options.${ propName }.${ value }`) || name;
                    input += `<option value="${ value }"${ attrs }>${ resultName }</option>`;
                });
                input += '</select>';
                this.$input = $(input);
                const val = model.getTargetValue();
                !a.isUndefined(val) && this.$input.val(val);
            }
            return this.$input.get(0);
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitCheckboxView',[
    'skylark-underscore',
    './TraitView'
], function (a, TraitView) {
    'use strict';
    return TraitView.extend({
        appendInput: 0,
        templateInput() {
            const {ppfx, clsField} = this;
            return `<label class="${ clsField }" data-input>
    <i class="${ ppfx }chk-icon"></i>
  </label>`;
        },
        onChange() {
            const value = this.getInputElem().checked;
            this.model.set('value', this.getCheckedValue(value));
        },
        getCheckedValue(checked) {
            let result = checked;
            const {valueTrue, valueFalse} = this.model.attributes;
            if (result && !a.isUndefined(valueTrue)) {
                result = valueTrue;
            }
            if (!result && !a.isUndefined(valueFalse)) {
                result = valueFalse;
            }
            return result;
        },
        getInputEl(...args) {
            const toInit = !this.$input;
            const el = TraitView.prototype.getInputEl.apply(this, args);
            if (toInit) {
                let checked, targetValue;
                const {model, target} = this;
                const {valueTrue, valueFalse} = model.attributes;
                const name = model.get('name');
                if (model.get('changeProp')) {
                    checked = target.get(name);
                    targetValue = checked;
                } else {
                    targetValue = target.get('attributes')[name];
                    checked = targetValue || targetValue === '' ? !0 : !1;
                }
                if (!a.isUndefined(valueFalse) && targetValue === valueFalse) {
                    checked = !1;
                }
                el.checked = checked;
            }
            return el;
        }
    });
});
define('domain_abstract/ui/Input',['skylark-backbone'], function (Backbone) {
    'use strict';
    const $ = Backbone.$;
    return Backbone.View.extend({
        events: { change: 'handleChange' },
        template() {
            return `<span class="${ this.holderClass() }"></span>`;
        },
        inputClass() {
            return `${ this.ppfx }field`;
        },
        holderClass() {
            return `${ this.ppfx }input-holder`;
        },
        initialize(opts = {}) {
            const ppfx = opts.ppfx || '';
            this.opts = opts;
            this.ppfx = ppfx;
            this.em = opts.target || {};
            this.listenTo(this.model, 'change:value', this.handleModelChange);
        },
        elementUpdated() {
            this.model.trigger('el:change');
        },
        setValue(value) {
            const model = this.model;
            let val = value || model.get('defaults');
            const input = this.getInputEl();
            input && (input.value = val);
        },
        handleModelChange(model, value, opts) {
            this.setValue(value, opts);
        },
        handleChange(e) {
            e.stopPropagation();
            const value = this.getInputEl().value;
            this.model.set({ value }, { fromInput: 1 });
            this.elementUpdated();
        },
        getInputEl() {
            if (!this.inputEl) {
                const {model} = this;
                const plh = model.get('placeholder') || model.get('defaults') || '';
                this.inputEl = $(`<input type="text" placeholder="${ plh }">`);
            }
            return this.inputEl.get(0);
        },
        render() {
            this.inputEl = null;
            const el = this.$el;
            el.addClass(this.inputClass());
            el.html(this.template());
            el.find(`.${ this.holderClass() }`).append(this.getInputEl());
            return this;
        }
    });
});
define('domain_abstract/ui/InputNumber',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins',
    './Input'
], function (Backbone, a, b, Input) {
    'use strict';
    const $ = Backbone.$;
    return Input.extend({
        events: {
            'change input': 'handleChange',
            'change select': 'handleUnitChange',
            'click [data-arrow-up]': 'upArrowClick',
            'click [data-arrow-down]': 'downArrowClick',
            'mousedown [data-arrows]': 'downIncrement'
        },
        template() {
            const ppfx = this.ppfx;
            return `
      <span class="${ ppfx }input-holder"></span>
      <span class="${ ppfx }field-units"></span>
      <div class="${ ppfx }field-arrows" data-arrows>
        <div class="${ ppfx }field-arrow-u" data-arrow-up></div>
        <div class="${ ppfx }field-arrow-d" data-arrow-down></div>
      </div>
    `;
        },
        inputClass() {
            const ppfx = this.ppfx;
            return this.opts.contClass || `${ ppfx }field ${ ppfx }field-integer`;
        },
        initialize(opts = {}) {
            Input.prototype.initialize.apply(this, arguments);
            a.bindAll(this, 'moveIncrement', 'upIncrement');
            this.doc = document;
            this.listenTo(this.model, 'change:unit', this.handleModelChange);
        },
        setValue(value, opts) {
            var opt = opts || {};
            var valid = this.validateInputValue(value, { deepCheck: 1 });
            var validObj = { value: valid.value };
            if (valid.unit || valid.force) {
                validObj.unit = valid.unit;
            }
            this.model.set(validObj, opt);
            if (opt.silent) {
                this.handleModelChange();
            }
        },
        handleChange(e) {
            e.stopPropagation();
            this.setValue(this.getInputEl().value);
            this.elementUpdated();
        },
        handleUnitChange(e) {
            e.stopPropagation();
            var value = this.getUnitEl().value;
            this.model.set('unit', value);
            this.elementUpdated();
        },
        elementUpdated() {
            this.model.trigger('el:change');
        },
        handleModelChange() {
            const model = this.model;
            this.getInputEl().value = model.get('value');
            const unitEl = this.getUnitEl();
            unitEl && (unitEl.value = model.get('unit') || '');
        },
        getUnitEl() {
            if (!this.unitEl) {
                const model = this.model;
                const units = model.get('units') || [];
                if (units.length) {
                    const options = [];
                    units.forEach(unit => {
                        const selected = unit == model.get('unit') ? 'selected' : '';
                        options.push(`<option ${ selected }>${ unit }</option>`);
                    });
                    const temp = document.createElement('div');
                    temp.innerHTML = `<select class="${ this.ppfx }input-unit">${ options.join('') }</select>`;
                    this.unitEl = temp.firstChild;
                }
            }
            return this.unitEl;
        },
        upArrowClick() {
            const model = this.model;
            const step = model.get('step');
            let value = parseInt(model.get('value'), 10);
            value = this.normalizeValue(value + step);
            var valid = this.validateInputValue(value);
            model.set('value', valid.value);
            this.elementUpdated();
        },
        downArrowClick() {
            const model = this.model;
            const step = model.get('step');
            const value = parseInt(model.get('value'), 10);
            const val = this.normalizeValue(value - step);
            var valid = this.validateInputValue(val);
            model.set('value', valid.value);
            this.elementUpdated();
        },
        downIncrement(e) {
            e.preventDefault();
            this.moved = 0;
            var value = this.model.get('value');
            value = this.normalizeValue(value);
            this.current = {
                y: e.pageY,
                val: value
            };
            b.on(this.doc, 'mousemove', this.moveIncrement);
            b.on(this.doc, 'mouseup', this.upIncrement);
        },
        moveIncrement(ev) {
            this.moved = 1;
            const model = this.model;
            const step = model.get('step');
            const data = this.current;
            var pos = this.normalizeValue(data.val + (data.y - ev.pageY) * step);
            this.prValue = this.validateInputValue(pos).value;
            model.set('value', this.prValue, { avoidStore: 1 });
            return false;
        },
        upIncrement() {
            const model = this.model;
            const step = model.get('step');
            b.off(this.doc, 'mouseup', this.upIncrement);
            b.off(this.doc, 'mousemove', this.moveIncrement);
            if (this.prValue && this.moved) {
                var value = this.prValue - step;
                model.set('value', value, { avoidStore: 1 }).set('value', value + step);
                this.elementUpdated();
            }
        },
        normalizeValue(value, defValue = 0) {
            const model = this.model;
            const step = model.get('step');
            let stepDecimals = 0;
            if (isNaN(value)) {
                return defValue;
            }
            value = parseFloat(value);
            if (Math.floor(value) !== value) {
                const side = step.toString().split('.')[1];
                stepDecimals = side ? side.length : 0;
            }
            return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
        },
        validateInputValue(value, opts) {
            var force = 0;
            var opt = opts || {};
            var model = this.model;
            const defValue = '';
            var val = !a.isUndefined(value) ? value : defValue;
            var units = model.get('units') || [];
            var unit = model.get('unit') || units.length && units[0] || '';
            var max = model.get('max');
            var min = model.get('min');
            if (opt.deepCheck) {
                var fixed = model.get('fixedValues') || [];
                if (val) {
                    var regFixed = new RegExp('^' + fixed.join('|'), 'g');
                    if (fixed.length && regFixed.test(val)) {
                        val = val.match(regFixed)[0];
                        unit = '';
                        force = 1;
                    } else {
                        var valCopy = val + '';
                        val += '';
                        val = parseFloat(val.replace(',', '.'));
                        val = !isNaN(val) ? val : defValue;
                        var uN = valCopy.replace(val, '');
                        if (a.indexOf(units, uN) >= 0)
                            unit = uN;
                    }
                }
            }
            if (!a.isUndefined(max) && max !== '')
                val = val > max ? max : val;
            if (!a.isUndefined(min) && min !== '')
                val = val < min ? min : val;
            return {
                force,
                value: val,
                unit
            };
        },
        render() {
            Input.prototype.render.call(this);
            this.unitEl = null;
            const unit = this.getUnitEl();
            unit && this.$el.find(`.${ this.ppfx }field-units`).get(0).appendChild(unit);
            return this;
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitNumberView',[
    './TraitView',
    'domain_abstract/ui/InputNumber'
], function (TraitView, InputNumber) {
    'use strict';
    return TraitView.extend({
        getValueForTarget() {
            const {model} = this;
            const {value, unit} = model.attributes;
            return value ? value + unit : '';
        },
        getInputEl() {
            if (!this.input) {
                var value = this.getModelValue();
                var inputNumber = new InputNumber({
                    contClass: this.ppfx + 'field-int',
                    model: this.model,
                    ppfx: this.ppfx
                });
                this.input = inputNumber.render();
                this.$input = this.input.inputEl;
                this.$unit = this.input.unitEl;
                this.model.set('value', value);
                this.$input.val(value);
                this.input = inputNumber.el;
            }
            return this.input;
        }
    });
});
define('utils/ColorPicker',[],function () {
    'use strict';
    return function ($, undefined) {
        'use strict';
        var defaultOpts = {
                beforeShow: noop,
                move: noop,
                change: noop,
                show: noop,
                hide: noop,
                color: false,
                flat: false,
                showInput: false,
                allowEmpty: false,
                showButtons: true,
                clickoutFiresChange: true,
                showInitial: false,
                showPalette: false,
                showPaletteOnly: false,
                hideAfterPaletteSelect: false,
                togglePaletteOnly: false,
                showSelectionPalette: true,
                localStorageKey: false,
                appendTo: 'body',
                maxSelectionSize: 7,
                cancelText: 'cancel',
                chooseText: 'choose',
                togglePaletteMoreText: 'more',
                togglePaletteLessText: 'less',
                clearText: 'Clear Color Selection',
                noColorSelectedText: 'No Color Selected',
                preferredFormat: false,
                className: '',
                containerClassName: '',
                replacerClassName: '',
                showAlpha: false,
                theme: 'sp-light',
                palette: [[
                        '#ffffff',
                        '#000000',
                        '#ff0000',
                        '#ff8000',
                        '#ffff00',
                        '#008000',
                        '#0000ff',
                        '#4b0082',
                        '#9400d3'
                    ]],
                selectionPalette: [],
                disabled: false,
                offset: null
            }, spectrums = [], IE = !!/msie/i.exec(window.navigator.userAgent), rgbaSupport = function () {
                function contains(str, substr) {
                    return !!~('' + str).indexOf(substr);
                }
                var elem = document.createElement('div');
                var style = elem.style;
                style.cssText = 'background-color:rgba(0,0,0,.5)';
                return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
            }(), replaceInput = [
                "<div class='sp-replacer'>",
                "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
                "<div class='sp-dd'>&#9660;</div>",
                '</div>'
            ].join(''), markup = function () {
                var gradientFix = '';
                if (IE) {
                    for (var i = 1; i <= 6; i++) {
                        gradientFix += "<div class='sp-" + i + "'></div>";
                    }
                }
                return [
                    "<div class='sp-container sp-hidden'>",
                    "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                    "<div class='sp-palette-button-container sp-cf'>",
                    "<button type='button' class='sp-palette-toggle'></button>",
                    '</div>',
                    '</div>',
                    "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                    "<div class='sp-fill'></div>",
                    "<div class='sp-top-inner'>",
                    "<div class='sp-color'>",
                    "<div class='sp-sat'>",
                    "<div class='sp-val'>",
                    "<div class='sp-dragger'></div>",
                    '</div>',
                    '</div>',
                    '</div>',
                    "<div class='sp-clear sp-clear-display'>",
                    '</div>',
                    "<div class='sp-hue'>",
                    "<div class='sp-slider'></div>",
                    gradientFix,
                    '</div>',
                    '</div>',
                    "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    '</div>',
                    "<div class='sp-input-container sp-cf'>",
                    "<input class='sp-input' type='text' spellcheck='false'  />",
                    '</div>',
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                    "<a class='sp-cancel' href='#'></a>",
                    "<button type='button' class='sp-choose'></button>",
                    '</div>',
                    '</div>',
                    '</div>'
                ].join('');
            }();
        function paletteTemplate(p, color, className, opts) {
            var html = [];
            for (var i = 0; i < p.length; i++) {
                var current = p[i];
                if (current) {
                    var tiny = tinycolor(current);
                    var c = tiny.toHsl().l < 0.5 ? 'sp-thumb-el sp-thumb-dark' : 'sp-thumb-el sp-thumb-light';
                    c += tinycolor.equals(color, current) ? ' sp-thumb-active' : '';
                    var formattedString = tiny.toString(opts.preferredFormat || 'rgb');
                    var swatchStyle = rgbaSupport ? 'background-color:' + tiny.toRgbString() : 'filter:' + tiny.toFilter();
                    html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';"></span></span>');
                } else {
                    var cls = 'sp-clear-display';
                    html.push($('<div />').append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>').attr('title', opts.noColorSelectedText)).html());
                }
            }
            return "<div class='sp-cf " + className + "'>" + html.join('') + '</div>';
        }
        function hideAll() {
            for (var i = 0; i < spectrums.length; i++) {
                if (spectrums[i]) {
                    spectrums[i].hide();
                }
            }
        }
        function instanceOptions(o, callbackContext) {
            var opts = $.extend({}, defaultOpts, o);
            opts.callbacks = {
                move: bind(opts.move, callbackContext),
                change: bind(opts.change, callbackContext),
                show: bind(opts.show, callbackContext),
                hide: bind(opts.hide, callbackContext),
                beforeShow: bind(opts.beforeShow, callbackContext)
            };
            return opts;
        }
        function spectrum(element, o) {
            var opts = instanceOptions(o, element), flat = opts.flat, showSelectionPalette = opts.showSelectionPalette, localStorageKey = opts.localStorageKey, theme = opts.theme, callbacks = opts.callbacks, resize = throttle(reflow, 10), visible = false, isDragging = false, dragWidth = 0, dragHeight = 0, dragHelperHeight = 0, slideHeight = 0, slideWidth = 0, alphaWidth = 0, alphaSlideHelperWidth = 0, slideHelperHeight = 0, currentHue = 0, currentSaturation = 0, currentValue = 0, currentAlpha = 1, palette = [], paletteArray = [], paletteLookup = {}, selectionPalette = opts.selectionPalette.slice(0), maxSelectionSize = opts.maxSelectionSize, draggingClass = 'sp-dragging', shiftMovementDirection = null;
            var doc = element.ownerDocument, body = doc.body, boundElement = $(element), disabled = false, container = $(markup, doc).addClass(theme), pickerContainer = container.find('.sp-picker-container'), dragger = container.find('.sp-color'), dragHelper = container.find('.sp-dragger'), slider = container.find('.sp-hue'), slideHelper = container.find('.sp-slider'), alphaSliderInner = container.find('.sp-alpha-inner'), alphaSlider = container.find('.sp-alpha'), alphaSlideHelper = container.find('.sp-alpha-handle'), textInput = container.find('.sp-input'), paletteContainer = container.find('.sp-palette'), initialColorContainer = container.find('.sp-initial'), cancelButton = container.find('.sp-cancel'), clearButton = container.find('.sp-clear'), chooseButton = container.find('.sp-choose'), toggleButton = container.find('.sp-palette-toggle'), isInput = boundElement.is('input'), isInputTypeColor = isInput && boundElement.attr('type') === 'color' && inputTypeColorSupport(), shouldReplace = isInput && !flat, replacer = shouldReplace ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]), offsetElement = shouldReplace ? replacer : boundElement, previewElement = replacer.find('.sp-preview-inner'), initialColor = opts.color || isInput && boundElement.val(), colorOnShow = false, currentPreferredFormat = opts.preferredFormat, clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange, isEmpty = !initialColor, allowEmpty = opts.allowEmpty && !isInputTypeColor;
            function applyOptions() {
                if (opts.showPaletteOnly) {
                    opts.showPalette = true;
                }
                toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
                if (opts.palette) {
                    palette = opts.palette.slice(0);
                    paletteArray = $.isArray(palette[0]) ? palette : [palette];
                    paletteLookup = {};
                    for (var i = 0; i < paletteArray.length; i++) {
                        for (var j = 0; j < paletteArray[i].length; j++) {
                            var rgb = tinycolor(paletteArray[i][j]).toRgbString();
                            paletteLookup[rgb] = true;
                        }
                    }
                }
                container.toggleClass('sp-flat', flat);
                container.toggleClass('sp-input-disabled', !opts.showInput);
                container.toggleClass('sp-alpha-enabled', opts.showAlpha);
                container.toggleClass('sp-clear-enabled', allowEmpty);
                container.toggleClass('sp-buttons-disabled', !opts.showButtons);
                container.toggleClass('sp-palette-buttons-disabled', !opts.togglePaletteOnly);
                container.toggleClass('sp-palette-disabled', !opts.showPalette);
                container.toggleClass('sp-palette-only', opts.showPaletteOnly);
                container.toggleClass('sp-initial-disabled', !opts.showInitial);
                container.addClass(opts.className).addClass(opts.containerClassName);
                reflow();
            }
            function initialize() {
                if (IE) {
                    container.find('*:not(input)').attr('unselectable', 'on');
                }
                applyOptions();
                if (shouldReplace) {
                    boundElement.after(replacer).hide();
                }
                if (!allowEmpty) {
                    clearButton.hide();
                }
                if (flat) {
                    boundElement.after(container).hide();
                } else {
                    var appendTo = opts.appendTo === 'parent' ? boundElement.parent() : $(opts.appendTo);
                    if (appendTo.length !== 1) {
                        appendTo = $('body');
                    }
                    appendTo.append(container);
                }
                updateSelectionPaletteFromStorage();
                offsetElement.bind('click.spectrum touchstart.spectrum', function (e) {
                    if (!disabled) {
                        toggle();
                    }
                    e.stopPropagation();
                    if (!$(e.target).is('input')) {
                        e.preventDefault();
                    }
                });
                if (boundElement.is(':disabled') || opts.disabled === true) {
                    disable();
                }
                container.click(stopPropagation);
                textInput.change(setFromTextInput);
                textInput.bind('paste', function () {
                    setTimeout(setFromTextInput, 1);
                });
                textInput.keydown(function (e) {
                    if (e.keyCode == 13) {
                        setFromTextInput();
                    }
                });
                cancelButton.text(opts.cancelText);
                cancelButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    revert();
                    hide();
                });
                clearButton.attr('title', opts.clearText);
                clearButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    isEmpty = true;
                    move();
                    if (flat) {
                        updateOriginalInput(true);
                    }
                });
                chooseButton.text(opts.chooseText);
                chooseButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    if (IE && textInput.is(':focus')) {
                        textInput.trigger('change');
                    }
                    if (isValid()) {
                        updateOriginalInput(true);
                        hide();
                    }
                });
                toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
                toggleButton.bind('click.spectrum', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    opts.showPaletteOnly = !opts.showPaletteOnly;
                    if (!opts.showPaletteOnly && !flat) {
                        container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
                    }
                    applyOptions();
                });
                draggable(alphaSlider, function (dragX, dragY, e) {
                    currentAlpha = dragX / alphaWidth;
                    isEmpty = false;
                    if (e.shiftKey) {
                        currentAlpha = Math.round(currentAlpha * 10) / 10;
                    }
                    move();
                }, dragStart, dragStop);
                draggable(slider, function (dragX, dragY) {
                    currentHue = parseFloat(dragY / slideHeight);
                    isEmpty = false;
                    if (!opts.showAlpha) {
                        currentAlpha = 1;
                    }
                    move();
                }, dragStart, dragStop);
                draggable(dragger, function (dragX, dragY, e) {
                    if (!e.shiftKey) {
                        shiftMovementDirection = null;
                    } else if (!shiftMovementDirection) {
                        var oldDragX = currentSaturation * dragWidth;
                        var oldDragY = dragHeight - currentValue * dragHeight;
                        var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
                        shiftMovementDirection = furtherFromX ? 'x' : 'y';
                    }
                    var setSaturation = !shiftMovementDirection || shiftMovementDirection === 'x';
                    var setValue = !shiftMovementDirection || shiftMovementDirection === 'y';
                    if (setSaturation) {
                        currentSaturation = parseFloat(dragX / dragWidth);
                    }
                    if (setValue) {
                        currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                    }
                    isEmpty = false;
                    if (!opts.showAlpha) {
                        currentAlpha = 1;
                    }
                    move();
                }, dragStart, dragStop);
                if (!!initialColor) {
                    set(initialColor);
                    updateUI();
                    currentPreferredFormat = opts.preferredFormat || tinycolor(initialColor).format;
                    addColorToSelectionPalette(initialColor);
                } else {
                    updateUI();
                }
                if (flat) {
                    show();
                }
                function paletteElementClick(e) {
                    if (e.data && e.data.ignore) {
                        set($(e.target).closest('.sp-thumb-el').data('color'));
                        move();
                    } else {
                        set($(e.target).closest('.sp-thumb-el').data('color'));
                        move();
                        updateOriginalInput(true);
                        if (opts.hideAfterPaletteSelect) {
                            hide();
                        }
                    }
                    return false;
                }
                var paletteEvent = IE ? 'mousedown.spectrum' : 'click.spectrum touchstart.spectrum';
                paletteContainer.delegate('.sp-thumb-el', paletteEvent, paletteElementClick);
                initialColorContainer.delegate('.sp-thumb-el:nth-child(1)', paletteEvent, { ignore: true }, paletteElementClick);
            }
            function updateSelectionPaletteFromStorage() {
                if (localStorageKey && window.localStorage) {
                    try {
                        var oldPalette = window.localStorage[localStorageKey].split(',#');
                        if (oldPalette.length > 1) {
                            delete window.localStorage[localStorageKey];
                            $.each(oldPalette, function (i, c) {
                                addColorToSelectionPalette(c);
                            });
                        }
                    } catch (e) {
                    }
                    try {
                        selectionPalette = window.localStorage[localStorageKey].split(';');
                    } catch (e) {
                    }
                }
            }
            function addColorToSelectionPalette(color) {
                if (showSelectionPalette) {
                    var rgb = tinycolor(color).toRgbString();
                    if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
                        selectionPalette.push(rgb);
                        while (selectionPalette.length > maxSelectionSize) {
                            selectionPalette.shift();
                        }
                    }
                    if (localStorageKey && window.localStorage) {
                        try {
                            window.localStorage[localStorageKey] = selectionPalette.join(';');
                        } catch (e) {
                        }
                    }
                }
            }
            function getUniqueSelectionPalette() {
                var unique = [];
                if (opts.showPalette) {
                    for (var i = 0; i < selectionPalette.length; i++) {
                        var rgb = tinycolor(selectionPalette[i]).toRgbString();
                        if (!paletteLookup[rgb]) {
                            unique.push(selectionPalette[i]);
                        }
                    }
                }
                return unique.reverse().slice(0, opts.maxSelectionSize);
            }
            function drawPalette() {
                var currentColor = get();
                var html = $.map(paletteArray, function (palette, i) {
                    return paletteTemplate(palette, currentColor, 'sp-palette-row sp-palette-row-' + i, opts);
                });
                updateSelectionPaletteFromStorage();
                if (selectionPalette) {
                    html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, 'sp-palette-row sp-palette-row-selection', opts));
                }
                paletteContainer.html(html.join(''));
            }
            function drawInitial() {
                if (opts.showInitial) {
                    var initial = colorOnShow;
                    var current = get();
                    initialColorContainer.html(paletteTemplate([
                        initial,
                        current
                    ], current, 'sp-palette-row-initial', opts));
                }
            }
            function dragStart() {
                if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                    reflow();
                }
                isDragging = true;
                container.addClass(draggingClass);
                shiftMovementDirection = null;
                boundElement.trigger('dragstart.spectrum', [get()]);
            }
            function dragStop() {
                isDragging = false;
                container.removeClass(draggingClass);
                boundElement.trigger('dragstop.spectrum', [get()]);
            }
            function setFromTextInput() {
                var value = textInput.val();
                if ((value === null || value === '') && allowEmpty) {
                    set(null);
                    updateOriginalInput(true);
                } else {
                    var tiny = tinycolor(value);
                    if (tiny.isValid()) {
                        set(tiny);
                        updateOriginalInput(true);
                    } else {
                        textInput.addClass('sp-validation-error');
                    }
                }
            }
            function toggle() {
                if (visible) {
                    hide();
                } else {
                    show();
                }
            }
            function show() {
                var event = $.Event('beforeShow.spectrum');
                if (visible) {
                    reflow();
                    return;
                }
                boundElement.trigger('beforeShow.spectrum', [get()]);
                if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                    return;
                }
                hideAll();
                visible = true;
                var $doc = $(doc);
                $doc.bind('keydown.spectrum', onkeydown);
                $doc.bind('click.spectrum', clickout);
                $(window).bind('resize.spectrum', resize);
                replacer.addClass('sp-active');
                container.removeClass('sp-hidden');
                reflow();
                updateUI();
                colorOnShow = get();
                drawInitial();
                callbacks.show(colorOnShow);
                boundElement.trigger('show.spectrum', [colorOnShow]);
            }
            function onkeydown(e) {
                if (e.keyCode === 27) {
                    hide();
                }
            }
            function clickout(e) {
                if (e.button == 2) {
                    return;
                }
                if (isDragging) {
                    return;
                }
                if (clickoutFiresChange) {
                    updateOriginalInput(true);
                } else {
                    revert();
                }
                hide();
            }
            function hide() {
                if (!visible || flat) {
                    return;
                }
                visible = false;
                $(doc).unbind('keydown.spectrum', onkeydown);
                $(doc).unbind('click.spectrum', clickout);
                $(window).unbind('resize.spectrum', resize);
                replacer.removeClass('sp-active');
                container.addClass('sp-hidden');
                callbacks.hide(get());
                boundElement.trigger('hide.spectrum', [get()]);
            }
            function revert() {
                set(colorOnShow, true);
            }
            function set(color, ignoreFormatChange) {
                if (tinycolor.equals(color, get())) {
                    updateUI();
                    return;
                }
                var newColor, newHsv;
                if (!color && allowEmpty) {
                    isEmpty = true;
                } else {
                    isEmpty = false;
                    newColor = tinycolor(color);
                    newHsv = newColor.toHsv();
                    currentHue = newHsv.h % 360 / 360;
                    currentSaturation = newHsv.s;
                    currentValue = newHsv.v;
                    currentAlpha = newHsv.a;
                }
                updateUI();
                if (newColor && newColor.isValid() && !ignoreFormatChange) {
                    currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
                }
            }
            function get(opts) {
                opts = opts || {};
                if (allowEmpty && isEmpty) {
                    return null;
                }
                return tinycolor.fromRatio({
                    h: currentHue,
                    s: currentSaturation,
                    v: currentValue,
                    a: Math.round(currentAlpha * 100) / 100
                }, { format: opts.format || currentPreferredFormat });
            }
            function isValid() {
                return !textInput.hasClass('sp-validation-error');
            }
            function move() {
                updateUI();
                callbacks.move(get());
                boundElement.trigger('move.spectrum', [get()]);
            }
            function updateUI() {
                textInput.removeClass('sp-validation-error');
                updateHelperLocations();
                var flatColor = tinycolor.fromRatio({
                    h: currentHue,
                    s: 1,
                    v: 1
                });
                dragger.css('background-color', flatColor.toHexString());
                var format = currentPreferredFormat;
                if (currentAlpha < 1 && !(currentAlpha === 0 && format === 'name')) {
                    if (format === 'hex' || format === 'hex3' || format === 'hex6' || format === 'name') {
                        format = 'rgb';
                    }
                }
                var realColor = get({ format: format }), displayColor = '';
                previewElement.removeClass('sp-clear-display');
                previewElement.css('background-color', 'transparent');
                if (!realColor && allowEmpty) {
                    previewElement.addClass('sp-clear-display');
                } else {
                    var realHex = realColor.toHexString(), realRgb = realColor.toRgbString();
                    if (rgbaSupport || realColor.alpha === 1) {
                        previewElement.css('background-color', realRgb);
                    } else {
                        previewElement.css('background-color', 'transparent');
                        previewElement.css('filter', realColor.toFilter());
                    }
                    if (opts.showAlpha) {
                        var rgb = realColor.toRgb();
                        rgb.a = 0;
                        var realAlpha = tinycolor(rgb).toRgbString();
                        var gradient = 'linear-gradient(left, ' + realAlpha + ', ' + realHex + ')';
                        if (IE) {
                            alphaSliderInner.css('filter', tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                        } else {
                            alphaSliderInner.css('background', '-webkit-' + gradient);
                            alphaSliderInner.css('background', '-moz-' + gradient);
                            alphaSliderInner.css('background', '-ms-' + gradient);
                            alphaSliderInner.css('background', 'linear-gradient(to right, ' + realAlpha + ', ' + realHex + ')');
                        }
                    }
                    displayColor = realColor.toString(format);
                }
                if (opts.showInput) {
                    textInput.val(displayColor);
                }
                if (opts.showPalette) {
                    drawPalette();
                }
                drawInitial();
            }
            function updateHelperLocations() {
                var s = currentSaturation;
                var v = currentValue;
                if (allowEmpty && isEmpty) {
                    alphaSlideHelper.hide();
                    slideHelper.hide();
                    dragHelper.hide();
                } else {
                    alphaSlideHelper.show();
                    slideHelper.show();
                    dragHelper.show();
                    var dragX = s * dragWidth;
                    var dragY = dragHeight - v * dragHeight;
                    dragX = Math.max(-dragHelperHeight, Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight));
                    dragY = Math.max(-dragHelperHeight, Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight));
                    dragHelper.css({
                        top: dragY + 'px',
                        left: dragX + 'px'
                    });
                    var alphaX = currentAlpha * alphaWidth;
                    alphaSlideHelper.css({ left: alphaX - alphaSlideHelperWidth / 2 + 'px' });
                    var slideY = currentHue * slideHeight;
                    slideHelper.css({ top: slideY - slideHelperHeight + 'px' });
                }
            }
            function updateOriginalInput(fireCallback) {
                var color = get(), displayColor = '', hasChanged = !tinycolor.equals(color, colorOnShow);
                if (color) {
                    displayColor = color.toString(currentPreferredFormat);
                    addColorToSelectionPalette(color);
                }
                if (isInput) {
                    boundElement.val(displayColor);
                }
                if (fireCallback && hasChanged) {
                    callbacks.change(color);
                    boundElement.trigger('change', [color]);
                }
            }
            function reflow() {
                if (!visible) {
                    return;
                }
                dragWidth = dragger.width();
                dragHeight = dragger.height();
                dragHelperHeight = dragHelper.height();
                slideWidth = slider.width();
                slideHeight = slider.height();
                slideHelperHeight = slideHelper.height();
                alphaWidth = alphaSlider.width();
                alphaSlideHelperWidth = alphaSlideHelper.width();
                if (!flat) {
                    container.css('position', 'absolute');
                    if (opts.offset) {
                        container.offset(opts.offset);
                    } else {
                        container.offset(getOffset(container, offsetElement));
                    }
                }
                updateHelperLocations();
                if (opts.showPalette) {
                    drawPalette();
                }
                boundElement.trigger('reflow.spectrum');
            }
            function destroy() {
                boundElement.show();
                offsetElement.unbind('click.spectrum touchstart.spectrum');
                container.remove();
                replacer.remove();
                spectrums[spect.id] = null;
            }
            function option(optionName, optionValue) {
                if (optionName === undefined) {
                    return $.extend({}, opts);
                }
                if (optionValue === undefined) {
                    return opts[optionName];
                }
                opts[optionName] = optionValue;
                if (optionName === 'preferredFormat') {
                    currentPreferredFormat = opts.preferredFormat;
                }
                applyOptions();
            }
            function enable() {
                disabled = false;
                boundElement.attr('disabled', false);
                offsetElement.removeClass('sp-disabled');
            }
            function disable() {
                hide();
                disabled = true;
                boundElement.attr('disabled', true);
                offsetElement.addClass('sp-disabled');
            }
            function setOffset(coord) {
                opts.offset = coord;
                reflow();
            }
            initialize();
            var spect = {
                show: show,
                hide: hide,
                toggle: toggle,
                reflow: reflow,
                option: option,
                enable: enable,
                disable: disable,
                offset: setOffset,
                set: function (c) {
                    set(c);
                    updateOriginalInput();
                },
                get: get,
                destroy: destroy,
                container: container
            };
            spect.id = spectrums.push(spect) - 1;
            return spect;
        }
        function getOffset(picker, input) {
            var extraY = 0;
            var dpWidth = picker.outerWidth();
            var dpHeight = picker.outerHeight();
            var inputHeight = input.outerHeight();
            var doc = picker[0].ownerDocument;
            var docElem = doc.documentElement;
            var cW = docElem.clientWidth;
            var cH = docElem.clientHeight;
            var scL = $(doc).scrollLeft();
            var scT = $(doc).scrollTop();
            var viewWidth = cW + scL;
            var viewHeight = cH + scT;
            var offset = input.offset();
            offset.top += inputHeight;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight - extraY) : extraY);
            return offset;
        }
        function noop() {
        }
        function stopPropagation(e) {
            e.stopPropagation();
        }
        function bind(func, obj) {
            var slice = Array.prototype.slice;
            var args = slice.call(arguments, 2);
            return function () {
                return func.apply(obj, args.concat(slice.call(arguments)));
            };
        }
        function draggable(element, onmove, onstart, onstop) {
            onmove = onmove || function () {
            };
            onstart = onstart || function () {
            };
            onstop = onstop || function () {
            };
            var doc = document;
            var dragging = false;
            var offset = {};
            var maxHeight = 0;
            var maxWidth = 0;
            var hasTouch = 'ontouchstart' in window;
            var duringDragEvents = {};
            duringDragEvents['selectstart'] = prevent;
            duringDragEvents['dragstart'] = prevent;
            duringDragEvents['touchmove mousemove'] = move;
            duringDragEvents['touchend mouseup'] = stop;
            function prevent(e) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                if (e.preventDefault) {
                    e.preventDefault();
                }
                e.returnValue = false;
            }
            function move(e) {
                if (dragging) {
                    if (IE && doc.documentMode < 9 && !e.button) {
                        return stop();
                    }
                    var t0 = e && e.touches && e.touches[0];
                    var pageX = t0 && t0.pageX || e.pageX;
                    var pageY = t0 && t0.pageY || e.pageY;
                    var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                    var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
                    if (hasTouch) {
                        prevent(e);
                    }
                    onmove.apply(element, [
                        dragX,
                        dragY,
                        e
                    ]);
                }
            }
            function start(e) {
                var rightclick = e.which ? e.which == 3 : e.button == 2;
                if (!rightclick && !dragging) {
                    if (onstart.apply(element, arguments) !== false) {
                        dragging = true;
                        maxHeight = $(element).height();
                        maxWidth = $(element).width();
                        offset = $(element).offset();
                        $(doc).bind(duringDragEvents);
                        $(doc.body).addClass('sp-dragging');
                        move(e);
                        prevent(e);
                    }
                }
            }
            function stop() {
                if (dragging) {
                    $(doc).unbind(duringDragEvents);
                    $(doc.body).removeClass('sp-dragging');
                    setTimeout(function () {
                        onstop.apply(element, arguments);
                    }, 0);
                }
                dragging = false;
            }
            $(element).bind('touchstart mousedown', start);
        }
        function throttle(func, wait, debounce) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var throttler = function () {
                    timeout = null;
                    func.apply(context, args);
                };
                if (debounce)
                    clearTimeout(timeout);
                if (debounce || !timeout)
                    timeout = setTimeout(throttler, wait);
            };
        }
        function inputTypeColorSupport() {
            return $.fn.spectrum.inputTypeColorSupport();
        }
        var dataID = 'spectrum.id';
        $.fn.spectrum = function (opts, extra) {
            if (typeof opts == 'string') {
                var returnValue = this;
                var args = Array.prototype.slice.call(arguments, 1);
                this.each(function () {
                    var spect = spectrums[$(this).data(dataID)];
                    if (spect) {
                        var method = spect[opts];
                        if (!method) {
                            throw new Error("Spectrum: no such method: '" + opts + "'");
                        }
                        if (opts == 'get') {
                            returnValue = spect.get();
                        } else if (opts == 'container') {
                            returnValue = spect.container;
                        } else if (opts == 'option') {
                            returnValue = spect.option.apply(spect, args);
                        } else if (opts == 'destroy') {
                            spect.destroy();
                            $(this).removeData(dataID);
                        } else {
                            method.apply(spect, args);
                        }
                    }
                });
                return returnValue;
            }
            return this.spectrum('destroy').each(function () {
                var options = $.extend({}, opts, $(this).data());
                var spect = spectrum(this, options);
                $(this).data(dataID, spect.id);
            });
        };
        $.fn.spectrum.load = true;
        $.fn.spectrum.loadOpts = {};
        $.fn.spectrum.draggable = draggable;
        $.fn.spectrum.defaults = defaultOpts;
        $.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport() {
            if (typeof inputTypeColorSupport._cachedResult === 'undefined') {
                var colorInput = $("<input type='color'/>")[0];
                inputTypeColorSupport._cachedResult = colorInput.type === 'color' && colorInput.value !== '';
            }
            return inputTypeColorSupport._cachedResult;
        };
        $.spectrum = {};
        $.spectrum.localization = {};
        $.spectrum.palettes = {};
        $.fn.spectrum.processNativeColorInputs = function () {
            var colorInputs = $('input[type=color]');
            if (colorInputs.length && !inputTypeColorSupport()) {
                colorInputs.spectrum({ preferredFormat: 'hex6' });
            }
        };
        var trimLeft = /^[\s,#]+/, trimRight = /\s+$/, tinyCounter = 0, math = Math, mathRound = math.round, mathMin = math.min, mathMax = math.max, mathRandom = math.random;
        var tinycolor = function (color, opts) {
            color = color ? color : '';
            opts = opts || {};
            if (color instanceof tinycolor) {
                return color;
            }
            if (!(this instanceof tinycolor)) {
                return new tinycolor(color, opts);
            }
            var rgb = inputToRGB(color);
            this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
            this._gradientType = opts.gradientType;
            if (this._r < 1) {
                this._r = mathRound(this._r);
            }
            if (this._g < 1) {
                this._g = mathRound(this._g);
            }
            if (this._b < 1) {
                this._b = mathRound(this._b);
            }
            this._ok = rgb.ok;
            this._tc_id = tinyCounter++;
        };
        tinycolor.prototype = {
            isDark: function () {
                return this.getBrightness() < 128;
            },
            isLight: function () {
                return !this.isDark();
            },
            isValid: function () {
                return this._ok;
            },
            getOriginalInput: function () {
                return this._originalInput;
            },
            getFormat: function () {
                return this._format;
            },
            getAlpha: function () {
                return this._a;
            },
            getBrightness: function () {
                var rgb = this.toRgb();
                return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            },
            setAlpha: function (value) {
                this._a = boundAlpha(value);
                this._roundA = mathRound(100 * this._a) / 100;
                return this;
            },
            toHsv: function () {
                var hsv = rgbToHsv(this._r, this._g, this._b);
                return {
                    h: hsv.h * 360,
                    s: hsv.s,
                    v: hsv.v,
                    a: this._a
                };
            },
            toHsvString: function () {
                var hsv = rgbToHsv(this._r, this._g, this._b);
                var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
                return this._a == 1 ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)' : 'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + this._roundA + ')';
            },
            toHsl: function () {
                var hsl = rgbToHsl(this._r, this._g, this._b);
                return {
                    h: hsl.h * 360,
                    s: hsl.s,
                    l: hsl.l,
                    a: this._a
                };
            },
            toHslString: function () {
                var hsl = rgbToHsl(this._r, this._g, this._b);
                var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
                return this._a == 1 ? 'hsl(' + h + ', ' + s + '%, ' + l + '%)' : 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + this._roundA + ')';
            },
            toHex: function (allow3Char) {
                return rgbToHex(this._r, this._g, this._b, allow3Char);
            },
            toHexString: function (allow3Char) {
                return '#' + this.toHex(allow3Char);
            },
            toHex8: function () {
                return rgbaToHex(this._r, this._g, this._b, this._a);
            },
            toHex8String: function () {
                return '#' + this.toHex8();
            },
            toRgb: function () {
                return {
                    r: mathRound(this._r),
                    g: mathRound(this._g),
                    b: mathRound(this._b),
                    a: this._a
                };
            },
            toRgbString: function () {
                return this._a == 1 ? 'rgb(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ')' : 'rgba(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ', ' + this._roundA + ')';
            },
            toPercentageRgb: function () {
                return {
                    r: mathRound(bound01(this._r, 255) * 100) + '%',
                    g: mathRound(bound01(this._g, 255) * 100) + '%',
                    b: mathRound(bound01(this._b, 255) * 100) + '%',
                    a: this._a
                };
            },
            toPercentageRgbString: function () {
                return this._a == 1 ? 'rgb(' + mathRound(bound01(this._r, 255) * 100) + '%, ' + mathRound(bound01(this._g, 255) * 100) + '%, ' + mathRound(bound01(this._b, 255) * 100) + '%)' : 'rgba(' + mathRound(bound01(this._r, 255) * 100) + '%, ' + mathRound(bound01(this._g, 255) * 100) + '%, ' + mathRound(bound01(this._b, 255) * 100) + '%, ' + this._roundA + ')';
            },
            toName: function () {
                if (this._a === 0) {
                    return 'transparent';
                }
                if (this._a < 1) {
                    return false;
                }
                return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
            },
            toFilter: function (secondColor) {
                var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
                var secondHex8String = hex8String;
                var gradientType = this._gradientType ? 'GradientType = 1, ' : '';
                if (secondColor) {
                    var s = tinycolor(secondColor);
                    secondHex8String = s.toHex8String();
                }
                return 'progid:DXImageTransform.Microsoft.gradient(' + gradientType + 'startColorstr=' + hex8String + ',endColorstr=' + secondHex8String + ')';
            },
            toString: function (format) {
                var formatSet = !!format;
                format = format || this._format;
                var formattedString = false;
                var hasAlpha = this._a < 1 && this._a >= 0;
                var needsAlphaFormat = !formatSet && hasAlpha && (format === 'hex' || format === 'hex6' || format === 'hex3' || format === 'name');
                if (needsAlphaFormat) {
                    if (format === 'name' && this._a === 0) {
                        return this.toName();
                    }
                    return this.toRgbString();
                }
                if (format === 'rgb') {
                    formattedString = this.toRgbString();
                }
                if (format === 'prgb') {
                    formattedString = this.toPercentageRgbString();
                }
                if (format === 'hex' || format === 'hex6') {
                    formattedString = this.toHexString();
                }
                if (format === 'hex3') {
                    formattedString = this.toHexString(true);
                }
                if (format === 'hex8') {
                    formattedString = this.toHex8String();
                }
                if (format === 'name') {
                    formattedString = this.toName();
                }
                if (format === 'hsl') {
                    formattedString = this.toHslString();
                }
                if (format === 'hsv') {
                    formattedString = this.toHsvString();
                }
                return formattedString || this.toHexString();
            },
            _applyModification: function (fn, args) {
                var color = fn.apply(null, [this].concat([].slice.call(args)));
                this._r = color._r;
                this._g = color._g;
                this._b = color._b;
                this.setAlpha(color._a);
                return this;
            },
            lighten: function () {
                return this._applyModification(lighten, arguments);
            },
            brighten: function () {
                return this._applyModification(brighten, arguments);
            },
            darken: function () {
                return this._applyModification(darken, arguments);
            },
            desaturate: function () {
                return this._applyModification(desaturate, arguments);
            },
            saturate: function () {
                return this._applyModification(saturate, arguments);
            },
            greyscale: function () {
                return this._applyModification(greyscale, arguments);
            },
            spin: function () {
                return this._applyModification(spin, arguments);
            },
            _applyCombination: function (fn, args) {
                return fn.apply(null, [this].concat([].slice.call(args)));
            },
            analogous: function () {
                return this._applyCombination(analogous, arguments);
            },
            complement: function () {
                return this._applyCombination(complement, arguments);
            },
            monochromatic: function () {
                return this._applyCombination(monochromatic, arguments);
            },
            splitcomplement: function () {
                return this._applyCombination(splitcomplement, arguments);
            },
            triad: function () {
                return this._applyCombination(triad, arguments);
            },
            tetrad: function () {
                return this._applyCombination(tetrad, arguments);
            }
        };
        tinycolor.fromRatio = function (color, opts) {
            if (typeof color == 'object') {
                var newColor = {};
                for (var i in color) {
                    if (color.hasOwnProperty(i)) {
                        if (i === 'a') {
                            newColor[i] = color[i];
                        } else {
                            newColor[i] = convertToPercentage(color[i]);
                        }
                    }
                }
                color = newColor;
            }
            return tinycolor(color, opts);
        };
        function inputToRGB(color) {
            var rgb = {
                r: 0,
                g: 0,
                b: 0
            };
            var a = 1;
            var ok = false;
            var format = false;
            if (typeof color == 'string') {
                color = stringInputToObject(color);
            }
            if (typeof color == 'object') {
                if (color.hasOwnProperty('r') && color.hasOwnProperty('g') && color.hasOwnProperty('b')) {
                    rgb = rgbToRgb(color.r, color.g, color.b);
                    ok = true;
                    format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
                } else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('v')) {
                    color.s = convertToPercentage(color.s);
                    color.v = convertToPercentage(color.v);
                    rgb = hsvToRgb(color.h, color.s, color.v);
                    ok = true;
                    format = 'hsv';
                } else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('l')) {
                    color.s = convertToPercentage(color.s);
                    color.l = convertToPercentage(color.l);
                    rgb = hslToRgb(color.h, color.s, color.l);
                    ok = true;
                    format = 'hsl';
                }
                if (color.hasOwnProperty('a')) {
                    a = color.a;
                }
            }
            a = boundAlpha(a);
            return {
                ok: ok,
                format: color.format || format,
                r: mathMin(255, mathMax(rgb.r, 0)),
                g: mathMin(255, mathMax(rgb.g, 0)),
                b: mathMin(255, mathMax(rgb.b, 0)),
                a: a
            };
        }
        function rgbToRgb(r, g, b) {
            return {
                r: bound01(r, 255) * 255,
                g: bound01(g, 255) * 255,
                b: bound01(b, 255) * 255
            };
        }
        function rgbToHsl(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max == min) {
                h = s = 0;
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                }
                h /= 6;
            }
            return {
                h: h,
                s: s,
                l: l
            };
        }
        function hslToRgb(h, s, l) {
            var r, g, b;
            h = bound01(h, 360);
            s = bound01(s, 100);
            l = bound01(l, 100);
            function hue2rgb(p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }
            if (s === 0) {
                r = g = b = l;
            } else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return {
                r: r * 255,
                g: g * 255,
                b: b * 255
            };
        }
        function rgbToHsv(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, v = max;
            var d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max == min) {
                h = 0;
            } else {
                switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                }
                h /= 6;
            }
            return {
                h: h,
                s: s,
                v: v
            };
        }
        function hsvToRgb(h, s, v) {
            h = bound01(h, 360) * 6;
            s = bound01(s, 100);
            v = bound01(v, 100);
            var i = math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [
                    v,
                    q,
                    p,
                    p,
                    t,
                    v
                ][mod], g = [
                    t,
                    v,
                    v,
                    q,
                    p,
                    p
                ][mod], b = [
                    p,
                    p,
                    t,
                    v,
                    v,
                    q
                ][mod];
            return {
                r: r * 255,
                g: g * 255,
                b: b * 255
            };
        }
        function rgbToHex(r, g, b, allow3Char) {
            var hex = [
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];
            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
                return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }
            return hex.join('');
        }
        function rgbaToHex(r, g, b, a) {
            var hex = [
                pad2(convertDecimalToHex(a)),
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];
            return hex.join('');
        }
        tinycolor.equals = function (color1, color2) {
            if (!color1 || !color2) {
                return false;
            }
            return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function () {
            return tinycolor.fromRatio({
                r: mathRandom(),
                g: mathRandom(),
                b: mathRandom()
            });
        };
        function desaturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
        }
        function saturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
        }
        function greyscale(color) {
            return tinycolor(color).desaturate(100);
        }
        function lighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
        }
        function brighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var rgb = tinycolor(color).toRgb();
            rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
            rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
            return tinycolor(rgb);
        }
        function darken(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
        }
        function spin(color, amount) {
            var hsl = tinycolor(color).toHsl();
            var hue = (mathRound(hsl.h) + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return tinycolor(hsl);
        }
        function complement(color) {
            var hsl = tinycolor(color).toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return tinycolor(hsl);
        }
        function triad(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({
                    h: (h + 120) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 240) % 360,
                    s: hsl.s,
                    l: hsl.l
                })
            ];
        }
        function tetrad(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({
                    h: (h + 90) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 180) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 270) % 360,
                    s: hsl.s,
                    l: hsl.l
                })
            ];
        }
        function splitcomplement(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({
                    h: (h + 72) % 360,
                    s: hsl.s,
                    l: hsl.l
                }),
                tinycolor({
                    h: (h + 216) % 360,
                    s: hsl.s,
                    l: hsl.l
                })
            ];
        }
        function analogous(color, results, slices) {
            results = results || 6;
            slices = slices || 30;
            var hsl = tinycolor(color).toHsl();
            var part = 360 / slices;
            var ret = [tinycolor(color)];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
                hsl.h = (hsl.h + part) % 360;
                ret.push(tinycolor(hsl));
            }
            return ret;
        }
        function monochromatic(color, results) {
            results = results || 6;
            var hsv = tinycolor(color).toHsv();
            var h = hsv.h, s = hsv.s, v = hsv.v;
            var ret = [];
            var modification = 1 / results;
            while (results--) {
                ret.push(tinycolor({
                    h: h,
                    s: s,
                    v: v
                }));
                v = (v + modification) % 1;
            }
            return ret;
        }
        tinycolor.mix = function (color1, color2, amount) {
            amount = amount === 0 ? 0 : amount || 50;
            var rgb1 = tinycolor(color1).toRgb();
            var rgb2 = tinycolor(color2).toRgb();
            var p = amount / 100;
            var w = p * 2 - 1;
            var a = rgb2.a - rgb1.a;
            var w1;
            if (w * a == -1) {
                w1 = w;
            } else {
                w1 = (w + a) / (1 + w * a);
            }
            w1 = (w1 + 1) / 2;
            var w2 = 1 - w1;
            var rgba = {
                r: rgb2.r * w1 + rgb1.r * w2,
                g: rgb2.g * w1 + rgb1.g * w2,
                b: rgb2.b * w1 + rgb1.b * w2,
                a: rgb2.a * p + rgb1.a * (1 - p)
            };
            return tinycolor(rgba);
        };
        tinycolor.readability = function (color1, color2) {
            var c1 = tinycolor(color1);
            var c2 = tinycolor(color2);
            var rgb1 = c1.toRgb();
            var rgb2 = c2.toRgb();
            var brightnessA = c1.getBrightness();
            var brightnessB = c2.getBrightness();
            var colorDiff = Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) + Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) + Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b);
            return {
                brightness: Math.abs(brightnessA - brightnessB),
                color: colorDiff
            };
        };
        tinycolor.isReadable = function (color1, color2) {
            var readability = tinycolor.readability(color1, color2);
            return readability.brightness > 125 && readability.color > 500;
        };
        tinycolor.mostReadable = function (baseColor, colorList) {
            var bestColor = null;
            var bestScore = 0;
            var bestIsReadable = false;
            for (var i = 0; i < colorList.length; i++) {
                var readability = tinycolor.readability(baseColor, colorList[i]);
                var readable = readability.brightness > 125 && readability.color > 500;
                var score = 3 * (readability.brightness / 125) + readability.color / 500;
                if (readable && !bestIsReadable || readable && bestIsReadable && score > bestScore || !readable && !bestIsReadable && score > bestScore) {
                    bestIsReadable = readable;
                    bestScore = score;
                    bestColor = tinycolor(colorList[i]);
                }
            }
            return bestColor;
        };
        var names = tinycolor.names = {
            aliceblue: 'f0f8ff',
            antiquewhite: 'faebd7',
            aqua: '0ff',
            aquamarine: '7fffd4',
            azure: 'f0ffff',
            beige: 'f5f5dc',
            bisque: 'ffe4c4',
            black: '000',
            blanchedalmond: 'ffebcd',
            blue: '00f',
            blueviolet: '8a2be2',
            brown: 'a52a2a',
            burlywood: 'deb887',
            burntsienna: 'ea7e5d',
            cadetblue: '5f9ea0',
            chartreuse: '7fff00',
            chocolate: 'd2691e',
            coral: 'ff7f50',
            cornflowerblue: '6495ed',
            cornsilk: 'fff8dc',
            crimson: 'dc143c',
            cyan: '0ff',
            darkblue: '00008b',
            darkcyan: '008b8b',
            darkgoldenrod: 'b8860b',
            darkgray: 'a9a9a9',
            darkgreen: '006400',
            darkgrey: 'a9a9a9',
            darkkhaki: 'bdb76b',
            darkmagenta: '8b008b',
            darkolivegreen: '556b2f',
            darkorange: 'ff8c00',
            darkorchid: '9932cc',
            darkred: '8b0000',
            darksalmon: 'e9967a',
            darkseagreen: '8fbc8f',
            darkslateblue: '483d8b',
            darkslategray: '2f4f4f',
            darkslategrey: '2f4f4f',
            darkturquoise: '00ced1',
            darkviolet: '9400d3',
            deeppink: 'ff1493',
            deepskyblue: '00bfff',
            dimgray: '696969',
            dimgrey: '696969',
            dodgerblue: '1e90ff',
            firebrick: 'b22222',
            floralwhite: 'fffaf0',
            forestgreen: '228b22',
            fuchsia: 'f0f',
            gainsboro: 'dcdcdc',
            ghostwhite: 'f8f8ff',
            gold: 'ffd700',
            goldenrod: 'daa520',
            gray: '808080',
            green: '008000',
            greenyellow: 'adff2f',
            grey: '808080',
            honeydew: 'f0fff0',
            hotpink: 'ff69b4',
            indianred: 'cd5c5c',
            indigo: '4b0082',
            ivory: 'fffff0',
            khaki: 'f0e68c',
            lavender: 'e6e6fa',
            lavenderblush: 'fff0f5',
            lawngreen: '7cfc00',
            lemonchiffon: 'fffacd',
            lightblue: 'add8e6',
            lightcoral: 'f08080',
            lightcyan: 'e0ffff',
            lightgoldenrodyellow: 'fafad2',
            lightgray: 'd3d3d3',
            lightgreen: '90ee90',
            lightgrey: 'd3d3d3',
            lightpink: 'ffb6c1',
            lightsalmon: 'ffa07a',
            lightseagreen: '20b2aa',
            lightskyblue: '87cefa',
            lightslategray: '789',
            lightslategrey: '789',
            lightsteelblue: 'b0c4de',
            lightyellow: 'ffffe0',
            lime: '0f0',
            limegreen: '32cd32',
            linen: 'faf0e6',
            magenta: 'f0f',
            maroon: '800000',
            mediumaquamarine: '66cdaa',
            mediumblue: '0000cd',
            mediumorchid: 'ba55d3',
            mediumpurple: '9370db',
            mediumseagreen: '3cb371',
            mediumslateblue: '7b68ee',
            mediumspringgreen: '00fa9a',
            mediumturquoise: '48d1cc',
            mediumvioletred: 'c71585',
            midnightblue: '191970',
            mintcream: 'f5fffa',
            mistyrose: 'ffe4e1',
            moccasin: 'ffe4b5',
            navajowhite: 'ffdead',
            navy: '000080',
            oldlace: 'fdf5e6',
            olive: '808000',
            olivedrab: '6b8e23',
            orange: 'ffa500',
            orangered: 'ff4500',
            orchid: 'da70d6',
            palegoldenrod: 'eee8aa',
            palegreen: '98fb98',
            paleturquoise: 'afeeee',
            palevioletred: 'db7093',
            papayawhip: 'ffefd5',
            peachpuff: 'ffdab9',
            peru: 'cd853f',
            pink: 'ffc0cb',
            plum: 'dda0dd',
            powderblue: 'b0e0e6',
            purple: '800080',
            rebeccapurple: '663399',
            red: 'f00',
            rosybrown: 'bc8f8f',
            royalblue: '4169e1',
            saddlebrown: '8b4513',
            salmon: 'fa8072',
            sandybrown: 'f4a460',
            seagreen: '2e8b57',
            seashell: 'fff5ee',
            sienna: 'a0522d',
            silver: 'c0c0c0',
            skyblue: '87ceeb',
            slateblue: '6a5acd',
            slategray: '708090',
            slategrey: '708090',
            snow: 'fffafa',
            springgreen: '00ff7f',
            steelblue: '4682b4',
            tan: 'd2b48c',
            teal: '008080',
            thistle: 'd8bfd8',
            tomato: 'ff6347',
            turquoise: '40e0d0',
            violet: 'ee82ee',
            wheat: 'f5deb3',
            white: 'fff',
            whitesmoke: 'f5f5f5',
            yellow: 'ff0',
            yellowgreen: '9acd32'
        };
        var hexNames = tinycolor.hexNames = flip(names);
        function flip(o) {
            var flipped = {};
            for (var i in o) {
                if (o.hasOwnProperty(i)) {
                    flipped[o[i]] = i;
                }
            }
            return flipped;
        }
        function boundAlpha(a) {
            a = parseFloat(a);
            if (isNaN(a) || a < 0 || a > 1) {
                a = 1;
            }
            return a;
        }
        function bound01(n, max) {
            if (isOnePointZero(n)) {
                n = '100%';
            }
            var processPercent = isPercentage(n);
            n = mathMin(max, mathMax(0, parseFloat(n)));
            if (processPercent) {
                n = parseInt(n * max, 10) / 100;
            }
            if (math.abs(n - max) < 0.000001) {
                return 1;
            }
            return n % max / parseFloat(max);
        }
        function clamp01(val) {
            return mathMin(1, mathMax(0, val));
        }
        function parseIntFromHex(val) {
            return parseInt(val, 16);
        }
        function isOnePointZero(n) {
            return typeof n == 'string' && n.indexOf('.') != -1 && parseFloat(n) === 1;
        }
        function isPercentage(n) {
            return typeof n === 'string' && n.indexOf('%') != -1;
        }
        function pad2(c) {
            return c.length == 1 ? '0' + c : '' + c;
        }
        function convertToPercentage(n) {
            if (n <= 1) {
                n = n * 100 + '%';
            }
            return n;
        }
        function convertDecimalToHex(d) {
            return Math.round(parseFloat(d) * 255).toString(16);
        }
        function convertHexToDecimal(h) {
            return parseIntFromHex(h) / 255;
        }
        var matchers = function () {
            var CSS_INTEGER = '[-\\+]?\\d+%?';
            var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';
            var CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';
            var PERMISSIVE_MATCH3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
            var PERMISSIVE_MATCH4 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
            return {
                rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
                rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
                hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
                hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
                hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
                hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
                hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
        }();
        function stringInputToObject(color) {
            color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
            var named = false;
            if (names[color]) {
                color = names[color];
                named = true;
            } else if (color == 'transparent') {
                return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    format: 'name'
                };
            }
            var match;
            if (match = matchers.rgb.exec(color)) {
                return {
                    r: match[1],
                    g: match[2],
                    b: match[3]
                };
            }
            if (match = matchers.rgba.exec(color)) {
                return {
                    r: match[1],
                    g: match[2],
                    b: match[3],
                    a: match[4]
                };
            }
            if (match = matchers.hsl.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    l: match[3]
                };
            }
            if (match = matchers.hsla.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    l: match[3],
                    a: match[4]
                };
            }
            if (match = matchers.hsv.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    v: match[3]
                };
            }
            if (match = matchers.hsva.exec(color)) {
                return {
                    h: match[1],
                    s: match[2],
                    v: match[3],
                    a: match[4]
                };
            }
            if (match = matchers.hex8.exec(color)) {
                return {
                    a: convertHexToDecimal(match[1]),
                    r: parseIntFromHex(match[2]),
                    g: parseIntFromHex(match[3]),
                    b: parseIntFromHex(match[4]),
                    format: named ? 'name' : 'hex8'
                };
            }
            if (match = matchers.hex6.exec(color)) {
                return {
                    r: parseIntFromHex(match[1]),
                    g: parseIntFromHex(match[2]),
                    b: parseIntFromHex(match[3]),
                    format: named ? 'name' : 'hex'
                };
            }
            if (match = matchers.hex3.exec(color)) {
                return {
                    r: parseIntFromHex(match[1] + '' + match[1]),
                    g: parseIntFromHex(match[2] + '' + match[2]),
                    b: parseIntFromHex(match[3] + '' + match[3]),
                    format: named ? 'name' : 'hex'
                };
            }
            return false;
        }
        window.tinycolor = tinycolor;
        $(function () {
            if ($.fn.spectrum.load) {
                $.fn.spectrum.processNativeColorInputs();
            }
        });
    };
});
define('domain_abstract/ui/InputColor',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/ColorPicker',
    './Input'
], function (Backbone, a, ColorPicker, Input) {
    'use strict';
    const $ = Backbone.$;
    ColorPicker($);
    return Input.extend({
        template() {
            const ppfx = this.ppfx;
            return `
      <div class="${ this.holderClass() }"></div>
      <div class="${ ppfx }field-colorp">
        <div class="${ ppfx }field-colorp-c" data-colorp-c>
          <div class="${ ppfx }checker-bg"></div>
        </div>
      </div>
    `;
        },
        inputClass() {
            const ppfx = this.ppfx;
            return `${ ppfx }field ${ ppfx }field-color`;
        },
        holderClass() {
            return `${ this.ppfx }input-holder`;
        },
        setValue(val, opts = {}) {
            const model = this.model;
            const def = model.get('defaults');
            const value = !a.isUndefined(val) ? val : !a.isUndefined(def) ? def : '';
            const inputEl = this.getInputEl();
            const colorEl = this.getColorEl();
            const valueClr = value != 'none' ? value : '';
            inputEl.value = value;
            colorEl.get(0).style.backgroundColor = valueClr;
            if (opts.fromTarget) {
                colorEl.spectrum('set', valueClr);
                this.noneColor = value == 'none';
            }
        },
        getColorEl() {
            if (!this.colorEl) {
                const self = this;
                const ppfx = this.ppfx;
                var model = this.model;
                var colorEl = $(`<div class="${ this.ppfx }field-color-picker"></div>`);
                var cpStyle = colorEl.get(0).style;
                var elToAppend = this.em && this.em.config ? this.em.config.el : '';
                var colorPickerConfig = this.em && this.em.getConfig && this.em.getConfig('colorPicker') || {};
                const getColor = color => {
                    let cl = color.getAlpha() == 1 ? color.toHexString() : color.toRgbString();
                    return cl.replace(/ /g, '');
                };
                let changed = 0;
                let previousColor;
                this.$el.find(`[data-colorp-c]`).append(colorEl);
                colorEl.spectrum({
                    containerClassName: `${ ppfx }one-bg ${ ppfx }two-color`,
                    appendTo: elToAppend || 'body',
                    maxSelectionSize: 8,
                    showPalette: true,
                    showAlpha: true,
                    chooseText: 'Ok',
                    cancelText: '\u2A2F',
                    palette: [],
                    ...colorPickerConfig,
                    move(color) {
                        const cl = getColor(color);
                        cpStyle.backgroundColor = cl;
                        model.setValueFromInput(cl, 0);
                    },
                    change(color) {
                        changed = 1;
                        const cl = getColor(color);
                        cpStyle.backgroundColor = cl;
                        model.setValueFromInput(0, 0);
                        model.setValueFromInput(cl);
                        self.noneColor = 0;
                    },
                    show(color) {
                        changed = 0;
                        previousColor = getColor(color);
                    },
                    hide(color) {
                        if (!changed && previousColor) {
                            if (self.noneColor) {
                                previousColor = '';
                            }
                            cpStyle.backgroundColor = previousColor;
                            colorEl.spectrum('set', previousColor);
                            model.setValueFromInput(previousColor, 0);
                        }
                    }
                });
                this.colorEl = colorEl;
            }
            return this.colorEl;
        },
        render() {
            Input.prototype.render.call(this);
            this.getColorEl();
            return this;
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitColorView',[
    './TraitView',
    'domain_abstract/ui/InputColor'
], function (TraitView, InputColor) {
    'use strict';
    return TraitView.extend({
        templateInput: '',
        getInputEl() {
            if (!this.input) {
                const model = this.model;
                const value = this.getModelValue();
                const inputColor = new InputColor({
                    model,
                    target: this.config.em,
                    contClass: this.ppfx + 'field-color',
                    ppfx: this.ppfx
                });
                const input = inputColor.render();
                input.setValue(value, { fromTarget: 1 });
                this.input = input.el;
            }
            return this.input;
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitButtonView',[
    'skylark-underscore',
    './TraitView'
], function (a, TraitView) {
    'use strict';
    return TraitView.extend({
        events: { 'click button': 'handleClick' },
        templateInput: '',
        handleClick() {
            const {model, em} = this;
            const command = model.get('command');
            if (command) {
                if (a.isString(command)) {
                    em.get('Commands').run(command);
                } else {
                    command(em.get('Editor'), model);
                }
            }
        },
        renderLabel() {
            if (this.model.get('label')) {
                TraitView.prototype.renderLabel.apply(this, arguments);
            }
        },
        getInputEl() {
            const {model, ppfx} = this;
            const {labelButton, text, full} = model.props();
            const label = labelButton || text;
            const className = `${ ppfx }btn`;
            const input = `<button type="button" class="${ className }-prim${ full ? ` ${ className }--full` : '' }">${ label }</button>`;
            return input;
        }
    });
});
define('skylark-grapejs/trait_manager/view/TraitsView',[
    'domain_abstract/view/DomainViews',
    './TraitView',
    './TraitSelectView',
    './TraitCheckboxView',
    './TraitNumberView',
    './TraitColorView',
    './TraitButtonView'
], function (DomainViews, TraitView, TraitSelectView, TraitCheckboxView, TraitNumberView, TraitColorView, TraitButtonView) {
    'use strict';
    return DomainViews.extend({
        ns: 'Traits',
        itemView: TraitView,
        reuseView: 1,
        itemsView: {
            text: TraitView,
            number: TraitNumberView,
            select: TraitSelectView,
            checkbox: TraitCheckboxView,
            color: TraitColorView,
            button: TraitButtonView
        },
        initialize(o = {}) {
            const config = o.config || {};
            this.config = config;
            this.em = o.editor;
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.className = this.pfx + 'traits';
            const toListen = 'component:toggled';
            this.listenTo(this.em, toListen, this.updatedCollection);
            this.updatedCollection();
        },
        updatedCollection() {
            const ppfx = this.ppfx;
            const comp = this.em.getSelected();
            this.el.className = `${ this.className } ${ ppfx }one-bg ${ ppfx }two-color`;
            this.collection = comp ? comp.get('traits') : [];
            this.render();
        }
    });
});
define('skylark-grapejs/trait_manager/index',[
    'skylark-underscore',
    './config/config',
    './view/TraitsView'
], function (a, defaultOpts, TraitsView) {
    'use strict';
    return () => {
        let c = {};
        let TraitsViewer;
        return {
            TraitsView,
            name: 'TraitManager',
            getConfig() {
                return c;
            },
            init(config = {}) {
                c = config;
                a.defaults(c, defaultOpts);
                const ppfx = c.pStylePrefix;
                ppfx && (c.stylePrefix = `${ ppfx }${ c.stylePrefix }`);
                TraitsViewer = new TraitsView({
                    collection: [],
                    editor: c.em,
                    config: c
                });
                return this;
            },
            postRender() {
                const elTo = this.getConfig().appendTo;
                if (elTo) {
                    const el = a.isElement(elTo) ? elTo : document.querySelector(elTo);
                    el.appendChild(this.render());
                }
            },
            getTraitsViewer() {
                return TraitsViewer;
            },
            addType(name, trait) {
                var itemView = TraitsViewer.itemView;
                TraitsViewer.itemsView[name] = itemView.extend(trait);
            },
            getType(name) {
                return TraitsViewer.itemsView[name];
            },
            render() {
                return TraitsViewer.render().el;
            }
        };
    };
});
define('skylark-grapejs/dom_components/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'comp-',
        wrapperId: 'wrapper',
        wrapperName: 'Body',
        wrapper: {
            removable: false,
            copyable: false,
            draggable: false,
            components: [],
            traits: [],
            stylable: [
                'background',
                'background-color',
                'background-image',
                'background-repeat',
                'background-attachment',
                'background-position',
                'background-size'
            ]
        },
        components: [],
        draggableComponents: 1,
        storeWrapper: 0,
        processor: 0,
        voidElements: [
            'area',
            'base',
            'br',
            'col',
            'embed',
            'hr',
            'img',
            'input',
            'keygen',
            'link',
            'menuitem',
            'meta',
            'param',
            'source',
            'track',
            'wbr'
        ]
    };
});
define('skylark-grapejs/dom_components/model/Components',[
    "skylark-langx/langx",
    'skylark-backbone',
    'skylark-underscore'
], function (langx,Backbone, _) {
    'use strict';
    let Component;
    return Backbone.Collection.extend({
        initialize(models, opt = {}) {
            this.opt = opt;
            this.listenTo(this, 'add', this.onAdd);
            this.config = opt.config;
            this.em = opt.em;
            const {em} = this;
            this.model = (attrs, options) => {
                var model;
                const df = opt.em.get('DomComponents').componentTypes;
                options.em = opt.em;
                options.config = opt.config;
                options.componentTypes = df;
                options.domc = opt.domc;
                for (var it = 0; it < df.length; it++) {
                    var dfId = df[it].id;
                    if (dfId == attrs.type) {
                        model = df[it].model;
                        break;
                    }
                }
                if (!model) {
                    model = df[df.length - 1].model;
                    em && attrs.type && em.logWarning(`Component type '${ attrs.type }' not found`, {
                        attrs,
                        options
                    });
                }
                return new model(attrs, options);
            };
        },
        parseString(value, opt = {}) {
            const {em} = this;
            const {domc} = this.opt;
            const cssc = em.get('CssComposer');
            const parsed = em.get('Parser').parseHtml(value);
            if (!Component)
                Component = require('./Component').default;
            Component.checkId(parsed.html, parsed.css, domc.componentsById);
            if (parsed.css && cssc && !opt.temporary) {
                cssc.addCollection(parsed.css, langx.mixin({},opt,{
                    extend: 1
                }));
            }
            return parsed.html;
        },
        add(models, opt = {}) {
            if (_.isString(models)) {
                models = this.parseString(models, opt);
            } else if (_.isArray(models)) {
                models.forEach((item, index) => {
                    if (_.isString(item)) {
                        models[index] = this.parseString(item, opt);
                    }
                });
            }
            const isMult = _.isArray(models);
            models = (isMult ? models : [models]).filter(i => i).map(model => this.processDef(model));
            models = isMult ? models : models[0];
            return Backbone.Collection.prototype.add.apply(this, [
                models,
                opt
            ]);
        },
        processDef(mdl) {
            if (mdl.cid && mdl.ccid)
                return mdl;
            const {em, config = {}} = this;
            const {processor} = config;
            let model = mdl;
            if (processor) {
                model = { ...model };
                const modelPr = processor(model);
                if (modelPr) {
                    _.each(model, (val, key) => delete model[key]);
                    _.extend(model, modelPr);
                }
            }
            if (model.$$typeof && typeof model.props == 'object') {
                model = { ...model };
                model.props = { ...model.props };
                const domc = em.get('DomComponents');
                const parser = em.get('Parser');
                const {parserHtml} = parser;
                _.each(model, (value, key) => {
                    if (!_.includes([
                            'props',
                            'type'
                        ], key))
                        delete model[key];
                });
                const {props} = model;
                const comps = props.children;
                delete props.children;
                delete model.props;
                const res = parserHtml.splitPropsFromAttr(props);
                model.attributes = res.attrs;
                if (comps) {
                    model.components = comps;
                }
                if (!model.type) {
                    model.type = 'textnode';
                } else if (!domc.getType(model.type)) {
                    model.tagName = model.type;
                    delete model.type;
                }
                _.extend(model, res.props);
            }
            return model;
        },
        onAdd(model, c, opts = {}) {
            const em = this.em;
            const style = model.getStyle();
            const avoidInline = em && em.getConfig('avoidInlineStyle');
            if (!_.isEmpty(style) && !avoidInline && em && em.get && em.getConfig('forceClass') && !opts.temporary) {
                const name = model.cid;
                const rule = em.get('CssComposer').setClassRule(name, style);
                model.setStyle({});
                model.addClass(name);
            }
        }
    });
});
define('skylark-grapejs/trait_manager/model/Trait',[
    'skylark-backbone',
    'skylark-underscore'
], function (Backbone, a) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            type: 'text',
            label: '',
            name: '',
            min: '',
            max: '',
            unit: '',
            step: 1,
            value: '',
            target: '',
            default: '',
            placeholder: '',
            changeProp: 0,
            options: []
        },
        initialize() {
            const target = this.get('target');
            const name = this.get('name');
            const changeProp = this.get('changeProp');
            if (target) {
                this.target = target;
                this.unset('target');
                const targetEvent = changeProp ? `change:${ name }` : `change:attributes:${ name }`;
                this.listenTo(target, targetEvent, this.targetUpdated);
            }
        },
        props() {
            return this.attributes;
        },
        targetUpdated() {
            const value = this.getTargetValue();
            this.set({ value }, { fromTarget: 1 });
        },
        getTargetValue() {
            const name = this.get('name');
            const target = this.target;
            let value;
            if (this.get('changeProp')) {
                value = target.get(name);
            } else {
                value = target.getAttributes()[name];
            }
            return !a.isUndefined(value) ? value : '';
        },
        setTargetValue(value, opts = {}) {
            const target = this.target;
            const name = this.get('name');
            if (a.isUndefined(value))
                return;
            let valueToSet = value;
            if (value === 'false') {
                valueToSet = false;
            } else if (value === 'true') {
                valueToSet = true;
            }
            if (this.get('changeProp')) {
                target.set(name, valueToSet, opts);
            } else {
                const attrs = { ...target.get('attributes') };
                attrs[name] = valueToSet;
                target.set('attributes', attrs, opts);
            }
        },
        setValueFromInput(value, final = 1, opts = {}) {
            const toSet = { value };
            this.set(toSet, {
                ...opts,
                avoidStore: 1
            });
            if (final) {
                this.set('value', '', opts);
                this.set(toSet, opts);
            }
        },
        getInitValue() {
            const target = this.target;
            const name = this.get('name');
            let value;
            if (target) {
                const attrs = target.get('attributes');
                value = this.get('changeProp') ? target.get(name) : attrs[name];
            }
            return value || this.get('value') || this.get('default');
        }
    });
});
define('skylark-grapejs/trait_manager/model/TraitFactory',[],function () {
    'use strict';
    return (config = {}) => ({
        build(props) {
            var objs = [];
            if (typeof props === 'string')
                props = [props];
            for (var i = 0; i < props.length; i++) {
                var obj = {};
                var prop = props[i];
                obj.name = prop;
                switch (prop) {
                case 'target':
                    obj.type = 'select';
                    break;
                }
                switch (prop) {
                case 'target':
                    obj.options = config.optionsTarget;
                    break;
                }
                objs.push(obj);
            }
            return objs;
        }
    });
});
define('skylark-grapejs/trait_manager/model/Traits',[
    'skylark-backbone',
    'skylark-underscore',
    './Trait',
    './TraitFactory'
], function (Backbone, a, Trait, TraitFactory) {
    'use strict';
    return Backbone.Collection.extend({
        model: Trait,
        initialize(coll, options = {}) {
            this.em = options.em || '';
            this.listenTo(this, 'add', this.handleAdd);
            this.listenTo(this, 'reset', this.handleReset);
        },
        handleReset(coll, {
            previousModels = []
        } = {}) {
            previousModels.forEach(model => model.trigger('remove'));
        },
        handleAdd(model) {
            const target = this.target;
            if (target) {
                model.target = target;
            }
        },
        setTarget(target) {
            this.target = target;
        },
        add(models, opt) {
            const em = this.em;
            if (a.isString(models) || a.isArray(models)) {
                const tm = em && em.get && em.get('TraitManager');
                const tmOpts = tm && tm.getConfig();
                const tf = TraitFactory(tmOpts);
                if (a.isString(models)) {
                    models = [models];
                }
                for (var i = 0, len = models.length; i < len; i++) {
                    const str = models[i];
                    const model = a.isString(str) ? tf.build(str)[0] : str;
                    model.target = this.target;
                    models[i] = model;
                }
            }
            return Backbone.Collection.prototype.add.apply(this, [
                models,
                opt
            ]);
        }
    });
});
define('skylark-grapejs/dom_components/model/Component',[
    "skylark-langx/langx",
    'skylark-underscore',
    '../../utils/mixins',
    '../../domain_abstract/model/Styleable',
    'skylark-backbone',
    './Components',
    '../../selector_manager/model/Selector',
    '../../selector_manager/model/Selectors',
    '../../trait_manager/model/Traits'
], function (langx,_, b, Styleable, Backbone, Components, Selector, Selectors, Traits) {
    'use strict';
    const componentList = {};
    let componentIndex = 0;
    const escapeRegExp = str => {
        return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
    };
    const avoidInline = em => em && em.getConfig('avoidInlineStyle');
    const eventDrag = 'component:drag';
    const Component = Backbone.Model.extend(Styleable).extend({
        defaults: {
            tagName: 'div',
            type: '',
            name: '',
            removable: true,
            draggable: true,
            droppable: true,
            badgable: true,
            stylable: true,
            'stylable-require': '',
            'style-signature': '',
            unstylable: '',
            highlightable: true,
            copyable: true,
            resizable: false,
            editable: false,
            layerable: true,
            selectable: true,
            hoverable: true,
            void: false,
            state: '',
            status: '',
            content: '',
            icon: '',
            style: '',
            classes: '',
            script: '',
            'script-export': '',
            attributes: '',
            traits: [
                'id',
                'title'
            ],
            propagate: '',
            dmode: '',
            toolbar: null
        },
        init() {
        },
        updated(property, value, previous) {
        },
        removed() {
        },
        initialize(props = {}, opt = {}) {
            const em = opt.em;
            const parent = this.parent();
            const parentAttr = parent && parent.attributes;
            if (parentAttr && parentAttr.propagate) {
                let newAttr = {};
                const toPropagate = parentAttr.propagate;
                toPropagate.undefined(prop => newAttr[prop] = parent.get(prop));
                newAttr.propagate = toPropagate;
                newAttr = langx.mixin({},newAttr,props);
                this.set(newAttr);
            }
            const propagate = this.get('propagate');
            propagate && this.set('propagate', _.isArray(propagate) ? propagate : [propagate]);
            if (opt && opt.config && opt.config.voidElements.indexOf(this.get('tagName')) >= 0) {
                this.set('void', true);
            }
            opt.em = em;
            this.opt = opt;
            this.em = em;
            this.frame = opt.frame;
            this.config = opt.config || {};
            this.set('attributes', langx.mixin({},this.defaults.attributes ,this.get('attributes') ));
            this.ccid = Component.createId(this);
            this.initClasses();
            this.initTraits();
            this.initComponents();
            this.initToolbar();
            this.listenTo(this, 'change:script', this.scriptUpdated);
            this.listenTo(this, 'change:tagName', this.tagUpdated);
            this.listenTo(this, 'change:attributes', this.attrUpdated);
            this.listenTo(this, 'change:attributes:id', this._idUpdated);
            this.set('status', '');
            this.views = [];
            [
                'classes',
                'traits',
                'components'
            ].undefined(name => {
                const events = `add remove ${ name !== 'components' ? 'change' : '' }`;
                this.listenTo(this.get(name), events.trim(), (...args) => this.emitUpdate(name, ...args));
            });
            if (!opt.temporary) {
                this.init();
                em && em.trigger('component:create', this);
            }
        },
        is(type) {
            return !!(this.get('type') == type);
        },
        props() {
            return this.attributes;
        },
        index() {
            const {collection} = this;
            return collection && collection.indexOf(this);
        },
        setDragMode(value) {
            return this.set('dmode', value);
        },
        find(query) {
            const result = [];
            const $els = this.view.$el.find(query);
            $els.each(i => {
                const $el = $els.eq(i);
                const model = $el.data('model');
                model && result.push(model);
            });
            return result;
        },
        findType(id) {
            const result = [];
            const find = components => components.undefined(item => {
                item.is(id) && result.push(item);
                find(item.components());
            });
            find(this.components());
            return result;
        },
        closest(query) {
            const result = this.view.$el.closest(query);
            return result.length && result.data('model');
        },
        tagUpdated() {
            const coll = this.collection;
            const at = coll.indexOf(this);
            coll.remove(this);
            coll.add(this, { at });
        },
        replaceWith(el) {
            const coll = this.collection;
            const at = coll.indexOf(this);
            coll.remove(this);
            return coll.add(el, { at });
        },
        attrUpdated(m, v, opts = {}) {
            const attrs = this.get('attributes');
            const classes = attrs.class;
            classes && this.setClass(classes);
            delete attrs.class;
            const style = attrs.style;
            style && this.setStyle(style);
            delete attrs.style;
            const attrPrev = { ...this.previous('attributes') };
            const diff = b.shallowDiff(attrPrev, this.get('attributes'));
            _.keys(diff).undefined(pr => this.trigger(`change:attributes:${ pr }`, this, diff[pr], opts));
        },
        setAttributes(attrs, opts = {}) {
            this.set('attributes', { ...attrs }, opts);
            return this;
        },
        addAttributes(attrs) {
            const newAttrs = {
                ...this.getAttributes(),
                ...attrs
            };
            this.setAttributes(newAttrs);
            return this;
        },
        getStyle() {
            const em = this.em;
            if (em && em.getConfig('avoidInlineStyle')) {
                const state = em.get('state');
                const cc = em.get('CssComposer');
                const rule = cc.getIdRule(this.getId(), { state });
                this.rule = rule;
                if (rule) {
                    return rule.getStyle();
                }
            }
            return Styleable.getStyle.call(this);
        },
        setStyle(prop = {}, opts = {}) {
            const em = this.em;
            const {opt} = this;
            if (em && em.getConfig('avoidInlineStyle') && !opt.temporary) {
                const style = this.get('style') || {};
                prop = _.isString(prop) ? this.parseStyle(prop) : prop;
                prop = {
                    ...prop,
                    ...style
                };
                const state = em.get('state');
                const cc = em.get('CssComposer');
                const propOrig = this.getStyle();
                this.rule = cc.setIdRule(this.getId(), prop, {
                    ...opts,
                    state
                });
                const diff = b.shallowDiff(propOrig, prop);
                this.set('style', {}, { silent: 1 });
                _.keys(diff).undefined(pr => this.trigger(`change:style:${ pr }`));
            } else {
                prop = Styleable.setStyle.apply(this, arguments);
            }
            return prop;
        },
        getAttributes() {
            const {em} = this;
            const classes = [];
            const attributes = { ...this.get('attributes') };
            const sm = em && em.get('SelectorManager');
            const id = this.getId();
            this.get('classes').undefined(cls => classes.push(_.isString(cls) ? cls : cls.get('name')));
            classes.length && (attributes.class = classes.join(' '));
            if (!_.has(attributes, 'id')) {
                let hasStyle;
                if (avoidInline(em)) {
                    hasStyle = sm && sm.get(id, sm.Selector.TYPE_ID);
                } else if (!_.isEmpty(this.getStyle())) {
                    hasStyle = 1;
                }
                if (hasStyle) {
                    attributes.id = this.getId();
                }
            }
            return attributes;
        },
        addClass(classes) {
            const added = this.em.get('SelectorManager').addClass(classes);
            return this.get('classes').add(added);
        },
        setClass(classes) {
            this.get('classes').reset();
            return this.addClass(classes);
        },
        removeClass(classes) {
            const removed = [];
            classes = _.isArray(classes) ? classes : [classes];
            const selectors = this.get('classes');
            const type = Selector.TYPE_CLASS;
            classes.undefined(classe => {
                const classes = classe.split(' ');
                classes.undefined(name => {
                    const selector = selectors.where({
                        name,
                        type
                    })[0];
                    selector && removed.push(selectors.remove(selector));
                });
            });
            return removed;
        },
        getClasses() {
            const attr = this.getAttributes();
            const classStr = attr.class;
            return classStr ? classStr.split(' ') : [];
        },
        initClasses() {
            const event = 'change:classes';
            const toListen = [
                this,
                event,
                this.initClasses
            ];
            const cls = this.get('classes') || [];
            const clsArr = _.isString(cls) ? cls.split(' ') : cls;
            this.stopListening(...toListen);
            const classes = this.normalizeClasses(clsArr);
            const selectors = new Selectors([]);
            this.set('classes', selectors);
            selectors.add(classes);
            this.listenTo(...toListen);
            return this;
        },
        initComponents() {
            const event = 'change:components';
            const toListen = [
                this,
                event,
                this.initComponents
            ];
            this.stopListening(...toListen);
            const comps = new Components(null, this.opt);
            comps.parent = this;
            const components = this.get('components');
            const addChild = !this.opt.avoidChildren;
            this.set('components', comps);
            addChild && comps.add(_.isFunction(components) ? components(this) : components);
            this.listenTo(...toListen);
            return this;
        },
        initTraits(changed) {
            const {em} = this;
            const event = 'change:traits';
            const toListen = [
                this,
                event,
                this.initTraits
            ];
            this.stopListening(...toListen);
            this.loadTraits();
            const attrs = { ...this.get('attributes') };
            const traits = this.get('traits');
            traits.each(trait => {
                if (!trait.get('changeProp')) {
                    const name = trait.get('name');
                    const value = trait.getInitValue();
                    if (name && value)
                        attrs[name] = value;
                }
            });
            traits.length && this.set('attributes', attrs);
            this.listenTo(...toListen);
            changed && em && em.trigger('component:toggled');
            return this;
        },
        append(components, opts = {}) {
            const result = this.components().add(components, opts);
            return _.isArray(result) ? result : [result];
        },
        components(components) {
            const coll = this.get('components');
            if (_.isUndefined(components)) {
                return coll;
            } else {
                coll.reset();
                return components && this.append(components);
            }
        },
        parent() {
            const coll = this.collection;
            return coll && coll.parent;
        },
        scriptUpdated() {
            this.set('scriptUpdated', 1);
        },
        initToolbar() {
            const {em} = this;
            const model = this;
            const ppfx = em && em.getConfig('stylePrefix') || '';
            if (!model.get('toolbar')) {
                var tb = [];
                if (model.collection) {
                    tb.push({
                        attributes: { class: 'fa fa-arrow-up' },
                        command: ed => ed.runCommand('core:component-exit', { force: 1 })
                    });
                }
                if (model.get('draggable')) {
                    tb.push({
                        attributes: {
                            class: `fa fa-arrows ${ ppfx }no-touch-actions`,
                            draggable: true
                        },
                        command: 'tlb-move'
                    });
                }
                if (model.get('copyable')) {
                    tb.push({
                        attributes: { class: 'fa fa-clone' },
                        command: 'tlb-clone'
                    });
                }
                if (model.get('removable')) {
                    tb.push({
                        attributes: { class: 'fa fa-trash-o' },
                        command: 'tlb-delete'
                    });
                }
                model.set('toolbar', tb);
            }
        },
        loadTraits(traits, opts = {}) {
            traits = traits || this.get('traits');
            traits = _.isFunction(traits) ? traits(this) : traits;
            if (!(traits instanceof Traits)) {
                const trt = new Traits([], this.opt);
                trt.setTarget(this);
                if (traits.length) {
                    traits.undefined(tr => tr.attributes && delete tr.attributes.value);
                    trt.add(traits);
                }
                this.set('traits', trt, opts);
            }
            return this;
        },
        getTrait(id) {
            return this.get('traits').filter(trait => {
                return trait.get('id') === id || trait.get('name') === id;
            })[0];
        },
        updateTrait(id, props) {
            const {em} = this;
            const trait = this.getTrait(id);
            trait && trait.set(props);
            em && em.trigger('component:toggled');
            return this;
        },
        getTraitIndex(id) {
            const trait = this.getTrait(id);
            return trait ? this.get('traits').indexOf(trait) : trait;
        },
        removeTrait(id) {
            const {em} = this;
            const ids = _.isArray(id) ? id : [id];
            const toRemove = ids.map(id => this.getTrait(id));
            const removed = this.get('traits').remove(toRemove);
            em && em.trigger('component:toggled');
            return removed;
        },
        addTrait(trait, opts = {}) {
            const {em} = this;
            const added = this.get('traits').add(trait, opts);
            em && em.trigger('component:toggled');
            return added;
        },
        normalizeClasses(arr) {
            var res = [];
            const em = this.em;
            if (!em)
                return;
            var clm = em.get('SelectorManager');
            if (!clm)
                return;
            arr.undefined(val => {
                var name = '';
                if (typeof val === 'string')
                    name = val;
                else
                    name = val.name;
                var model = clm.add(name);
                res.push(model);
            });
            return res;
        },
        clone() {
            const em = this.em;
            const style = this.getStyle();
            const attr = { ...this.attributes };
            const opts = { ...this.opt };
            attr.attributes = { ...attr.attributes };
            delete attr.attributes.id;
            attr.components = [];
            attr.classes = [];
            attr.traits = [];
            this.get('components').each((md, i) => {
                attr.components[i] = md.clone();
            });
            this.get('traits').each((md, i) => {
                attr.traits[i] = md.clone();
            });
            this.get('classes').each((md, i) => {
                attr.classes[i] = md.get('name');
            });
            attr.status = '';
            attr.view = '';
            opts.collection = null;
            if (em && em.getConfig('avoidInlineStyle') && !_.isEmpty(style)) {
                attr.style = style;
            }
            const cloned = new this.constructor(attr, opts);
            const event = 'component:clone';
            em && em.trigger(event, cloned);
            this.trigger(event, cloned);
            return cloned;
        },
        getName() {
            const {em} = this;
            const {type, tagName} = this.attributes;
            const cName = this.get('name');
            const isDiv = tagName == 'div';
            const tag = isDiv ? 'box' : tagName;
            const defName = type || tag;
            const nameTag = !type && tagName && !isDiv && tagName;
            const i18nPfx = 'domComponents.names.';
            const i18nName = cName && em && em.t(`${ i18nPfx }${ cName }`);
            const i18nNameTag = nameTag && em && em.t(`${ i18nPfx }${ nameTag }`);
            const i18nDefName = em && (em.t(`${ i18nPfx }${ type }`) || em.t(`${ i18nPfx }${ tagName }`));
            return this.get('custom-name') || i18nName || cName || i18nNameTag || b.capitalize(nameTag) || i18nDefName || b.capitalize(defName);
        },
        getIcon() {
            let icon = this.get('icon');
            return icon ? icon + ' ' : '';
        },
        toHTML(opts = {}) {
            const model = this;
            const attrs = [];
            const customTag = opts.tag;
            const tag = customTag || model.get('tagName');
            const sTag = model.get('void');
            const customAttr = opts.attributes;
            let attributes = this.getAttrToHTML();
            delete opts.tag;
            if (customAttr) {
                if (_.isFunction(customAttr)) {
                    attributes = customAttr(model, attributes) || {};
                } else if (_.isObject(customAttr)) {
                    attributes = customAttr;
                }
            }
            for (let attr in attributes) {
                const val = attributes[attr];
                const value = _.isString(val) ? val.replace(/"/g, '&quot;') : val;
                if (!_.isUndefined(value)) {
                    if (_.isBoolean(value)) {
                        value && attrs.push(attr);
                    } else {
                        attrs.push(`${ attr }="${ value }"`);
                    }
                }
            }
            let attrString = attrs.length ? ` ${ attrs.join(' ') }` : '';
            let code = `<${ tag }${ attrString }${ sTag ? '/' : '' }>${ model.get('content') }`;
            model.get('components').each(comp => code += comp.toHTML(opts));
            !sTag && (code += `</${ tag }>`);
            return code;
        },
        getAttrToHTML() {
            var attr = this.getAttributes();
            delete attr.style;
            return attr;
        },
        toJSON(...args) {
            const obj = Backbone.Model.prototype.toJSON.apply(this, args);
            obj.attributes = this.getAttributes();
            delete obj.attributes.class;
            delete obj.toolbar;
            delete obj.traits;
            if (this.em.getConfig('avoidDefaults')) {
                const defaults = _.result(this, 'defaults');
                _.forEach(defaults, (value, key) => {
                    if ([
                            'type',
                            'content'
                        ].indexOf(key) === -1 && obj[key] === value) {
                        delete obj[key];
                    }
                });
                if (_.isEmpty(obj.type)) {
                    delete obj.type;
                }
                _.forEach([
                    'attributes',
                    'style'
                ], prop => {
                    if (_.isEmpty(defaults[prop]) && _.isEmpty(obj[prop])) {
                        delete obj[prop];
                    }
                });
                _.forEach([
                    'classes',
                    'components'
                ], prop => {
                    if (_.isEmpty(defaults[prop]) && !obj[prop].length) {
                        delete obj[prop];
                    }
                });
            }
            return obj;
        },
        getId() {
            let attrs = this.get('attributes') || {};
            return attrs.id || this.ccid || this.cid;
        },
        setId(id, opts) {
            const attrs = { ...this.get('attributes') };
            attrs.id = id;
            this.set('attributes', attrs, opts);
            return this;
        },
        getEl(frame) {
            const view = this.getView(frame);
            return view && view.el;
        },
        getView(frame) {
            let {view, views} = this;
            if (frame) {
                view = views.filter(view => view._getFrame() === frame.view)[0];
            }
            return view;
        },
        getCurrentView() {
            const frame = (this.em.get('currentFrame') || {}).model;
            return this.getView(frame);
        },
        getScriptString(script) {
            var scr = script || this.get('script');
            if (!scr) {
                return scr;
            }
            if (typeof scr == 'function') {
                var scrStr = scr.toString().trim();
                scrStr = scrStr.replace(/^function[\s\w]*\(\)\s?\{/, '').replace(/\}$/, '');
                scr = scrStr.trim();
            }
            var config = this.em.getConfig();
            var tagVarStart = escapeRegExp(config.tagVarStart || '{[ ');
            var tagVarEnd = escapeRegExp(config.tagVarEnd || ' ]}');
            var reg = new RegExp(`${ tagVarStart }([\\w\\d-]*)${ tagVarEnd }`, 'g');
            scr = scr.replace(reg, (match, v) => {
                this.scriptUpdated();
                const result = this.attributes[v] || '';
                return _.isArray(result) || typeof result == 'object' ? JSON.stringify(result) : result;
            });
            return scr;
        },
        emitUpdate(property, ...args) {
            const em = this.em;
            const event = 'component:update' + (property ? `:${ property }` : '');
            property && this.updated(property, property && this.get(property), property && this.previous(property), ...args);
            this.trigger(event, ...args);
            em && em.trigger(event, this, ...args);
        },
        onAll(clb) {
            if (_.isFunction(clb)) {
                clb(this);
                this.components().undefined(model => model.onAll(clb));
            }
            return this;
        },
        remove() {
            const coll = this.collection;
            return coll && coll.remove(this);
        },
        resetId(opts = {}) {
            const {em} = this;
            const oldId = this.getId();
            if (!oldId)
                return;
            const newId = Component.createId(this);
            this.setId(newId);
            const rule = em && em.get('CssComposer').getIdRule(oldId);
            const selector = rule && rule.get('selectors').at(0);
            selector && selector.set('name', newId);
            return this;
        },
        _getStyleRule({id} = {}) {
            const {em} = this;
            const idS = id || this.getId();
            return em && em.get('CssComposer').getIdRule(idS);
        },
        _getStyleSelector(opts) {
            const rule = this._getStyleRule(opts);
            return rule && rule.get('selectors').at(0);
        },
        _idUpdated(m, v, opts = {}) {
            if (opts.idUpdate)
                return;
            const {ccid} = this;
            const {id} = this.get('attributes') || {};
            const idPrev = (this.previous('attributes') || {}).id || ccid;
            const list = Component.getList(this);
            if (list[id]) {
                return this.setId(idPrev, { idUpdate: 1 });
            }
            delete list[idPrev];
            list[id] = this;
            this.ccid = id;
            const selector = this._getStyleSelector({ id: idPrev });
            selector && selector.set({
                name: id,
                label: id
            });
        }
    }, {
        isComponent(el) {
            return { tagName: el.tagName ? el.tagName.toLowerCase() : '' };
        },
        createId(model) {
            const list = Component.getList(model);
            let {id} = model.get('attributes');
            let nextId;
            if (id) {
                nextId = Component.getIncrementId(id, list);
                model.setId(nextId);
            } else {
                nextId = Component.getNewId(list);
            }
            list[nextId] = model;
            return nextId;
        },
        getNewId(list) {
            const count = Object.undefined(list).length;
            const ilen = count.toString().length + 2;
            const uid = (Math.random() + 1.1).toString(36).slice(-ilen);
            let newId = `i${ uid }`;
            while (list[newId]) {
                newId = Component.getNewId(list);
            }
            return newId;
        },
        getIncrementId(id, list) {
            let counter = 1;
            let newId = id;
            while (list[newId]) {
                counter++;
                newId = `${ id }-${ counter }`;
            }
            return newId;
        },
        getList(model) {
            const domc = model.opt && model.opt.domc;
            return domc ? domc.componentsById : {};
        },
        checkId(components, styles = [], list = {}) {
            const comps = _.isArray(components) ? components : [components];
            comps.undefined(comp => {
                const {attributes = {}, components} = comp;
                const {id} = attributes;
                if (id && list[id]) {
                    const newId = Component.getIncrementId(id, list);
                    attributes.id = newId;
                    _.isArray(styles) && styles.undefined(style => {
                        const {selectors} = style;
                        selectors.undefined((sel, idx) => {
                            if (sel === `#${ id }`)
                                selectors[idx] = `#${ newId }`;
                        });
                    });
                }
                components && Component.checkId(components, styles, list);
            });
        }
    });
    
    Component.eventDrag = eventDrag;
    
    return Component;
});
define('skylark-grapejs/dom_components/view/ComponentsView',[
    'skylark-backbone',
    'skylark-underscore'
], function (Backbone, a) {
    'use strict';
    return Backbone.View.extend({
        initialize(o) {
            this.opts = o || {};
            this.config = o.config || {};
            this.em = this.config.em;
            const coll = this.collection;
            this.listenTo(coll, 'add', this.addTo);
            this.listenTo(coll, 'reset', this.resetChildren);
            this.listenTo(coll, 'remove', this.removeChildren);
        },
        removeChildren(removed, coll, opts = {}) {
            const {em} = this.config;
            const tempRemove = opts.temporary;
            removed.views.forEach(view => {
                if (!view)
                    return;
                view.remove.apply(view);
                const {childrenView, scriptContainer} = view;
                childrenView && childrenView.stopListening();
                scriptContainer && scriptContainer.remove();
            });
            removed.components().forEach(it => this.removeChildren(it, coll, opts));
            if (em && !tempRemove) {
                const id = removed.getId();
                const domc = em.get('DomComponents');
                delete domc.componentsById[id];
                const allRules = em.get('CssComposer').getAll();
                allRules.remove(allRules.filter(rule => rule.getSelectors().getFullString() === `#${ id }`));
                if (!removed.opt.temporary) {
                    const cm = em.get('Commands');
                    const hasSign = removed.get('style-signature');
                    const optStyle = { target: removed };
                    hasSign && cm.run('core:component-style-clear', optStyle);
                    removed.removed();
                    em.trigger('component:remove', removed);
                }
            }
        },
        addTo(model, coll = {}, opts = {}) {
            const em = this.config.em;
            const i = this.collection.indexOf(model);
            this.addToCollection(model, null, i);
            if (em && !opts.temporary) {
                const triggerAdd = model => {
                    em.trigger('component:add', model);
                    model.components().forEach(comp => triggerAdd(comp));
                };
                triggerAdd(model);
            }
        },
        addToCollection(model, fragmentEl, index) {
            if (!this.compView)
                this.compView = require('./ComponentView').default;
            const {config, opts, em} = this;
            const fragment = fragmentEl || null;
            const dt = opts.componentTypes || em && em.get('DomComponents').getTypes();
            const type = model.get('type');
            let viewObject = this.compView;
            for (let it = 0; it < dt.length; it++) {
                if (dt[it].id == type) {
                    viewObject = dt[it].view;
                    break;
                }
            }
            const view = new viewObject({
                model,
                config,
                componentTypes: dt
            });
            let rendered = view.render().el;
            if (fragment) {
                fragment.appendChild(rendered);
            } else {
                const parent = this.parentEl;
                const children = parent.childNodes;
                if (!a.isUndefined(index)) {
                    const lastIndex = children.length == index;
                    if (lastIndex) {
                        index--;
                    }
                    if (lastIndex || !children.length) {
                        parent.appendChild(rendered);
                    } else {
                        parent.insertBefore(rendered, children[index]);
                    }
                } else {
                    parent.appendChild(rendered);
                }
            }
            return rendered;
        },
        resetChildren() {
            this.parentEl.innerHTML = '';
            this.collection.each(model => this.addToCollection(model));
        },
        render(parent) {
            const el = this.el;
            const frag = document.createDocumentFragment();
            this.parentEl = parent || this.el;
            this.collection.each(model => this.addToCollection(model, frag));
            el.innerHTML = '';
            el.appendChild(frag);
            return this;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentView',[
    'skylark-backbone',
    'skylark-underscore',
    '../model/Components',
    './ComponentsView',
    '../../selector_manager/model/Selectors',
    '../../utils/dom',
    '../../utils/mixins'
], function (Backbone, a, Components, ComponentsView, Selectors, b, c) {
    'use strict';
    return Backbone.View.extend({
        className() {
            return this.getClasses();
        },
        tagName() {
            return this.model.get('tagName');
        },
        initialize(opt = {}) {
            const model = this.model;
            const config = opt.config || {};
            const em = config.em;
            const modelOpt = model.opt || {};
            const {$el, el} = this;
            const {draggableComponents} = config;
            this.opts = opt;
            this.modelOpt = modelOpt;
            this.config = config;
            this.em = em || '';
            this.pfx = config.stylePrefix || '';
            this.ppfx = config.pStylePrefix || '';
            this.attr = model.get('attributes');
            this.classe = this.attr.class || [];
            this.listenTo(model, 'change:style', this.updateStyle);
            this.listenTo(model, 'change:attributes change:_innertext', this.renderAttributes);
            this.listenTo(model, 'change:highlightable', this.updateHighlight);
            this.listenTo(model, 'change:status', this.updateStatus);
            this.listenTo(model, 'change:script', this.reset);
            this.listenTo(model, 'change:content', this.updateContent);
            this.listenTo(model, 'change', this.handleChange);
            this.listenTo(model, 'active', this.onActive);
            this.listenTo(model, 'disable', this.onDisable);
            $el.data('model', model);
            c.setViewEl(el, this);
            model.view = this;
            this._getFrame() && model.views.push(this);
            this.initClasses();
            this.initComponents({ avoidRender: 1 });
            this.events = {
                ...this.events,
                ...draggableComponents && { dragstart: 'handleDragStart' }
            };
            this.delegateEvents();
            !modelOpt.temporary && this.init(this._clbObj());
        },
        _clbObj() {
            const {em, model, el} = this;
            return {
                editor: em && em.getEditor(),
                model,
                el
            };
        },
        init() {
        },
        removed() {
        },
        onActive() {
        },
        onDisable() {
        },
        remove() {
            Backbone.View.prototype.remove.apply(this, arguments);
            const {model} = this;
            const frame = this._getFrame() || {};
            const frameM = frame.model;
            model.components().forEach(comp => {
                const view = comp.getView(frameM);
                view && view.remove();
            });
            const {views} = model;
            views.splice(views.indexOf(this), 1);
            this.removed(this._clbObj());
            return this;
        },
        handleDragStart(event) {
            event.preventDefault();
            event.stopPropagation();
            this.em.get('Commands').run('tlb-move', {
                target: this.model,
                event
            });
        },
        initClasses() {
            const {model} = this;
            const event = 'change:classes';
            const classes = model.get('classes');
            if (classes instanceof Selectors) {
                this.stopListening(model, event, this.initClasses);
                this.listenTo(model, event, this.initClasses);
                this.listenTo(classes, 'add remove change', this.updateClasses);
                classes.length && this.importClasses();
            }
        },
        initComponents(opts = {}) {
            const {model, $el, childrenView} = this;
            const event = 'change:components';
            const comps = model.get('components');
            const toListen = [
                model,
                event,
                this.initComponents
            ];
            if (comps instanceof Components) {
                $el.data('collection', comps);
                childrenView && childrenView.remove();
                this.stopListening(...toListen);
                !opts.avoidRender && this.renderChildren();
                this.listenTo(...toListen);
            }
        },
        handleChange() {
            const {model} = this;
            const chgArr = a.keys(model.changed);
            if (chgArr.length === 1 && chgArr[0] === 'status')
                return;
            model.emitUpdate();
            for (let prop in model.changed) {
                model.emitUpdate(prop);
            }
        },
        importClasses() {
            var clm = this.config.em.get('SelectorManager');
            if (clm) {
                this.model.get('classes').undefined(m => {
                    clm.add(m.get('name'));
                });
            }
        },
        updateStatus(opts = {}) {
            const em = this.em;
            const el = this.el;
            const status = this.model.get('status');
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            const selectedCls = `${ ppfx }selected`;
            const selectedParentCls = `${ selectedCls }-parent`;
            const freezedCls = `${ ppfx }freezed`;
            const hoveredCls = `${ ppfx }hovered`;
            const toRemove = [
                selectedCls,
                selectedParentCls,
                freezedCls,
                hoveredCls
            ];
            this.$el.removeClass(toRemove.join(' '));
            var actualCls = el.getAttribute('class') || '';
            var cls = '';
            switch (status) {
            case 'selected':
                cls = `${ actualCls } ${ selectedCls }`;
                break;
            case 'selected-parent':
                cls = `${ actualCls } ${ selectedParentCls }`;
                break;
            case 'freezed':
                cls = `${ actualCls } ${ freezedCls }`;
                break;
            case 'freezed-selected':
                cls = `${ actualCls } ${ freezedCls } ${ selectedCls }`;
                break;
            case 'hovered':
                cls = !opts.avoidHover ? `${ actualCls } ${ hoveredCls }` : '';
                break;
            }
            cls = cls.trim();
            cls && el.setAttribute('class', cls);
        },
        updateHighlight() {
            const hl = this.model.get('highlightable');
            this.setAttribute('data-highlightable', hl ? 1 : '');
        },
        updateStyle() {
            const {model, em, el} = this;
            if (em && em.getConfig('avoidInlineStyle')) {
                if (model.get('_innertext')) {
                    el.removeAttribute('id');
                } else {
                    el.id = model.getId();
                }
                const style = model.getStyle();
                !a.isEmpty(style) && model.setStyle(style);
            } else {
                this.setAttribute('style', model.styleToString());
            }
        },
        updateClasses() {
            const str = this.model.get('classes').pluck('name').join(' ');
            this.setAttribute('class', str);
            this.updateStatus();
        },
        setAttribute(name, value) {
            const el = this.$el;
            value ? el.attr(name, value) : el.removeAttr(name);
        },
        getClasses() {
            return this.model.getClasses().join(' ');
        },
        updateAttributes() {
            const attrs = [];
            const {model, $el, el, config} = this;
            const {highlightable, textable, type, _innertext} = model.attributes;
            const {draggableComponents} = config;
            const defaultAttr = {
                'data-gjs-type': type || 'default',
                ...draggableComponents && !_innertext ? { draggable: true } : {},
                ...highlightable ? { 'data-highlightable': 1 } : {},
                ...textable ? {
                    contenteditable: 'false',
                    'data-gjs-textable': 'true'
                } : {}
            };
            a.each(el.attributes, attr => attrs.push(attr.nodeName));
            attrs.forEach(attr => $el.removeAttr(attr));
            const attr = {
                ...defaultAttr,
                ...model.getAttributes()
            };
            a.keys(attr).forEach(key => attr[key] === false && delete attr[key]);
            $el.attr(attr);
            this.updateStyle();
        },
        updateContent() {
            this.getChildrenContainer().innerHTML = this.model.get('content');
        },
        prevDef(e) {
            e.preventDefault();
        },
        updateScript() {
            const {model, em} = this;
            if (!model.get('script'))
                return;
            em && em.get('Canvas').getCanvasView().updateScript(this);
        },
        getChildrenContainer() {
            var container = this.el;
            if (typeof this.getChildrenSelector == 'function') {
                container = this.el.querySelector(this.getChildrenSelector());
            } else if (typeof this.getTemplate == 'function') {
            }
            return container;
        },
        getOffsetRect() {
            const rect = {};
            const target = this.el;
            let gtop = 0;
            let gleft = 0;
            const assignRect = el => {
                const {offsetParent} = el;
                if (offsetParent) {
                    gtop += offsetParent.offsetTop;
                    gleft += offsetParent.offsetLeft;
                    assignRect(offsetParent);
                } else {
                    rect.top = target.offsetTop + gtop;
                    rect.left = target.offsetLeft + gleft;
                    rect.bottom = rect.top + target.offsetHeight;
                    rect.right = rect.left + target.offsetWidth;
                }
            };
            assignRect(target);
            return rect;
        },
        isInViewport({rect} = {}) {
            const {el} = this;
            const elDoc = el.ownerDocument;
            const {body} = elDoc;
            const {frameElement} = elDoc.defaultView;
            const {top, left} = rect || this.getOffsetRect();
            const frame = this._getFrame().getOffsetRect();
            return top >= frame.scrollTop && left >= frame.scrollLeft && top <= frame.scrollBottom && left <= frameElement.offsetWidth + body.scrollLeft;
        },
        scrollIntoView(opts = {}) {
            const rect = this.getOffsetRect();
            const isInViewport = this.isInViewport({ rect });
            if (!isInViewport || opts.force) {
                const {el} = this;
                if (opts.behavior !== 'smooth') {
                    el.ownerDocument.defaultView.scrollTo(0, rect.top);
                } else {
                    el.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        ...opts
                    });
                }
            }
        },
        reset() {
            const {el} = this;
            this.el = '';
            this._ensureElement();
            this._setData();
            b.replaceWith(el, this.el);
            this.render();
        },
        _setData() {
            const {model} = this;
            const collection = model.components();
            const view = this;
            this.$el.data({
                model,
                collection,
                view
            });
        },
        _getFrame() {
            return this.config.frameView;
        },
        renderChildren() {
            this.updateContent();
            const container = this.getChildrenContainer();
            const view = new ComponentsView({
                collection: this.model.get('components'),
                config: this.config,
                componentTypes: this.opts.componentTypes
            });
            view.render(container);
            this.childrenView = view;
            const childNodes = Array.prototype.slice.call(view.el.childNodes);
            for (var i = 0, len = childNodes.length; i < len; i++) {
                container.appendChild(childNodes.shift());
            }
        },
        renderAttributes() {
            this.updateAttributes();
            this.updateClasses();
        },
        render() {
            this.renderAttributes();
            if (this.modelOpt.temporary)
                return this;
            this.renderChildren();
            this.updateScript();
            this.postRender();
            return this;
        },
        postRender() {
            const {em, model, modelOpt} = this;
            if (!modelOpt.temporary) {
                this.onRender(this._clbObj());
                em && em.trigger('component:mount', model);
            }
        },
        onRender() {
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentTableCell',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'cell',
            tagName: 'td',
            draggable: ['tr']
        }
    }, {
        isComponent(el) {
            let result = '';
            const tag = el.tagName;
            if (tag == 'TD' || tag == 'TH') {
                result = {
                    type: 'cell',
                    tagName: tag.toLowerCase()
                };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTableCellView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({});
});
define('skylark-grapejs/dom_components/model/ComponentTableRow',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'row',
            tagName: 'tr',
            draggable: [
                'thead',
                'tbody',
                'tfoot'
            ],
            droppable: [
                'th',
                'td'
            ]
        },
        initialize(o, opt) {
            Component.prototype.initialize.apply(this, arguments);
            const cells = [];
            const components = this.get('components');
            components.each(model => model.is('cell') && cells.push(model));
            components.reset(cells);
        }
    }, {
        isComponent(el) {
            let result = '';
            if (el.tagName == 'TR') {
                result = { type: 'row' };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTableRowView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({});
});
define('skylark-grapejs/dom_components/model/ComponentTable',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'table',
            tagName: 'table',
            droppable: [
                'tbody',
                'thead',
                'tfoot'
            ]
        },
        initialize(o, opt) {
            Component.prototype.initialize.apply(this, arguments);
            const components = this.get('components');
            !components.length && components.add({ type: 'tbody' });
        }
    }, {
        isComponent(el) {
            let result = '';
            if (el.tagName == 'TABLE') {
                result = { type: 'table' };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTableView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({ events: {} });
});
define('skylark-grapejs/dom_components/model/ComponentTableBody',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'tbody',
            tagName: 'tbody',
            draggable: ['table'],
            droppable: ['tr'],
            columns: 1,
            rows: 1
        },
        initialize(o, opt) {
            Component.prototype.initialize.apply(this, arguments);
            const components = this.get('components');
            let columns = this.get('columns');
            let rows = this.get('rows');
            if (!components.length) {
                const rowsToAdd = [];
                while (rows--) {
                    const columnsToAdd = [];
                    let clm = columns;
                    while (clm--) {
                        columnsToAdd.push({
                            type: 'cell',
                            classes: ['cell']
                        });
                    }
                    rowsToAdd.push({
                        type: 'row',
                        classes: ['row'],
                        components: columnsToAdd
                    });
                }
                components.add(rowsToAdd);
            }
        }
    }, {
        isComponent(el) {
            let result = '';
            if (el.tagName == 'TBODY') {
                result = { type: 'tbody' };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentTableHead',['./ComponentTableBody'], function (ComponentTableBody) {
    'use strict';
    return ComponentTableBody.extend({
        defaults: {
            ...ComponentTableBody.prototype.defaults,
            type: 'thead',
            tagName: 'thead'
        }
    }, {
        isComponent(el) {
            let result = '';
            if (el.tagName == 'THEAD') {
                result = { type: 'thead' };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTableHeadView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({});
});
define('skylark-grapejs/dom_components/view/ComponentTableBodyView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({});
});
define('skylark-grapejs/dom_components/model/ComponentTableFoot',['./ComponentTableBody'], function (ComponentTableBody) {
    'use strict';
    return ComponentTableBody.extend({
        defaults: {
            ...ComponentTableBody.prototype.defaults,
            type: 'tfoot',
            tagName: 'tfoot'
        }
    }, {
        isComponent(el) {
            let result = '';
            if (el.tagName == 'TFOOT') {
                result = { type: 'tfoot' };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTableFootView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({});
});
define('skylark-grapejs/dom_components/model/ComponentImage',[
    "skylark-langx",
    'skylark-underscore',
    './Component'
], function (langx,_, Component) {
    'use strict';
    const svgAttrs = 'xmlns="http://www.w3.org/2000/svg" width="100" viewBox="0 0 24 24" style="fill: rgba(0,0,0,0.15); transform: scale(0.75)"';
    return Component.extend({
        defaults: langx.mixin({},Component.prototype.defaults,{
            type: 'image',
            tagName: 'img',
            void: 1,
            droppable: 0,
            editable: 1,
            highlightable: 0,
            resizable: { ratioDefault: 1 },
            traits: ['alt'],
            src: `<svg ${ svgAttrs }>
        <path d="M8.5 13.5l2.5 3 3.5-4.5 4.5 6H5m16 1V5a2 2 0 0 0-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2z"></path>
      </svg>`,
            fallback: `<svg ${ svgAttrs }>
        <path d="M2.28 3L1 4.27l2 2V19c0 1.1.9 2 2 2h12.73l2 2L21 21.72 2.28 3m2.55 0L21 19.17V5a2 2 0 0 0-2-2H4.83M8.5 13.5l2.5 3 1-1.25L14.73 18H5l3.5-4.5z"></path>
      </svg>`,
            file: ''
        }),
        initialize(o, opt) {
            Component.prototype.initialize.apply(this, arguments);
            var attr = this.get('attributes');
            if (attr.src)
                this.set('src', attr.src);
        },
        initToolbar(...args) {
            Component.prototype.initToolbar.apply(this, args);
            const em = this.em;
            if (em) {
                var cmd = em.get('Commands');
                var cmdName = 'image-editor';
                if (cmd.has(cmdName)) {
                    let hasButtonBool = false;
                    var tb = this.get('toolbar');
                    for (let i = 0; i < tb.length; i++) {
                        if (tb[i].command === 'image-editor') {
                            hasButtonBool = true;
                            break;
                        }
                    }
                    if (!hasButtonBool) {
                        tb.push({
                            attributes: { class: 'fa fa-pencil' },
                            command: cmdName
                        });
                        this.set('toolbar', tb);
                    }
                }
            }
        },
        getAttrToHTML(...args) {
            const attr = Component.prototype.getAttrToHTML.apply(this, args);
            const src = this.getSrcResult();
            if (src)
                attr.src = src;
            return attr;
        },
        getSrcResult(opt = {}) {
            const src = this.get(opt.fallback ? 'fallback' : 'src') || '';
            let result = src;
            if (src && src.substr(0, 4) === '<svg') {
                result = `data:image/svg+xml;base64,${ window.btoa(src) }`;
            }
            return result;
        },
        isDefaultSrc() {
            return this.get('src') === _.result(this, 'defaults').src;
        },
        parseUri(uri) {
            var el = document.createElement('a');
            el.href = uri;
            var query = {};
            var qrs = el.search.substring(1).split('&');
            for (var i = 0; i < qrs.length; i++) {
                var pair = qrs[i].split('=');
                var name = decodeURIComponent(pair[0]);
                if (name)
                    query[name] = decodeURIComponent(pair[1]);
            }
            return {
                hostname: el.hostname,
                pathname: el.pathname,
                protocol: el.protocol,
                search: el.search,
                hash: el.hash,
                port: el.port,
                query
            };
        }
    }, {
        isComponent(el) {
            var result = '';
            if (el.tagName == 'IMG') {
                result = { type: 'image' };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentMap',[
    './ComponentImage',
    './Component'
], function (Component, OComponent) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'map',
            src: '',
            void: 0,
            mapUrl: 'https://maps.google.com/maps',
            tagName: 'iframe',
            mapType: 'q',
            address: '',
            zoom: '1',
            attributes: { frameborder: 0 },
            toolbar: OComponent.prototype.defaults.toolbar,
            traits: [
                {
                    label: 'Address',
                    name: 'address',
                    placeholder: 'eg. London, UK',
                    changeProp: 1
                },
                {
                    type: 'select',
                    label: 'Map type',
                    name: 'mapType',
                    changeProp: 1,
                    options: [
                        {
                            value: 'q',
                            name: 'Roadmap'
                        },
                        {
                            value: 'w',
                            name: 'Satellite'
                        }
                    ]
                },
                {
                    label: 'Zoom',
                    name: 'zoom',
                    type: 'range',
                    min: '1',
                    max: '20',
                    changeProp: 1
                }
            ]
        },
        initialize(o, opt) {
            if (this.get('src'))
                this.parseFromSrc();
            else
                this.updateSrc();
            Component.prototype.initialize.apply(this, arguments);
            this.listenTo(this, 'change:address change:zoom change:mapType', this.updateSrc);
        },
        updateSrc() {
            this.set('src', this.getMapUrl());
        },
        getMapUrl() {
            var md = this;
            var addr = md.get('address');
            var zoom = md.get('zoom');
            var type = md.get('mapType');
            var size = '';
            addr = addr ? '&q=' + addr : '';
            zoom = zoom ? '&z=' + zoom : '';
            type = type ? '&t=' + type : '';
            var result = md.get('mapUrl') + '?' + addr + zoom + type;
            result += '&output=embed';
            return result;
        },
        parseFromSrc() {
            var uri = this.parseUri(this.get('src'));
            var qr = uri.query;
            if (qr.q)
                this.set('address', qr.q);
            if (qr.z)
                this.set('zoom', qr.z);
            if (qr.t)
                this.set('mapType', qr.t);
        }
    }, {
        isComponent(el) {
            var result = '';
            if (el.tagName == 'IFRAME' && /maps\.google\.com/.test(el.src)) {
                result = {
                    type: 'map',
                    src: el.src
                };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentImageView',[
    'skylark-underscore',
    './ComponentView'
], function (a, ComponentView) {
    'use strict';
    return ComponentView.extend({
        tagName: 'img',
        events: {
            dblclick: 'onActive',
            click: 'initResize',
            error: 'onError',
            dragstart: 'noDrag'
        },
        initialize(o) {
            const model = this.model;
            ComponentView.prototype.initialize.apply(this, arguments);
            this.listenTo(model, 'change:src', this.updateSrc);
            this.classEmpty = `${ this.ppfx }plh-image`;
            const config = this.config;
            config.modal && (this.modal = config.modal);
            config.am && (this.am = config.am);
            this.fetchFile();
        },
        fetchFile() {
            if (this.modelOpt.temporary)
                return;
            const model = this.model;
            const file = model.get('file');
            if (file) {
                const fu = this.em.get('AssetManager').FileUploader();
                fu.uploadFile({ dataTransfer: { files: [file] } }, res => {
                    const obj = res && res.data && res.data[0];
                    const src = obj && (a.isString(obj) ? obj : obj.src);
                    src && model.set({ src });
                });
                model.set('file', '');
            }
        },
        updateSrc() {
            const {model, classEmpty, $el} = this;
            const src = model.getSrcResult();
            const srcExists = src && !model.isDefaultSrc();
            model.addAttributes({ src });
            $el[srcExists ? 'removeClass' : 'addClass'](classEmpty);
        },
        onActive(ev) {
            ev && ev.stopPropagation();
            var em = this.opts.config.em;
            var editor = em ? em.get('Editor') : '';
            if (editor && this.model.get('editable')) {
                editor.runCommand('open-assets', {
                    target: this.model,
                    types: ['image'],
                    accept: 'image/*',
                    onSelect() {
                        editor.Modal.close();
                        editor.AssetManager.setTarget(null);
                    }
                });
            }
        },
        onError() {
            const fallback = this.model.getSrcResult({ fallback: 1 });
            if (fallback)
                this.el.src = fallback;
        },
        noDrag(ev) {
            ev.preventDefault();
            return false;
        },
        render() {
            this.renderAttributes();
            this.updateSrc();
            const {$el, model} = this;
            const cls = $el.attr('class') || '';
            !model.get('src') && $el.attr('class', `${ cls } ${ this.classEmpty }`.trim());
            this.postRender();
            return this;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentMapView',[
    'skylark-backbone',
    './ComponentImageView'
], function (Backbone, ComponentView) {
    'use strict';
    return ComponentView.extend({
        tagName: 'div',
        events: {},
        initialize(o) {
            ComponentView.prototype.initialize.apply(this, arguments);
            this.classEmpty = this.ppfx + 'plh-map';
        },
        updateSrc() {
            this.getIframe().src = this.model.get('src');
        },
        getIframe() {
            if (!this.iframe) {
                var ifrm = document.createElement('iframe');
                ifrm.src = this.model.get('src');
                ifrm.frameBorder = 0;
                ifrm.style.height = '100%';
                ifrm.style.width = '100%';
                ifrm.className = this.ppfx + 'no-pointer';
                this.iframe = ifrm;
            }
            return this.iframe;
        },
        render(...args) {
            ComponentView.prototype.render.apply(this, args);
            this.updateClasses();
            this.el.appendChild(this.getIframe());
            return this;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentText',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'text',
            droppable: false,
            editable: true
        },
        toHTML() {
            this.trigger('sync:content', { silent: 1 });
            return Component.prototype.toHTML.apply(this, arguments);
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentLink',[    
    "skylark-langx/langx",
    './ComponentText'
], function (langx,Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'link',
            tagName: 'a',
            traits: [
                'title',
                'href',
                'target'
            ]
        },
        getAttrToHTML(...args) {
            const attr = Component.prototype.getAttrToHTML.apply(this, args);
            delete attr.onmousedown;
            return attr;
        }
    }, {
        isComponent(el) {
            let result;
            let avoidEdit;
            if (el.tagName == 'A') {
                result = {
                    type: 'link',
                    editable: 0
                };
                const children = el.childNodes;
                const len = children.length;
                if (!len)
                    delete result.editable;
                for (let i = 0; i < len; i++) {
                    const child = children[i];
                    if (child.nodeType == 3 && child.textContent.trim() != '') {
                        delete result.editable;
                        break;
                    }
                }
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTextView',[
    '../../utils/mixins',
    './ComponentView'
], function (mixins, ComponentView) {
    'use strict';
    const compProt = ComponentView.prototype;
    return ComponentView.extend({
        events: {
            dblclick: 'onActive',
            input: 'onInput'
        },
        initialize(o) {
            compProt.initialize.apply(this, arguments);
            this.disableEditing = this.disableEditing.bind(this);
            const model = this.model;
            const em = this.em;
            this.listenTo(model, 'focus', this.onActive);
            this.listenTo(model, 'change:content', this.updateContentText);
            this.listenTo(model, 'sync:content', this.syncContent);
            this.rte = em && em.get('RichTextEditor');
        },
        updateContentText(m, v, opts = {}) {
            !opts.fromDisable && this.disableEditing();
        },
        onActive(e) {
            if (this.rteEnabled || !this.model.get('editable')) {
                return;
            }
            e && e.stopPropagation && e.stopPropagation();
            const {rte, em} = this;
            if (rte) {
                try {
                    this.activeRte = rte.enable(this, this.activeRte);
                } catch (err) {
                    em.logError(err);
                }
            }
            this.toggleEvents(1);
        },
        onDisable() {
            this.disableEditing();
        },
        disableEditing() {
            const {model, rte, activeRte, em} = this;
            const editable = model.get('editable');
            if (rte && editable) {
                try {
                    rte.disable(this, activeRte);
                } catch (err) {
                    em.logError(err);
                }
                this.syncContent();
            }
            this.toggleEvents();
        },
        getContent() {
            const {rte} = this;
            const {activeRte} = rte || {};
            let content = '';
            if (activeRte && typeof activeRte.getContent === 'function') {
                content = activeRte.getContent();
            } else {
                content = this.getChildrenContainer().innerHTML;
            }
            return content;
        },
        syncContent(opts = {}) {
            const {model, rte, rteEnabled} = this;
            if (!rteEnabled && !opts.force)
                return;
            const content = this.getContent();
            const comps = model.components();
            const contentOpt = {
                fromDisable: 1,
                ...opts
            };
            comps.length && comps.reset(null, opts);
            model.set('content', '', contentOpt);
            if (rte.customRte) {
                model.set('content', content, contentOpt);
            } else {
                const clean = model => {
                    const textable = !!model.get('textable');
                    const selectable = ![
                        'text',
                        'default',
                        ''
                    ].some(type => model.is(type)) || textable;
                    model.set({
                        _innertext: !selectable,
                        editable: selectable && model.get('editable'),
                        selectable: selectable,
                        hoverable: selectable,
                        removable: textable,
                        draggable: textable,
                        highlightable: 0,
                        copyable: textable,
                        ...!textable && { toolbar: '' }
                    }, opts);
                    model.get('components').each(model => clean(model));
                };
                !opts.silent && model.trigger('change:content', model, '', contentOpt);
                comps.add(content, opts);
                comps.each(model => clean(model));
                comps.trigger('resetNavigator');
            }
        },
        onInput() {
            const {em} = this;
            em && em.trigger('component:update', this.model);
        },
        disablePropagation(e) {
            e.stopPropagation();
        },
        toggleEvents(enable) {
            const {em} = this;

            const method = enable ? 'on' : 'off';
            em.setEditing(enable);
            this.rteEnabled = !!enable;
            var elDocs = [
                this.el.ownerDocument,
                document
            ];
            mixins.off(elDocs, 'mousedown', this.disableEditing);
            mixins[method](elDocs, 'mousedown', this.disableEditing);
            em[method]('toolbar:run:before', this.disableEditing);
            this.$el.off('mousedown', this.disablePropagation);
            this.$el[method]('mousedown', this.disablePropagation);
            if (this.config.draggableComponents) {
                let {el} = this;
                while (el) {
                    el.draggable = enable ? !1 : !0;
                    el = el.parentNode;
                    el && el.tagName == 'BODY' && (el = 0);
                }
            }
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentLinkView',['./ComponentTextView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({
        render(...args) {
            ComponentView.prototype.render.apply(this, args);
            this.el.addEventListener('click', this.prevDef, true);
            return this;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentLabel',[    
    "skylark-langx/langx",
    './ComponentText'
], function (langx,Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            tagName: 'label',
            traits: [
                'id',
                'title',
                'for'
            ]
        }
    }, {
        isComponent(el) {
            if (el.tagName == 'LABEL') {
                return { type: 'label' };
            }
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentLabelView',['./ComponentLinkView'], function (ComponentLinkView) {
    'use strict';
    return ComponentLinkView.extend({ tagName: 'span' });
});
define('skylark-grapejs/dom_components/model/ComponentVideo',[
    './ComponentImage',
    './Component'
], function (Component, OComponent) {
    'use strict';
    const yt = 'yt';
    const vi = 'vi';
    const ytnc = 'ytnc';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'video',
            tagName: 'video',
            videoId: '',
            void: 0,
            provider: 'so',
            ytUrl: 'https://www.youtube.com/embed/',
            ytncUrl: 'https://www.youtube-nocookie.com/embed/',
            viUrl: 'https://player.vimeo.com/video/',
            loop: 0,
            poster: '',
            muted: 0,
            autoplay: 0,
            controls: 1,
            color: '',
            rel: 1,
            modestbranding: 0,
            sources: [],
            attributes: { allowfullscreen: 'allowfullscreen' },
            toolbar: OComponent.prototype.defaults.toolbar
        },
        initialize(o, opt) {
            var traits = [];
            var prov = this.get('provider');
            switch (prov) {
            case yt:
            case ytnc:
                traits = this.getYoutubeTraits();
                break;
            case vi:
                traits = this.getVimeoTraits();
                break;
            default:
                traits = this.getSourceTraits();
            }
            if (this.get('src'))
                this.parseFromSrc();
            this.set('traits', traits);
            Component.prototype.initialize.apply(this, arguments);
            this.listenTo(this, 'change:provider', this.updateTraits);
            this.listenTo(this, 'change:videoId change:provider', this.updateSrc);
        },
        initToolbar(...args) {
            OComponent.prototype.initToolbar.apply(this, args);
        },
        parseFromSrc() {
            var prov = this.get('provider');
            var uri = this.parseUri(this.get('src'));
            var qr = uri.query;
            switch (prov) {
            case yt:
            case ytnc:
            case vi:
                var videoId = uri.pathname.split('/').pop();
                this.set('videoId', videoId);
                if (qr.autoplay)
                    this.set('autoplay', 1);
                if (qr.loop)
                    this.set('loop', 1);
                if (parseInt(qr.controls) === 0)
                    this.set('controls', 0);
                if (qr.color)
                    this.set('color', qr.color);
                if (qr.rel === '0')
                    this.set('rel', 0);
                if (qr.modestbranding === '1')
                    this.set('modestbranding', 1);
                break;
            default:
            }
        },
        updateSrc() {
            var prov = this.get('provider');
            switch (prov) {
            case yt:
                this.set('src', this.getYoutubeSrc());
                break;
            case ytnc:
                this.set('src', this.getYoutubeNoCookieSrc());
                break;
            case vi:
                this.set('src', this.getVimeoSrc());
                break;
            }
        },
        getAttrToHTML(...args) {
            var attr = Component.prototype.getAttrToHTML.apply(this, args);
            var prov = this.get('provider');
            switch (prov) {
            case yt:
            case ytnc:
            case vi:
                break;
            default:
                if (this.get('loop'))
                    attr.loop = 'loop';
                if (this.get('autoplay'))
                    attr.autoplay = 'autoplay';
                if (this.get('controls'))
                    attr.controls = 'controls';
            }
            return attr;
        },
        updateTraits() {
            var prov = this.get('provider');
            var traits = this.getSourceTraits();
            switch (prov) {
            case yt:
            case ytnc:
                this.set('tagName', 'iframe');
                traits = this.getYoutubeTraits();
                break;
            case vi:
                this.set('tagName', 'iframe');
                traits = this.getVimeoTraits();
                break;
            default:
                this.set('tagName', 'video');
            }
            this.loadTraits(traits);
            this.em.trigger('component:toggled');
        },
        getProviderTrait() {
            return {
                type: 'select',
                label: 'Provider',
                name: 'provider',
                changeProp: 1,
                options: [
                    {
                        value: 'so',
                        name: 'HTML5 Source'
                    },
                    {
                        value: yt,
                        name: 'Youtube'
                    },
                    {
                        value: ytnc,
                        name: 'Youtube (no cookie)'
                    },
                    {
                        value: vi,
                        name: 'Vimeo'
                    }
                ]
            };
        },
        getSourceTraits() {
            return [
                this.getProviderTrait(),
                {
                    label: 'Source',
                    name: 'src',
                    placeholder: 'eg. ./media/video.mp4',
                    changeProp: 1
                },
                {
                    label: 'Poster',
                    name: 'poster',
                    placeholder: 'eg. ./media/image.jpg'
                },
                this.getAutoplayTrait(),
                this.getLoopTrait(),
                this.getControlsTrait()
            ];
        },
        getYoutubeTraits() {
            return [
                this.getProviderTrait(),
                {
                    label: 'Video ID',
                    name: 'videoId',
                    placeholder: 'eg. jNQXAC9IVRw',
                    changeProp: 1
                },
                this.getAutoplayTrait(),
                this.getLoopTrait(),
                this.getControlsTrait(),
                {
                    type: 'checkbox',
                    label: 'Related',
                    name: 'rel',
                    changeProp: 1
                },
                {
                    type: 'checkbox',
                    label: 'Modest',
                    name: 'modestbranding',
                    changeProp: 1
                }
            ];
        },
        getVimeoTraits() {
            return [
                this.getProviderTrait(),
                {
                    label: 'Video ID',
                    name: 'videoId',
                    placeholder: 'eg. 123456789',
                    changeProp: 1
                },
                {
                    label: 'Color',
                    name: 'color',
                    placeholder: 'eg. FF0000',
                    changeProp: 1
                },
                this.getAutoplayTrait(),
                this.getLoopTrait()
            ];
        },
        getAutoplayTrait() {
            return {
                type: 'checkbox',
                label: 'Autoplay',
                name: 'autoplay',
                changeProp: 1
            };
        },
        getLoopTrait() {
            return {
                type: 'checkbox',
                label: 'Loop',
                name: 'loop',
                changeProp: 1
            };
        },
        getControlsTrait() {
            return {
                type: 'checkbox',
                label: 'Controls',
                name: 'controls',
                changeProp: 1
            };
        },
        getYoutubeSrc() {
            const id = this.get('videoId');
            let url = this.get('ytUrl');
            url += id + '?';
            url += this.get('autoplay') ? '&autoplay=1' : '';
            url += !this.get('controls') ? '&controls=0&showinfo=0' : '';
            url += this.get('loop') ? `&loop=1&playlist=${ id }` : '';
            url += this.get('rel') ? '' : '&rel=0';
            url += this.get('modestbranding') ? '&modestbranding=1' : '';
            return url;
        },
        getYoutubeNoCookieSrc() {
            let url = this.getYoutubeSrc();
            url = url.replace(this.get('ytUrl'), this.get('ytncUrl'));
            return url;
        },
        getVimeoSrc() {
            var url = this.get('viUrl');
            url += this.get('videoId') + '?';
            url += this.get('autoplay') ? '&autoplay=1' : '';
            url += this.get('loop') ? '&loop=1' : '';
            url += !this.get('controls') ? '&title=0&portrait=0&badge=0' : '';
            url += this.get('color') ? '&color=' + this.get('color') : '';
            return url;
        }
    }, {
        isComponent(el) {
            var result = '';
            var isYtProv = /youtube\.com\/embed/.test(el.src);
            var isYtncProv = /youtube-nocookie\.com\/embed/.test(el.src);
            var isViProv = /player\.vimeo\.com\/video/.test(el.src);
            var isExtProv = isYtProv || isYtncProv || isViProv;
            if (el.tagName == 'VIDEO' || el.tagName == 'IFRAME' && isExtProv) {
                result = { type: 'video' };
                if (el.src)
                    result.src = el.src;
                if (isExtProv) {
                    if (isYtProv)
                        result.provider = yt;
                    else if (isYtncProv)
                        result.provider = ytnc;
                    else if (isViProv)
                        result.provider = vi;
                }
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentVideoView',[
    './ComponentImageView',
    './ComponentView'
], function (ComponentView, OComponentView) {
    'use strict';
    return ComponentView.extend({
        tagName: 'div',
        events: {},
        initialize(o) {
            OComponentView.prototype.initialize.apply(this, arguments);
            const {model} = this;
            const props = [
                'loop',
                'autoplay',
                'controls',
                'color',
                'rel',
                'modestbranding',
                'poster'
            ];
            const events = props.map(p => `change:${ p }`).join(' ');
            this.listenTo(model, 'change:provider', this.updateProvider);
            this.listenTo(model, 'change:src', this.updateSrc);
            this.listenTo(model, events, this.updateVideo);
        },
        updateProvider() {
            var prov = this.model.get('provider');
            this.el.innerHTML = '';
            this.el.appendChild(this.renderByProvider(prov));
        },
        updateSrc() {
            const {model, videoEl} = this;
            if (!videoEl)
                return;
            const prov = model.get('provider');
            let src = model.get('src');
            switch (prov) {
            case 'yt':
                src = model.getYoutubeSrc();
                break;
            case 'ytnc':
                src = model.getYoutubeNoCookieSrc();
                break;
            case 'vi':
                src = model.getVimeoSrc();
                break;
            }
            videoEl.src = src;
        },
        updateVideo() {
            var prov = this.model.get('provider');
            var videoEl = this.videoEl;
            var md = this.model;
            switch (prov) {
            case 'yt':
            case 'ytnc':
            case 'vi':
                this.model.trigger('change:videoId');
                break;
            default:
                videoEl.loop = md.get('loop');
                videoEl.autoplay = md.get('autoplay');
                videoEl.controls = md.get('controls');
                videoEl.poster = md.get('poster');
            }
        },
        renderByProvider(prov) {
            var videoEl;
            switch (prov) {
            case 'yt':
                videoEl = this.renderYoutube();
                break;
            case 'ytnc':
                videoEl = this.renderYoutubeNoCookie();
                break;
            case 'vi':
                videoEl = this.renderVimeo();
                break;
            default:
                videoEl = this.renderSource();
            }
            this.videoEl = videoEl;
            return videoEl;
        },
        renderSource() {
            var el = document.createElement('video');
            el.src = this.model.get('src');
            this.initVideoEl(el);
            return el;
        },
        renderYoutube() {
            var el = document.createElement('iframe');
            el.src = this.model.getYoutubeSrc();
            el.frameBorder = 0;
            el.setAttribute('allowfullscreen', true);
            this.initVideoEl(el);
            return el;
        },
        renderYoutubeNoCookie() {
            var el = document.createElement('iframe');
            el.src = this.model.getYoutubeNoCookieSrc();
            el.frameBorder = 0;
            el.setAttribute('allowfullscreen', true);
            this.initVideoEl(el);
            return el;
        },
        renderVimeo() {
            var el = document.createElement('iframe');
            el.src = this.model.getVimeoSrc();
            el.frameBorder = 0;
            el.setAttribute('allowfullscreen', true);
            this.initVideoEl(el);
            return el;
        },
        initVideoEl(el) {
            el.className = this.ppfx + 'no-pointer';
            el.style.height = '100%';
            el.style.width = '100%';
        },
        render(...args) {
            ComponentView.prototype.render.apply(this, args);
            this.updateClasses();
            var prov = this.model.get('provider');
            this.el.appendChild(this.renderByProvider(prov));
            this.updateVideo();
            return this;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentScript',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            type: 'script',
            droppable: false,
            draggable: false,
            layerable: false
        }
    }, {
        isComponent(el) {
            if (el.tagName == 'SCRIPT') {
                var result = { type: 'script' };
                if (el.src) {
                    result.src = el.src;
                    result.onload = el.onload;
                }
                return result;
            }
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentScriptView',[
    'skylark-backbone',
    './ComponentImageView'
], function (Backbone, ComponentView) {
    'use strict';
    return ComponentView.extend({
        tagName: 'script',
        events: {},
        render() {
            var model = this.model;
            var src = model.get('src');
            var em = this.em;
            var scriptCount = em && em.get('scriptCount') ? em.get('scriptCount') : 0;
            var content = '';
            if (src) {
                var onload = model.get('onload');
                var svar = 'script' + scriptCount;
                var svarNext = 'script' + (scriptCount + 1);
                content = 'var ' + svar + " = document.createElement('script');\n" + svar + '.onload = function(){\n' + (onload ? onload + '();\n' : '') + 'typeof ' + svarNext + "Start == 'function' && " + svarNext + 'Start();\n' + '};\n' + svar + ".src = '" + src + "';\n" + 'function ' + svar + 'Start() { document.body.appendChild(' + svar + '); };\n' + (!scriptCount ? svar + 'Start();' : '');
                if (em) {
                    em.set('scriptCount', scriptCount + 1);
                }
            } else {
                content = model.get('content');
            }
            this.el.innerHTML = content;
            return this;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentSvg',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            resizable: { ratioDefault: 1 },
            highlightable: 0
        },
        getName() {
            let name = this.get('tagName');
            let customName = this.get('custom-name');
            name = name.charAt(0).toUpperCase() + name.slice(1);
            return customName || name;
        }
    }, {
        isComponent(el) {
            if (SVGElement && el instanceof SVGElement) {
                return {
                    tagName: el.tagName,
                    type: 'svg'
                };
            }
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentSvgIn',['./ComponentSvg'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            selectable: false,
            hoverable: false,
            layerable: false
        }
    }, {
        isComponent(el) {
            if (Component.isComponent(el) && el.tagName.toLowerCase() !== 'svg') {
                return {
                    tagName: el.tagName,
                    type: 'svg-in'
                };
            }
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentSvgView',['./ComponentView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({
        _createElement: function (tagName) {
            return document.createElementNS('http://www.w3.org/2000/svg', tagName);
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentTextNode',['./Component'], function (Component) {
    'use strict';
    return Component.extend({
        defaults: {
            ...Component.prototype.defaults,
            droppable: false,
            layerable: false,
            editable: true
        },
        toHTML() {
            return this.get('content').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        }
    }, {
        isComponent(el) {
            var result = '';
            if (el.nodeType === 3) {
                result = {
                    type: 'textnode',
                    content: el.textContent
                };
            }
            return result;
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentComment',[
    "skylark-langx/langx",
    './ComponentTextNode'
], function (langx,Component) {
    'use strict';
    return Component.extend({
        defaults: { ...Component.prototype.defaults },
        toHTML() {
            return `<!--${ this.get('content') }-->`;
        }
    }, {
        isComponent(el) {
            if (el.nodeType == 8) {
                return {
                    tagName: 'NULL',
                    type: 'comment',
                    content: el.textContent
                };
            }
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentTextNodeView',['skylark-backbone'], function (Backbone) {
    'use strict';
    return Backbone.View.extend({
        initialize() {
            const {$el, model} = this;
            $el.data('model', model);
            model.view = this;
        },
        _createElement() {
            return document.createTextNode(this.model.get('content'));
        }
    });
});
define('skylark-grapejs/dom_components/view/ComponentCommentView',['./ComponentTextNodeView'], function (ComponentView) {
    'use strict';
    return ComponentView.extend({
        _createElement() {
            return document.createComment(this.model.get('content'));
        }
    });
});
define('skylark-grapejs/dom_components/model/ComponentWrapper',['./Component'], function (Component) {
    'use strict';
    return Component.extend({}, {
        isComponent() {
            return false;
        }
    });
});
define('skylark-grapejs/dom_components/index',[
    'skylark-backbone',
    'skylark-underscore',
    './config/config',
    './model/Component',
    './model/Components',
    './view/ComponentView',
    './view/ComponentsView',
    './model/ComponentTableCell',
    './view/ComponentTableCellView',
    './model/ComponentTableRow',
    './view/ComponentTableRowView',
    './model/ComponentTable',
    './view/ComponentTableView',
    './model/ComponentTableHead',
    './view/ComponentTableHeadView',
    './model/ComponentTableBody',
    './view/ComponentTableBodyView',
    './model/ComponentTableFoot',
    './view/ComponentTableFootView',
    './model/ComponentMap',
    './view/ComponentMapView',
    './model/ComponentLink',
    './view/ComponentLinkView',
    './model/ComponentLabel',
    './view/ComponentLabelView',
    './model/ComponentVideo',
    './view/ComponentVideoView',
    './model/ComponentImage',
    './view/ComponentImageView',
    './model/ComponentScript',
    './view/ComponentScriptView',
    './model/ComponentSvg',
    './model/ComponentSvgIn',
    './view/ComponentSvgView',
    './model/ComponentComment',
    './view/ComponentCommentView',
    './model/ComponentTextNode',
    './view/ComponentTextNodeView',
    './model/ComponentText',
    './view/ComponentTextView',
    './model/ComponentWrapper'
], function (Backbone, _, defaults, Component, Components, ComponentView, ComponentsView, ComponentTableCell, ComponentTableCellView, ComponentTableRow, ComponentTableRowView, ComponentTable, ComponentTableView, ComponentTableHead, ComponentTableHeadView, ComponentTableBody, ComponentTableBodyView, ComponentTableFoot, ComponentTableFootView, ComponentMap, ComponentMapView, ComponentLink, ComponentLinkView, ComponentLabel, ComponentLabelView, ComponentVideo, ComponentVideoView, ComponentImage, ComponentImageView, ComponentScript, ComponentScriptView, ComponentSvg, ComponentSvgIn, ComponentSvgView, ComponentComment, ComponentCommentView, ComponentTextNode, ComponentTextNodeView, ComponentText, ComponentTextView, ComponentWrapper) {
    'use strict';
    return () => {
        var c = {};
        let em;
        const componentsById = {};
        var component, componentView;
        var componentTypes = [
            {
                id: 'cell',
                model: ComponentTableCell,
                view: ComponentTableCellView
            },
            {
                id: 'row',
                model: ComponentTableRow,
                view: ComponentTableRowView
            },
            {
                id: 'table',
                model: ComponentTable,
                view: ComponentTableView
            },
            {
                id: 'thead',
                model: ComponentTableHead,
                view: ComponentTableHeadView
            },
            {
                id: 'tbody',
                model: ComponentTableBody,
                view: ComponentTableBodyView
            },
            {
                id: 'tfoot',
                model: ComponentTableFoot,
                view: ComponentTableFootView
            },
            {
                id: 'map',
                model: ComponentMap,
                view: ComponentMapView
            },
            {
                id: 'link',
                model: ComponentLink,
                view: ComponentLinkView
            },
            {
                id: 'label',
                model: ComponentLabel,
                view: ComponentLabelView
            },
            {
                id: 'video',
                model: ComponentVideo,
                view: ComponentVideoView
            },
            {
                id: 'image',
                model: ComponentImage,
                view: ComponentImageView
            },
            {
                id: 'script',
                model: ComponentScript,
                view: ComponentScriptView
            },
            {
                id: 'svg-in',
                model: ComponentSvgIn,
                view: ComponentSvgView
            },
            {
                id: 'svg',
                model: ComponentSvg,
                view: ComponentSvgView
            },
            {
                id: 'comment',
                model: ComponentComment,
                view: ComponentCommentView
            },
            {
                id: 'textnode',
                model: ComponentTextNode,
                view: ComponentTextNodeView
            },
            {
                id: 'text',
                model: ComponentText,
                view: ComponentTextView
            },
            {
                id: 'wrapper',
                model: ComponentWrapper,
                view: ComponentView
            },
            {
                id: 'default',
                model: Component,
                view: ComponentView
            }
        ];
        return {
            Component,
            Components,
            ComponentsView,
            componentTypes,
            componentsById,
            name: 'DomComponents',
            getConfig() {
                return c;
            },
            storageKey() {
                var keys = [];
                var smc = c.stm && c.stm.getConfig() || {};
                if (smc.storeHtml)
                    keys.push('html');
                if (smc.storeComponents)
                    keys.push('components');
                return keys;
            },
            init(config) {
                c = config || {};
                em = c.em;
                this.em = em;
                if (em) {
                    c.components = em.config.components || c.components;
                }
                for (var name in defaults) {
                    if (!(name in c))
                        c[name] = defaults[name];
                }
                var ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                if (em) {
                    c.modal = em.get('Modal') || '';
                    c.am = em.get('AssetManager') || '';
                    em.get('Parser').compTypes = componentTypes;
                    em.on('change:componentHovered', this.componentHovered, this);
                    const selected = em.get('selected');
                    em.listenTo(selected, 'add', (sel, c, opts) => this.selectAdd(sel, opts));
                    em.listenTo(selected, 'remove', (sel, c, opts) => this.selectRemove(sel, opts));
                }
                let components = c.components;
                let wrapper = { ...c.wrapper };
                wrapper['custom-name'] = c.wrapperName;
                wrapper.wrapper = 1;
                wrapper.type = 'wrapper';
                if (components && components.constructor === Object && components.wrapper) {
                    wrapper = { ...components };
                    components = components.components || [];
                    wrapper.components = [];
                    if (em) {
                        em.config.components = components;
                        c.components = components;
                    }
                }
                component = new Component(wrapper, {
                    em,
                    config: c,
                    componentTypes,
                    domc: this
                });
                component.set({ attributes: { id: 'wrapper' } });
                componentView = new ComponentView({
                    model: component,
                    config: c,
                    componentTypes
                });
                return this;
            },
            onLoad() {
                this.setComponents(c.components);
            },
            postLoad(em) {
                this.handleChanges(this.getWrapper(), null, { avoidStore: 1 });
            },
            handleChanges(model, value, opts = {}) {
                const comps = model.components();
                const um = em.get('UndoManager');
                const handleUpdates = em.handleUpdates.bind(em);
                const handleChanges = this.handleChanges.bind(this);
                const handleChangesColl = this.handleChangesColl.bind(this);
                const handleRemoves = this.handleRemoves.bind(this);
                um && um.add(model);
                um && comps && um.add(comps);
                const evn = 'change:style change:content change:attributes change:src';
                [
                    [
                        model,
                        evn,
                        handleUpdates
                    ],
                    [
                        model,
                        'change:components',
                        handleChangesColl
                    ],
                    [
                        comps,
                        'add',
                        handleChanges
                    ],
                    [
                        comps,
                        'remove',
                        handleRemoves
                    ],
                    [
                        model.get('classes'),
                        'add remove',
                        handleUpdates
                    ]
                ].forEach(els => {
                    em.stopListening(els[0], els[1], els[2]);
                    em.listenTo(els[0], els[1], els[2]);
                });
                !opts.avoidStore && handleUpdates('', '', opts);
                comps.each(model => this.handleChanges(model, value, opts));
            },
            handleChangesColl(model, coll) {
                const um = em.get('UndoManager');
                if (um && coll instanceof Backbone.Collection) {
                    const handleChanges = this.handleChanges.bind(this);
                    const handleRemoves = this.handleRemoves.bind(this);
                    um.add(coll);
                    [
                        [
                            coll,
                            'add',
                            handleChanges
                        ],
                        [
                            coll,
                            'remove',
                            handleRemoves
                        ]
                    ].forEach(els => {
                        em.stopListening(els[0], els[1], els[2]);
                        em.listenTo(els[0], els[1], els[2]);
                    });
                }
            },
            handleRemoves(model, value, opts = {}) {
                !opts.avoidStore && em.handleUpdates(model, value, opts);
            },
            load(data = '') {
                const {em} = this;
                let result = '';
                if (!data && c.stm) {
                    data = c.em.getCacheLoad();
                }
                const {components, html} = data;
                if (components) {
                    if (_.isObject(components) || _.isArray(components)) {
                        result = components;
                    } else {
                        try {
                            result = JSON.parse(components);
                        } catch (err) {
                            em && em.logError(err);
                        }
                    }
                } else if (html) {
                    result = html;
                }
                const isObj = result && result.constructor === Object;
                if (result && result.length || isObj) {
                    this.clear();
                    if (isObj) {
                        this.getWrapper().set(result);
                    } else {
                        this.getComponents().add(result);
                    }
                }
                return result;
            },
            store(noStore) {
                if (!c.stm) {
                    return;
                }
                var obj = {};
                var keys = this.storageKey();
                if (keys.indexOf('html') >= 0) {
                    obj.html = c.em.getHtml();
                }
                if (keys.indexOf('components') >= 0) {
                    const {em} = this;
                    const storeWrap = c.storeWrapper;
                    const toStore = storeWrap ? this.getWrapper() : this.getComponents();
                    obj.components = JSON.stringify(toStore);
                }
                if (!noStore) {
                    c.stm.store(obj);
                }
                return obj;
            },
            getComponent() {
                return component;
            },
            getWrapper() {
                return this.getComponent();
            },
            getComponents() {
                return this.getWrapper().get('components');
            },
            addComponent(component) {
                return this.getComponents().add(component);
            },
            render() {
                return componentView.render().el;
            },
            clear() {
                this.getComponents().map(i => i).forEach(i => i.remove());
                return this;
            },
            setComponents(components) {
                this.clear().addComponent(components);
            },
            addType(type, methods) {
                const {em} = this;
                const {model = {}, view = {}, isComponent, extend, extendView, extendFn = [], extendFnView = []} = methods;
                const compType = this.getType(type);
                const extendType = this.getType(extend);
                const extendViewType = this.getType(extendView);
                const typeToExtend = extendType ? extendType : compType ? compType : this.getType('default');
                const modelToExt = typeToExtend.model;
                const viewToExt = extendViewType ? extendViewType.view : typeToExtend.view;
                const getExtendedObj = (fns, target, srcToExt) => fns.reduce((res, next) => {
                    const fn = target[next];
                    const parentFn = srcToExt.prototype[next];
                    if (fn && parentFn) {
                        res[next] = function (...args) {
                            parentFn.bind(this)(...args);
                            fn.bind(this)(...args);
                        };
                    }
                    return res;
                }, {});
                if (typeof model === 'object') {
                    methods.model = modelToExt.extend({
                        ...model,
                        ...getExtendedObj(extendFn, model, modelToExt),
                        defaults: langx.mixin({},
                            modelToExt.prototype.defaults,
                            _.result(model, 'defaults') 
                        )
                    }, { isComponent: compType && !extendType && !isComponent ? modelToExt.isComponent : isComponent || (() => 0) });
                }
                if (typeof view === 'object') {
                    methods.view = viewToExt.extend(langx.mixin({},
                        view,
                        getExtendedObj(extendFnView, view, viewToExt)
                    ));
                }
                if (compType) {
                    compType.model = methods.model;
                    compType.view = methods.view;
                } else {
                    methods.id = type;
                    componentTypes.unshift(methods);
                }
                const event = `component:type:${ compType ? 'update' : 'add' }`;
                em && em.trigger(event, compType || methods);
                return this;
            },
            getType(type) {
                var df = componentTypes;
                for (var it = 0; it < df.length; it++) {
                    var dfId = df[it].id;
                    if (dfId == type) {
                        return df[it];
                    }
                }
                return;
            },
            removeType(id) {
                const df = componentTypes;
                const type = this.getType(id);
                if (!type)
                    return;
                const index = df.indexOf(type);
                df.splice(index, 1);
                return type;
            },
            getTypes() {
                return componentTypes;
            },
            selectAdd(component, opts = {}) {
                if (component) {
                    component.set({ status: 'selected' });
                    [
                        'component:selected',
                        'component:toggled'
                    ].forEach(event => this.em.trigger(event, component, opts));
                }
            },
            selectRemove(component, opts = {}) {
                if (component) {
                    const {em} = this;
                    component.set({
                        status: '',
                        state: ''
                    });
                    [
                        'component:deselected',
                        'component:toggled'
                    ].forEach(event => this.em.trigger(event, component, opts));
                }
            },
            componentHovered() {
                const em = c.em;
                const model = em.get('componentHovered');
                const previous = em.previous('componentHovered');
                const state = 'hovered';
                previous && previous.get('status') == state && previous.set({
                    status: '',
                    state: ''
                });
                model && _.isEmpty(model.get('status')) && model.set('status', state);
            }
        };
    };
});
define('skylark-grapejs/navigator/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: '',
        appendTo: '',
        sortable: 1,
        hidable: 1,
        hideTextnode: 1,
        root: '',
        showWrapper: 1,
        showHover: 1,
        scrollCanvas: {
            behavior: 'smooth',
            block: 'nearest'
        },
        scrollLayers: {
            behavior: 'auto',
            block: 'nearest'
        },
        highlightHover: 1
    };
});
define('skylark-grapejs/navigator/view/ItemView',[
    'skylark-underscore',
    '../../utils/mixins',
    'skylark-backbone',
    '../../dom_components/view/ComponentView',
    '../../dom_components/model/Component'
], function (_, b, Backbone, ComponentView, Component) {
    'use strict';
    const inputProp = 'contentEditable';
    const $ = Backbone.$;
    let ItemsView;
    return Backbone.View.extend({
        events: {
            'mousedown [data-toggle-move]': 'startSort',
            'touchstart [data-toggle-move]': 'startSort',
            'click [data-toggle-visible]': 'toggleVisibility',
            'click [data-toggle-select]': 'handleSelect',
            'mouseover [data-toggle-select]': 'handleHover',
            'click [data-toggle-open]': 'toggleOpening',
            'dblclick [data-name]': 'handleEdit',
            'focusout [data-name]': 'handleEditEnd'
        },
        template(model) {
            const {pfx, ppfx, config, clsNoEdit} = this;
            const {hidable} = config;
            const count = this.countChildren(model);
            const addClass = !count ? this.clsNoChild : '';
            const clsTitle = `${ this.clsTitle } ${ addClass }`;
            const clsTitleC = `${ this.clsTitleC } ${ ppfx }one-bg`;
            const clsCaret = `${ this.clsCaret } fa fa-chevron-right`;
            const clsInput = `${ this.inputNameCls } ${ clsNoEdit } ${ ppfx }no-app`;
            const level = this.level + 1;
            const gut = `${ 30 + level * 10 }px`;
            const name = model.getName();
            const icon = model.getIcon();
            const clsBase = `${ pfx }layer`;
            return `
      ${ hidable ? `<i class="${ pfx }layer-vis fa fa-eye ${ this.isVisible() ? '' : 'fa-eye-slash' }" data-toggle-visible></i>` : '' }
      <div class="${ clsTitleC }">
        <div class="${ clsTitle }" style="padding-left: ${ gut }" data-toggle-select>
          <div class="${ pfx }layer-title-inn">
            <i class="${ clsCaret }" data-toggle-open></i>
            ${ icon ? `<span class="${ clsBase }__icon">${ icon }</span>` : '' }
            <span class="${ clsInput }" data-name>${ name }</span>
          </div>
        </div>
      </div>
      <div class="${ this.clsCount }" data-count>${ count || '' }</div>
      <div class="${ this.clsMove }" data-toggle-move>
        <i class="fa fa-arrows"></i>
      </div>
      <div class="${ this.clsChildren }"></div>`;
        },
        initialize(o = {}) {
            this.opt = o;
            this.level = o.level;
            this.config = o.config;
            this.em = o.config.em;
            this.ppfx = this.em.get('Config').stylePrefix;
            this.sorter = o.sorter || '';
            this.pfx = this.config.stylePrefix;
            this.parentView = o.parentView;
            const pfx = this.pfx;
            const ppfx = this.ppfx;
            const model = this.model;
            const components = model.get('components');
            const type = model.get('type') || 'default';
            model.set('open', false);
            this.listenTo(components, 'remove add reset', this.checkChildren);
            this.listenTo(model, 'change:status', this.updateStatus);
            this.listenTo(model, 'change:open', this.updateOpening);
            this.listenTo(model, 'change:layerable', this.updateLayerable);
            this.listenTo(model, 'change:style:display', this.updateVisibility);
            this.className = `${ pfx }layer ${ pfx }layer__t-${ type } no-select ${ ppfx }two-color`;
            this.inputNameCls = `${ ppfx }layer-name`;
            this.clsTitleC = `${ pfx }layer-title-c`;
            this.clsTitle = `${ pfx }layer-title`;
            this.clsCaret = `${ pfx }layer-caret`;
            this.clsCount = `${ pfx }layer-count`;
            this.clsMove = `${ pfx }layer-move`;
            this.clsChildren = `${ pfx }layer-children`;
            this.clsNoChild = `${ pfx }layer-no-chld`;
            this.clsEdit = `${ this.inputNameCls }--edit`;
            this.clsNoEdit = `${ this.inputNameCls }--no-edit`;
            this.$el.data('model', model);
            this.$el.data('collection', components);
            model.viewLayer = this;
        },
        getVisibilityEl() {
            if (!this.eyeEl) {
                this.eyeEl = this.$el.children(`.${ this.pfx }layer-vis`);
            }
            return this.eyeEl;
        },
        updateVisibility() {
            const pfx = this.pfx;
            const model = this.model;
            const hClass = `${ pfx }layer-hidden`;
            const hideIcon = 'fa-eye-slash';
            const hidden = model.getStyle().display == 'none';
            const method = hidden ? 'addClass' : 'removeClass';
            this.$el[method](hClass);
            this.getVisibilityEl()[method](hideIcon);
        },
        toggleVisibility(e) {
            e && e.stopPropagation();
            const {model} = this;
            const prevDspKey = '__prev-display';
            const prevDisplay = model.get(prevDspKey);
            const style = model.getStyle();
            const {display} = style;
            const hidden = display == 'none';
            if (hidden) {
                delete style.display;
                if (prevDisplay) {
                    style.display = prevDisplay;
                    model.unset(prevDspKey);
                }
            } else {
                display && model.set(prevDspKey, display);
                style.display = 'none';
            }
            model.setStyle(style);
        },
        handleEdit(e) {
            e && e.stopPropagation();
            const {em, $el, clsNoEdit, clsEdit} = this;
            const inputEl = this.getInputName();
            inputEl[inputProp] = true;
            inputEl.focus();
            em && em.setEditing(1);
            $el.find(`.${ this.inputNameCls }`).removeClass(clsNoEdit).addClass(clsEdit);
        },
        handleEditEnd(e) {
            e && e.stopPropagation();
            const {em, $el, clsNoEdit, clsEdit} = this;
            const inputEl = this.getInputName();
            const name = inputEl.textContent;
            inputEl.scrollLeft = 0;
            inputEl[inputProp] = false;
            this.model.set({ 'custom-name': name });
            em && em.setEditing(0);
            $el.find(`.${ this.inputNameCls }`).addClass(clsNoEdit).removeClass(clsEdit);
        },
        getInputName() {
            if (!this.inputName) {
                this.inputName = this.el.querySelector(`.${ this.inputNameCls }`);
            }
            return this.inputName;
        },
        updateOpening() {
            var opened = this.opt.opened || {};
            var model = this.model;
            const chvDown = 'fa-chevron-down';
            if (model.get('open')) {
                this.$el.addClass('open');
                this.getCaret().addClass(chvDown);
                opened[model.cid] = model;
            } else {
                this.$el.removeClass('open');
                this.getCaret().removeClass(chvDown);
                delete opened[model.cid];
            }
        },
        toggleOpening(e) {
            e.stopPropagation();
            if (!this.model.get('components').length)
                return;
            this.model.set('open', !this.model.get('open'));
        },
        handleSelect(e) {
            e.stopPropagation();
            const {em, config} = this;
            if (em) {
                const model = this.model;
                em.setSelected(model, { fromLayers: 1 });
                const scroll = config.scrollCanvas;
                scroll && model.views.forEach(view => view.scrollIntoView(scroll));
            }
        },
        handleHover(e) {
            e.stopPropagation();
            const {em, config, model} = this;
            em && config.showHover && em.setHovered(model, { fromLayers: 1 });
        },
        startSort(e) {
            e.stopPropagation();
            const {em, sorter} = this;
            if (e.button && e.button !== 0)
                return;
            if (sorter) {
                sorter.onStart = data => em.trigger(`${ Component.eventDrag }:start`, data);
                sorter.onMoveClb = data => em.trigger(Component.eventDrag, data);
                sorter.startSort(e.target);
            }
        },
        freeze() {
            this.$el.addClass(this.pfx + 'opac50');
            this.model.set('open', 0);
        },
        unfreeze() {
            this.$el.removeClass(this.pfx + 'opac50');
        },
        updateStatus(e) {
            ComponentView.prototype.updateStatus.apply(this, [{ avoidHover: !this.config.highlightHover }]);
        },
        isVisible() {
            var css = this.model.get('style'), pr = css.display;
            if (pr && pr == 'none')
                return;
            return 1;
        },
        checkChildren() {
            const {model, clsNoChild} = this;
            const count = this.countChildren(model);
            const title = this.$el.children(`.${ this.clsTitleC }`).children(`.${ this.clsTitle }`);
            let {cnt} = this;
            if (!cnt) {
                cnt = this.$el.children('[data-count]').get(0);
                this.cnt = cnt;
            }
            title[count ? 'removeClass' : 'addClass'](clsNoChild);
            if (cnt)
                cnt.innerHTML = count || '';
            !count && model.set('open', 0);
        },
        countChildren(model) {
            var count = 0;
            model.get('components').each(function (m) {
                var isCountable = this.opt.isCountable;
                var hide = this.config.hideTextnode;
                if (isCountable && !isCountable(m, hide))
                    return;
                count++;
            }, this);
            return count;
        },
        getCaret() {
            if (!this.caret || !this.caret.length) {
                const pfx = this.pfx;
                this.caret = this.$el.children(`.${ this.clsTitleC }`).find(`.${ this.clsCaret }`);
            }
            return this.caret;
        },
        setRoot(el) {
            el = _.isString(el) ? this.em.getWrapper().find(el)[0] : el;
            const model = b.getModel(el, $);
            if (!model)
                return;
            this.stopListening();
            this.model = model;
            this.initialize(this.opt);
            this.render();
        },
        updateLayerable() {
            const {parentView} = this;
            const toRerender = parentView || this;
            toRerender.render();
        },
        render() {
            const {model, config, pfx, ppfx, opt} = this;
            const {isCountable} = opt;
            const hidden = isCountable && !isCountable(model, config.hideTextnode);
            const vis = this.isVisible();
            const el = this.$el.empty();
            const level = this.level + 1;
            if (_.isUndefined(ItemsView)) {
                ItemsView = require('./ItemsView').default;
            }
            const children = new ItemsView({
                collection: model.get('components'),
                config: this.config,
                sorter: this.sorter,
                opened: this.opt.opened,
                parentView: this,
                parent: model,
                level
            }).render().$el;
            if (!this.config.showWrapper && level === 1) {
                el.append(children);
            } else {
                el.html(this.template(model));
                el.find(`.${ this.clsChildren }`).append(children);
            }
            if (!model.get('draggable') || !this.config.sortable) {
                el.children(`.${ this.clsMove }`).remove();
            }
            !vis && (this.className += ` ${ pfx }hide`);
            hidden && (this.className += ` ${ ppfx }hidden`);
            el.attr('class', this.className);
            this.updateOpening();
            this.updateStatus();
            this.updateVisibility();
            return this;
        }
    });
});
define('skylark-grapejs/navigator/index',[
    './config/config',
    './view/ItemView',
    'skylark-underscore'
], function (defaults, ItemView, a) {
    'use strict';
    return () => {
        let em;
        let layers;
        let config = {};
        return {
            name: 'LayerManager',
            init(opts = {}) {
                config = {
                    ...defaults,
                    ...opts
                };
                config.stylePrefix = opts.pStylePrefix;
                em = config.em;
                return this;
            },
            getConfig() {
                return config;
            },
            onLoad() {
                layers = new ItemView({
                    level: 0,
                    config,
                    opened: config.opened || {},
                    model: em.get('DomComponents').getWrapper()
                });
                em && em.on('component:selected', this.componentChanged);
                this.componentChanged();
            },
            postRender() {
                const elTo = config.appendTo;
                const root = config.root;
                root && this.setRoot(root);
                if (elTo) {
                    const el = a.isElement(elTo) ? elTo : document.querySelector(elTo);
                    el.appendChild(this.render());
                }
            },
            setRoot(el) {
                layers.setRoot(el);
                return this;
            },
            getRoot() {
                return layers.model;
            },
            getAll() {
                return layers;
            },
            componentChanged(selected, opts = {}) {
                if (opts.fromLayers)
                    return;
                const opened = em.get('opened');
                const model = em.getSelected();
                const scroll = config.scrollLayers;
                let parent = model && model.collection ? model.collection.parent : null;
                for (let cid in opened)
                    opened[cid].set('open', 0);
                while (parent) {
                    parent.set('open', 1);
                    opened[parent.cid] = parent;
                    parent = parent.collection ? parent.collection.parent : null;
                }
                if (model && scroll) {
                    const el = model.viewLayer && model.viewLayer.el;
                    el && el.scrollIntoView(scroll);
                }
            },
            render() {
                return layers.render().el;
            }
        };
    };
});
define('skylark-grapejs/utils/Droppable',[
    './mixins',
    'skylark-underscore'
], function (mixins, _) {
    'use strict';
    return class Droppable {
        constructor(em, rootEl) {
            this.em = em;
            const el = rootEl || em.get('Canvas').getFrames().map(frame => frame.get('root').getEl());
            const els = Array.isArray(el) ? el : [el];
            this.el = el;
            this.counter = 0;
            _.bindAll(this, 'handleDragEnter', 'handleDragOver', 'handleDrop', 'handleDragLeave');
            els.forEach(el => this.toggleEffects(el, 1));
            return this;
        }
        toggleEffects(el, enable) {

            const method = enable ? 'on' : 'off';
            mixins[method](el, 'dragenter', this.handleDragEnter);
            mixins[method](el, 'dragover', this.handleDragOver);
            mixins[method](el, 'drop', this.handleDrop);
            mixins[method](el, 'dragleave', this.handleDragLeave);
        }
        endDrop(cancel, ev) {
            const {em, dragStop} = this;
            this.counter = 0;
            this.over = 0;
            dragStop && dragStop(cancel);
            em.runDefault({ preserveSelected: 1 });
            em.trigger('canvas:dragend', ev);
        }
        handleDragLeave(ev) {
            this.updateCounter(-1, ev);
        }
        updateCounter(value, ev) {
            this.counter += value;
            this.counter === 0 && this.endDrop(1, ev);
        }
        handleDragEnter(ev) {
            const {em} = this;
            const dt = ev.dataTransfer;
            this.updateCounter(1, ev);
            if (this.over)
                return;
            this.over = 1;
            const utils = em.get('Utils');
            const canvas = em.get('Canvas');
            const container = canvas.getBody();
            let content = em.get('dragContent') || '<br>';
            let dragStop, dragContent;
            em.stopDefault();
            if (em.inAbsoluteMode()) {
                const wrapper = em.get('DomComponents').getWrapper();
                const target = wrapper.append({})[0];
                const dragger = em.get('Commands').run('core:component-drag', {
                    event: ev,
                    guidesInfo: 1,
                    center: 1,
                    target,
                    onEnd: (ev, dragger, {cancelled}) => {
                        if (!cancelled) {
                            const comp = wrapper.append(content)[0];
                            const {left, top, position} = target.getStyle();
                            comp.addStyle({
                                left,
                                top,
                                position
                            });
                            this.handleDragEnd(comp, dt);
                        }
                        target.remove();
                    }
                });
                dragStop = cancel => dragger.stop(ev, { cancel });
                dragContent = cnt => content = cnt;
            } else {
                const sorter = new utils.Sorter({
                    em,
                    wmargin: 1,
                    nested: 1,
                    canvasRelative: 1,
                    direction: 'a',
                    container,
                    placer: canvas.getPlacerEl(),
                    containerSel: '*',
                    itemSel: '*',
                    pfx: 'gjs-',
                    onEndMove: model => this.handleDragEnd(model, dt),
                    document: canvas.getFrameEl().contentDocument
                });
                sorter.setDropContent(content);
                sorter.startSort();
                this.sorter = sorter;
                dragStop = cancel => {
                    cancel && (sorter.moved = 0);
                    sorter.endMove();
                };
                dragContent = content => sorter.setDropContent(content);
            }
            this.dragStop = dragStop;
            this.dragContent = dragContent;
            em.trigger('canvas:dragenter', dt, content);
        }
        handleDragEnd(model, dt) {
            if (!model)
                return;
            const {em} = this;
            em.set('dragResult', model);
            em.trigger('canvas:drop', dt, model);
        }
        handleDragOver(ev) {
            ev.preventDefault();
            this.em.trigger('canvas:dragover', ev);
        }
        handleDrop(ev) {
            ev.preventDefault();
            const {dragContent} = this;
            const dt = ev.dataTransfer;
            const content = this.getContentByData(dt).content;
            ev.target.style.border = '';
            content && dragContent && dragContent(content);
            this.endDrop(!content, ev);
        }
        getContentByData(dataTransfer) {
            const em = this.em;
            const types = dataTransfer.types;
            const files = dataTransfer.files || [];
            const dragContent = em.get('dragContent');
            let content = dataTransfer.getData('text');
            if (files.length) {
                content = [];
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const type = file.type.split('/')[0];
                    if (type == 'image') {
                        content.push({
                            type,
                            file,
                            attributes: { alt: file.name }
                        });
                    }
                }
            } else if (dragContent) {
                content = dragContent;
            } else if (_.indexOf(types, 'text/html') >= 0) {
                content = dataTransfer.getData('text/html').replace(/<\/?meta[^>]*>/g, '');
            } else if (_.indexOf(types, 'text/uri-list') >= 0) {
                content = {
                    type: 'link',
                    attributes: { href: content },
                    content: content
                };
            } else if (_.indexOf(types, 'text/json') >= 0) {
                const json = dataTransfer.getData('text/json');
                json && (content = JSON.parse(json));
            }
            const result = { content };
            em.trigger('canvas:dragdata', dataTransfer, result);
            return result;
        }
    };
});
define('skylark-grapejs/canvas/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'cv-',
        scripts: [],
        styles: [],
        customBadgeLabel: '',
        autoscrollLimit: 50,
        notTextable: [
            'button',
            'a',
            'input[type=checkbox]',
            'input[type=radio]'
        ]
    };
});
define('skylark-grapejs/canvas/model/Frame',[
    'skylark-backbone',
    '../../dom_components/model/Component',
    '../../css_composer/model/CssRules',
    'skylark-underscore'
], function (Backbone, Component, CssRules, a) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            wrapper: '',
            width: null,
            height: null,
            head: '',
            x: 0,
            y: 0,
            root: 0,
            components: 0,
            styles: 0,
            attributes: {}
        },
        initialize(props, opts = {}) {
            const {root, styles, components} = this.attributes;
            this.set('head', []);
            this.em = opts.em;
            const modOpts = {
                em: opts.em,
                config: opts.em.get('DomComponents').getConfig(),
                frame: this
            };
            !root && this.set('root', new Component({
                type: 'wrapper',
                components: components || []
            }, modOpts));
            (!styles || a.isString(styles)) && this.set('styles', new CssRules(styles, modOpts));
        },
        remove() {
            this.view = 0;
            const coll = this.collection;
            return coll && coll.remove(this);
        },
        getHead() {
            return [...this.get('head')];
        },
        setHead(value) {
            return this.set('head', [...value]);
        },
        addHeadItem(item) {
            const head = this.getHead();
            head.push(item);
            this.setHead(head);
        },
        getHeadByAttr(attr, value, tag) {
            const head = this.getHead();
            return head.filter(item => item.attributes && item.attributes[attr] == value && (!tag || tag === item.tag))[0];
        },
        removeHeadByAttr(attr, value, tag) {
            const head = this.getHead();
            const item = this.getHeadByAttr(attr, value, tag);
            const index = head.indexOf(item);
            if (index >= 0) {
                head.splice(index, 1);
                this.setHead(head);
            }
        },
        addLink(href) {
            const tag = 'link';
            !this.getHeadByAttr('href', href, tag) && this.addHeadItem({
                tag,
                attributes: {
                    href,
                    rel: 'stylesheet'
                }
            });
        },
        removeLink(href) {
            this.removeHeadByAttr('href', href, 'link');
        },
        addScript(src) {
            const tag = 'script';
            !this.getHeadByAttr('src', src, tag) && this.addHeadItem({
                tag,
                attributes: { src }
            });
        },
        removeScript(src) {
            this.removeHeadByAttr('src', src, 'script');
        },
        _emitUpdated(data = {}) {
            this.em.trigger('frame:updated', {
                frame: this,
                ...data
            });
        }
    });
});
define('skylark-grapejs/canvas/model/Frames',[
    'skylark-underscore',
    'skylark-backbone',
    './Frame'
], function (a, Backbone, model) {
    'use strict';
    return Backbone.Collection.extend({
        model,
        initialize() {
            a.bindAll(this, 'itemLoaded');
        },
        itemLoaded() {
            this.loadedItems++;
            if (this.loadedItems >= this.itemsToLoad) {
                this.trigger('loaded:all');
                this.listenToLoadItems(0);
            }
        },
        listenToLoad() {
            this.loadedItems = 0;
            this.itemsToLoad = this.length;
            this.listenToLoadItems(1);
        },
        listenToLoadItems(on) {
            this.forEach(item => item[on ? 'on' : 'off']('loaded', this.itemLoaded));
        }
    });
});
define('skylark-grapejs/canvas/model/Canvas',[
    'skylark-backbone',
    './Frame',
    './Frames'
], function (Backbone, Frame, Frames) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            frame: '',
            frames: '',
            wrapper: '',
            rulers: false,
            zoom: 100,
            x: 0,
            y: 0
        },
        initialize(config = {}) {
            const {em} = config;
            const {styles = [], scripts = []} = config;
            const frame = new Frame({}, config);
            styles.forEach(style => frame.addLink(style));
            scripts.forEach(script => frame.addScript(script));
            this.em = em;
            this.set('frame', frame);
            this.set('frames', new Frames([frame], config));
            this.listenTo(this, 'change:zoom', this.onZoomChange);
            this.listenTo(em, 'change:device', this.updateDevice);
        },
        updateDevice() {
            const {em} = this;
            const device = em.getDeviceModel();
            const model = em.getCurrentFrameModel();
            if (model && device) {
                const {width, height} = device.attributes;
                model.set({
                    width,
                    height
                });
            }
        },
        onZoomChange() {
            const zoom = this.get('zoom');
            zoom < 1 && this.set('zoom', 1);
        }
    });
});
define('skylark-grapejs/domain_abstract/view/DomainViews',[
    'skylark-underscore',
    'skylark-backbone'
], function (a, Backbone) {
    'use strict';
    return Backbone.View.extend({
        itemView: '',
        itemsView: '',
        itemType: 'type',
        autoAdd: 0,
        initialize(opts = {}, config) {
            this.config = config || opts.config || {};
            this.autoAdd && this.listenTo(this.collection, 'add', this.addTo);
            this.init();
        },
        init() {
        },
        addTo(model) {
            this.add(model);
        },
        itemViewNotFound(type) {
            const {config, ns} = this;
            const {em} = config;
            const warn = `${ ns ? `[${ ns }]: ` : '' }'${ type }' type not found`;
            em && em.logWarning(warn);
        },
        add(model, fragment) {
            const {config, reuseView, itemsView = {}} = this;
            const inputTypes = [
                'button',
                'checkbox',
                'color',
                'date',
                'datetime-local',
                'email',
                'file',
                'hidden',
                'image',
                'month',
                'number',
                'password',
                'radio',
                'range',
                'reset',
                'search',
                'submit',
                'tel',
                'text',
                'time',
                'url',
                'week'
            ];
            var frag = fragment || null;
            var itemView = this.itemView;
            var typeField = model.get(this.itemType);
            let view;
            if (itemsView[typeField]) {
                itemView = itemsView[typeField];
            } else if (typeField && !itemsView[typeField] && !a.includes(inputTypes, typeField)) {
                this.itemViewNotFound(typeField);
            }
            if (model.view && reuseView) {
                view = model.view;
            } else {
                view = new itemView({
                    model,
                    config
                }, config);
            }
            var rendered = view.render().el;
            if (frag)
                frag.appendChild(rendered);
            else
                this.$el.append(rendered);
        },
        render() {
            var frag = document.createDocumentFragment();
            this.$el.empty();
            if (this.collection.length)
                this.collection.each(function (model) {
                    this.add(model, frag);
                }, this);
            this.$el.append(frag);
            this.onRender();
            return this;
        },
        onRender() {
        }
    });
});
define('skylark-grapejs/canvas/view/FrameView',[
    "skylark-langx/langx",
    'skylark-backbone',
    'skylark-underscore',
    '../../css_composer/view/CssRulesView',
    '../../dom_components/view/ComponentView',
    '../../utils/dom',
    '../../utils/mixins'
], function (langx,Backbone, _, CssRulesView, ComponentView, dom, mixins) {
    'use strict';
    return Backbone.View.extend({
        tagName: 'iframe',
        attributes: {
            allowfullscreen: 'allowfullscreen',
            'data-frame-el': true
        },
        initialize(o) {
            _.bindAll(this, 'updateClientY', 'stopAutoscroll', 'autoscroll', '_emitUpdate');
            const {model, el} = this;
            this.config = langx.mixin({},
                ...o.config ,{
                frameView: this
            });
            this.ppfx = this.config.pStylePrefix || '';
            this.em = this.config.em;
            this.listenTo(model, 'change:head', this.updateHead);
            model.view = this;
            mixins.setViewEl(el, this);
        },
        updateHead() {
            const headEl = this.getHead();
            dom.empty(headEl);
            dom.appendVNodes(headEl, this.model.getHead());
        },
        getEl() {
            return this.el;
        },
        getWindow() {
            return this.getEl().contentWindow;
        },
        getDoc() {
            return this.getEl().contentDocument;
        },
        getHead() {
            return this.getDoc().querySelector('head');
        },
        getBody() {
            return this.getDoc().querySelector('body');
        },
        getWrapper() {
            return this.getBody().querySelector('[data-gjs-type=wrapper]');
        },
        getJsContainer() {
            if (!this.jsContainer) {
                this.jsContainer = dom.createEl('div', { class: `${ this.ppfx }js-cont` });
            }
            return this.jsContainer;
        },
        getToolsEl() {
            const {frameWrapView} = this.config;
            return frameWrapView && frameWrapView.elTools;
        },
        getGlobalToolsEl() {
            return this.em.get('Canvas').getGlobalToolsEl();
        },
        getHighlighter() {
            return this._getTool('[data-hl]');
        },
        getBadgeEl() {
            return this._getTool('[data-badge]');
        },
        getOffsetViewerEl() {
            return this._getTool('[data-offset]');
        },
        getRect() {
            if (!this.rect) {
                this.rect = this.el.getBoundingClientRect();
            }
            return this.rect;
        },
        getOffsetRect() {
            const {el} = this;
            const {scrollTop, scrollLeft} = this.getBody();
            const height = el.offsetHeight;
            const width = el.offsetWidth;
            return {
                top: el.offsetTop,
                left: el.offsetLeft,
                height,
                width,
                scrollTop,
                scrollLeft,
                scrollBottom: scrollTop + height,
                scrollRight: scrollLeft + width
            };
        },
        _getTool(name) {
            const toolsEl = this.getToolsEl();
            if (!this[name]) {
                this[name] = toolsEl.querySelector(name);
            }
            return this[name];
        },
        remove() {
            const {root, model} = this;
            this._toggleEffects();
            Backbone.View.prototype.remove.apply(this, arguments);
            root.remove();
            model.remove();
        },
        startAutoscroll() {
            this.lastMaxHeight = this.getWrapper().offsetHeight - this.el.offsetHeight;
            setTimeout(() => {
                this._toggleAutoscrollFx(1);
                requestAnimationFrame(this.autoscroll);
            }, 0);
        },
        autoscroll() {
            if (this.dragging) {
                const canvas = this.em.get('Canvas');
                const win = this.getWindow();
                const body = this.getBody();
                const actualTop = body.scrollTop;
                const clientY = this.lastClientY || 0;
                const limitTop = canvas.getConfig().autoscrollLimit;
                const limitBottom = this.getRect().height - limitTop;
                let nextTop = actualTop;
                if (clientY < limitTop) {
                    nextTop -= limitTop - clientY;
                }
                if (clientY > limitBottom) {
                    nextTop += clientY - limitBottom;
                }
                if (nextTop !== actualTop && nextTop > 0 && nextTop < this.lastMaxHeight) {
                    const toolsEl = this.getGlobalToolsEl();
                    toolsEl.style.opacity = 0;
                    this.showGlobalTools();
                    win.scrollTo(0, nextTop);
                }
                requestAnimationFrame(this.autoscroll);
            }
        },
        updateClientY(ev) {
            ev.preventDefault();
            this.lastClientY = mixins.getPointerEvent(ev).clientY * this.em.getZoomDecimal();
        },
        showGlobalTools: _.debounce(function () {
            this.getGlobalToolsEl().style.opacity = '';
        }, 50),
        stopAutoscroll() {
            this.dragging && this._toggleAutoscrollFx();
        },
        _toggleAutoscrollFx(enable) {
            this.dragging = enable;
            const win = this.getWindow();
            const method = enable ? 'on' : 'off';
            mixins[method](win, 'mousemove dragover', this.updateClientY);
            mixins[method](win, 'mouseup', this.stopAutoscroll);
        },
        render() {
            const {el, $el, ppfx, config} = this;
            $el.attr({ class: ppfx + 'frame' });
            if (config.scripts.length) {
                this.renderScripts();
            } else if (config.renderContent) {
                el.onload = this.renderBody.bind(this);
            }
            return this;
        },
        renderScripts() {
            const {el, config} = this;
            const appendScript = scripts => {
                if (scripts.length > 0) {
                    const src = scripts.shift();
                    const scriptEl = dom.createEl('script', langx.mixin({
                                            type: 'text/javascript'
                                        },_.isString(src) ? { src } : src
                    ));
                    scriptEl.onerror = scriptEl.onload = appendScript.bind(null, scripts);
                    el.contentDocument.head.appendChild(scriptEl);
                } else {
                    this.renderBody();
                }
            };
            el.onload = () => appendScript([...config.scripts]);
        },
        renderBody() {
            const {config, model, ppfx} = this;
            const root = model.get('root');
            const styles = model.get('styles');
            const {em} = config;
            const doc = this.getDoc();
            const head = this.getHead();
            const body = this.getBody();
            const win = this.getWindow();
            const conf = em.get('Config');
            const extStyles = [];
            config.styles.forEach(href => extStyles.push(_.isString(href) ? {
                tag: 'link',
                attributes: {
                    href,
                    rel: 'stylesheet'
                }
            } : {
                tag: 'link',
                attributes: {
                    rel: 'stylesheet',
                    ...href
                }
            }));
            extStyles.length && dom.appendVNodes(head, extStyles);
            const colorWarn = '#ffca6f';
            dom.append(body, `<style>
      ${ conf.baseCss || '' }

      .${ ppfx }dashed *[data-highlightable] {
        outline: 1px dashed rgba(170,170,170,0.7);
        outline-offset: -2px;
      }

      .${ ppfx }selected {
        outline: 3px solid #3b97e3 !important;
        outline-offset: -3px;
      }

      .${ ppfx }selected-parent {
        outline: 2px solid ${ colorWarn } !important
      }

      .${ ppfx }no-select {
        user-select: none;
        -webkit-user-select:none;
        -moz-user-select: none;
      }

      .${ ppfx }freezed {
        opacity: 0.5;
        pointer-events: none;
      }

      .${ ppfx }no-pointer {
        pointer-events: none;
      }

      .${ ppfx }plh-image {
        background: #f5f5f5;
        border: none;
        height: 100px;
        width: 100px;
        display: block;
        outline: 3px solid #ffca6f;
        cursor: pointer;
        outline-offset: -2px
      }

      .${ ppfx }grabbing {
        cursor: grabbing;
        cursor: -webkit-grabbing;
      }

      .${ ppfx }is__grabbing {
        overflow-x: hidden;
      }

      .${ ppfx }is__grabbing,
      .${ ppfx }is__grabbing * {
        cursor: grabbing !important;
      }

      ${ conf.canvasCss || '' }
      ${ conf.protectedCss || '' }
    </style>`);
            this.root = new ComponentView({
                model: root,
                config: {
                    ...root.config,
                    frameView: this
                }
            }).render();
            dom.append(body, this.root.el);
            dom.append(body, new CssRulesView({
                collection: styles,
                config: {
                    ...em.get('CssComposer').getConfig(),
                    frameView: this
                }
            }).render().el);
            dom.append(body, this.getJsContainer());
            mixins.on(body, 'click', ev => ev && ev.target.tagName == 'A' && ev.preventDefault());
            mixins.on(body, 'submit', ev => ev && ev.preventDefault());
            [
                {
                    event: 'keydown keyup keypress',
                    class: 'KeyboardEvent'
                },
                {
                    event: 'wheel',
                    class: 'WheelEvent'
                }
            ].forEach(obj => obj.event.split(' ').forEach(event => {
                doc.addEventListener(event, ev => this.el.dispatchEvent(dom.createCustomEvent(ev, obj.class)));
            }));
            this._toggleEffects(1);
            model.trigger('loaded');
        },
        _toggleEffects(enable) {
            const method = enable ? mixins.on : mixins.off;
            const win = this.getWindow();
            method(win, `${ dom.motionsEv } resize`, this._emitUpdate);
        },
        _emitUpdate() {
            this.model._emitUpdated();
        }
    });
});
define('skylark-grapejs/canvas/view/FrameWrapView',[
    'skylark-backbone',
    './FrameView',
    'skylark-underscore',
    '../../utils/dom',
    '../../utils/Dragger'
], function (Backbone, FrameView, a, b, Dragger) {
    'use strict';
    return Backbone.View.extend({
        events: {
            'click [data-action-remove]': 'remove',
            'mousedown [data-action-move]': 'startDrag'
        },
        initialize(opts = {}, conf = {}) {
            a.bindAll(this, 'onScroll', 'frameLoaded', 'updateOffset', 'remove', 'startDrag');
            const {model} = this;
            const config = {
                ...opts.config || conf,
                frameWrapView: this
            };
            const {canvasView, em} = config;
            this.cv = canvasView;
            this.config = config;
            this.em = em;
            this.canvas = em && em.get('Canvas');
            this.ppfx = config.pStylePrefix || '';
            this.frame = new FrameView({
                model,
                config
            });
            this.classAnim = `${ this.ppfx }frame-wrapper--anim`;
            this.listenTo(model, 'loaded', this.frameLoaded);
            this.listenTo(model, 'change:x change:y', this.updatePos);
            this.listenTo(model, 'change:width change:height', this.updateSize);
            this.updatePos();
            this.setupDragger();
        },
        setupDragger() {
            const {canvas, model} = this;
            let dragX, dragY, zoom;
            const toggleEffects = on => {
                canvas.toggleFramesEvents(on);
            };
            this.dragger = new Dragger({
                onStart: () => {
                    const {x, y} = model.attributes;
                    zoom = this.em.getZoomMultiplier();
                    dragX = x;
                    dragY = y;
                    toggleEffects();
                },
                onEnd: () => toggleEffects(1),
                setPosition: posOpts => {
                    model.set({
                        x: dragX + posOpts.x * zoom,
                        y: dragY + posOpts.y * zoom
                    });
                }
            });
        },
        startDrag(ev) {
            ev && this.dragger.start(ev);
        },
        remove() {
            Backbone.View.prototype.remove.apply(this, arguments);
            this.frame.remove();
            return this;
        },
        updateOffset: a.debounce(function () {
            const {em, $el, frame} = this;
            em.runDefault({ preserveSelected: 1 });
            $el.removeClass(this.classAnim);
            frame.model._emitUpdated();
        }),
        updatePos(md) {
            const {model, el} = this;
            const {x, y} = model.attributes;
            const {style} = el;
            this.frame.rect = 0;
            style.left = isNaN(x) ? x : `${ x }px`;
            style.top = isNaN(y) ? y : `${ y }px`;
            md && this.updateOffset();
        },
        updateSize: a.debounce(function () {
            this.updateDim();
        }),
        updateDim() {
            const {em, el, $el, model, classAnim} = this;
            const {width, height} = model.attributes;
            const {style} = el;
            const currW = style.width || '';
            const currH = style.height || '';
            const newW = width || '';
            const newH = height || '';
            const noChanges = currW == newW && currH == newH;
            const un = 'px';
            this.frame.rect = 0;
            $el.addClass(classAnim);
            style.width = a.isNumber(newW) ? `${ newW }${ un }` : newW;
            style.height = a.isNumber(newH) ? `${ newH }${ un }` : newH;
            if (a.isNull(width) || a.isNull(height)) {
                const newDims = {
                    ...!width ? { width: el.offsetWidth } : {},
                    ...!height ? { height: el.offsetHeight } : {}
                };
                model.set(newDims, { silent: 1 });
            }
            em.stopDefault({ preserveSelected: 1 });
            noChanges ? this.updateOffset() : $el.one(b.motionsEv, this.updateOffset);
        },
        onScroll() {
            const {frame, em} = this;
            em.trigger('frame:scroll', {
                frame,
                body: frame.getBody(),
                target: frame.getWindow()
            });
        },
        frameLoaded() {
            const {frame} = this;
            frame.getWindow().onscroll = this.onScroll;
            this.updateDim();
        },
        render() {
            const {frame, $el, ppfx, cv, model, el} = this;
            const {onRender} = model.attributes;
            frame.render();
            $el.empty().attr({ class: `${ ppfx }frame-wrapper` }).append(`
      <div class="${ ppfx }frame-wrapper__top gjs-two-color" data-frame-top>
        <div class="${ ppfx }frame-wrapper__name" data-action-move>
          ${ model.get('name') || '' }
        </div>
        <div class="${ ppfx }frame-wrapper__top-r">
          <div class="${ ppfx }frame-wrapper__icon" data-action-remove style="display: none">
            <svg viewBox="0 0 24 24"><path d="M19 4h-3.5l-1-1h-5l-1 1H5v2h14M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12z"></path></svg>
          </div>
        </div>
      </div>
      <div class="${ ppfx }frame-wrapper__right" data-frame-right></div>
      <div class="${ ppfx }frame-wrapper__left" data-frame-left></div>
      <div class="${ ppfx }frame-wrapper__bottom" data-frame-bottom></div>
      `).append(frame.el);
            const elTools = b.createEl('div', {
                class: `${ ppfx }tools`,
                style: 'pointer-events:none; opacity: 0'
            }, `
      <div class="${ ppfx }highlighter" data-hl></div>
      <div class="${ ppfx }badge" data-badge></div>
      <div class="${ ppfx }placeholder">
        <div class="${ ppfx }placeholder-int"></div>
      </div>
      <div class="${ ppfx }ghost"></div>
      <div class="${ ppfx }toolbar" style="pointer-events:all"></div>
      <div class="${ ppfx }resizer"></div>
      <div class="${ ppfx }offset-v" data-offset>
        <div class="gjs-marginName" data-offset-m>
          <div class="gjs-margin-v-el gjs-margin-v-top" data-offset-m-t></div>
          <div class="gjs-margin-v-el gjs-margin-v-bottom" data-offset-m-b></div>
          <div class="gjs-margin-v-el gjs-margin-v-left" data-offset-m-l></div>
          <div class="gjs-margin-v-el gjs-margin-v-right" data-offset-m-r></div>
        </div>
        <div class="gjs-paddingName" data-offset-m>
          <div class="gjs-padding-v-el gjs-padding-v-top" data-offset-p-t></div>
          <div class="gjs-padding-v-el gjs-padding-v-bottom" data-offset-p-b></div>
          <div class="gjs-padding-v-el gjs-padding-v-left" data-offset-p-l></div>
          <div class="gjs-padding-v-el gjs-padding-v-right" data-offset-p-r></div>
        </div>
      </div>
      <div class="${ ppfx }offset-fixed-v"></div>
    `);
            this.elTools = elTools;
            cv.toolsWrapper.appendChild(elTools);
            onRender && onRender({
                el,
                elTop: el.querySelector('[data-frame-top]'),
                elRight: el.querySelector('[data-frame-right]'),
                elBottom: el.querySelector('[data-frame-bottom]'),
                elLeft: el.querySelector('[data-frame-left]'),
                frame: model,
                frameWrapperView: this,
                remove: this.remove,
                startDrag: this.startDrag
            });
            return this;
        }
    });
});
define('skylark-grapejs/canvas/view/FramesView',[
    '../../domain_abstract/view/DomainViews',
    './FrameWrapView'
], function (DomainViews, FrameWrapView) {
    'use strict';
    return DomainViews.extend({
        itemView: FrameWrapView,
        autoAdd: 1,
        init() {
            this.listenTo(this.collection, 'reset', this.render);
        },
        onRender() {
            const {config, $el} = this;
            const {em} = config;
            em && $el.attr({ class: `${ em.getConfig('stylePrefix') }frames` });
        }
    });
});
define('skylark-grapejs/canvas/view/CanvasView',[
    "skylark-langx/langx",
    "skylark-jquery",
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins',
    './FramesView'
], function (langx,$,Backbone, _, mixins, FramesView) {
    'use strict';
    let timerZoom;
    return Backbone.View.extend({
        events: { wheel: 'onWheel' },
        template() {
            const {pfx} = this;
            return `
      <div class="${ pfx }canvas__frames" data-frames></div>
      <div id="${ pfx }tools" class="${ pfx }canvas__tools" data-tools></div>
    `;
        },
        initialize(o) {
            _.bindAll(this, 'clearOff', 'onKeyPress');
            mixins.on(window, 'scroll resize', this.clearOff);
            const {model} = this;
            const frames = model.get('frames');
            this.config = o.config || {};
            this.em = this.config.em || {};
            this.pfx = this.config.stylePrefix || '';
            this.ppfx = this.config.pStylePrefix || '';
            this.className = this.config.stylePrefix + 'canvas';
            const {em, config} = this;
            this.frames = new FramesView({
                collection: frames,
                config: langx.mixin({},config,{
                    canvasView: this,
                    renderContent: 1
                })
            });
            this.listenTo(em, 'change:canvasOffset', this.clearOff);
            this.listenTo(em, 'component:selected', this.checkSelected);
            this.listenTo(model, 'change:zoom change:x change:y', this.updateFrames);
            this.listenTo(frames, 'loaded:all', () => em.trigger('loaded'));
            this.toggleListeners(1);
        },
        checkSelected(component, opts = {}) {
            const {scroll} = opts;
            const currFrame = this.em.get('currentFrame');
            scroll && component.views.forEach(view => {
                view._getFrame() !== currFrame && view.scrollIntoView(scroll);
            });
        },
        remove() {
            Backbone.View.prototype.remove.apply(this, arguments);
            this.toggleListeners();
        },
        preventDefault(ev) {
            if (ev) {
                ev.preventDefault();
                ev._parentEvent && ev._parentEvent.preventDefault();
            }
        },
        toggleListeners(enable) {
            const method = enable ? 'on' : 'off';

            mixins[method](document, 'keypress', this.onKeyPress);
        },
        onKeyPress(ev) {
            const {em} = this;
            const key = mixins.getKeyChar(ev);
            if (key === ' ' && em.getZoomDecimal() !== 1) {
                this.preventDefault(ev);
                em.get('Editor').runCommand('core:canvas-move');
            }
        },
        onWheel(ev) {
            if ((ev.ctrlKey || ev.metaKey) && this.em.getConfig('multiFrames')) {
                this.preventDefault(ev);
                const {model} = this;
                const delta = Math.max(-1, Math.min(1, ev.wheelDelta || -ev.detail));
                const zoom = model.get('zoom');
                model.set('zoom', zoom + delta * 2);
            }
        },
        updateFrames(ev) {
            const {em, model} = this;
            const {x, y} = model.attributes;
            const zoom = this.getZoom();
            const defOpts = { preserveSelected: 1 };
            const mpl = zoom ? 1 / zoom : 1;
            this.framesArea.style.transform = `scale(${ zoom }) translate(${ x * mpl }px, ${ y * mpl }px)`;
            this.clearOff();
            em.stopDefault(defOpts);
            em.trigger('canvas:update', ev);
            timerZoom && clearTimeout(timerZoom);
            timerZoom = setTimeout(() => em.runDefault(defOpts), 300);
        },
        getZoom() {
            return this.em.getZoomDecimal();
        },
        isElInViewport(el) {
            const elem = mixins.getElement(el);
            const rect = mixins.getElRect(elem);
            const frameRect = this.getFrameOffset(elem);
            const rTop = rect.top;
            const rLeft = rect.left;
            return rTop >= 0 && rLeft >= 0 && rTop <= frameRect.height && rLeft <= frameRect.width;
        },
        offset(el, opts = {}) {
            const rect = mixins.getElRect(el);
            const docBody = el.ownerDocument.body;
            const {noScroll} = opts;
            return {
                top: rect.top + (noScroll ? 0 : docBody.scrollTop),
                left: rect.left + (noScroll ? 0 : docBody.scrollLeft),
                width: rect.width,
                height: rect.height
            };
        },
        clearOff() {
            this.frmOff = null;
            this.cvsOff = null;
        },
        getFrameOffset(el) {
            if (!this.frmOff || el) {
                const frEl = el ? el.ownerDocument.defaultView.frameElement : this.frame.el;
                this.frmOff = this.offset(frEl);
            }
            return this.frmOff;
        },
        getCanvasOffset() {
            if (!this.cvsOff)
                this.cvsOff = this.offset(this.el);
            return this.cvsOff;
        },
        getElementPos(el, opts) {
            const zoom = this.getZoom();
            var opt = opts || {};
            var frmOff = this.getFrameOffset(el);
            var cvsOff = this.getCanvasOffset();
            var eo = this.offset(el, opts);
            var frmTop = opt.avoidFrameOffset ? 0 : frmOff.top;
            var frmLeft = opt.avoidFrameOffset ? 0 : frmOff.left;
            const top = eo.top * zoom + frmTop - cvsOff.top;
            const left = eo.left * zoom + frmLeft - cvsOff.left;
            const height = eo.height * zoom;
            const width = eo.width * zoom;
            return {
                top,
                left,
                height,
                width,
                zoom,
                rect: eo
            };
        },
        getElementOffsets(el) {
            if (!el || mixins.isTextNode(el))
                return {};
            const result = {};
            const styles = window.getComputedStyle(el);
            [
                'marginTop',
                'marginRight',
                'marginBottom',
                'marginLeft',
                'paddingTop',
                'paddingRight',
                'paddingBottom',
                'paddingLeft'
            ].forEach(offset => {
                result[offset] = parseFloat(styles[offset]) * this.getZoom();
            });
            return result;
        },
        getPosition(opts = {}) {
            const doc = this.frame.el.contentDocument;
            if (!doc)
                return;
            const bEl = doc.body;
            const zoom = this.getZoom();
            const fo = this.getFrameOffset();
            const co = this.getCanvasOffset();
            const {noScroll} = opts;
            return {
                top: fo.top + (noScroll ? 0 : bEl.scrollTop) * zoom - co.top,
                left: fo.left + (noScroll ? 0 : bEl.scrollLeft) * zoom - co.left,
                width: co.width,
                height: co.height
            };
        },
        updateScript(view) {
            const model = view.model;
            const id = model.getId();
            if (!view.scriptContainer) {
                view.scriptContainer = $(`<div data-id="${ id }">`);
                this.getJsContainer().appendChild(view.scriptContainer.get(0));
            }
            view.el.id = id;
            view.scriptContainer.html('');
            const script = document.createElement('script');
            script.innerHTML = `
        setTimeout(function() {
          var item = document.getElementById('${ id }');
          if (!item) return;
          (function(){
            ${ model.getScriptString() };
          }.bind(item))()
        }, 1);`;
            setTimeout(() => view.scriptContainer.get(0).appendChild(script), 0);
        },
        getJsContainer(view) {
            const frameView = this.getFrameView(view);
            return frameView && frameView.getJsContainer();
        },
        getFrameView(view) {
            return view && view._getFrame() || this.em.get('currentFrame');
        },
        render() {
            const {el, $el, ppfx, model, em, frames} = this;
            const cssc = em.get('CssComposer');
            const wrapper = model.get('wrapper');
            $el.html(this.template());
            const $frames = $el.find('[data-frames]');
            this.framesArea = $frames.get(0);
            this.wrapper = wrapper;
            if (wrapper && typeof wrapper.render == 'function') {
                model.get('frame').set({
                    wrapper,
                    root: wrapper.getWrapper(),
                    styles: cssc.getAll()
                });
            }
            const toolsWrp = $el.find('[data-tools]');
            this.toolsWrapper = toolsWrp.get(0);
            toolsWrp.append(`
      <div class="${ ppfx }tools ${ ppfx }tools-gl" style="pointer-events:none">
        <div class="${ ppfx }placeholder">
          <div class="${ ppfx }placeholder-int"></div>
        </div>
      </div>
      <div id="${ ppfx }tools" style="pointer-events:none">
        <div class="${ ppfx }badge"></div>
        <div class="${ ppfx }ghost"></div>
        <div class="${ ppfx }toolbar" style="pointer-events:all"></div>
        <div class="${ ppfx }resizer"></div>
        <div class="${ ppfx }offset-v"></div>
        <div class="${ ppfx }offset-fixed-v"></div>
      </div>
    `);
            const toolsEl = el.querySelector(`#${ ppfx }tools`);
            this.hlEl = el.querySelector(`.${ ppfx }highlighter`);
            this.badgeEl = el.querySelector(`.${ ppfx }badge`);
            this.placerEl = el.querySelector(`.${ ppfx }placeholder`);
            this.ghostEl = el.querySelector(`.${ ppfx }ghost`);
            this.toolbarEl = el.querySelector(`.${ ppfx }toolbar`);
            this.resizerEl = el.querySelector(`.${ ppfx }resizer`);
            this.offsetEl = el.querySelector(`.${ ppfx }offset-v`);
            this.fixedOffsetEl = el.querySelector(`.${ ppfx }offset-fixed-v`);
            this.toolsGlobEl = el.querySelector(`.${ ppfx }tools-gl`);
            this.toolsEl = toolsEl;
            this.el.className = this.className;
            const frms = model.get('frames');
            frms.listenToLoad();
            frames.render();
            em.setCurrentFrame(frms.at(0).view);
            $frames.append(frames.el);
            this.frame = frms.at(0).view;
            return this;
        }
    });
});
define('skylark-grapejs/canvas/index',[
    "skylark-langx/langx",
    '../utils/mixins',
    'skylark-underscore',
    '../utils/Droppable',
    './config/config',
    './model/Canvas',
    './view/CanvasView'
], function (langx,mixins, _, Droppable, defaults, Canvas, canvasView) {
    'use strict';
    const {requestAnimationFrame} = window;
    return () => {
        let c = {};
        let canvas;
        let frameRect;
        let CanvasView;
        return {
            getCanvasView() {
                return CanvasView;
            },
            name: 'Canvas',
            init(config = {}) {
                c = langx.mixin({},defaults,config, { module: this});
                this.em = c.em;
                const ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                canvas = new Canvas(config);
                CanvasView = new canvasView({
                    model: canvas,
                    config: c
                });
                var cm = c.em.get('DomComponents');
                if (cm)
                    this.setWrapper(cm);
                this.model = canvas;
                this.startAutoscroll = this.startAutoscroll.bind(this);
                this.stopAutoscroll = this.stopAutoscroll.bind(this);
                return this;
            },
            getConfig() {
                return c;
            },
            setWrapper(wrp) {
                canvas.set('wrapper', wrp);
            },
            getElement() {
                return CanvasView.el;
            },
            getFrame() {
                return canvas.get('frame');
            },
            getFrameEl() {
                const {frame} = CanvasView;
                return frame && frame.el;
            },
            getFramesEl() {
                return CanvasView.framesArea;
            },
            getWindow() {
                return this.getFrameEl().contentWindow;
            },
            getDocument() {
                const frame = this.getFrameEl();
                return frame && frame.contentDocument;
            },
            getBody() {
                const doc = this.getDocument();
                return doc && doc.body;
            },
            getWrapperEl() {
                const body = this.getBody();
                return body && body.querySelector('#wrapper');
            },
            _getCompFrame(compView) {
                return compView && compView._getFrame();
            },
            _getLocalEl(globalEl, compView, method) {
                let result = globalEl;
                const frameView = this._getCompFrame(compView);
                result = frameView ? frameView[method]() : result;
                return result;
            },
            getGlobalToolsEl() {
                return CanvasView.toolsGlobEl;
            },
            getToolsEl(compView) {
                return this._getLocalEl(CanvasView.toolsEl, compView, 'getToolsEl');
            },
            getHighlighter(compView) {
                return this._getLocalEl(CanvasView.hlEl, compView, 'getHighlighter');
            },
            getBadgeEl(compView) {
                return this._getLocalEl(CanvasView.badgeEl, compView, 'getBadgeEl');
            },
            getPlacerEl() {
                return CanvasView.placerEl;
            },
            getGhostEl() {
                return CanvasView.ghostEl;
            },
            getToolbarEl() {
                return CanvasView.toolbarEl;
            },
            getResizerEl() {
                return CanvasView.resizerEl;
            },
            getOffsetViewerEl(compView) {
                return this._getLocalEl(CanvasView.offsetEl, compView, 'getOffsetViewerEl');
            },
            getFixedOffsetViewerEl() {
                return CanvasView.fixedOffsetEl;
            },
            render() {
                return CanvasView.render().el;
            },
            getOffset() {
                var frameOff = this.offset(this.getFrameEl());
                var canvasOff = this.offset(this.undefined());
                return {
                    top: frameOff.top - canvasOff.top,
                    left: frameOff.left - canvasOff.left
                };
            },
            offset(el) {
                return CanvasView.offset(el);
            },
            setCustomBadgeLabel(f) {
                c.customBadgeLabel = f;
            },
            getElementPos(el, opts) {
                return CanvasView.getElementPos(el, opts);
            },
            getElementOffsets(el) {
                return CanvasView.getElementOffsets(el);
            },
            getRect() {
                const {top, left} = CanvasView.getPosition();
                return {
                    ...CanvasView.getCanvasOffset(),
                    topScroll: top,
                    leftScroll: left
                };
            },
            getTargetToElementDim(target, element, options = {}) {
                var opts = options || {};
                var canvasPos = CanvasView.getPosition();
                if (!canvasPos)
                    return;
                var pos = opts.elPos || CanvasView.getElementPos(element);
                var toRight = options.toRight || 0;
                var targetHeight = opts.targetHeight || target.offsetHeight;
                var targetWidth = opts.targetWidth || target.offsetWidth;
                var eventToTrigger = opts.event || null;
                var elTop = pos.top - targetHeight;
                var elLeft = pos.left;
                elLeft += toRight ? pos.width : 0;
                elLeft = toRight ? elLeft - targetWidth : elLeft;
                var leftPos = elLeft < canvasPos.left ? canvasPos.left : elLeft;
                var topPos = elTop < canvasPos.top ? canvasPos.top : elTop;
                topPos = topPos > pos.top + pos.height ? pos.top + pos.height : topPos;
                var result = {
                    top: topPos,
                    left: leftPos,
                    elementTop: pos.top,
                    elementLeft: pos.left,
                    elementWidth: pos.width,
                    elementHeight: pos.height,
                    targetWidth: target.offsetWidth,
                    targetHeight: target.offsetHeight,
                    canvasTop: canvasPos.top,
                    canvasLeft: canvasPos.left,
                    canvasWidth: canvasPos.width,
                    canvasHeight: canvasPos.height
                };
                if (eventToTrigger && c.em) {
                    c.em.trigger(eventToTrigger, result);
                }
                return result;
            },
            canvasRectOffset(el, pos, opts = {}) {
                const getFrameElFromDoc = doc => {
                    const {defaultView} = doc;
                    return defaultView && defaultView.frameElement;
                };
                const rectOff = (el, top = 1, pos) => {
                    const zoom = this.em.getZoomDecimal();
                    const side = top ? 'top' : 'left';
                    const doc = el.ownerDocument;
                    const {offsetTop = 0, offsetLeft = 0} = opts.offset ? getFrameElFromDoc(doc) : {};
                    const {scrollTop = 0, scrollLeft = 0} = doc.body || {};
                    const scroll = top ? scrollTop : scrollLeft;
                    const offset = top ? offsetTop : offsetLeft;
                    return pos[side] - (scroll - offset) * zoom;
                };
                return {
                    top: rectOff(el, 1, pos),
                    left: rectOff(el, 0, pos)
                };
            },
            getTargetToElementFixed(el, elToMove, opts = {}) {
                const pos = opts.pos || this.getElementPos(el);
                const cvOff = opts.canvasOff || this.canvasRectOffset(el, pos);
                const toolbarH = elToMove.offsetHeight || 0;
                const toolbarW = elToMove.offsetWidth || 0;
                const elRight = pos.left + pos.width;
                const cv = this.getCanvasView();
                const frCvOff = cv.getPosition();
                const frameOffset = cv.getFrameOffset(el);
                const {event} = opts;
                let top = -toolbarH;
                let left = pos.width - toolbarW;
                left = pos.left < -left ? -pos.left : left;
                left = elRight > frCvOff.width ? left - (elRight - frCvOff.width) : left;
                const fullHeight = pos.height + toolbarH;
                const elIsShort = fullHeight < frameOffset.height;
                if (cvOff.top < toolbarH) {
                    if (elIsShort) {
                        top = top + fullHeight;
                    } else {
                        top = -cvOff.top < pos.height ? -cvOff.top : pos.height;
                    }
                }
                const result = {
                    top,
                    left,
                    canvasOffsetTop: cvOff.top,
                    canvasOffsetLeft: cvOff.left
                };
                event && this.em.trigger(event, result);
                return result;
            },
            getMouseRelativePos(e, options) {
                var opts = options || {};
                var addTop = 0;
                var addLeft = 0;
                var subWinOffset = opts.subWinOffset;
                var doc = e.target.ownerDocument;
                var win = doc.defaultView || doc.parentWindow;
                var frame = win.frameElement;
                var yOffset = subWinOffset ? win.pageYOffset : 0;
                var xOffset = subWinOffset ? win.pageXOffset : 0;
                if (frame) {
                    var frameRect = frame.getBoundingClientRect();
                    addTop = frameRect.top || 0;
                    addLeft = frameRect.left || 0;
                }
                return {
                    y: e.clientY + addTop - yOffset,
                    x: e.clientX + addLeft - xOffset
                };
            },
            getMouseRelativeCanvas(ev, opts) {
                const zoom = this.getZoomDecimal();
                const {top, left} = CanvasView.getPosition(opts);
                return {
                    y: ev.clientY * zoom + top,
                    x: ev.clientX * zoom + left
                };
            },
            hasFocus() {
                return this.getDocument().hasFocus();
            },
            isInputFocused() {
                const doc = this.getDocument();
                const toIgnore = [
                    'body',
                    ...this.getConfig().notTextable
                ];
                const focused = doc && doc.activeElement;
                return focused && !toIgnore.some(item => focused.matches(item));
            },
            scrollTo(el, opts = {}) {
                const elem = mixins.getElement(el);
                const view = elem && mixins.getViewEl(elem);
                view && view.scrollIntoView(opts);
            },
            startAutoscroll(frame) {
                const fr = frame && frame.view || this.em.getCurrentFrame();
                fr && fr.startAutoscroll();
            },
            stopAutoscroll(frame) {
                const fr = frame && frame.view || this.em.getCurrentFrame();
                fr && fr.stopAutoscroll();
            },
            postRender() {
                if (mixins.hasDnd(c.em))
                    this.droppable = new Droppable(c.em);
            },
            setZoom(value) {
                canvas.set('zoom', parseFloat(value));
                return this;
            },
            getZoom() {
                return parseFloat(canvas.get('zoom'));
            },
            getZoomDecimal() {
                return this.getZoom() / 100;
            },
            getZoomMultiplier() {
                const zoom = this.getZoomDecimal();
                return zoom ? 1 / zoom : 1;
            },
            toggleFramesEvents(on) {
                const {style} = this.getFramesEl();
                style.pointerEvents = on ? '' : 'none';
            },
            getFrameWrapperEl() {
                return CanvasView.frame.getWrapper();
            },
            getFrames() {
                return canvas.get('frames').map(item => item);
            },
            addFrame(props = {}, opts = {}) {
                return canvas.get('frames').add({ ...props }, {
                    ...opts,
                    em: this.em
                });
            }
        };
    };
});
define('skylark-grapejs/commands/view/CommandAbstract',['skylark-backbone'], function (Backbone) {
    'use strict';
    const $ = Backbone.$;
    return Backbone.View.extend({
        initialize(o) {
            this.config = o || {};
            this.editorModel = this.em = this.config.em || {};
            this.pfx = this.config.stylePrefix;
            this.ppfx = this.config.pStylePrefix;
            this.hoverClass = this.pfx + 'hover';
            this.badgeClass = this.pfx + 'badge';
            this.plhClass = this.pfx + 'placeholder';
            this.freezClass = this.ppfx + 'freezed';
            this.canvas = this.em.get && this.em.get('Canvas');
            if (this.em.get)
                this.setElement(this.getCanvas());
            if (this.canvas) {
                this.$canvas = this.$el;
                this.canvasTool = this.getCanvasTools();
            }
            this.init(this.config);
        },
        onFrameScroll(e) {
        },
        getCanvas() {
            return this.canvas.getElement();
        },
        getCanvasBody() {
            return this.canvas.getBody();
        },
        getCanvasWrapper() {
            return this.canvas.getWrapperEl();
        },
        getCanvasTools() {
            return this.canvas.getToolsEl();
        },
        offset(el) {
            var rect = el.getBoundingClientRect();
            return {
                top: rect.top + el.ownerDocument.body.scrollTop,
                left: rect.left + el.ownerDocument.body.scrollLeft
            };
        },
        init(o) {
        },
        callRun(editor, options = {}) {
            const id = this.id;
            editor.trigger(`run:${ id }:before`, options);
            if (options && options.abort) {
                editor.trigger(`abort:${ id }`, options);
                return;
            }
            const sender = options.sender || editor;
            const result = this.run(editor, sender, options);
            editor.trigger(`run:${ id }`, result, options);
            editor.trigger('run', id, result, options);
            return result;
        },
        callStop(editor, options = {}) {
            const id = this.id;
            const sender = options.sender || editor;
            editor.trigger(`stop:${ id }:before`, options);
            const result = this.stop(editor, sender, options);
            editor.trigger(`stop:${ id }`, result, options);
            editor.trigger('stop', id, result, options);
            return result;
        },
        stopCommand() {
            this.em.get('Commands').stop(this.id);
        },
        run(em, sender) {
        },
        stop(em, sender) {
        }
    });
});
define('skylark-grapejs/commands/config/config',[],function () {
    'use strict';
    return {
        stylePrefix: 'com-',
        defaults: [],
        strict: 1
    };
});
define('parser/model/ParserHtml',['skylark-underscore'], function (a) {
    'use strict';
    return config => {
        var TEXT_NODE = 'span';
        var c = config;
        var modelAttrStart = 'data-gjs-';
        return {
            compTypes: '',
            modelAttrStart,
            splitPropsFromAttr(attr = {}) {
                const props = {};
                const attrs = {};
                a.each(attr, (value, key) => {
                    if (key.indexOf(this.modelAttrStart) === 0) {
                        const modelAttr = key.replace(modelAttrStart, '');
                        const valueLen = value.length;
                        const valStr = value && a.isString(value);
                        const firstChar = valStr && value.substr(0, 1);
                        const lastChar = valStr && value.substr(valueLen - 1);
                        value = value === 'true' ? true : value;
                        value = value === 'false' ? false : value;
                        try {
                            value = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(value) : value;
                        } catch (e) {
                        }
                        props[modelAttr] = value;
                    } else {
                        attrs[key] = value;
                    }
                });
                return {
                    props,
                    attrs
                };
            },
            parseStyle(str) {
                var result = {};
                var decls = str.split(';');
                for (var i = 0, len = decls.length; i < len; i++) {
                    var decl = decls[i].trim();
                    if (!decl)
                        continue;
                    var prop = decl.split(':');
                    result[prop[0].trim()] = prop.slice(1).join(':').trim();
                }
                return result;
            },
            parseClass(str) {
                const result = [];
                const cls = str.split(' ');
                for (let i = 0, len = cls.length; i < len; i++) {
                    const cl = cls[i].trim();
                    if (!cl)
                        continue;
                    result.push(cl);
                }
                return result;
            },
            parseNode(el) {
                const result = [];
                const nodes = el.childNodes;
                for (var i = 0, len = nodes.length; i < len; i++) {
                    const node = nodes[i];
                    const attrs = node.attributes || [];
                    const attrsLen = attrs.length;
                    const nodePrev = result[result.length - 1];
                    const nodeChild = node.childNodes.length;
                    const ct = this.compTypes;
                    let model = {};
                    if (ct) {
                        let obj = '';
                        let type = node.getAttribute && node.getAttribute(`${ modelAttrStart }type`);
                        if (type) {
                            model = { type };
                        } else {
                            for (let it = 0; it < ct.length; it++) {
                                const compType = ct[it];
                                obj = compType.model.isComponent(node);
                                if (obj) {
                                    if (typeof obj !== 'object') {
                                        obj = { type: compType.id };
                                    }
                                    break;
                                }
                            }
                            model = obj;
                        }
                    }
                    if (!model.tagName) {
                        model.tagName = node.tagName ? node.tagName.toLowerCase() : '';
                    }
                    if (attrsLen) {
                        model.attributes = {};
                    }
                    for (let j = 0; j < attrsLen; j++) {
                        const nodeName = attrs[j].nodeName;
                        let nodeValue = attrs[j].nodeValue;
                        if (nodeName == 'style') {
                            model.style = this.parseStyle(nodeValue);
                        } else if (nodeName == 'class') {
                            model.classes = this.parseClass(nodeValue);
                        } else if (nodeName == 'contenteditable') {
                            continue;
                        } else if (nodeName.indexOf(modelAttrStart) === 0) {
                            const modelAttr = nodeName.replace(modelAttrStart, '');
                            const valueLen = nodeValue.length;
                            const firstChar = nodeValue && nodeValue.substr(0, 1);
                            const lastChar = nodeValue && nodeValue.substr(valueLen - 1);
                            nodeValue = nodeValue === 'true' ? true : nodeValue;
                            nodeValue = nodeValue === 'false' ? false : nodeValue;
                            try {
                                nodeValue = firstChar == '{' && lastChar == '}' || firstChar == '[' && lastChar == ']' ? JSON.parse(nodeValue) : nodeValue;
                            } catch (e) {
                            }
                            model[modelAttr] = nodeValue;
                        } else {
                            model.attributes[nodeName] = nodeValue;
                        }
                    }
                    if (nodeChild && !model.components) {
                        const firstChild = node.childNodes[0];
                        if (nodeChild === 1 && firstChild.nodeType === 3) {
                            !model.type && (model.type = 'text');
                            model.content = firstChild.nodeValue;
                        } else {
                            model.components = this.parseNode(node);
                        }
                    }
                    if (model.type == 'textnode') {
                        if (nodePrev && nodePrev.type == 'textnode') {
                            nodePrev.content += model.content;
                            continue;
                        }
                        if (!config.keepEmptyTextNodes) {
                            const content = node.nodeValue;
                            if (content != ' ' && !content.trim()) {
                                continue;
                            }
                        }
                    }
                    const comps = model.components;
                    if (!model.type && comps) {
                        let allTxt = 1;
                        let foundTextNode = 0;
                        for (let ci = 0; ci < comps.length; ci++) {
                            const comp = comps[ci];
                            const cType = comp.type;
                            if ([
                                    'text',
                                    'textnode'
                                ].indexOf(cType) < 0 && c.textTags.indexOf(comp.tagName) < 0) {
                                allTxt = 0;
                                break;
                            }
                            if (cType == 'textnode') {
                                foundTextNode = 1;
                            }
                        }
                        if (allTxt && foundTextNode) {
                            model.type = 'text';
                        }
                    }
                    if (!model.tagName && model.type != 'textnode') {
                        continue;
                    }
                    result.push(model);
                }
                return result;
            },
            parse(str, parserCss) {
                var config = c.em && c.em.get('Config') || {};
                var res = {
                    html: '',
                    css: ''
                };
                var el = document.createElement('div');
                el.innerHTML = str;
                var scripts = el.querySelectorAll('script');
                var i = scripts.length;
                if (!config.allowScripts) {
                    while (i--)
                        scripts[i].parentNode.removeChild(scripts[i]);
                }
                if (parserCss) {
                    var styleStr = '';
                    var styles = el.querySelectorAll('style');
                    var j = styles.length;
                    while (j--) {
                        styleStr = styles[j].innerHTML + styleStr;
                        styles[j].parentNode.removeChild(styles[j]);
                    }
                    if (styleStr)
                        res.css = parserCss.parse(styleStr);
                }
                var result = this.parseNode(el);
                if (result.length == 1)
                    result = result[0];
                res.html = result;
                return res;
            }
        };
    };
});
define('domain_abstract/model/Styleable',[
    'skylark-underscore',
    '../../utils/mixins',
    '../../parser/model/ParserHtml'
], function (a, b, ParserHtml) {
    'use strict';
    const parseStyle = ParserHtml().parseStyle;
    return {
        parseStyle,
        extendStyle(prop) {
            return {
                ...this.getStyle(),
                ...prop
            };
        },
        getStyle() {
            const style = this.get('style') || {};
            return { ...style };
        },
        setStyle(prop = {}, opts = {}) {
            if (a.isString(prop)) {
                prop = parseStyle(prop);
            }
            const propOrig = this.getStyle();
            const propNew = { ...prop };
            this.set('style', propNew, opts);
            const diff = b.shallowDiff(propOrig, propNew);
            a.keys(diff).forEach(pr => {
                const em = this.em;
                this.trigger(`change:style:${ pr }`);
                if (em) {
                    em.trigger(`styleable:change`, this, pr);
                    em.trigger(`styleable:change:${ pr }`, this, pr);
                }
            });
            return propNew;
        },
        addStyle(prop, value = '', opts = {}) {
            if (typeof prop == 'string') {
                prop = { prop: value };
            } else {
                opts = value || {};
            }
            prop = this.extendStyle(prop);
            this.setStyle(prop, opts);
        },
        removeStyle(prop) {
            let style = this.getStyle();
            delete style[prop];
            this.setStyle(style);
        },
        styleToString(opts = {}) {
            const result = [];
            const style = this.getStyle();
            for (let prop in style) {
                const imp = opts.important;
                const important = a.isArray(imp) ? imp.indexOf(prop) >= 0 : imp;
                const value = `${ style[prop] }${ important ? ' !important' : '' }`;
                const propPrv = prop.substr(0, 2) == '__';
                value && !propPrv && result.push(`${ prop }:${ value };`);
            }
            return result.join('');
        },
        getSelectors() {
            return this.get('selectors') || this.get('classes');
        },
        getSelectorsString() {
            return this.selectorsToString ? this.selectorsToString() : this.getSelectors().getFullString();
        }
    };
});
define('dom_components/model/Components',[
    "skylark-langx/langx",
    'skylark-backbone',
    'skylark-underscore'
], function (langx,Backbone, _) {
    'use strict';
    let Component;
    return Backbone.Collection.extend({
        initialize(models, opt = {}) {
            this.opt = opt;
            this.listenTo(this, 'add', this.onAdd);
            this.config = opt.config;
            this.em = opt.em;
            const {em} = this;
            this.model = (attrs, options) => {
                var model;
                const df = opt.em.get('DomComponents').componentTypes;
                options.em = opt.em;
                options.config = opt.config;
                options.componentTypes = df;
                options.domc = opt.domc;
                for (var it = 0; it < df.length; it++) {
                    var dfId = df[it].id;
                    if (dfId == attrs.type) {
                        model = df[it].model;
                        break;
                    }
                }
                if (!model) {
                    model = df[df.length - 1].model;
                    em && attrs.type && em.logWarning(`Component type '${ attrs.type }' not found`, {
                        attrs,
                        options
                    });
                }
                return new model(attrs, options);
            };
        },
        parseString(value, opt = {}) {
            const {em} = this;
            const {domc} = this.opt;
            const cssc = em.get('CssComposer');
            const parsed = em.get('Parser').parseHtml(value);
            if (!Component)
                Component = require('./Component').default;
            Component.checkId(parsed.html, parsed.css, domc.componentsById);
            if (parsed.css && cssc && !opt.temporary) {
                cssc.addCollection(parsed.css, langx.mixin({},opt,{
                    extend: 1
                }));
            }
            return parsed.html;
        },
        add(models, opt = {}) {
            if (_.isString(models)) {
                models = this.parseString(models, opt);
            } else if (_.isArray(models)) {
                models.forEach((item, index) => {
                    if (_.isString(item)) {
                        models[index] = this.parseString(item, opt);
                    }
                });
            }
            const isMult = _.isArray(models);
            models = (isMult ? models : [models]).filter(i => i).map(model => this.processDef(model));
            models = isMult ? models : models[0];
            return Backbone.Collection.prototype.add.apply(this, [
                models,
                opt
            ]);
        },
        processDef(mdl) {
            if (mdl.cid && mdl.ccid)
                return mdl;
            const {em, config = {}} = this;
            const {processor} = config;
            let model = mdl;
            if (processor) {
                model = { ...model };
                const modelPr = processor(model);
                if (modelPr) {
                    _.each(model, (val, key) => delete model[key]);
                    _.extend(model, modelPr);
                }
            }
            if (model.$$typeof && typeof model.props == 'object') {
                model = { ...model };
                model.props = { ...model.props };
                const domc = em.get('DomComponents');
                const parser = em.get('Parser');
                const {parserHtml} = parser;
                _.each(model, (value, key) => {
                    if (!_.includes([
                            'props',
                            'type'
                        ], key))
                        delete model[key];
                });
                const {props} = model;
                const comps = props.children;
                delete props.children;
                delete model.props;
                const res = parserHtml.splitPropsFromAttr(props);
                model.attributes = res.attrs;
                if (comps) {
                    model.components = comps;
                }
                if (!model.type) {
                    model.type = 'textnode';
                } else if (!domc.getType(model.type)) {
                    model.tagName = model.type;
                    delete model.type;
                }
                _.extend(model, res.props);
            }
            return model;
        },
        onAdd(model, c, opts = {}) {
            const em = this.em;
            const style = model.getStyle();
            const avoidInline = em && em.getConfig('avoidInlineStyle');
            if (!_.isEmpty(style) && !avoidInline && em && em.get && em.getConfig('forceClass') && !opts.temporary) {
                const name = model.cid;
                const rule = em.get('CssComposer').setClassRule(name, style);
                model.setStyle({});
                model.addClass(name);
            }
        }
    });
});
define('trait_manager/model/Trait',[
    'skylark-backbone',
    'skylark-underscore'
], function (Backbone, a) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            type: 'text',
            label: '',
            name: '',
            min: '',
            max: '',
            unit: '',
            step: 1,
            value: '',
            target: '',
            default: '',
            placeholder: '',
            changeProp: 0,
            options: []
        },
        initialize() {
            const target = this.get('target');
            const name = this.get('name');
            const changeProp = this.get('changeProp');
            if (target) {
                this.target = target;
                this.unset('target');
                const targetEvent = changeProp ? `change:${ name }` : `change:attributes:${ name }`;
                this.listenTo(target, targetEvent, this.targetUpdated);
            }
        },
        props() {
            return this.attributes;
        },
        targetUpdated() {
            const value = this.getTargetValue();
            this.set({ value }, { fromTarget: 1 });
        },
        getTargetValue() {
            const name = this.get('name');
            const target = this.target;
            let value;
            if (this.get('changeProp')) {
                value = target.get(name);
            } else {
                value = target.getAttributes()[name];
            }
            return !a.isUndefined(value) ? value : '';
        },
        setTargetValue(value, opts = {}) {
            const target = this.target;
            const name = this.get('name');
            if (a.isUndefined(value))
                return;
            let valueToSet = value;
            if (value === 'false') {
                valueToSet = false;
            } else if (value === 'true') {
                valueToSet = true;
            }
            if (this.get('changeProp')) {
                target.set(name, valueToSet, opts);
            } else {
                const attrs = { ...target.get('attributes') };
                attrs[name] = valueToSet;
                target.set('attributes', attrs, opts);
            }
        },
        setValueFromInput(value, final = 1, opts = {}) {
            const toSet = { value };
            this.set(toSet, {
                ...opts,
                avoidStore: 1
            });
            if (final) {
                this.set('value', '', opts);
                this.set(toSet, opts);
            }
        },
        getInitValue() {
            const target = this.target;
            const name = this.get('name');
            let value;
            if (target) {
                const attrs = target.get('attributes');
                value = this.get('changeProp') ? target.get(name) : attrs[name];
            }
            return value || this.get('value') || this.get('default');
        }
    });
});
define('trait_manager/model/TraitFactory',[],function () {
    'use strict';
    return (config = {}) => ({
        build(props) {
            var objs = [];
            if (typeof props === 'string')
                props = [props];
            for (var i = 0; i < props.length; i++) {
                var obj = {};
                var prop = props[i];
                obj.name = prop;
                switch (prop) {
                case 'target':
                    obj.type = 'select';
                    break;
                }
                switch (prop) {
                case 'target':
                    obj.options = config.optionsTarget;
                    break;
                }
                objs.push(obj);
            }
            return objs;
        }
    });
});
define('trait_manager/model/Traits',[
    'skylark-backbone',
    'skylark-underscore',
    './Trait',
    './TraitFactory'
], function (Backbone, a, Trait, TraitFactory) {
    'use strict';
    return Backbone.Collection.extend({
        model: Trait,
        initialize(coll, options = {}) {
            this.em = options.em || '';
            this.listenTo(this, 'add', this.handleAdd);
            this.listenTo(this, 'reset', this.handleReset);
        },
        handleReset(coll, {
            previousModels = []
        } = {}) {
            previousModels.forEach(model => model.trigger('remove'));
        },
        handleAdd(model) {
            const target = this.target;
            if (target) {
                model.target = target;
            }
        },
        setTarget(target) {
            this.target = target;
        },
        add(models, opt) {
            const em = this.em;
            if (a.isString(models) || a.isArray(models)) {
                const tm = em && em.get && em.get('TraitManager');
                const tmOpts = tm && tm.getConfig();
                const tf = TraitFactory(tmOpts);
                if (a.isString(models)) {
                    models = [models];
                }
                for (var i = 0, len = models.length; i < len; i++) {
                    const str = models[i];
                    const model = a.isString(str) ? tf.build(str)[0] : str;
                    model.target = this.target;
                    models[i] = model;
                }
            }
            return Backbone.Collection.prototype.add.apply(this, [
                models,
                opt
            ]);
        }
    });
});
define('dom_components/model/Component',[
    "skylark-langx/langx",
    'skylark-underscore',
    '../../utils/mixins',
    '../../domain_abstract/model/Styleable',
    'skylark-backbone',
    './Components',
    '../../selector_manager/model/Selector',
    '../../selector_manager/model/Selectors',
    '../../trait_manager/model/Traits'
], function (langx,_, b, Styleable, Backbone, Components, Selector, Selectors, Traits) {
    'use strict';
    const componentList = {};
    let componentIndex = 0;
    const escapeRegExp = str => {
        return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
    };
    const avoidInline = em => em && em.getConfig('avoidInlineStyle');
    const eventDrag = 'component:drag';
    const Component = Backbone.Model.extend(Styleable).extend({
        defaults: {
            tagName: 'div',
            type: '',
            name: '',
            removable: true,
            draggable: true,
            droppable: true,
            badgable: true,
            stylable: true,
            'stylable-require': '',
            'style-signature': '',
            unstylable: '',
            highlightable: true,
            copyable: true,
            resizable: false,
            editable: false,
            layerable: true,
            selectable: true,
            hoverable: true,
            void: false,
            state: '',
            status: '',
            content: '',
            icon: '',
            style: '',
            classes: '',
            script: '',
            'script-export': '',
            attributes: '',
            traits: [
                'id',
                'title'
            ],
            propagate: '',
            dmode: '',
            toolbar: null
        },
        init() {
        },
        updated(property, value, previous) {
        },
        removed() {
        },
        initialize(props = {}, opt = {}) {
            const em = opt.em;
            const parent = this.parent();
            const parentAttr = parent && parent.attributes;
            if (parentAttr && parentAttr.propagate) {
                let newAttr = {};
                const toPropagate = parentAttr.propagate;
                toPropagate.undefined(prop => newAttr[prop] = parent.get(prop));
                newAttr.propagate = toPropagate;
                newAttr = langx.mixin({},newAttr,props);
                this.set(newAttr);
            }
            const propagate = this.get('propagate');
            propagate && this.set('propagate', _.isArray(propagate) ? propagate : [propagate]);
            if (opt && opt.config && opt.config.voidElements.indexOf(this.get('tagName')) >= 0) {
                this.set('void', true);
            }
            opt.em = em;
            this.opt = opt;
            this.em = em;
            this.frame = opt.frame;
            this.config = opt.config || {};
            this.set('attributes', langx.mixin({},this.defaults.attributes ,this.get('attributes') ));
            this.ccid = Component.createId(this);
            this.initClasses();
            this.initTraits();
            this.initComponents();
            this.initToolbar();
            this.listenTo(this, 'change:script', this.scriptUpdated);
            this.listenTo(this, 'change:tagName', this.tagUpdated);
            this.listenTo(this, 'change:attributes', this.attrUpdated);
            this.listenTo(this, 'change:attributes:id', this._idUpdated);
            this.set('status', '');
            this.views = [];
            [
                'classes',
                'traits',
                'components'
            ].undefined(name => {
                const events = `add remove ${ name !== 'components' ? 'change' : '' }`;
                this.listenTo(this.get(name), events.trim(), (...args) => this.emitUpdate(name, ...args));
            });
            if (!opt.temporary) {
                this.init();
                em && em.trigger('component:create', this);
            }
        },
        is(type) {
            return !!(this.get('type') == type);
        },
        props() {
            return this.attributes;
        },
        index() {
            const {collection} = this;
            return collection && collection.indexOf(this);
        },
        setDragMode(value) {
            return this.set('dmode', value);
        },
        find(query) {
            const result = [];
            const $els = this.view.$el.find(query);
            $els.each(i => {
                const $el = $els.eq(i);
                const model = $el.data('model');
                model && result.push(model);
            });
            return result;
        },
        findType(id) {
            const result = [];
            const find = components => components.undefined(item => {
                item.is(id) && result.push(item);
                find(item.components());
            });
            find(this.components());
            return result;
        },
        closest(query) {
            const result = this.view.$el.closest(query);
            return result.length && result.data('model');
        },
        tagUpdated() {
            const coll = this.collection;
            const at = coll.indexOf(this);
            coll.remove(this);
            coll.add(this, { at });
        },
        replaceWith(el) {
            const coll = this.collection;
            const at = coll.indexOf(this);
            coll.remove(this);
            return coll.add(el, { at });
        },
        attrUpdated(m, v, opts = {}) {
            const attrs = this.get('attributes');
            const classes = attrs.class;
            classes && this.setClass(classes);
            delete attrs.class;
            const style = attrs.style;
            style && this.setStyle(style);
            delete attrs.style;
            const attrPrev = { ...this.previous('attributes') };
            const diff = b.shallowDiff(attrPrev, this.get('attributes'));
            _.keys(diff).undefined(pr => this.trigger(`change:attributes:${ pr }`, this, diff[pr], opts));
        },
        setAttributes(attrs, opts = {}) {
            this.set('attributes', { ...attrs }, opts);
            return this;
        },
        addAttributes(attrs) {
            const newAttrs = {
                ...this.getAttributes(),
                ...attrs
            };
            this.setAttributes(newAttrs);
            return this;
        },
        getStyle() {
            const em = this.em;
            if (em && em.getConfig('avoidInlineStyle')) {
                const state = em.get('state');
                const cc = em.get('CssComposer');
                const rule = cc.getIdRule(this.getId(), { state });
                this.rule = rule;
                if (rule) {
                    return rule.getStyle();
                }
            }
            return Styleable.getStyle.call(this);
        },
        setStyle(prop = {}, opts = {}) {
            const em = this.em;
            const {opt} = this;
            if (em && em.getConfig('avoidInlineStyle') && !opt.temporary) {
                const style = this.get('style') || {};
                prop = _.isString(prop) ? this.parseStyle(prop) : prop;
                prop = {
                    ...prop,
                    ...style
                };
                const state = em.get('state');
                const cc = em.get('CssComposer');
                const propOrig = this.getStyle();
                this.rule = cc.setIdRule(this.getId(), prop, {
                    ...opts,
                    state
                });
                const diff = b.shallowDiff(propOrig, prop);
                this.set('style', {}, { silent: 1 });
                _.keys(diff).undefined(pr => this.trigger(`change:style:${ pr }`));
            } else {
                prop = Styleable.setStyle.apply(this, arguments);
            }
            return prop;
        },
        getAttributes() {
            const {em} = this;
            const classes = [];
            const attributes = { ...this.get('attributes') };
            const sm = em && em.get('SelectorManager');
            const id = this.getId();
            this.get('classes').undefined(cls => classes.push(_.isString(cls) ? cls : cls.get('name')));
            classes.length && (attributes.class = classes.join(' '));
            if (!_.has(attributes, 'id')) {
                let hasStyle;
                if (avoidInline(em)) {
                    hasStyle = sm && sm.get(id, sm.Selector.TYPE_ID);
                } else if (!_.isEmpty(this.getStyle())) {
                    hasStyle = 1;
                }
                if (hasStyle) {
                    attributes.id = this.getId();
                }
            }
            return attributes;
        },
        addClass(classes) {
            const added = this.em.get('SelectorManager').addClass(classes);
            return this.get('classes').add(added);
        },
        setClass(classes) {
            this.get('classes').reset();
            return this.addClass(classes);
        },
        removeClass(classes) {
            const removed = [];
            classes = _.isArray(classes) ? classes : [classes];
            const selectors = this.get('classes');
            const type = Selector.TYPE_CLASS;
            classes.undefined(classe => {
                const classes = classe.split(' ');
                classes.undefined(name => {
                    const selector = selectors.where({
                        name,
                        type
                    })[0];
                    selector && removed.push(selectors.remove(selector));
                });
            });
            return removed;
        },
        getClasses() {
            const attr = this.getAttributes();
            const classStr = attr.class;
            return classStr ? classStr.split(' ') : [];
        },
        initClasses() {
            const event = 'change:classes';
            const toListen = [
                this,
                event,
                this.initClasses
            ];
            const cls = this.get('classes') || [];
            const clsArr = _.isString(cls) ? cls.split(' ') : cls;
            this.stopListening(...toListen);
            const classes = this.normalizeClasses(clsArr);
            const selectors = new Selectors([]);
            this.set('classes', selectors);
            selectors.add(classes);
            this.listenTo(...toListen);
            return this;
        },
        initComponents() {
            const event = 'change:components';
            const toListen = [
                this,
                event,
                this.initComponents
            ];
            this.stopListening(...toListen);
            const comps = new Components(null, this.opt);
            comps.parent = this;
            const components = this.get('components');
            const addChild = !this.opt.avoidChildren;
            this.set('components', comps);
            addChild && comps.add(_.isFunction(components) ? components(this) : components);
            this.listenTo(...toListen);
            return this;
        },
        initTraits(changed) {
            const {em} = this;
            const event = 'change:traits';
            const toListen = [
                this,
                event,
                this.initTraits
            ];
            this.stopListening(...toListen);
            this.loadTraits();
            const attrs = { ...this.get('attributes') };
            const traits = this.get('traits');
            traits.each(trait => {
                if (!trait.get('changeProp')) {
                    const name = trait.get('name');
                    const value = trait.getInitValue();
                    if (name && value)
                        attrs[name] = value;
                }
            });
            traits.length && this.set('attributes', attrs);
            this.listenTo(...toListen);
            changed && em && em.trigger('component:toggled');
            return this;
        },
        append(components, opts = {}) {
            const result = this.components().add(components, opts);
            return _.isArray(result) ? result : [result];
        },
        components(components) {
            const coll = this.get('components');
            if (_.isUndefined(components)) {
                return coll;
            } else {
                coll.reset();
                return components && this.append(components);
            }
        },
        parent() {
            const coll = this.collection;
            return coll && coll.parent;
        },
        scriptUpdated() {
            this.set('scriptUpdated', 1);
        },
        initToolbar() {
            const {em} = this;
            const model = this;
            const ppfx = em && em.getConfig('stylePrefix') || '';
            if (!model.get('toolbar')) {
                var tb = [];
                if (model.collection) {
                    tb.push({
                        attributes: { class: 'fa fa-arrow-up' },
                        command: ed => ed.runCommand('core:component-exit', { force: 1 })
                    });
                }
                if (model.get('draggable')) {
                    tb.push({
                        attributes: {
                            class: `fa fa-arrows ${ ppfx }no-touch-actions`,
                            draggable: true
                        },
                        command: 'tlb-move'
                    });
                }
                if (model.get('copyable')) {
                    tb.push({
                        attributes: { class: 'fa fa-clone' },
                        command: 'tlb-clone'
                    });
                }
                if (model.get('removable')) {
                    tb.push({
                        attributes: { class: 'fa fa-trash-o' },
                        command: 'tlb-delete'
                    });
                }
                model.set('toolbar', tb);
            }
        },
        loadTraits(traits, opts = {}) {
            traits = traits || this.get('traits');
            traits = _.isFunction(traits) ? traits(this) : traits;
            if (!(traits instanceof Traits)) {
                const trt = new Traits([], this.opt);
                trt.setTarget(this);
                if (traits.length) {
                    traits.undefined(tr => tr.attributes && delete tr.attributes.value);
                    trt.add(traits);
                }
                this.set('traits', trt, opts);
            }
            return this;
        },
        getTrait(id) {
            return this.get('traits').filter(trait => {
                return trait.get('id') === id || trait.get('name') === id;
            })[0];
        },
        updateTrait(id, props) {
            const {em} = this;
            const trait = this.getTrait(id);
            trait && trait.set(props);
            em && em.trigger('component:toggled');
            return this;
        },
        getTraitIndex(id) {
            const trait = this.getTrait(id);
            return trait ? this.get('traits').indexOf(trait) : trait;
        },
        removeTrait(id) {
            const {em} = this;
            const ids = _.isArray(id) ? id : [id];
            const toRemove = ids.map(id => this.getTrait(id));
            const removed = this.get('traits').remove(toRemove);
            em && em.trigger('component:toggled');
            return removed;
        },
        addTrait(trait, opts = {}) {
            const {em} = this;
            const added = this.get('traits').add(trait, opts);
            em && em.trigger('component:toggled');
            return added;
        },
        normalizeClasses(arr) {
            var res = [];
            const em = this.em;
            if (!em)
                return;
            var clm = em.get('SelectorManager');
            if (!clm)
                return;
            arr.undefined(val => {
                var name = '';
                if (typeof val === 'string')
                    name = val;
                else
                    name = val.name;
                var model = clm.add(name);
                res.push(model);
            });
            return res;
        },
        clone() {
            const em = this.em;
            const style = this.getStyle();
            const attr = { ...this.attributes };
            const opts = { ...this.opt };
            attr.attributes = { ...attr.attributes };
            delete attr.attributes.id;
            attr.components = [];
            attr.classes = [];
            attr.traits = [];
            this.get('components').each((md, i) => {
                attr.components[i] = md.clone();
            });
            this.get('traits').each((md, i) => {
                attr.traits[i] = md.clone();
            });
            this.get('classes').each((md, i) => {
                attr.classes[i] = md.get('name');
            });
            attr.status = '';
            attr.view = '';
            opts.collection = null;
            if (em && em.getConfig('avoidInlineStyle') && !_.isEmpty(style)) {
                attr.style = style;
            }
            const cloned = new this.constructor(attr, opts);
            const event = 'component:clone';
            em && em.trigger(event, cloned);
            this.trigger(event, cloned);
            return cloned;
        },
        getName() {
            const {em} = this;
            const {type, tagName} = this.attributes;
            const cName = this.get('name');
            const isDiv = tagName == 'div';
            const tag = isDiv ? 'box' : tagName;
            const defName = type || tag;
            const nameTag = !type && tagName && !isDiv && tagName;
            const i18nPfx = 'domComponents.names.';
            const i18nName = cName && em && em.t(`${ i18nPfx }${ cName }`);
            const i18nNameTag = nameTag && em && em.t(`${ i18nPfx }${ nameTag }`);
            const i18nDefName = em && (em.t(`${ i18nPfx }${ type }`) || em.t(`${ i18nPfx }${ tagName }`));
            return this.get('custom-name') || i18nName || cName || i18nNameTag || b.capitalize(nameTag) || i18nDefName || b.capitalize(defName);
        },
        getIcon() {
            let icon = this.get('icon');
            return icon ? icon + ' ' : '';
        },
        toHTML(opts = {}) {
            const model = this;
            const attrs = [];
            const customTag = opts.tag;
            const tag = customTag || model.get('tagName');
            const sTag = model.get('void');
            const customAttr = opts.attributes;
            let attributes = this.getAttrToHTML();
            delete opts.tag;
            if (customAttr) {
                if (_.isFunction(customAttr)) {
                    attributes = customAttr(model, attributes) || {};
                } else if (_.isObject(customAttr)) {
                    attributes = customAttr;
                }
            }
            for (let attr in attributes) {
                const val = attributes[attr];
                const value = _.isString(val) ? val.replace(/"/g, '&quot;') : val;
                if (!_.isUndefined(value)) {
                    if (_.isBoolean(value)) {
                        value && attrs.push(attr);
                    } else {
                        attrs.push(`${ attr }="${ value }"`);
                    }
                }
            }
            let attrString = attrs.length ? ` ${ attrs.join(' ') }` : '';
            let code = `<${ tag }${ attrString }${ sTag ? '/' : '' }>${ model.get('content') }`;
            model.get('components').each(comp => code += comp.toHTML(opts));
            !sTag && (code += `</${ tag }>`);
            return code;
        },
        getAttrToHTML() {
            var attr = this.getAttributes();
            delete attr.style;
            return attr;
        },
        toJSON(...args) {
            const obj = Backbone.Model.prototype.toJSON.apply(this, args);
            obj.attributes = this.getAttributes();
            delete obj.attributes.class;
            delete obj.toolbar;
            delete obj.traits;
            if (this.em.getConfig('avoidDefaults')) {
                const defaults = _.result(this, 'defaults');
                _.forEach(defaults, (value, key) => {
                    if ([
                            'type',
                            'content'
                        ].indexOf(key) === -1 && obj[key] === value) {
                        delete obj[key];
                    }
                });
                if (_.isEmpty(obj.type)) {
                    delete obj.type;
                }
                _.forEach([
                    'attributes',
                    'style'
                ], prop => {
                    if (_.isEmpty(defaults[prop]) && _.isEmpty(obj[prop])) {
                        delete obj[prop];
                    }
                });
                _.forEach([
                    'classes',
                    'components'
                ], prop => {
                    if (_.isEmpty(defaults[prop]) && !obj[prop].length) {
                        delete obj[prop];
                    }
                });
            }
            return obj;
        },
        getId() {
            let attrs = this.get('attributes') || {};
            return attrs.id || this.ccid || this.cid;
        },
        setId(id, opts) {
            const attrs = { ...this.get('attributes') };
            attrs.id = id;
            this.set('attributes', attrs, opts);
            return this;
        },
        getEl(frame) {
            const view = this.getView(frame);
            return view && view.el;
        },
        getView(frame) {
            let {view, views} = this;
            if (frame) {
                view = views.filter(view => view._getFrame() === frame.view)[0];
            }
            return view;
        },
        getCurrentView() {
            const frame = (this.em.get('currentFrame') || {}).model;
            return this.getView(frame);
        },
        getScriptString(script) {
            var scr = script || this.get('script');
            if (!scr) {
                return scr;
            }
            if (typeof scr == 'function') {
                var scrStr = scr.toString().trim();
                scrStr = scrStr.replace(/^function[\s\w]*\(\)\s?\{/, '').replace(/\}$/, '');
                scr = scrStr.trim();
            }
            var config = this.em.getConfig();
            var tagVarStart = escapeRegExp(config.tagVarStart || '{[ ');
            var tagVarEnd = escapeRegExp(config.tagVarEnd || ' ]}');
            var reg = new RegExp(`${ tagVarStart }([\\w\\d-]*)${ tagVarEnd }`, 'g');
            scr = scr.replace(reg, (match, v) => {
                this.scriptUpdated();
                const result = this.attributes[v] || '';
                return _.isArray(result) || typeof result == 'object' ? JSON.stringify(result) : result;
            });
            return scr;
        },
        emitUpdate(property, ...args) {
            const em = this.em;
            const event = 'component:update' + (property ? `:${ property }` : '');
            property && this.updated(property, property && this.get(property), property && this.previous(property), ...args);
            this.trigger(event, ...args);
            em && em.trigger(event, this, ...args);
        },
        onAll(clb) {
            if (_.isFunction(clb)) {
                clb(this);
                this.components().undefined(model => model.onAll(clb));
            }
            return this;
        },
        remove() {
            const coll = this.collection;
            return coll && coll.remove(this);
        },
        resetId(opts = {}) {
            const {em} = this;
            const oldId = this.getId();
            if (!oldId)
                return;
            const newId = Component.createId(this);
            this.setId(newId);
            const rule = em && em.get('CssComposer').getIdRule(oldId);
            const selector = rule && rule.get('selectors').at(0);
            selector && selector.set('name', newId);
            return this;
        },
        _getStyleRule({id} = {}) {
            const {em} = this;
            const idS = id || this.getId();
            return em && em.get('CssComposer').getIdRule(idS);
        },
        _getStyleSelector(opts) {
            const rule = this._getStyleRule(opts);
            return rule && rule.get('selectors').at(0);
        },
        _idUpdated(m, v, opts = {}) {
            if (opts.idUpdate)
                return;
            const {ccid} = this;
            const {id} = this.get('attributes') || {};
            const idPrev = (this.previous('attributes') || {}).id || ccid;
            const list = Component.getList(this);
            if (list[id]) {
                return this.setId(idPrev, { idUpdate: 1 });
            }
            delete list[idPrev];
            list[id] = this;
            this.ccid = id;
            const selector = this._getStyleSelector({ id: idPrev });
            selector && selector.set({
                name: id,
                label: id
            });
        }
    }, {
        isComponent(el) {
            return { tagName: el.tagName ? el.tagName.toLowerCase() : '' };
        },
        createId(model) {
            const list = Component.getList(model);
            let {id} = model.get('attributes');
            let nextId;
            if (id) {
                nextId = Component.getIncrementId(id, list);
                model.setId(nextId);
            } else {
                nextId = Component.getNewId(list);
            }
            list[nextId] = model;
            return nextId;
        },
        getNewId(list) {
            const count = Object.undefined(list).length;
            const ilen = count.toString().length + 2;
            const uid = (Math.random() + 1.1).toString(36).slice(-ilen);
            let newId = `i${ uid }`;
            while (list[newId]) {
                newId = Component.getNewId(list);
            }
            return newId;
        },
        getIncrementId(id, list) {
            let counter = 1;
            let newId = id;
            while (list[newId]) {
                counter++;
                newId = `${ id }-${ counter }`;
            }
            return newId;
        },
        getList(model) {
            const domc = model.opt && model.opt.domc;
            return domc ? domc.componentsById : {};
        },
        checkId(components, styles = [], list = {}) {
            const comps = _.isArray(components) ? components : [components];
            comps.undefined(comp => {
                const {attributes = {}, components} = comp;
                const {id} = attributes;
                if (id && list[id]) {
                    const newId = Component.getIncrementId(id, list);
                    attributes.id = newId;
                    _.isArray(styles) && styles.undefined(style => {
                        const {selectors} = style;
                        selectors.undefined((sel, idx) => {
                            if (sel === `#${ id }`)
                                selectors[idx] = `#${ newId }`;
                        });
                    });
                }
                components && Component.checkId(components, styles, list);
            });
        }
    });
    
    Component.eventDrag = eventDrag;
    
    return Component;
});
define('skylark-grapejs/commands/index',[
    'skylark-underscore',
    './view/CommandAbstract',
    './config/config',
    '../../dom_components/model/Component'
], function (a, CommandAbstract, defaults, b) {
    'use strict';
    return () => {
        let em;
        let c = {};
        const commands = {};
        const defaultCommands = {};
        const active = {};
        const commandsDef = [
            [
                'preview',
                'Preview',
                'preview'
            ],
            [
                'resize',
                'Resize',
                'resize'
            ],
            [
                'fullscreen',
                'Fullscreen',
                'fullscreen'
            ],
            [
                'copy',
                'CopyComponent'
            ],
            [
                'paste',
                'PasteComponent'
            ],
            [
                'canvas-move',
                'CanvasMove'
            ],
            [
                'canvas-clear',
                'CanvasClear'
            ],
            [
                'open-code',
                'ExportTemplate',
                'export-template'
            ],
            [
                'open-layers',
                'OpenLayers',
                'open-layers'
            ],
            [
                'open-styles',
                'OpenStyleManager',
                'open-sm'
            ],
            [
                'open-traits',
                'OpenTraitManager',
                'open-tm'
            ],
            [
                'open-blocks',
                'OpenBlocks',
                'open-blocks'
            ],
            [
                'open-assets',
                'OpenAssets',
                'open-assets'
            ],
            [
                'component-select',
                'SelectComponent',
                'select-comp'
            ],
            [
                'component-outline',
                'SwitchVisibility',
                'sw-visibility'
            ],
            [
                'component-offset',
                'ShowOffset',
                'show-offset'
            ],
            [
                'component-move',
                'MoveComponent',
                'move-comp'
            ],
            [
                'component-next',
                'ComponentNext'
            ],
            [
                'component-prev',
                'ComponentPrev'
            ],
            [
                'component-enter',
                'ComponentEnter'
            ],
            [
                'component-exit',
                'ComponentExit',
                'select-parent'
            ],
            [
                'component-delete',
                'ComponentDelete'
            ],
            [
                'component-style-clear',
                'ComponentStyleClear'
            ],
            [
                'component-drag',
                'ComponentDrag'
            ]
        ];
        const add = function (id, obj) {
            if (a.isFunction(obj))
                obj = { run: obj };
            if (!obj.stop)
                obj.noStop = 1;
            delete obj.initialize;
            obj.id = id;
            commands[id] = CommandAbstract.extend(obj);
            return this;
        };
        return {
            CommandAbstract,
            name: 'Commands',
            init(config = {}) {
                c = {
                    ...defaults,
                    ...config
                };
                em = c.em;
                const ppfx = c.pStylePrefix;
                if (ppfx)
                    c.stylePrefix = ppfx + c.stylePrefix;
                for (let k in c.defaults) {
                    const obj = c.defaults[k];
                    if (obj.id)
                        this.add(obj.id, obj);
                }
                defaultCommands['tlb-delete'] = {
                    run(ed) {
                        return ed.runCommand('core:component-delete');
                    }
                };
                defaultCommands['tlb-clone'] = {
                    run(ed) {
                        ed.runCommand('core:copy');
                        ed.runCommand('core:paste');
                    }
                };
                defaultCommands['tlb-move'] = {
                    run(ed, sender, opts = {}) {
                        let dragger;
                        const em = ed.getModel();
                        const event = opts && opts.event;
                        const {target} = opts;
                        const sel = target || ed.getSelected();
                        const selAll = target ? [target] : [...ed.getSelectedAll()];
                        const nativeDrag = event && event.type == 'dragstart';
                        const defComOptions = { preserveSelected: 1 };
                        const modes = [
                            'absolute',
                            'translate'
                        ];
                        const mode = sel.get('dmode') || em.get('dmode');
                        const hideTlb = () => em.stopDefault(defComOptions);
                        const altMode = a.includes(modes, mode);
                        selAll.forEach(sel => sel.trigger('disable'));
                        if (!sel || !sel.get('draggable')) {
                            return em.logWarning('The element is not draggable');
                        }
                        nativeDrag ? setTimeout(hideTlb, 0) : hideTlb();
                        const onStart = data => {
                            em.trigger(`${ b.eventDrag }:start`, data);
                        };
                        const onDrag = data => {
                            em.trigger(b.eventDrag, data);
                        };
                        const onEnd = (e, opts, data) => {
                            em.runDefault(defComOptions);
                            selAll.forEach(sel => sel.set('status', 'selected'));
                            ed.select(selAll);
                            sel.emitUpdate();
                            em.trigger(`${ b.eventDrag }:end`, data);
                            (altMode || data.cancelled) && em.set('_cmpDrag', 1);
                        };
                        if (altMode) {
                            dragger = ed.runCommand('core:component-drag', {
                                guidesInfo: 1,
                                mode,
                                target: sel,
                                onStart,
                                onDrag,
                                onEnd,
                                event
                            });
                        } else {
                            if (nativeDrag) {
                                event.dataTransfer.setDragImage(sel.view.el, 0, 0);
                            }
                            const cmdMove = ed.Commands.get('move-comp');
                            cmdMove.onStart = onStart;
                            cmdMove.onDrag = onDrag;
                            cmdMove.onEndMoveFromModel = onEnd;
                            cmdMove.initSorterFromModels(selAll);
                        }
                        selAll.forEach(sel => sel.set('status', 'freezed-selected'));
                    }
                };
                defaultCommands['core:undo'] = e => e.UndoManager.undo();
                defaultCommands['core:redo'] = e => e.UndoManager.redo();
                commandsDef.forEach(item => {
                    const oldCmd = item[2];
                    const cmd = require(`./view/${ item[1] }`).default;
                    const cmdName = `core:${ item[0] }`;
                    defaultCommands[cmdName] = cmd;
                    if (oldCmd) {
                        defaultCommands[oldCmd] = cmd;
                        [
                            'run',
                            'stop'
                        ].forEach(name => {
                            em.on(`${ name }:${ oldCmd }`, (...args) => em.trigger(`${ name }:${ cmdName }`, ...args));
                        });
                    }
                });
                if (c.em)
                    c.model = c.em.get('Canvas');
                this.loadDefaultCommands();
                return this;
            },
            add,
            get(id) {
                let el = commands[id];
                if (a.isFunction(el)) {
                    el = new el(c);
                    commands[id] = el;
                } else if (!el) {
                    em.logWarning(`'${ id }' command not found`);
                }
                return el;
            },
            extend(id, cmd = {}) {
                const command = this.get(id);
                if (command) {
                    const cmdObj = {
                        ...command.constructor.prototype,
                        ...cmd
                    };
                    this.add(id, cmdObj);
                    const oldCmd = commandsDef.filter(cmd => `core:${ cmd[0] }` === id && cmd[2])[0];
                    oldCmd && this.add(oldCmd[2], cmdObj);
                }
                return this;
            },
            has(id) {
                return !!commands[id];
            },
            getAll() {
                return commands;
            },
            run(id, options = {}) {
                return this.runCommand(this.get(id), options);
            },
            stop(id, options = {}) {
                return this.stopCommand(this.get(id), options);
            },
            isActive(id) {
                return this.getActive().hasOwnProperty(id);
            },
            getActive() {
                return active;
            },
            loadDefaultCommands() {
                for (var id in defaultCommands) {
                    this.add(id, defaultCommands[id]);
                }
                return this;
            },
            runCommand(command, options = {}) {
                let result;
                if (command && command.run) {
                    const id = command.id;
                    const editor = em.get('Editor');
                    if (!this.isActive(id) || options.force || !c.strict) {
                        result = command.callRun(editor, options);
                        if (id && command.stop && !command.noStop && !options.abort) {
                            active[id] = result;
                        }
                    }
                }
                return result;
            },
            stopCommand(command, options = {}) {
                let result;
                if (command && command.run) {
                    const id = command.id;
                    const editor = em.get('Editor');
                    if (this.isActive(id) || options.force || !c.strict) {
                        if (id)
                            delete active[id];
                        result = command.callStop(editor, options);
                    }
                }
                return result;
            },
            create(command) {
                if (!command.stop)
                    command.noStop = 1;
                const cmd = CommandAbstract.extend(command);
                return new cmd(c);
            }
        };
    };
});
define('skylark-grapejs/block_manager/config/config',[],function () {
    'use strict';
    return {
        appendTo: '',
        appendOnClick: 0,
        blocks: []
    };
});
define('skylark-grapejs/block_manager/model/Category',[
	'skylark-backbone'
], function (Backbone) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            id: '',
            label: '',
            open: true,
            attributes: {}
        }
    });
});
define('skylark-grapejs/block_manager/model/Block',[
    'skylark-backbone',
    './Category'
], function (Backbone, Category) {
    'use strict';
    return Backbone.Model.extend({
        defaults: {
            activate: 0,
            select: 0,
            resetId: 0,
            label: '',
            media: '',
            content: '',
            category: '',
            attributes: {}
        },
        initialize(opts = {}) {
            let category = this.get('category');
            if (category) {
                if (typeof category == 'string') {
                    var catObj = new Category({
                        id: category,
                        label: category
                    });
                }
            }
        }
    });
});
define('skylark-grapejs/block_manager/model/Blocks',[
    'skylark-backbone',
    './Block'
], function (Backbone, Block) {
    'use strict';
    return Backbone.Collection.extend({ model: Block });
});
define('skylark-grapejs/block_manager/model/Categories',[
    'skylark-backbone',
    './Category'
], function (Backbone, Category) {
    'use strict';
    return Backbone.Collection.extend({ model: Category });
});
define('skylark-grapejs/block_manager/view/BlockView',[
    'skylark-backbone',
    'skylark-underscore',
    '../../utils/mixins'
], function (Backbone, _, mixins) {
    'use strict';
    return Backbone.View.extend({
        events: {
            click: 'handleClick',
            mousedown: 'startDrag',
            dragstart: 'handleDragStart',
            drag: 'handleDrag',
            dragend: 'handleDragEnd'
        },
        initialize(o, config = {}) {
            const {model} = this;
            this.em = config.em;
            this.config = config;
            this.endDrag = this.endDrag.bind(this);
            this.ppfx = config.pStylePrefix || '';
            this.listenTo(model, 'destroy remove', this.remove);
            this.listenTo(model, 'change', this.render);
        },
        handleClick() {
            const {config, model, em} = this;
            if (!config.appendOnClick)
                return;
            const sorter = config.getSorter();
            const content = model.get('content');
            const selected = em.getSelected();
            sorter.setDropContent(content);
            let target, valid;
            if (selected) {
                valid = sorter.validTarget(selected.getEl(), content);
                if (valid.valid) {
                    target = selected;
                } else {
                    const parent = selected.parent();
                    valid = sorter.validTarget(parent.getEl(), content);
                    if (valid.valid)
                        target = parent;
                }
            }
            if (!target) {
                const wrapper = em.getWrapper();
                valid = sorter.validTarget(wrapper.getEl(), content);
                if (valid.valid)
                    target = wrapper;
            }
            const result = target && target.append(content)[0];
            result && em.setSelected(result, { scroll: 1 });
        },
        startDrag(e) {
            const {config, em} = this;
            if (e.button !== 0 || !config.getSorter || this.el.draggable)
                return;
            em.refreshCanvas();
            const sorter = config.getSorter();
            sorter.setDragHelper(this.el, e);
            sorter.setDropContent(this.model.get('content'));
            sorter.startSort(this.el);
            mixins.on(document, 'mouseup', this.endDrag);
        },
        handleDragStart(ev) {
            const {em, model} = this;
            const content = model.get('content');
            const isObj = _.isObject(content);
            const data = isObj ? JSON.stringify(content) : content;
            em.set('dragResult');
            ev.dataTransfer.setData('text', data);
            em.set('dragContent', content);
            em.trigger('block:drag:start', model, ev);
        },
        handleDrag(ev) {
            this.em.trigger('block:drag', this.model, ev);
        },
        handleDragEnd() {
            const {em, model} = this;
            const result = em.get('dragResult');
            if (result) {
                const oldKey = 'activeOnRender';
                const oldActive = result.get && result.get(oldKey);
                if (model.get('activate') || oldActive) {
                    result.trigger('active');
                    result.set(oldKey, 0);
                }
                if (model.get('select')) {
                    em.setSelected(result);
                }
                if (model.get('resetId')) {
                    result.onAll(model => model.resetId());
                }
            }
            em.set({
                dragResult: null,
                dragContent: null
            });
            em.trigger('block:drag:stop', result, model);
        },
        endDrag(e) {
            mixins.off(document, 'mouseup', this.endDrag);
            const sorter = this.config.getSorter();
            sorter.moved = 0;
            sorter.endMove();
        },
        render() {
            const {em, el, ppfx, model} = this;
            const className = `${ ppfx }block`;
            const label = em && em.t(`blockManager.labels.${ model.id }`) || model.get('label');
            const render = model.get('render');
            const media = model.get('media');
            el.className += ` ${ className } ${ ppfx }one-bg ${ ppfx }four-color-h`;
            el.innerHTML = `
      ${ media ? `<div class="${ className }__media">${ media }</div>` : '' }
      <div class="${ className }-label">${ label }</div>
    `;
            el.title = el.textContent.trim();
            mixins.hasDnd(em) && el.setAttribute('draggable', true);
            const result = render && render({
                el,
                model,
                className,
                prefix: ppfx
            });
            if (result)
                el.innerHTML = result;
            return this;
        }
    });
});
define('skylark-grapejs/block_manager/view/CategoryView',[
    'skylark-underscore',
    'skylark-backbone'
], function (_, Backbone) {
    'use strict';
    return Backbone.View.extend({
        template: _.template(`
  <div class="<%= pfx %>title">
    <i class="<%= pfx %>caret-icon"></i>
    <%= label %>
  </div>
  <div class="<%= pfx %>blocks-c"></div>
  `),
        events: {},
        initialize(o = {}, config = {}) {
            this.config = config;
            const pfx = config.pStylePrefix || '';
            this.em = config.em;
            this.pfx = pfx;
            this.caretR = 'fa fa-caret-right';
            this.caretD = 'fa fa-caret-down';
            this.iconClass = `${ pfx }caret-icon`;
            this.activeClass = `${ pfx }open`;
            this.className = `${ pfx }block-category`;
            this.events[`click .${ pfx }title`] = 'toggle';
            this.listenTo(this.model, 'change:open', this.updateVisibility);
            this.delegateEvents();
        },
        updateVisibility() {
            if (this.model.get('open'))
                this.open();
            else
                this.close();
        },
        open() {
            this.el.className = `${ this.className } ${ this.activeClass }`;
            this.getIconEl().className = `${ this.iconClass } ${ this.caretD }`;
            this.getBlocksEl().style.display = '';
        },
        close() {
            this.el.className = this.className;
            this.getIconEl().className = `${ this.iconClass } ${ this.caretR }`;
            this.getBlocksEl().style.display = 'none';
        },
        toggle() {
            var model = this.model;
            model.set('open', !model.get('open'));
        },
        getIconEl() {
            if (!this.iconEl) {
                this.iconEl = this.el.querySelector('.' + this.iconClass);
            }
            return this.iconEl;
        },
        getBlocksEl() {
            if (!this.blocksEl) {
                this.blocksEl = this.el.querySelector('.' + this.pfx + 'blocks-c');
            }
            return this.blocksEl;
        },
        append(el) {
            this.getBlocksEl().appendChild(el);
        },
        render() {
            const {em, el, $el, model} = this;
            const label = em.t(`blockManager.categories.${ model.id }`) || model.get('label');
            el.innerHTML = this.undefined({
                pfx: this.pfx,
                label
            });
            el.className = this.className;
            $el.css({ order: model.get('order') });
            this.updateVisibility();
            return this;
        }
    });
});
define('skylark-grapejs/block_manager/view/BlocksView',[
    'skylark-backbone',
    'skylark-underscore',
    './BlockView',
    './CategoryView'
], function (Backbone, _, BlockView, CategoryView) {
    'use strict';
    return Backbone.View.extend({
        initialize(opts, config) {
            _.bindAll(this, 'getSorter', 'onDrag', 'onDrop');
            this.config = config || {};
            this.categories = opts.categories || '';
            this.renderedCategories = [];
            var ppfx = this.config.pStylePrefix || '';
            this.ppfx = ppfx;
            this.noCatClass = `${ ppfx }blocks-no-cat`;
            this.blockContClass = `${ ppfx }blocks-c`;
            this.catsClass = `${ ppfx }block-categories`;
            const coll = this.collection;
            this.listenTo(coll, 'add', this.addTo);
            this.listenTo(coll, 'reset', this.render);
            this.em = this.config.em;
            this.tac = 'test-tac';
            this.grabbingCls = this.ppfx + 'grabbing';
            if (this.em) {
                this.config.getSorter = this.getSorter;
                this.canvas = this.em.get('Canvas');
            }
        },
        updateConfig(opts = {}) {
            this.config = {
                ...this.config,
                ...opts
            };
        },
        getSorter() {
            if (!this.em)
                return;
            if (!this.sorter) {
                var utils = this.em.get('Utils');
                var canvas = this.canvas;
                this.sorter = new utils.Sorter({
                    container: canvas.getBody(),
                    placer: canvas.getPlacerEl(),
                    containerSel: '*',
                    itemSel: '*',
                    pfx: this.ppfx,
                    onStart: this.onDrag,
                    onEndMove: this.onDrop,
                    onMove: this.onMove,
                    document: canvas.getFrameEl().contentDocument,
                    direction: 'a',
                    wmargin: 1,
                    nested: 1,
                    em: this.em,
                    canvasRelative: 1
                });
            }
            return this.sorter;
        },
        onDrag(e) {
            this.em.stopDefault();
            this.em.trigger('block:drag:start', e);
        },
        onMove(e) {
            this.em.trigger('block:drag:move', e);
        },
        onDrop(model) {
            const em = this.em;
            em.runDefault();
            if (model && model.get) {
                if (model.get('activeOnRender')) {
                    model.trigger('active');
                    model.set('activeOnRender', 0);
                }
                em.trigger('block:drag:stop', model);
            }
        },
        addTo(model) {
            this.add(model);
        },
        add(model, fragment) {
            const {config} = this;
            var frag = fragment || null;
            var view = new BlockView({
                model,
                attributes: model.get('attributes')
            }, config);
            var rendered = view.render().el;
            var category = model.get('category');
            if (category && this.categories && !config.ignoreCategories) {
                if (_.isString(category)) {
                    category = {
                        id: category,
                        label: category
                    };
                } else if (_.isObject(category) && !category.id) {
                    category.id = category.label;
                }
                var catModel = this.categories.add(category);
                var catId = catModel.get('id');
                var catView = this.renderedCategories[catId];
                var categories = this.getCategoriesEl();
                model.set('category', catModel);
                if (!catView && categories) {
                    catView = new CategoryView({ model: catModel }, this.config).render();
                    this.renderedCategories[catId] = catView;
                    categories.appendChild(catView.el);
                }
                catView && catView.append(rendered);
                return;
            }
            if (frag)
                frag.appendChild(rendered);
            else
                this.append(rendered);
        },
        getCategoriesEl() {
            if (!this.catsEl) {
                this.catsEl = this.el.querySelector(`.${ this.catsClass }`);
            }
            return this.catsEl;
        },
        getBlocksEl() {
            if (!this.blocksEl) {
                this.blocksEl = this.el.querySelector(`.${ this.noCatClass } .${ this.blockContClass }`);
            }
            return this.blocksEl;
        },
        append(el) {
            let blocks = this.getBlocksEl();
            blocks && blocks.appendChild(el);
        },
        render() {
            const ppfx = this.ppfx;
            const frag = document.createDocumentFragment();
            this.catsEl = null;
            this.blocksEl = null;
            this.renderedCategories = [];
            this.el.innerHTML = `
      <div class="${ this.catsClass }"></div>
      <div class="${ this.noCatClass }">
        <div class="${ this.blockContClass }"></div>
      </div>
    `;
            this.collection.each(model => this.add(model, frag));
            this.append(frag);
            const cls = `${ this.blockContClass }s ${ ppfx }one-bg ${ ppfx }two-color`;
            this.$el.addClass(cls);
            return this;
        }
    });
});
define('skylark-grapejs/block_manager/index',[
    'skylark-underscore',
    './config/config',
    './model/Blocks',
    './model/Categories',
    './view/BlocksView'
], function (a, defaults, Blocks, BlockCategories, BlocksView) {
    'use strict';
    return () => {
        var c = {};
        var blocks, blocksVisible, blocksView;
        var categories = [];
        return {
            name: 'BlockManager',
            init(config) {
                c = config || {};
                const em = c.em;
                for (let name in defaults) {
                    if (!(name in c)) {
                        c[name] = defaults[name];
                    }
                }
                blocks = new Blocks([]);
                blocksVisible = new Blocks([]);
                categories = new BlockCategories();
                blocksView = new BlocksView({
                    collection: blocksVisible,
                    categories
                }, c);
                blocks.listenTo(blocks, 'add', model => {
                    blocksVisible.add(model);
                    em && em.trigger('block:add', model);
                });
                blocks.listenTo(blocks, 'remove', model => {
                    blocksVisible.remove(model);
                    em && em.trigger('block:remove', model);
                });
                blocks.listenTo(blocks, 'reset', coll => {
                    blocksVisible.reset(coll.models);
                });
                return this;
            },
            getConfig() {
                return c;
            },
            onLoad() {
                const blocks = this.getAll();
                !blocks.length && blocks.reset(c.blocks);
            },
            postRender() {
                const elTo = this.getConfig().appendTo;
                if (elTo) {
                    const el = a.isElement(elTo) ? elTo : document.querySelector(elTo);
                    el.appendChild(this.render());
                }
            },
            add(id, opts) {
                var obj = opts || {};
                obj.id = id;
                return blocks.add(obj);
            },
            get(id) {
                return blocks.get(id);
            },
            getAll() {
                return blocks;
            },
            getAllVisible() {
                return blocksVisible;
            },
            remove(id) {
                return blocks.remove(id);
            },
            getCategories() {
                return categories;
            },
            getContainer() {
                return blocksView.el;
            },
            render(blocks, opts = {}) {
                const toRender = blocks || this.getAll().models;
                if (opts.external) {
                    return new BlocksView({
                        collection: new Blocks(toRender),
                        categories
                    }, {
                        ...c,
                        ...opts
                    }).render().el;
                }
                if (!blocksView.rendered) {
                    blocksView.render();
                    blocksView.rendered = 1;
                }
                blocksView.updateConfig(opts);
                blocksView.collection.reset(toRender);
                return this.getContainer();
            }
        };
    };
});
define('skylark-grapejs/editor/model/Editor',[
    "skylark-langx",
    'skylark-underscore',
    'skylark-jquery',
    'skylark-backbone',
    '../../utils/extender',
    '../../utils/mixins',
    "../../utils/index",
    "../../i18n/index",
    "../../keymaps/index",
    "../../undo_manager/index",
    "../../storage_manager/index",
    "../../device_manager/index",
    "../../parser/index",
    "../../selector_manager/index",
    "../../style_manager/index",
    "../../modal_dialog/index",
    "../../code_manager/index",
    "../../panels/index",
    "../../rich_text_editor/index",
    "../../asset_manager/index",
    "../../css_composer/index",
    "../../trait_manager/index",
    "../../dom_components/index",
    "../../navigator/index",
    "../../canvas/index",
    "../../commands/index",
    "../../block_manager/index"
], function (langx,_, $, Backbone, Extender, b,
    _utils,
    _i18n,
    _keymaps,
    _undo_manager,
    _storage_manager,
    _device_manager,
    _parser,
    _selector_manager,
    _style_manager,
    _modal_dialog,
    _code_manager,
    _panels,
    _rich_text_editor,
    _asset_manager,
    _css_composer,
    _trait_manager,
    _dom_components,
    _navigator,
    _canvas,
    _commands,
    _block_manager
) {
    'use strict';
    Backbone.$ = $;
    const deps = [
        _utils,
        _i18n,
        _keymaps,
        _undo_manager,
        _storage_manager,
        _device_manager,
        _parser,
        _selector_manager,
        _style_manager,
        _modal_dialog,
        _code_manager,
        _panels,
        _rich_text_editor,
        _asset_manager,
        _css_composer,
        _trait_manager,
        _dom_components,
        _navigator,
        _canvas,
        _commands,
        _block_manager
    ];
    const {Collection} = Backbone;
    let timedInterval;
    let updateItr;
    Extender({
        Backbone: Backbone,
        $: Backbone.$
    });
    const logs = {
        debug: console.log,
        info: console.info,
        warning: console.warn,
        error: console.error
    };
    return Backbone.Model.extend({
        defaults() {
            return {
                editing: 0,
                selected: new Collection(),
                clipboard: null,
                dmode: 0,
                componentHovered: null,
                previousModel: null,
                changesCount: 0,
                storables: [],
                modules: [],
                toLoad: [],
                opened: {},
                device: ''
            };
        },
        initialize(c = {}) {
            this.config = c;
            this.set('Config', c);
            this.set('modules', []);
            this.set('toLoad', []);
            this.set('storables', []);
            this.set('dmode', c.dragMode);
            const el = c.el;
            const log = c.log;
            const toLog = log === true ? _.keys(logs) : _.isArray(log) ? log : [];
            _.bindAll(this, 'initBaseColorPicker');
            if (el && c.fromElement)
                this.config.components = el.innerHTML;
            this.attrsOrig = el ? _.toArray(el.attributes).reduce((res, next) => {
                res[next.nodeName] = next.nodeValue;
                return res;
            }, {}) : '';
            deps.forEach(name => this.loadModule(name));
            this.on('change:componentHovered', this.componentHovered, this);
            this.on('change:changesCount', this.updateChanges, this);
            toLog.forEach(e => this.listenLog(e));
            [{
                    from: 'change:selectedComponent',
                    to: 'component:toggled'
                }].forEach(event => {
                const eventFrom = event.from;
                const eventTo = event.to;
                this.listenTo(this, eventFrom, (...args) => {
                    this.trigger(eventTo, ...args);
                    this.logWarning(`The event '${ eventFrom }' is deprecated, replace it with '${ eventTo }'`);
                });
            });
        },
        getContainer() {
            return this.config.el;
        },
        listenLog(event) {
            this.listenTo(this, `log:${ event }`, logs[event]);
        },
        getConfig(prop) {
            const config = this.config;
            return _.isUndefined(prop) ? config : config[prop];
        },
        loadOnStart(clb = null) {
            const sm = this.get('StorageManager');
            this.get('toLoad').forEach(module => {
                module.onLoad();
            });
            const postLoad = () => {
                const modules = this.get('modules');
                modules.forEach(module => module.postLoad && module.postLoad(this));
                clb && clb();
            };
            if (sm && sm.canAutoload()) {
                this.load(postLoad);
            } else {
                postLoad();
            }
        },
        updateChanges() {
            const stm = this.get('StorageManager');
            const changes = this.get('changesCount');
            updateItr && clearTimeout(updateItr);
            updateItr = setTimeout(() => this.trigger('update'));
            if (this.config.noticeOnUnload) {
                window.onbeforeunload = changes ? e => 1 : null;
            }
            if (stm.isAutosave() && changes >= stm.getStepsBeforeSave()) {
                this.store();
            }
        },
        loadModule(moduleName) {
            const {config} = this;
            const Module = moduleName.default || moduleName;
            const Mod = new Module();
            const name = Mod.name.charAt(0).toLowerCase() + Mod.name.slice(1);
            const cfgParent = !_.isUndefined(config[name]) ? config[name] : config[Mod.name];
            const cfg = cfgParent || {};
            const sm = this.get('StorageManager');
            cfg.pStylePrefix = config.pStylePrefix || '';
            if (!_.isUndefined(cfgParent) && !cfgParent) {
                cfg._disable = 1;
            }
            if (Mod.storageKey && Mod.store && Mod.load && sm) {
                cfg.stm = sm;
                const mth = name == 'domComponents' ? 'unshift' : 'push';
                this.get('storables')[mth](Mod);
            }
            cfg.em = this;
            Mod.init(cfg);
            !Mod.private && this.set(Mod.name, Mod);
            Mod.onLoad && this.get('toLoad').push(Mod);
            this.get('modules').push(Mod);
            return this;
        },
        init(editor) {
            this.set('Editor', editor);
        },
        getEditor() {
            return this.get('Editor');
        },
        handleUpdates(model, val, opt = {}) {
            if (opt.temporary) {
                return;
            }
            timedInterval && clearInterval(timedInterval);
            timedInterval = setTimeout(() => {
                if (!opt.avoidStore) {
                    this.set('changesCount', this.get('changesCount') + 1, opt);
                }
            }, 0);
        },
        componentHovered(editor, component, options) {
            const prev = this.previous('componentHovered');
            prev && this.trigger('component:unhovered', prev, options);
            component && this.trigger('component:hovered', component, options);
        },
        getSelected() {
            return this.get('selected').last();
        },
        getSelectedAll() {
            return this.get('selected').models;
        },
        setSelected(el, opts = {}) {
            const multiple = _.isArray(el);
            const els = multiple ? el : [el];
            const selected = this.get('selected');
            let added;
            multiple && this.removeSelected(selected.filter(s => !_.contains(els, s)));
            els.forEach(el => {
                const model = b.getModel(el, $);
                if (model && !model.get('selectable'))
                    return;
                !multiple && this.removeSelected(selected.filter(s => s !== model));
                this.addSelected(model, opts);
                added = model;
            });
        },
        addSelected(el, opts = {}) {
            const model = b.getModel(el, $);
            const models = _.isArray(model) ? model : [model];
            models.forEach(model => {
                if (model && !model.get('selectable'))
                    return;
                const selected = this.get('selected');
                opts.forceChange && selected.remove(model, opts);
                selected.push(model, opts);
            });
        },
        removeSelected(el, opts = {}) {
            this.get('selected').remove(b.getModel(el, $), opts);
        },
        toggleSelected(el, opts = {}) {
            const model = b.getModel(el, $);
            const models = _.isArray(model) ? model : [model];
            models.forEach(model => {
                if (this.get('selected').undefined(model)) {
                    this.removeSelected(model, opts);
                } else {
                    this.addSelected(model, opts);
                }
            });
        },
        setHovered(el, opts = {}) {
            const model = b.getModel(el, $);
            if (model && !model.get('hoverable'))
                return;
            opts.forceChange && this.set('componentHovered', '');
            this.set('componentHovered', model, opts);
        },
        getHovered() {
            return this.get('componentHovered');
        },
        setComponents(components) {
            return this.get('DomComponents').setComponents(components);
        },
        getComponents() {
            var cmp = this.get('DomComponents');
            var cm = this.get('CodeManager');
            if (!cmp || !cm)
                return;
            var wrp = cmp.getComponents();
            return cm.getCode(wrp, 'json');
        },
        setStyle(style) {
            var rules = this.get('CssComposer').getAll();
            for (var i = 0, len = rules.length; i < len; i++)
                rules.pop();
            rules.add(style);
            return this;
        },
        getStyle() {
            return this.get('CssComposer').getAll();
        },
        setState(value) {
            this.set('state', value);
            return this;
        },
        getState() {
            return this.get('state');
        },
        getHtml() {
            const config = this.config;
            const exportWrapper = config.exportWrapper;
            const wrapperIsBody = config.wrapperIsBody;
            const js = config.jsInHtml ? this.getJs() : '';
            var wrp = this.get('DomComponents').getComponent();
            var html = this.get('CodeManager').getCode(wrp, 'html', {
                exportWrapper,
                wrapperIsBody
            });
            html += js ? `<script>${ js }</script>` : '';
            return html;
        },
        getCss(opts = {}) {
            const config = this.config;
            const wrapperIsBody = config.wrapperIsBody;
            const avoidProt = opts.avoidProtected;
            const keepUnusedStyles = !_.isUndefined(opts.keepUnusedStyles) ? opts.keepUnusedStyles : config.keepUnusedStyles;
            const cssc = this.get('CssComposer');
            const wrp = this.get('DomComponents').getComponent();
            const protCss = !avoidProt ? config.protectedCss : '';
            return protCss + this.get('CodeManager').getCode(wrp, 'css', {
                cssc,
                wrapperIsBody,
                keepUnusedStyles
            });
        },
        getJs() {
            var wrp = this.get('DomComponents').getWrapper();
            return this.get('CodeManager').getCode(wrp, 'js').trim();
        },
        store(clb) {
            var sm = this.get('StorageManager');
            var store = {};
            if (!sm)
                return;
            this.get('storables').forEach(m => {
                var obj = m.store(1);
                for (var el in obj)
                    store[el] = obj[el];
            });
            sm.store(store, res => {
                clb && clb(res);
                this.set('changesCount', 0);
                this.trigger('storage:store', store);
            });
            return store;
        },
        load(clb = null) {
            this.getCacheLoad(1, res => {
                this.get('storables').forEach(module => module.load(res));
                clb && clb(res);
            });
        },
        getCacheLoad(force, clb) {
            if (this.cacheLoad && !force)
                return this.cacheLoad;
            const sm = this.get('StorageManager');
            const load = [];
            if (!sm)
                return {};
            this.get('storables').forEach(m => {
                let key = m.storageKey;
                key = _.isFunction(key) ? key() : key;
                const keys = _.isArray(key) ? key : [key];
                keys.forEach(k => load.push(k));
            });
            sm.load(load, res => {
                this.cacheLoad = res;
                clb && clb(res);
                setTimeout(() => this.trigger('storage:load', res));
            });
        },
        getDeviceModel() {
            var name = this.get('device');
            return this.get('DeviceManager').get(name);
        },
        runDefault(opts = {}) {
            var command = this.get('Commands').get(this.config.defaultCommand);
            if (!command || this.defaultRunning)
                return;
            command.stop(this, this, opts);
            command.run(this, this, opts);
            this.defaultRunning = 1;
        },
        stopDefault(opts = {}) {
            var command = this.get('Commands').get(this.config.defaultCommand);
            if (!command)
                return;
            command.stop(this, this, opts);
            this.defaultRunning = 0;
        },
        refreshCanvas() {
            this.set('canvasOffset', null);
            this.set('canvasOffset', this.get('Canvas').getOffset());
        },
        clearSelection(win) {
            var w = win || window;
            w.getSelection().removeAllRanges();
        },
        getCurrentMedia() {
            const config = this.config;
            const device = this.getDeviceModel();
            const condition = config.mediaCondition;
            const preview = config.devicePreviewMode;
            const width = device && device.get('widthMedia');
            return device && width && !preview ? `(${ condition }: ${ width })` : '';
        },
        getWrapper() {
            return this.get('DomComponents').getWrapper();
        },
        setCurrentFrame(frameView) {
            return this.set('currentFrame', frameView);
        },
        getCurrentFrame() {
            return this.get('currentFrame');
        },
        getCurrentFrameModel() {
            return (this.getCurrentFrame() || {}).model;
        },
        getDirtyCount() {
            return this.get('changesCount');
        },
        getZoomDecimal() {
            return this.get('Canvas').getZoomDecimal();
        },
        getZoomMultiplier() {
            return this.get('Canvas').getZoomMultiplier();
        },
        setDragMode(value) {
            return this.set('dmode', value);
        },
        t(...args) {
            return this.get('I18n').t(...args);
        },
        inAbsoluteMode() {
            return this.get('dmode') === 'absolute';
        },
        destroyAll() {
            const {DomComponents, CssComposer, UndoManager, Panels, Canvas, Keymaps, RichTextEditor} = this.attributes;
            DomComponents.clear();
            CssComposer.clear();
            UndoManager.clear().removeAll();
            Panels.getPanels().reset();
            Canvas.getCanvasView().remove();
            Keymaps.removeAll();
            RichTextEditor.destroy();
            this.view.remove();
            this.stopListening();
            $(this.config.el).empty().attr(this.attrsOrig);
        },
        setEditing(value) {
            this.set('editing', value);
            return this;
        },
        isEditing() {
            return !!this.get('editing');
        },
        log(msg, opts = {}) {
            const {ns, level = 'debug'} = opts;
            this.trigger('log', msg, opts);
            level && this.trigger(`log:${ level }`, msg, opts);
            if (ns) {
                const logNs = `log-${ ns }`;
                this.trigger(logNs, msg, opts);
                level && this.trigger(`${ logNs }:${ level }`, msg, opts);
            }
        },
        logInfo(msg, opts) {
            this.log(msg, langx.mixin({},opts, {evel: 'info' }));
        },
        logWarning(msg, opts) {
            this.log(msg, langx.mixin({},opts, {evel: 'warning' }));
        },
        logError(msg, opts) {
            this.log(msg, langx.mixin({},opts, {evel: 'error' }));
        },
        initBaseColorPicker(el, opts = {}) {
            const config = this.getConfig();
            const {
                colorPicker = {}
            } = config;
            const elToAppend = config.el;
            const ppfx = config.stylePrefix;
            return $(el).spectrum(langx.mixin({
                    containerClassName: `${ ppfx }one-bg ${ ppfx }two-color`,
                    appendTo: elToAppend || 'body',
                    maxSelectionSize: 8,
                    showPalette: true,
                    palette: [],
                    showAlpha: true,
                    chooseText: 'Ok',
                    cancelText: '\u2A2F',
                },opts,colorPicker)
            );
        },
        data(el, name, value) {
            const varName = '_gjs-data';
            if (!el[varName]) {
                el[varName] = {};
            }
            if (_.isUndefined(value)) {
                return el[varName][name];
            } else {
                el[varName][name] = value;
            }
        }
    });
});
define('skylark-grapejs/editor/view/EditorView',[
    "skylark-jquery",
    'skylark-backbone',
    '../../utils/mixins'
], function ($,Backbone, mixins) {
    'use strict';
    return Backbone.View.extend({
        initialize() {
            const {model} = this;
            model.view = this;
            this.conf = model.config;
            this.pn = model.get('Panels');
            this.cv = model.get('Canvas');
            model.on('loaded', () => {
                this.pn.active();
                this.pn.disableButtons();
                setTimeout(() => {
                    model.runDefault();
                    model.trigger('load', model.get('Editor'));
                });
            });
        },
        render() {
            const {model, $el, conf} = this;
            const pfx = conf.stylePrefix;
            const contEl = $(conf.el || `body ${ conf.container }`);
            mixins.appendStyles(conf.cssIcons, {
                unique: 1,
                prepand: 1
            });
            $el.empty();
            if (conf.width)
                contEl.css('width', conf.width);
            if (conf.height)
                contEl.css('height', conf.height);
            $el.append(this.cv.render());
            $el.append(this.pn.render());
            $el.attr('class', `${ pfx }editor ${ pfx }one-bg ${ pfx }two-color`);
            contEl.addClass(`${ pfx }editor-cont`).empty().append($el);
            return this;
        }
    });
});
define('skylark-grapejs/editor/index',[
    "skylark-langx",
    'skylark-jquery',
    './config/config',
    './model/Editor',
    './view/EditorView'
], function (langx,$, defaults, EditorModel, EditorView) {
    'use strict';
    return (config = {}) => {

        const c = langx.mixin(
            {},
            defaults,
            config
        );

        c.pStylePrefix = c.stylePrefix;

        var em = new EditorModel(c);

        var editorView = new EditorView({
            model: em,
            config: c
        });
        
        return {
            $,
            editor: em,
            I18n: em.get('I18n'),
            DomComponents: em.get('DomComponents'),
            LayerManager: em.get('LayerManager'),
            CssComposer: em.get('CssComposer'),
            StorageManager: em.get('StorageManager'),
            AssetManager: em.get('AssetManager'),
            BlockManager: em.get('BlockManager'),
            TraitManager: em.get('TraitManager'),
            SelectorManager: em.get('SelectorManager'),
            CodeManager: em.get('CodeManager'),
            Commands: em.get('Commands'),
            Keymaps: em.get('Keymaps'),
            Modal: em.get('Modal'),
            Panels: em.get('Panels'),
            StyleManager: em.get('StyleManager'),
            Canvas: em.get('Canvas'),
            UndoManager: em.get('UndoManager'),
            DeviceManager: em.get('DeviceManager'),
            RichTextEditor: em.get('RichTextEditor'),
            Parser: em.get('Parser'),
            Utils: em.get('Utils'),
            Config: em.get('Config'),
            init() {
                em.init(this);
                em.on('loaded', () => {
                    this.UndoManager.clear();
                    em.get('modules').forEach(module => {
                        module.postRender && module.postRender(editorView);
                    });
                });
                return this;
            },
            getConfig(prop) {
                return em.getConfig(prop);
            },
            getHtml(opts) {
                return em.getHtml(opts);
            },
            getCss(opts) {
                return em.getCss(opts);
            },
            getJs() {
                return em.getJs();
            },
            getComponents() {
                return em.get('DomComponents').getComponents();
            },
            getWrapper() {
                return em.get('DomComponents').getWrapper();
            },
            setComponents(components) {
                em.setComponents(components);
                return this;
            },
            addComponents(components, opts) {
                return this.getWrapper().append(components, opts);
            },
            getStyle() {
                return em.get('CssComposer').getAll();
            },
            setStyle(style) {
                em.setStyle(style);
                return this;
            },
            getSelected() {
                return em.getSelected();
            },
            getSelectedAll() {
                return em.getSelectedAll();
            },
            getSelectedToStyle() {
                let selected = em.getSelected();
                if (selected) {
                    return this.StyleManager.getModelToStyle(selected);
                }
            },
            select(el, opts) {
                em.setSelected(el, opts);
                return this;
            },
            selectAdd(el) {
                em.addSelected(el);
                return this;
            },
            selectRemove(el) {
                em.removeSelected(el);
                return this;
            },
            selectToggle(el) {
                em.toggleSelected(el);
                return this;
            },
            setDevice(name) {
                em.set('device', name);
                return this;
            },
            getDevice() {
                return em.get('device');
            },
            runCommand(id, options = {}) {
                return em.get('Commands').run(id, options);
            },
            stopCommand(id, options = {}) {
                return em.get('Commands').stop(id, options);
            },
            store(clb) {
                return em.store(clb);
            },
            load(clb) {
                return em.load(clb);
            },
            getContainer() {
                return c.el;
            },
            getDirtyCount() {
                return em.getDirtyCount();
            },
            refresh() {
                em.refreshCanvas();
            },
            setCustomRte(obj) {
                this.RichTextEditor.customRte = obj;
            },
            setCustomParserCss(parser) {
                this.Parser.getConfig().parserCss = parser;
                return this;
            },
            setDragMode(value) {
                em.setDragMode(value);
                return this;
            },
            log(msg, opts = {}) {
                em.log(msg, opts);
                return this;
            },
            t(...args) {
                return em.t(...args);
            },
            on(event, callback) {
                em.on(event, callback);
                return this;
            },
            once(event, callback) {
                em.once(event, callback);
                return this;
            },
            off(event, callback) {
                em.off(event, callback);
                return this;
            },
            trigger(event) {
                em.trigger.apply(em, arguments);
                return this;
            },
            destroy() {
                return em.destroyAll();
            },
            getEl() {
                return editorView.el;
            },
            getModel() {
                return em;
            },
            render() {
                editorView.render();
                return editorView.el;
            }
        };
    };
});
define('skylark-grapejs/utils/polyfills',[],function () {
    'use strict';
    return () => {
        const isIE = () => {
            let match;
            const agent = window.navigator.userAgent;
            const rules = [
                [
                    'edge',
                    /Edge\/([0-9\._]+)/
                ],
                [
                    'ie',
                    /MSIE\s(7\.0)/
                ],
                [
                    'ie',
                    /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/
                ],
                [
                    'ie',
                    /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/
                ]
            ];
            for (let i = 0; i < rules.length; i++) {
                const rule = rules[i];
                match = rule[1].exec(agent);
                if (match)
                    break;
            }
            return !!match;
        };
        if (isIE()) {
            const originalCreateHTMLDocument = DOMImplementation.prototype.createHTMLDocument;
            DOMImplementation.prototype.createHTMLDocument = title => {
                if (!title)
                    title = '';
                return originalCreateHTMLDocument.apply(document.implementation, [title]);
            };
        }
    };
});
define('skylark-grapejs/plugin_manager/config/config',[],function () {
    'use strict';
    return { plugins: [] };
});
define('skylark-grapejs/plugin_manager/index',['./config/config'], function (defaults) {
    'use strict';
    return config => {
        var c = config || {};
        for (var name in defaults) {
            if (!(name in c))
                c[name] = defaults[name];
        }
        var plugins = {};
        return {
            add(id, plugin) {
                if (plugins[id]) {
                    return plugins[id];
                }
                plugins[id] = plugin;
                return plugin;
            },
            get(id) {
                return plugins[id];
            },
            getAll() {
                return plugins;
            }
        };
    };
});
define('skylark-grapejs/main',[
    "skylark-langx/langx",
    'skylark-jquery',
    './editor/index',
    'skylark-underscore',
    './utils/polyfills',
    './plugin_manager/index'
], function (langx,$, Editor, _, polyfills, PluginManager) {
    'use strict';
    polyfills();
    const plugins = new PluginManager();
    const editors = [];
    const defaultConfig = {
        autorender: 1,
        plugins: [],
        pluginsOpts: {}
    };
    return {
        $,
        editors,
        plugins,
        version: '<# VERSION #>',
        init(config = {}) {
            const els = config.container;
            if (!els)
                throw new Error("'container' is required");
            config = langx.mixin({},
                defaultConfig,
                config
            );
            config.el = _.isElement(els) ? els : document.querySelector(els);
            const editor = new Editor(config).init();
            config.plugins.forEach(pluginId => {
                let plugin = plugins.get(pluginId);
                const plgOptions = config.pluginsOpts[pluginId] || {};
                if (!plugin) {
                    const wplg = window[pluginId];
                    plugin = wplg && wplg.default ? wplg.default : wplg;
                }
                if (plugin) {
                    plugin(editor, plgOptions);
                } else if (_.isFunction(pluginId)) {
                    pluginId(editor, plgOptions);
                } else {
                    console.warn(`Plugin ${ pluginId } not found`);
                }
            });
            editor.getModel().loadOnStart();
            config.autorender && editor.render();
            editors.push(editor);
            return editor;
        }
    };
});
define('skylark-grapejs', ['skylark-grapejs/main'], function (main) { return main; });


},this);